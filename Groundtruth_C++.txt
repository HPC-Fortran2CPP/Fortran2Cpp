#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for collapse(2)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n
#include <stdio.h>\n#if (_OPENMP<201511)\n#error "An OpenMP 4.5 compiler is needed to compile this test."\n#endif\n\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf ("a[50][50]=%d\n", a[50][50]);\n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  for (i=0;i<len;i++)\n    printf("i=%d a[%d]=%d\n",i,i,a[i]);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                             // 1st taskwait\n  {}\n\n  printf("x=%d\n",x);\n  printf("y=%d\n",y);\n\n  #pragma omp taskwait		                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n
#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf("Error, malloc() returns NULL. End execution. \n");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) // this level of loop has no loop carried dependence\n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  // verify the results, no overlapping of xa1 vs. xa2, no addition happens to the same element twice\n  for (i =521; i<= 2025; ++i)\n  {\n    //printf ("%f  ", base[i]);\n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n
#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, "skip the execution due to malloc failures.\n");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, "skip the execution due to malloc failures.\n");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, "skip the execution due to malloc failures.\n");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n
#include <stdio.h>\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=0;j<m-1;j++) // Be careful about bounds of j\n      b[i][j]=b[i][j+1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n
#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\nstatic int counter;\nstatic int pcounter;\n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0;\nint A::pcounter=0;\n\nA a;\n\nvoid foo()\n{\na.counter++;\na.pcounter++;\n}\n\nint main()\n{\n#pragma omp parallel\n{\nfoo();\n}\nassert (A::pcounter == 1);\ncout<<A::counter <<" "<< A::pcounter<<endl;\nreturn 0;\n}
#include <stdio.h>\nvoid foo()\n{\n  static int q; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=2, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf("Expected: -1; Real: %d\n",b[3]);\n  return 0;\n}\n\n\n
#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf("Data Race Present\n");\n      return 0;\n    }\n  }\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                                  // 1st taskwait\n  {}\n\n  printf("x=%d\n",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf("y=%d\n",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n
#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n
#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf("sum=%d\n", sum);\n  return 0;   \n}\n
#include <stdio.h>\n#define num_steps 2000000000 \n\n#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf ("PI=%f\n", pi);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf("%d\n",x);\n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf("x=%d",x);\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf("%d\n ",var);\n\n  return 0;\n}\n
#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\nstatic int counter;\nstatic int pcounter;\n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0;\nint A::pcounter=0;\n\nA a;\n\nint main()\n{\n#pragma omp parallel\n{\na.counter++;\na.pcounter++;\n}\nassert (A::pcounter == 1);\ncout<<A::counter <<" "<< A::pcounter<<endl;\nreturn 0;\n}
#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n
#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf("x=%d",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n
#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf("a[50]=%d\n", a[50]);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf("%d\n",var[97]);\n\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n
#include <stdio.h>\n#if (_OPENMP<201511)\n#error "An OpenMP 4.5 compiler is needed to compile this test."\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf ("a[50][50]=%d\n", a[50][50]);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf ("sum = %f\n", sum);  \n  return 0;\n}\n
#include <assert.h> \n#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Proper user of ordered directive and clause, no data races\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf ("x=%d\n",x);\n  return 0;\n} \n
#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf ("j=%d k=%d\n", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n
#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf("a[50]=%d\n", a[50]);   \n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf("Data Race Detected\n");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf("x = %d\n", x); }\n    }\n  }\n  return 0;\n}\n
#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n
#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf ("error = %d\n", error);\n  return 0;\n}  \n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf("x=%d\n",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf("y=%d\n",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n
#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf("%d\n",var);\n  return 0;\n}\n
#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf("sum=%d; sum1=%d\n",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n
#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf ("i=%d\n",i);\n  return 0;\n} \n
#include <stdio.h>\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=1;j<m;j++) // Be careful about bounds of j\n      b[i][j]=b[i][j-1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n
#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n
#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf("%d\n",var);\n  return 0;\n}\n
#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n
#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf("%d\n",var[i]);\n    }\n  }\n\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf("expected %d real %d \n",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n
#include <stdio.h>\nvoid foo1(double o1[], double c[], int len)\n{ \n  int i ;\n#pragma omp parallel for\n  for (i = 0; i < len; ++i) {\n    double volnew_o8 = 0.5 * c[i];\n    o1[i] = volnew_o8;\n  } \n}\n\ndouble o1[100];\ndouble c[100];\nint main()\n{\n  foo1 (o1, c, 100);\n  return 0;\n}\n
#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf("%d\n",var);\n  return 0;\n}\n
#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf ("Error in malloc(). Aborting ...\n");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf("x1[999]=%f xa2[1285]=%f\n", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n
#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=1, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf("Expected: -1; Real: %d\n",b[3]);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf("%d\n",var);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf("Sum is %d\n", a);\n  }\n\n  return 0;\n}\n
#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n
#include <stdio.h>\n/*\nTwo-dimensional array computation using loops: missing private(j).\nReferences to j in the loop cause data races.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@61:10, j@61:20}\n  Read_set = {j@62:20, j@62:12, j@61:14, j@61:20}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n*/\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf("Sum is %d\n", a);\n  }\n\n  return 0;\n}\n
#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf("b[500][500]=%f\n", b[500][500]);  \n  return 0;\n}\n
#include <stdio.h>\n\n/*\nuse of omp target + teams \nWithout protection, master threads from two teams cause data races.\nData race pair: a@66:5:W vs. a@66:5:W\n*/\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf ("a[50]=%f\n", a[50]);\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf("Data Race\n");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf("%d\n",var);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf("%d\n",i);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf("%d\n",d);\n  return 0;\n}\n
#include <stdio.h> \nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n}\n
#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n
#include <stdio.h>\nint a[100], b[100], c[100];\nint main()\n{\n  int i;\n#pragma omp simd\n  for (i=0;i<100;i++)\n    a[i]=b[i]*c[i];\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf("x=%d",x);\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf("%d\n ",var);\n  return 0;\n}\n
#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n
#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf("a[50]=%d\n", a[50]);\n  return 0;      \n}\n\n
#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf("output[500]=%d\n",output[500]);\n\n  return 0;\n}\n
#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, // change original 921 to 923 = 911+12\n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  // max index value is 2013. +12 to obtain a valid xa2[idx] after xa1+12.\n  // +1 to ensure a reference like base[2015] is within the bound.\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf ("Error in malloc(). Aborting ...\n");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n// default static even scheduling may not trigger data race, using static,1 instead.\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf("x1[999]=%f xa2[1285]=%f\n", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n
#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf ("Error in malloc(). Aborting ...\n");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf("x1[999]=%f xa2[1285]=%f\n", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n
#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Missing the ordered clause\n * Data race pair: x@56:5:W vs. x@56:5:W\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf ("x=%d\n",x);\n  return 0;\n} \n
#include <stdio.h>\n#if (_OPENMP<201511)\n#error "An OpenMP 4.5 compiler is needed to compile this test."\n#endif\n#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf ("c[50]=%f\n",c[50]);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf("%d\n",var);\n  int error = (var != 2);\n  return error;\n}\n
#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf ("a[10][10]=%f\n", a[10][10]);\n  return 0;\n}\n\n
#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n
#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf("%d\n",var);\n  return 0;\n}\n
#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf("%d\n ",var[i]);\n  }\n\n  return 0;\n}\n
#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n
#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf ("error = %d\n", error);\n  return 0;\n}  \n
#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n/* Initialize initial condition and RHS */\n//#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n/* Initialize coefficients */\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         /* X-direction coef */\n  ay = 1.0 / (dy * dy);         /* Y-direction coef */\n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       /* Central coeff */\n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n/* Copy new solution into old */\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n/*  omp end parallel */\n\n/* Error check */\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           /*  End iteration loop */\n\n  printf ("Total Number of Iterations:%d\n", k);\n  printf ("Residual:%E\n", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n
#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len], b[len];\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n#pragma omp simd\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]*b[i];\n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len;i++)\n    a[i]=a[i]+1;\n\n  return 0;\n}\n
#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf("a[50]=%d\n", a[50]);   \n  return 0;\n}\n
#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf("x=%d",x);    \n  return 0;\n} \n\n
#include <stdio.h>\n#if (_OPENMP<201511)\n#error "OpenMP 4.5 compilers (e.g. GCC 6.x or later ) are needed to compile this test."\n#endif\n\n#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n{\na[i]= i+1;\n}\n}\n\nint main()\n{\nint i=0;\n#pragma omp parallel\n{\n#pragma omp single\n{\nfor (i=0; i<MYLEN; i++)\n{\ngen_task(i);\n}\n}\n}\n\n/* correctness checking */\nfor (i=0; i<MYLEN; i++)\n{\n//assert (a[i]==i+1);\nif (a[i]!= i+1)\n{\nprintf("warning: a[%d] = %d, not expected %d\n", i, a[i], i+1);\n}\n}\nreturn 0;\n}
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf("x=%d\n",x);\n  printf("y=%d\n",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf("index: %d val: %d\n",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf("%d\n",d);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp taskwait depend(in: x)                               // 1st taskwait\n\n  printf("x=%d\n",x);\n  printf("y=%d\n",y);\n\n  #pragma omp taskwait		                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n
#include <stdio.h>\n/*\n * Test if atomic can be recognized properly. No data races.\n * */\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf ("a=%d\n",a);\n  return 0;\n}\n\n
#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf("a[500]=%d\n", a[500]);\n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf("a[50]=%d\n",a[50]);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf("x=%d\n",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf("y=%d\n",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n
#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf("sum=%d\n", sum);\n  return 0;   \n}\n
#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf("%d\n",var);\n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen("mytempfile.txt","a+");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,"Error in fopen()\n");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, "%d\n", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove("mytempfile.txt");\n  if (ret != 0)\n  {\n    fprintf(stderr, "Error: unable to delete mytempfile.txt\n");\n  }\n  return 0;\n}\n\n
#include <stdio.h>\nint a[100];\nint main()\n{\nint i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n
#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf ("numThreads=%d\n", numThreads);\n  return 0;\n}\n
#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf("sum=%d; sum1=%d\n",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n
#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf ("Error in malloc(). Aborting ...\n");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf("x1[999]=%f xa2[1285]=%f\n", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n
#include <stdio.h>\n#define N 100\n#define M 100 \n#define K 100\ndouble a[N][M],b[M][K],c[N][K];\n            \nint mmm()   \n{           \n  int i,j,k;\n#pragma omp parallel for private(j,k)\n  for (i = 0; i < N; i++) \n    for (k = 0; k < K; k++) \n      for (j = 0; j < M; j++)\n        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n  return 0; \n} \n\nint main()\n{\n  mmm();\n  return 0;\n}  \n
#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf("i=%d\n",i);\n  return 0;\n} \n
#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf ("x=%f y=%d\n", x, y);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf("Data Race Present");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n
#include <stdio.h>\n/*\n *  loop missing the linear clause\n *  Data race pairs (race on j allows wrong indexing of c):  \n     j@70:7:R vs. j@71:5:W\n     j@71:5:W vs. j@71:5:W \n     c[j]@70:5:W vs. c[j]@70:5:W\n*/\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf ("c[50]=%f\n",c[50]);\n  return 0;\n}\n
#include <stdio.h>\n#define N 100\n\ndouble a[N][N],v[N],v_out[N];\nint mv()\n{           \n  int i,j;\n#pragma omp parallel for private (i,j)\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n  return 0; \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf("%d\n ",var);\n  return 0;\n}\n
#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf("a[1001]=%d\n", a[1001]);  \n  return 0;\n}\n\n
#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf("%d\n ",var[i]);\n  }\n\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf ("Number of Threads requested = %i\n",k);\n    }\n  }\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp taskwait depend(in: x)                                    // 1st taskwait\n\n  printf("x=%d\n",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf("y=%d\n",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n
#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n//#pragma omp threadprivate(counter)\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, "malloc() fails\n");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf("%d \n", *counter);\n  free (counter);\n  return 0;   \n}\n\n
#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n/*\nuse of omp target + teams + distribute + parallel for\n*/\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n/* CPU reference computation */  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf ("sum=%f sum2=%f\n", sum, sum2);\n  return 0;\n}\n
#include<stdio.h>\n#include<assert.h>\n/*  argument pass-by-value */\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf ("i=%d\n",i);\n  return 0;\n}\n\n
#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n
#include <stdio.h>\n#if (_OPENMP<201511)\n#error "An OpenMP 4.5 compiler is needed to compile this test."\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf ("test i=%d j=%d\n",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n
#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  // initialize x[]\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf ("numNodes2 = %d\n", numNodes2);\n  return 0;\n} \n
#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n
#include <stdio.h>\nvoid foo(int * a, int n, int g)\n{\n  int i;\n#pragma omp parallel for firstprivate (g)\n  for (i=0;i<n;i++)\n  {\n    a[i] = a[i]+g;\n  }\n}\n\nint a[100];\nint main()\n{\n  foo(a, 100, 7);\n  return 0;\n}  \n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf("%d\n",var[63]);\n\n  return 0;\n}\n
#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf("b[500][500]=%f\n", b[500][500]);\n  return 0;\n}\n\n
#include <stdio.h>\nvoid foo()\n{\n  int q=0; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n
#include <stdio.h>\nint main()\n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n\n  for(i=0;i<n; i++) \n    for(j=0;j<n; j++) \n      b[i][j]=(double)(i*j);\n\n  for (i=1;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n  return 0;\n}\n
#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n
#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf ("a[500]=%d\n", a[500] );\n  return 0;\n} \n
#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  /* Initialize initial condition and RHS */\n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n
#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          sleep(3);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf ("result=%d\n", result);\n  assert (result==2);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf("%d\n",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf("%d\n",section_count);\n    }\n  }\n  return 0;\n}\n
#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, "malloc() fails\n");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf("%d \n", *counter);\n  free (counter);\n  return 0;   \n}\n\n
#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf("%d\n",x);\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf("sum = %d\n", sum);\n  return 0;\n }\n
#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n/* static storage for a local variable */\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n/* automatic storage for a local variable */\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf("a[50]=%d b[50]=%d\n", a[50], b[50]);\n \n  return 0;\n}\n
#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf ("count= %d\n", count);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf("%d\n",p->b);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf("%d %d\n",var,20*res);\n  return error;\n}\n
#include <stdio.h>\n/*\nuse of omp target + map + array sections derived from pointers\n*/\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf("b[50]=%f\n",b[50]);\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf("%d\n",p->b);\n  return 0;\n}\n
#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n
#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  /*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf("sum=%d; sum1=%d\n",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n
#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task but missing taskwait. \n * Data races pairs: i@61:5:W vs. i@65:14:R\n *                   j@63:5:W vs. j@65:16:R\n * */\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n/* We move the original taskwait to a location after i+j to \n * simulate the missing taskwait mistake.\n * Directly removing the taskwait may cause a child task to write to i or j\n * within the stack of a parent task which may already be gone, causing seg fault.\n * This change is suggested by Joachim Protze @RWTH-Aachen. \n * */\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf ("Fib(%d)=%d (correct answer should be 55)\n", input, result);\n  return 0;\n}\n
#include <stdio.h>\n#define N 1000\ndouble a[N][N],v[N],v_out[N];\n\nvoid mv()\n{           \n  int i,j;\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n#pragma omp parallel for reduction(+:sum)\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n
#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf("x=%d, a[0]=%d\n",x,a[0]);    \n  return 0;\n} \n\n
#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf("numThreads=%d\n", numThreads);\n    }\n  }\n  return 0;\n}\n
void error_norm(double rms[]){\nint i, j, k, m, d;\ndouble xi, eta, zeta, u_exact[5], add;\nfor(m=0; m<5; m++){rms[m]=0.0;}\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)k*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)j*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)i*dnxm1;\nexact_solution(xi, eta, zeta, u_exact);\nfor(m=0; m<5; m++){\nadd=u[k][j][i][m]-u_exact[m];\nrms[m]=rms[m]+add*add;\n}\n}\n}\n}\nfor(m=0; m<5; m++){\nfor(d=0; d<3; d++){\nrms[m]=rms[m]/(double)(grid_points[d]-2);\n}\nrms[m]=sqrt(rms[m]);\n}\n}
void set_constants(){\nce[0][0]=2.0;\nce[1][0]=0.0;\nce[2][0]=0.0;\nce[3][0]=4.0;\nce[4][0]=5.0;\nce[5][0]=3.0;\nce[6][0]=0.5;\nce[7][0]=0.02;\nce[8][0]=0.01;\nce[9][0]=0.03;\nce[10][0]=0.5;\nce[11][0]=0.4;\nce[12][0]=0.3;\n\nce[0][1]=1.0;\nce[1][1]=0.0;\nce[2][1]=0.0;\nce[3][1]=0.0;\nce[4][1]=1.0;\nce[5][1]=2.0;\nce[6][1]=3.0;\nce[7][1]=0.01;\nce[8][1]=0.03;\nce[9][1]=0.02;\nce[10][1]=0.4;\nce[11][1]=0.3;\nce[12][1]=0.5;\n\nce[0][2]=2.0;\nce[1][2]=2.0;\nce[2][2]=0.0;\nce[3][2]=0.0;\nce[4][2]=0.0;\nce[5][2]=2.0;\nce[6][2]=3.0;\nce[7][2]=0.04;\nce[8][2]=0.03;\nce[9][2]=0.05;\nce[10][2]=0.3;\nce[11][2]=0.5;\nce[12][2]=0.4;\n\nce[0][3]=2.0;\nce[1][3]=2.0;\nce[2][3]=0.0;\nce[3][3]=0.0;\nce[4][3]=0.0;\nce[5][3]=2.0;\nce[6][3]=3.0;\nce[7][3]=0.03;\nce[8][3]=0.05;\nce[9][3]=0.04;\nce[10][3]=0.2;\nce[11][3]=0.1;\nce[12][3]=0.3;\n\nce[0][4]=5.0;\nce[1][4]=4.0;\nce[2][4]=3.0;\nce[3][4]=2.0;\nce[4][4]=0.1;\nce[5][4]=0.4;\nce[6][4]=0.3;\nce[7][4]=0.05;\nce[8][4]=0.04;\nce[9][4]=0.03;\nce[10][4]=0.1;\nce[11][4]=0.3;\nce[12][4]=0.2;\n\nc1=1.4;\nc2=0.4;\nc3=0.1;\nc4=1.0;\nc5=1.4;\ndnxm1=1.0/(double)(grid_points[0]-1);\ndnym1=1.0/(double)(grid_points[1]-1);\ndnzm1=1.0/(double)(grid_points[2]-1);\nc1c2=c1*c2;\nc1c5=c1*c5;\nc3c4=c3*c4;\nc1345=c1c5*c3c4;\nconz1=(1.0-c1c5);\ntx1=1.0/(dnxm1*dnxm1);\ntx2=1.0/(2.0*dnxm1);\ntx3=1.0/dnxm1;\nty1=1.0/(dnym1*dnym1);\nty2=1.0/(2.0*dnym1);\nty3=1.0/dnym1;\ntz1=1.0/(dnzm1*dnzm1);\ntz2=1.0/(2.0*dnzm1);\ntz3=1.0/dnzm1;\ndx1=0.75;\ndx2=0.75;\ndx3=0.75;\ndx4=0.75;\ndx5=0.75;\ndy1=0.75;\ndy2=0.75;\ndy3=0.75;\ndy4=0.75;\ndy5=0.75;\ndz1=1.0;\ndz2=1.0;\ndz3=1.0;\ndz4=1.0;\ndz5=1.0;\ndxmax=max(dx3, dx4);\ndymax=max(dy2, dy4);\ndzmax=max(dz2, dz3);\ndssp=0.25*max(dx1, max(dy1, dz1));\nc4dssp=4.0*dssp;\nc5dssp=5.0*dssp;\ndttx1=dt*tx1;\ndttx2=dt*tx2;\ndtty1=dt*ty1;\ndtty2=dt*ty2;\ndttz1=dt*tz1;\ndttz2=dt*tz2;\nc2dttx1=2.0*dttx1;\nc2dtty1=2.0*dtty1;\nc2dttz1=2.0*dttz1;\ndtdssp=dt*dssp;\ncomz1=dtdssp;\ncomz4=4.0*dtdssp;\ncomz5=5.0*dtdssp;\ncomz6=6.0*dtdssp;\nc3c4tx3=c3c4*tx3;\nc3c4ty3=c3c4*ty3;\nc3c4tz3=c3c4*tz3;\ndx1tx1=dx1*tx1;\ndx2tx1=dx2*tx1;\ndx3tx1=dx3*tx1;\ndx4tx1=dx4*tx1;\ndx5tx1=dx5*tx1;\ndy1ty1=dy1*ty1;\ndy2ty1=dy2*ty1;\ndy3ty1=dy3*ty1;\ndy4ty1=dy4*ty1;\ndy5ty1=dy5*ty1;\ndz1tz1=dz1*tz1;\ndz2tz1=dz2*tz1;\ndz3tz1=dz3*tz1;\ndz4tz1=dz4*tz1;\ndz5tz1=dz5*tz1;\nc2iv=2.5;\ncon43=4.0/3.0;\ncon16=1.0/6.0;\nxxcon1=c3c4tx3*con43*tx3;\nxxcon2=c3c4tx3*tx3;\nxxcon3=c3c4tx3*conz1*tx3;\nxxcon4=c3c4tx3*con16*tx3;\nxxcon5=c3c4tx3*c1c5*tx3;\nyycon1=c3c4ty3*con43*ty3;\nyycon2=c3c4ty3*ty3;\nyycon3=c3c4ty3*conz1*ty3;\nyycon4=c3c4ty3*con16*ty3;\nyycon5=c3c4ty3*c1c5*ty3;\nzzcon1=c3c4tz3*con43*tz3;\nzzcon2=c3c4tz3*tz3;\nzzcon3=c3c4tz3*conz1*tz3;\nzzcon4=c3c4tz3*con16*tz3;\nzzcon5=c3c4tz3*c1c5*tz3;\n}
void set_constants(){\nce[0][0]=2.0;\nce[1][0]=0.0;\nce[2][0]=0.0;\nce[3][0]=4.0;\nce[4][0]=5.0;\nce[5][0]=3.0;\nce[6][0]=0.5;\nce[7][0]=0.02;\nce[8][0]=0.01;\nce[9][0]=0.03;\nce[10][0]=0.5;\nce[11][0]=0.4;\nce[12][0]=0.3;\n\nce[0][1]=1.0;\nce[1][1]=0.0;\nce[2][1]=0.0;\nce[3][1]=0.0;\nce[4][1]=1.0;\nce[5][1]=2.0;\nce[6][1]=3.0;\nce[7][1]=0.01;\nce[8][1]=0.03;\nce[9][1]=0.02;\nce[10][1]=0.4;\nce[11][1]=0.3;\nce[12][1]=0.5;\n\nce[0][2]=2.0;\nce[1][2]=2.0;\nce[2][2]=0.0;\nce[3][2]=0.0;\nce[4][2]=0.0;\nce[5][2]=2.0;\nce[6][2]=3.0;\nce[7][2]=0.04;\nce[8][2]=0.03;\nce[9][2]=0.05;\nce[10][2]=0.3;\nce[11][2]=0.5;\nce[12][2]=0.4;\n\nce[0][3]=2.0;\nce[1][3]=2.0;\nce[2][3]=0.0;\nce[3][3]=0.0;\nce[4][3]=0.0;\nce[5][3]=2.0;\nce[6][3]=3.0;\nce[7][3]=0.03;\nce[8][3]=0.05;\nce[9][3]=0.04;\nce[10][3]=0.2;\nce[11][3]=0.1;\nce[12][3]=0.3;\n\nce[0][4]=5.0;\nce[1][4]=4.0;\nce[2][4]=3.0;\nce[3][4]=2.0;\nce[4][4]=0.1;\nce[5][4]=0.4;\nce[6][4]=0.3;\nce[7][4]=0.05;\nce[8][4]=0.04;\nce[9][4]=0.03;\nce[10][4]=0.1;\nce[11][4]=0.3;\nce[12][4]=0.2;\n\nc1=1.4;\nc2=0.4;\nc3=0.1;\nc4=1.0;\nc5=1.4;\n\nbt=sqrt(0.5);\n\ndnxm1=1.0/(double)(grid_points[0]-1);\ndnym1=1.0/(double)(grid_points[1]-1);\ndnzm1=1.0/(double)(grid_points[2]-1);\n\nc1c2=c1*c2;\nc1c5=c1*c5;\nc3c4=c3*c4;\nc1345=c1c5*c3c4;\n\nconz1=(1.0-c1c5);\n\ntx1=1.0/(dnxm1*dnxm1);\ntx2=1.0/(2.0*dnxm1);\ntx3=1.0/dnxm1;\n\nty1=1.0/(dnym1*dnym1);\nty2=1.0/(2.0*dnym1);\nty3=1.0/dnym1;\n\ntz1=1.0/(dnzm1*dnzm1);\ntz2=1.0/(2.0*dnzm1);\ntz3=1.0/dnzm1;\n\ndx1=0.75;\ndx2=0.75;\ndx3=0.75;\ndx4=0.75;\ndx5=0.75;\n\ndy1=0.75;\ndy2=0.75;\ndy3=0.75;\ndy4=0.75;\ndy5=0.75;\n\ndz1=1.0;\ndz2=1.0;\ndz3=1.0;\ndz4=1.0;\ndz5=1.0;\n\ndxmax=max(dx3, dx4);\ndymax=max(dy2, dy4);\ndzmax=max(dz2, dz3);\n\ndssp=0.25*max(dx1, max(dy1, dz1));\n\nc4dssp=4.0*dssp;\nc5dssp=5.0*dssp;\n\ndttx1=dt*tx1;\ndttx2=dt*tx2;\ndtty1=dt*ty1;\ndtty2=dt*ty2;\ndttz1=dt*tz1;\ndttz2=dt*tz2;\n\nc2dttx1=2.0*dttx1;\nc2dtty1=2.0*dtty1;\nc2dttz1=2.0*dttz1;\n\ndtdssp=dt*dssp;\n\ncomz1=dtdssp;\ncomz4=4.0*dtdssp;\ncomz5=5.0*dtdssp;\ncomz6=6.0*dtdssp;\n\nc3c4tx3=c3c4*tx3;\nc3c4ty3=c3c4*ty3;\nc3c4tz3=c3c4*tz3;\n\ndx1tx1=dx1*tx1;\ndx2tx1=dx2*tx1;\ndx3tx1=dx3*tx1;\ndx4tx1=dx4*tx1;\ndx5tx1=dx5*tx1;\n\ndy1ty1=dy1*ty1;\ndy2ty1=dy2*ty1;\ndy3ty1=dy3*ty1;\ndy4ty1=dy4*ty1;\ndy5ty1=dy5*ty1;\n\ndz1tz1=dz1*tz1;\ndz2tz1=dz2*tz1;\ndz3tz1=dz3*tz1;\ndz4tz1=dz4*tz1;\ndz5tz1=dz5*tz1;\n\nc2iv=2.5;\ncon43=4.0/3.0;\ncon16=1.0/6.0;\n\nxxcon1=c3c4tx3*con43*tx3;\nxxcon2=c3c4tx3*tx3;\nxxcon3=c3c4tx3*conz1*tx3;\nxxcon4=c3c4tx3*con16*tx3;\nxxcon5=c3c4tx3*c1c5*tx3;\n\nyycon1=c3c4ty3*con43*ty3;\nyycon2=c3c4ty3*ty3;\nyycon3=c3c4ty3*conz1*ty3;\nyycon4=c3c4ty3*con16*ty3;\nyycon5=c3c4ty3*c1c5*ty3;\n\nzzcon1=c3c4tz3*con43*tz3;\nzzcon2=c3c4tz3*tz3;\nzzcon3=c3c4tz3*conz1*tz3;\nzzcon4=c3c4tz3*con16*tz3;\nzzcon5=c3c4tz3*c1c5*tz3;\n}
static void makea(int n,\nint nz,\ndouble a[],\nint colidx[],\nint rowstr[],\nint firstrow,\nint lastrow,\nint firstcol,\nint lastcol,\nint arow[],\nint acol[][NONZER+1],\ndouble aelt[][NONZER+1],\nint iv[]){\nint iouter, ivelt, nzv, nn1;\nint ivc[NONZER+1];\ndouble vc[NONZER+1];\n\n\nnn1 = 1;\ndo{\nnn1 = 2 * nn1;\n}while(nn1 < n);\n\n\nfor(iouter = 0; iouter < n; iouter++){\nnzv = NONZER;\nsprnvc(n, nzv, nn1, vc, ivc);\nvecset(n, vc, ivc, &nzv, iouter+1, 0.5);\narow[iouter] = nzv;\nfor(ivelt = 0; ivelt < nzv; ivelt++){\nacol[iouter][ivelt] = ivc[ivelt] - 1;\naelt[iouter][ivelt] = vc[ivelt];\n}\n}\n\n\nsparse(a,\ncolidx,\nrowstr,\nn,\nnz,\nNONZER,\narow,\nacol,\naelt,\nfirstrow,\nlastrow,\niv,\nRCOND,\nSHIFT);\n}
void initialize(){\nint i, j, k, m, ix, iy, iz;\ndouble xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5];\n\nfor(k=0; k<=grid_points[2]-1; k++){\nfor(j=0; j<=grid_points[1]-1; j++){\nfor(i=0; i<=grid_points[0]-1; i++){\nu[k][j][i][0]=1.0;\nu[k][j][i][1]=0.0;\nu[k][j][i][2]=0.0;\nu[k][j][i][3]=0.0;\nu[k][j][i][4]=1.0;\n}\n}\n}\n\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)k*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)j*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)i*dnxm1;\nfor(ix=0; ix<2; ix++){\nPxi=(double)ix;\nexact_solution(Pxi, eta, zeta, &Pface[ix][0][0]);\n}\nfor(iy=0; iy<2; iy++){\nPeta=(double)iy;\nexact_solution(xi, Peta, zeta, &Pface[iy][1][0]);\n}\nfor(iz=0; iz<2; iz++){\nPzeta=(double)iz;\nexact_solution(xi, eta, Pzeta, &Pface[iz][2][0]);\n}\nfor(m=0; m<5; m++){\nPxi=xi*Pface[1][0][m]+(1.0-xi)*Pface[0][0][m];\nPeta=eta*Pface[1][1][m]+(1.0-eta)*Pface[0][1][m];\nPzeta=zeta*Pface[1][2][m]+(1.0-zeta)*Pface[0][2][m];\nu[k][j][i][m]=Pxi+Peta+Pzeta-\nPxi*Peta-Pxi*Pzeta-Peta*Pzeta+\nPxi*Peta*Pzeta;\n}\n}\n}\n}\n\nxi=0.0;\ni=0;\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)k*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)j*dnym1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nxi=1.0;\ni=grid_points[0]-1;\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)k*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)j*dnym1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\neta=0.0;\nj=0;\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)k*dnzm1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)i*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\neta=1.0;\nj=grid_points[1]-1;\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)k*dnzm1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)i*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nzeta=0.0;\nk=0;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)j*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)i*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nzeta=1.0;\nk=grid_points[2]-1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)j*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)i*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n}
void read_input(){\n\nFILE* fp; int avoid_warning;\nif((fp=fopen("inputlu.data","r"))!=NULL){\nprintf("Reading from input file inputlu.data\n");\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\navoid_warning=fscanf(fp,"%d%d",&ipr,&inorm);\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\navoid_warning=fscanf(fp,"%d",&itmax);\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\navoid_warning=fscanf(fp,"%lf",&dt);\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\navoid_warning=fscanf(fp,"%lf",&omega);\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\navoid_warning=fscanf(fp,"%lf%lf%lf%lf%lf",&tolrsd[0],\n&tolrsd[1],\n&tolrsd[2],\n&tolrsd[3],\n&tolrsd[4]);\nwhile(fgetc(fp)!='\n');\nwhile(fgetc(fp)!='\n');\navoid_warning=fscanf(fp,"%d%d%d",&nx0,&ny0,&nz0);\nfclose(fp);\n}else{\nipr=IPR_DEFAULT;\ninorm=INORM_DEFAULT;\nitmax=ITMAX_DEFAULT;\ndt=DT_DEFAULT;\nomega=OMEGA_DEFAULT;\ntolrsd[0]=TOLRSD1_DEF;\ntolrsd[1]=TOLRSD2_DEF;\ntolrsd[2]=TOLRSD3_DEF;\ntolrsd[3]=TOLRSD4_DEF;\ntolrsd[4]=TOLRSD5_DEF;\nnx0=ISIZ1;\nny0=ISIZ2;\nnz0=ISIZ3;\n}\n\nif((nx0<4)||(ny0<4)||(nz0<4)){\nprintf("     PROBLEM SIZE IS TOO SMALL -\n"\n"     SET EACH OF NX, NY AND NZ AT LEAST EQUAL TO 5\n");\nexit(EXIT_FAILURE);\n}\nif((nx0>ISIZ1)||(ny0>ISIZ2)||(nz0>ISIZ3)){\nprintf("     PROBLEM SIZE IS TOO LARGE -\n"\n"     NX, NY AND NZ SHOULD BE EQUAL TO\n"\n"     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY\n");\nexit(EXIT_FAILURE);\n}\nprintf("\n\nNAS Parallel Benchmarks 4.1 Parallel C++ version with OpenMP - LU Benchmark\n\n");\nprintf(" Size: %4dx%4dx%4d\n",nx0,ny0,nz0);\nprintf(" Iterations: %4d\n",itmax);\nprintf("\n");\n}
void ninvr(){\nint i, j, k;\ndouble r1, r2, r3, r4, r5, t1, t2;\nint thread_id = omp_get_thread_num();\n\nif(timeron && thread_id==0){timer_start(T_NINVR);}\n#pragma omp for\nfor(k=1; k<=nz2; k++){\nfor(j=1; j<=ny2; j++){\nfor(i=1; i<=nx2; i++){\nr1=rhs[k][j][i][0];\nr2=rhs[k][j][i][1];\nr3=rhs[k][j][i][2];\nr4=rhs[k][j][i][3];\nr5=rhs[k][j][i][4];\nt1=bt*r3;\nt2=0.5*(r4+r5);\nrhs[k][j][i][0]=-r2;\nrhs[k][j][i][1]=r1;\nrhs[k][j][i][2]=bt*(r4-r5);\nrhs[k][j][i][3]=-t1+t2;\nrhs[k][j][i][4]=t1+t2;\n}\n}\n}\nif(timeron && thread_id==0){timer_stop(T_NINVR);}\n}
void l2norm(int nx0,\nint ny0,\nint nz0,\nint ist,\nint iend,\nint jst,\nint jend,\ndouble v[][ISIZ2/2*2+1][ISIZ1/2*2+1][5],\ndouble sum[]){\n\nint i, j, k, m;\ndouble sum0=0.0, sum1=0.0, sum2=0.0, sum3=0.0, sum4=0.0;\n\n#pragma omp single\nfor (m = 0; m < 5; m++) {\nsum[m] = 0.0;\n}\n\n#pragma omp for nowait\nfor(k=1; k<nz0-1; k++){\nfor(j=jst; j<jend; j++){\nfor(i=ist; i<iend; i++){\nsum0 = sum0 + v[i][j][k][0] * v[i][j][k][0];\nsum1 = sum1 + v[i][j][k][1] * v[i][j][k][1];\nsum2 = sum2 + v[i][j][k][2] * v[i][j][k][2];\nsum3 = sum3 + v[i][j][k][3] * v[i][j][k][3];\nsum4 = sum4 + v[i][j][k][4] * v[i][j][k][4];\n}\n}\n}\n\n#pragma omp critical\n{\nsum[0] += sum0;\nsum[1] += sum1;\nsum[2] += sum2;\nsum[3] += sum3;\nsum[4] += sum4;\n}\n#pragma omp barrier\n\n#pragma omp single\nfor(m=0; m<5; m++){\nsum[m]=sqrt(sum[m]/((nx0-2)*(ny0-2)*(nz0-2)));\n}\n}
static void evolve(void* pointer_u0,\nvoid* pointer_u1,\nvoid* pointer_twiddle,\nint d1,\nint d2,\nint d3){\ndcomplex (*u0)[NY][NX] = (dcomplex(*)[NY][NX])pointer_u0;\ndcomplex (*u1)[NY][NX] = (dcomplex(*)[NY][NX])pointer_u1;\ndouble (*twiddle)[NY][NX] = (double(*)[NY][NX])pointer_twiddle;\n\nint i, j, k;\n#pragma omp for\nfor(k=0; k<d3; k++){\nfor(j=0; j<d2; j++){\nfor(i=0; i<d1; i++){\nu0[k][j][i] = dcomplex_mul2(u0[k][j][i], twiddle[k][j][i]);\nu1[k][j][i] = u0[k][j][i];\n}\n}\n}\n}
void domain(){\n\nnx=nx0;\nny=ny0;\nnz=nz0;\n\nif((nx<4)||(ny<4)||(nz<4)){\nprintf("     SUBDOMAIN SIZE IS TOO SMALL -\n"\n"     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\n"\n"     SO THAT NX, NY AND NZ ARE GREATER THAN OR EQUAL\n"\n"     TO 4 THEY ARE CURRENTLY%3d%3d%3d\n",nx,ny,nz);\nexit(EXIT_FAILURE);\n}\nif((nx>ISIZ1)||(ny>ISIZ2)||(nz>ISIZ3)){\nprintf("     SUBDOMAIN SIZE IS TOO LARGE -\n"\n"     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\n"\n"     SO THAT NX, NY AND NZ ARE LESS THAN OR EQUAL TO\n"\n"     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY.  THEY ARE\n"\n"     CURRENTLYi%4d%4d%4d\n", nx, ny, nz);\nexit(EXIT_FAILURE);\n}\n\nist=1;\niend=nx-1;\njst=1;\njend=ny-1;\nii1=1;\nii2=nx0-1;\nji1=1;\nji2=ny0-2;\nki1=2;\nki2=nz0-1;\n}
void tzetar(){\nint i, j, k;\ndouble t1, t2, t3, ac, xvel, yvel, zvel, r1, r2, r3, r4, r5, btuz, ac2u, uzik1;\nint thread_id = omp_get_thread_num();\n\nif(timeron && thread_id==0){timer_start(T_TZETAR);}\n#pragma omp for\nfor(k=1; k<=nz2; k++){\nfor(j=1; j<=ny2; j++){\nfor(i=1; i<=nx2; i++){\nxvel=us[k][j][i];\nyvel=vs[k][j][i];\nzvel=ws[k][j][i];\nac=speed[k][j][i];\nac2u=ac*ac;\nr1=rhs[k][j][i][0];\nr2=rhs[k][j][i][1];\nr3=rhs[k][j][i][2];\nr4=rhs[k][j][i][3];\nr5=rhs[k][j][i][4];\nuzik1=u[k][j][i][0];\nbtuz=bt*uzik1;\nt1=btuz/ac*(r4+r5);\nt2=r3+t1;\nt3=btuz*(r4-r5);\nrhs[k][j][i][0]=t2;\nrhs[k][j][i][1]=-uzik1*r2+xvel*t2;\nrhs[k][j][i][2]=uzik1*r1+yvel*t2;\nrhs[k][j][i][3]=zvel*t2+t3;\nrhs[k][j][i][4]=uzik1*(-xvel*r2+yvel*r1) +\nqs[k][j][i]*t2+c2iv*ac2u*t1+zvel*t3;\n}\n}\n}\nif(timeron && thread_id==0){timer_stop(T_TZETAR);}\n}
static void rep_nrm(void* pointer_u, int n1, int n2, int n3, char* title, int kk){\ndouble rnm2, rnmu;\nnorm2u3(pointer_u,n1,n2,n3,&rnm2,&rnmu,nx[kk],ny[kk],nz[kk]);\n#pragma omp master\nprintf(" Level%2d in %8s: norms =%21.14e%21.14e\n", kk, title, rnm2, rnmu);\n}
void pinvr(){\nint i, j, k;\ndouble r1, r2, r3, r4, r5, t1, t2;\nint thread_id = omp_get_thread_num();\n\nif(timeron && thread_id==0){timer_start(T_PINVR);}\n#pragma omp for\nfor(k=1; k<=nz2; k++){\nfor(j=1; j<=ny2; j++){\nfor(i=1; i<=nx2; i++){\nr1=rhs[k][j][i][0];\nr2=rhs[k][j][i][1];\nr3=rhs[k][j][i][2];\nr4=rhs[k][j][i][3];\nr5=rhs[k][j][i][4];\nt1=bt*r1;\nt2=0.5*(r4+r5);\nrhs[k][j][i][0]=bt*(r4-r5);\nrhs[k][j][i][1]=-r3;\nrhs[k][j][i][2]=r2;\nrhs[k][j][i][3]=-t1+t2;\nrhs[k][j][i][4]=t1+t2;\n}\n}\n}\nif(timeron && thread_id==0){timer_stop(T_PINVR);}\n}
static void cffts1(int is,\nint d1,\nint d2,\nint d3,\nvoid* pointer_x,\nvoid* pointer_xout,\ndcomplex y1[][FFTBLOCKPAD],\ndcomplex y2[][FFTBLOCKPAD]){\ndcomplex (*x)[NY][NX] = (dcomplex(*)[NY][NX])pointer_x;\ndcomplex (*xout)[NY][NX] = (dcomplex(*)[NY][NX])pointer_xout;\n\nint logd1;\nint i, j, k, jj;\n\nlogd1 = ilog2(d1);\n\n\nif(timers_enabled){\n#pragma omp master\ntimer_start(T_FFTX);\n}\n\n#pragma omp for\nfor(k=0; k<d3; k++){\nfor(jj=0; jj<=d2-FFTBLOCK; jj+=FFTBLOCK){\nfor(j=0; j<FFTBLOCK; j++){\nfor(i=0; i<d1; i++){\ny1[i][j] = x[k][j+jj][i];\n}\n}\ncfftz(is, logd1, d1, y1, y2);\nfor(j=0; j<FFTBLOCK; j++){\nfor(i=0; i<d1; i++){\nxout[k][j+jj][i] = y1[i][j];\n}\n}\n}\n}\n\nif(timers_enabled){\n#pragma omp master\ntimer_stop(T_FFTX);\n}\n}
void error(){\n\nint i, j, k, m;\ndouble tmp;\ndouble u000ijk[5];\nfor(m=0;m<5;m++){errnm[m]=0.0;}\nfor(k=1; k<nz-1; k++){\nfor(j=jst; j<jend; j++){\nfor(i=ist; i<iend; i++){\nexact(i, j, k, u000ijk);\nfor(m=0; m<5; m++){\ntmp=(u000ijk[m]-u[k][j][i][m]);\nerrnm[m]=errnm[m]+tmp*tmp;\n}\n}\n}\n}\nfor(m=0; m<5; m++){\nerrnm[m]=sqrt(errnm[m]/((nx0-2)*(ny0-2)*(nz0-2)));\n}\n}
static void cffts3(int is,\nint d1,\nint d2,\nint d3,\nvoid* pointer_x,\nvoid* pointer_xout,\ndcomplex y1[][FFTBLOCKPAD],\ndcomplex y2[][FFTBLOCKPAD]){\ndcomplex (*x)[NY][NX] = (dcomplex(*)[NY][NX])pointer_x;\ndcomplex (*xout)[NY][NX] = (dcomplex(*)[NY][NX])pointer_xout;\n\nint logd3;\nint i, j, k, ii;\n\nlogd3 = ilog2(d3);\n\nif(timers_enabled){\n#pragma omp master\ntimer_start(T_FFTZ);\n}\n\n#pragma omp for\nfor(j=0; j<d2; j++){\nfor(ii=0; ii<=d1-FFTBLOCK; ii+=FFTBLOCK){\nfor(k=0; k<d3; k++){\nfor(i=0; i<FFTBLOCK; i++){\ny1[k][i] = x[k][j][i+ii];\n}\n}\ncfftz(is, logd3, d3, y1, y2);\nfor(k=0; k<d3; k++){\nfor(i=0; i<FFTBLOCK; i++){\nxout[k][j][i+ii] = y1[k][i];\n}\n}\n}\n}\n\nif(timers_enabled){\n#pragma omp master\ntimer_stop(T_FFTZ);\n}\n}
void setcoeff(){\n\ndxi=1.0/(nx0-1);\ndeta=1.0/(ny0-1);\ndzeta=1.0/(nz0-1);\ntx1=1.0/(dxi*dxi);\ntx2=1.0/(2.0*dxi);\ntx3=1.0/dxi;\nty1=1.0/(deta*deta);\nty2=1.0/(2.0*deta);\nty3=1.0/deta;\ntz1=1.0/(dzeta*dzeta);\ntz2=1.0/(2.0*dzeta);\ntz3=1.0/dzeta;\n\ndx1=0.75;\ndx2=dx1;\ndx3=dx1;\ndx4=dx1;\ndx5=dx1;\ndy1=0.75;\ndy2=dy1;\ndy3=dy1;\ndy4=dy1;\ndy5=dy1;\ndz1=1.00;\ndz2=dz1;\ndz3=dz1;\ndz4=dz1;\ndz5=dz1;\n\ndssp=(max(max(dx1,dy1),dz1))/4.0;\n\nce[0][0]=2.0;\nce[1][0]=0.0;\nce[2][0]=0.0;\nce[3][0]=4.0;\nce[4][0]=5.0;\nce[5][0]=3.0;\nce[6][0]=5.0e-01;\nce[7][0]=2.0e-02;\nce[8][0]=1.0e-02;\nce[9][0]=3.0e-02;\nce[10][0]=5.0e-01;\nce[11][0]=4.0e-01;\nce[12][0]=3.0e-01;\n\nce[0][1]=1.0;\nce[1][1]=0.0;\nce[2][1]=0.0;\nce[3][1]=0.0;\nce[4][1]=1.0;\nce[5][1]=2.0;\nce[6][1]=3.0;\nce[7][1]=1.0e-02;\nce[8][1]=3.0e-02;\nce[9][1]=2.0e-02;\nce[10][1]=4.0e-01;\nce[11][1]=3.0e-01;\nce[12][1]=5.0e-01;\n\nce[0][2]=2.0;\nce[1][2]=2.0;\nce[2][2]=0.0;\nce[3][2]=0.0;\nce[4][2]=0.0;\nce[5][2]=2.0;\nce[6][2]=3.0;\nce[7][2]=4.0e-02;\nce[8][2]=3.0e-02;\nce[9][2]=5.0e-02;\nce[10][2]=3.0e-01;\nce[11][2]=5.0e-01;\nce[12][2]=4.0e-01;\n\nce[0][3]=2.0;\nce[1][3]=2.0;\nce[2][3]=0.0;\nce[3][3]=0.0;\nce[4][3]=0.0;\nce[5][3]=2.0;\nce[6][3]=3.0;\nce[7][3]=3.0e-02;\nce[8][3]=5.0e-02;\nce[9][3]=4.0e-02;\nce[10][3]=2.0e-01;\nce[11][3]=1.0e-01;\nce[12][3]=3.0e-01;\n\nce[0][4]=5.0;\nce[1][4]=4.0;\nce[2][4]=3.0;\nce[3][4]=2.0;\nce[4][4]=1.0e-01;\nce[5][4]=4.0e-01;\nce[6][4]=3.0e-01;\nce[7][4]=5.0e-02;\nce[8][4]=4.0e-02;\nce[9][4]=3.0e-02;\nce[10][4]=1.0e-01;\nce[11][4]=3.0e-01;\nce[12][4]=2.0e-01;\n}
void initialize(){\nint i, j, k, m, ix, iy, iz;\ndouble xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5];\n\n#pragma omp for\nfor(k=0; k<=grid_points[2]-1; k++){\nfor(j=0; j<=grid_points[1]-1; j++){\nfor(i=0; i<=grid_points[0]-1; i++){\nfor(m=0; m<5; m++){\nu[k][j][i][m]=1.0;\n}\n}\n}\n}\n\n#pragma omp for\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)(k)* dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)(j)*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)(i)*dnxm1;\nfor(ix=0; ix<2; ix++){\nexact_solution((double)ix, eta, zeta, &Pface[ix][0][0]);\n}\nfor(iy=0; iy<2; iy++){\nexact_solution(xi, (double)iy , zeta, &Pface[iy][1][0]);\n}\nfor(iz=0; iz<2; iz++){\nexact_solution(xi, eta, (double)iz, &Pface[iz][2][0]);\n}\nfor(m=0; m<5; m++){\nPxi=xi*Pface[1][0][m]+(1.0-xi)*Pface[0][0][m];\nPeta=eta*Pface[1][1][m]+(1.0-eta)*Pface[0][1][m];\nPzeta=zeta*Pface[1][2][m]+(1.0-zeta)*Pface[0][2][m];\nu[k][j][i][m]=Pxi+Peta+Pzeta-\nPxi*Peta-Pxi*Pzeta-Peta*Pzeta+\nPxi*Peta*Pzeta;\n}\n}\n}\n}\n\ni=0;\nxi=0.0;\n#pragma omp for\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)(k)*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)(j)*dnym1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\ni=grid_points[0]-1;\nxi=1.0;\n#pragma omp for\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)(k)*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)(j)*dnym1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nj=0;\neta=0.0;\n#pragma omp for\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)(k)*dnzm1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)(i)*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nj=grid_points[1]-1;\neta=1.0;\n#pragma omp for\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)(k)*dnzm1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)(i)*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nk=0;\nzeta=0.0;\n#pragma omp for\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)(j)*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)(i)*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n\nk=grid_points[2]-1;\nzeta=1.0;\n#pragma omp for\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)(j)*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)(i)*dnxm1;\nexact_solution(xi, eta, zeta, temp);\nfor(m=0; m<5; m++){\nu[k][j][i][m]=temp[m];\n}\n}\n}\n}
static void conj_grad(int colidx[],\nint rowstr[],\ndouble x[],\ndouble z[],\ndouble a[],\ndouble p[],\ndouble q[],\ndouble r[],\ndouble* rnorm){\nint j, k;\nint cgit, cgitmax;\ndouble alpha, beta, suml;\nstatic double d, sum, rho, rho0;\n\ncgitmax = 25;\n#pragma omp single nowait\n{\n\nrho = 0.0;\nsum = 0.0;\n}\n\n#pragma omp for\nfor(j = 0; j < naa+1; j++){\nq[j] = 0.0;\nz[j] = 0.0;\nr[j] = x[j];\np[j] = r[j];\n}\n\n\n#pragma omp for reduction(+:rho)\nfor(j = 0; j < lastcol - firstcol + 1; j++){\nrho += r[j]*r[j];\n}\n\n\nfor(cgit = 1; cgit <= cgitmax; cgit++){\n\n\n#pragma omp single nowait\n{\nd = 0.0;\n\nrho0 = rho;\nrho = 0.0;\n}\n\n#pragma omp for nowait\nfor(j = 0; j < lastrow - firstrow + 1; j++){\nsuml = 0.0;\nfor(k = rowstr[j]; k < rowstr[j+1]; k++){\nsuml += a[k]*p[colidx[k]];\n}\nq[j] = suml;\n}\n\n\n\n#pragma omp for reduction(+:d)\nfor (j = 0; j < lastcol - firstcol + 1; j++) {\nd += p[j]*q[j];\n}\n\n\nalpha = rho0 / d;\n\n\n\n#pragma omp for reduction(+:rho)\nfor(j = 0; j < lastcol - firstcol + 1; j++){\nz[j] += alpha*p[j];\nr[j] -= alpha*q[j];\n\n\nrho += r[j]*r[j];\n}\n\n\nbeta = rho / rho0;\n\n\n#pragma omp for\nfor(j = 0; j < lastcol - firstcol + 1; j++){\np[j] = r[j] + beta*p[j];\n}\n} \n\n\n#pragma omp for nowait\nfor(j = 0; j < lastrow - firstrow + 1; j++){\nsuml = 0.0;\nfor(k = rowstr[j]; k < rowstr[j+1]; k++){\nsuml += a[k]*z[colidx[k]];\n}\nr[j] = suml;\n}\n\n\n#pragma omp for reduction(+:sum)\nfor(j = 0; j < lastcol-firstcol+1; j++){\nsuml   = x[j] - r[j];\nsum += suml*suml;\n}\n#pragma omp single\n*rnorm = sqrt(sum);\n}
static void sparse(double a[],\nint colidx[],\nint rowstr[],\nint n,\nint nz,\nint nozer,\nint arow[],\nint acol[][NONZER+1],\ndouble aelt[][NONZER+1],\nint firstrow,\nint lastrow,\nint nzloc[],\ndouble rcond,\ndouble shift){\nint nrows;\n\n\nint i, j, j1, j2, nza, k, kk, nzrow, jcol;\ndouble size, scale, ratio, va;\nboolean goto_40;\n\n\nnrows = lastrow - firstrow + 1;\n\n\nfor(j = 0; j < nrows+1; j++){\nrowstr[j] = 0;\n}\nfor(i = 0; i < n; i++){\nfor(nza = 0; nza < arow[i]; nza++){\nj = acol[i][nza] + 1;\nrowstr[j] = rowstr[j] + arow[i];\n}\n}\nrowstr[0] = 0;\nfor(j = 1; j < nrows+1; j++){\nrowstr[j] = rowstr[j] + rowstr[j-1];\n}\nnza = rowstr[nrows] - 1;\n\n\nif(nza > nz){\nprintf("Space for matrix elements exceeded in sparse\n");\nprintf("nza, nzmax = %d, %d\n", nza, nz);\nexit(EXIT_FAILURE);\n}\n\n\nfor(j = 0; j < nrows; j++){\nfor(k = rowstr[j]; k < rowstr[j+1]; k++){\na[k] = 0.0;\ncolidx[k] = -1;\n}\nnzloc[j] = 0;\n}\n\n\nsize = 1.0;\nratio = pow(rcond, (1.0 / (double)(n)));\nfor(i = 0; i < n; i++){\nfor(nza = 0; nza < arow[i]; nza++){\nj = acol[i][nza];\n\nscale = size * aelt[i][nza];\nfor(nzrow = 0; nzrow < arow[i]; nzrow++){\njcol = acol[i][nzrow];\nva = aelt[i][nzrow] * scale;\n\n\nif(jcol == j && j == i){\nva = va + rcond - shift;\n}\n\ngoto_40 = FALSE;\nfor(k = rowstr[j]; k < rowstr[j+1]; k++){\nif(colidx[k] > jcol){\n\nfor(kk = rowstr[j+1]-2; kk >= k; kk--){\nif(colidx[kk] > -1){\na[kk+1] = a[kk];\ncolidx[kk+1] = colidx[kk];\n}\n}\ncolidx[k] = jcol;\na[k]  = 0.0;\ngoto_40 = TRUE;\nbreak;\n}else if(colidx[k] == -1){\ncolidx[k] = jcol;\ngoto_40 = TRUE;\nbreak;\n}else if(colidx[k] == jcol){\n\nnzloc[j] = nzloc[j] + 1;\ngoto_40 = TRUE;\nbreak;\n}\n}\nif(goto_40 == FALSE){\nprintf("internal error in sparse: i=%d\n", i);\nexit(EXIT_FAILURE);\n}\na[k] = a[k] + va;\n}\n}\nsize = size * ratio;\n}\n\n\nfor(j = 1; j < nrows; j++){\nnzloc[j] = nzloc[j] + nzloc[j-1];\n}\n\nfor(j = 0; j < nrows; j++){\nif(j > 0){\nj1 = rowstr[j] - nzloc[j-1];\n}else{\nj1 = 0;\n}\nj2 = rowstr[j+1] - nzloc[j];\nnza = rowstr[j];\nfor(k = j1; k < j2; k++){\na[k] = a[nza];\ncolidx[k] = colidx[nza];\nnza = nza + 1;\n}\n}\nfor(j = 1; j < nrows+1; j++){\nrowstr[j] = rowstr[j] - nzloc[j-1];\n}\nnza = rowstr[nrows] - 1;\n}
void exact_solution(double xi, double eta, double zeta, double dtemp[5]){\nint m;\nfor(m=0; m<5; m++){\ndtemp[m]=ce[0][m]+\nxi*(ce[1][m]+\nxi*(ce[4][m]+\nxi*(ce[7][m]+\nxi*ce[10][m])))+\neta*(ce[2][m]+\neta*(ce[5][m]+\neta*(ce[8][m]+\neta*ce[11][m])))+\nzeta*(ce[3][m]+\nzeta*(ce[6][m]+\nzeta*(ce[9][m]+\nzeta*ce[12][m])));\n}\n}
void exact(int i, int j, int k, double u000ijk[]){\n\nint m;\ndouble xi, eta, zeta;\nxi=((double)i)/(nx0-1);\neta=((double)j)/(ny0-1);\nzeta=((double)k)/(nz-1);\nfor(m=0; m<5; m++){\nu000ijk[m]=ce[0][m]+\n(ce[1][m]+\n(ce[4][m]+\n(ce[7][m]+\nce[10][m]*xi)*xi)*xi)*xi+\n(ce[2][m]+\n(ce[5][m]+\n(ce[8][m]+\nce[11][m]*eta)*eta)*eta)*eta+\n(ce[3][m]+\n(ce[6][m]+\n(ce[9][m]+\nce[12][m]*zeta)*zeta)*zeta)*zeta;\n}\n}
static void cfftz(int is,\nint m,\nint n,\ndcomplex x[][FFTBLOCKPAD],\ndcomplex y[][FFTBLOCKPAD]){\nint i,j,l,mx;\n\n\nmx = (int)(u[0].real);\nif((is != 1 && is != -1) || m < 1 || m > mx){\nprintf("CFFTZ: Either U has not been initialized, or else\n"\n"one of the input parameters is invalid%5d%5d%5d\n", is, m, mx);\nexit(EXIT_FAILURE);\n}\n\n\nfor(l=1; l<=m; l+=2){\nfftz2(is, l, m, n, FFTBLOCK, FFTBLOCKPAD, u, x, y);\nif(l==m){\n\nfor(j=0; j<n; j++){\nfor(i=0; i<FFTBLOCK; i++){\nx[j][i] = y[j][i];\n}\n}\nbreak;\n}\nfftz2(is, l + 1, m, n, FFTBLOCK, FFTBLOCKPAD, u, y, x);\n}\n}
static void ipow46(double a,\nint exponent,\ndouble* result){\ndouble q, r;\nint n, n2;\n\n\n*result = 1;\nif(exponent==0){return;}\nq = a;\nr = 1;\nn = exponent;\n\nwhile(n > 1){\nn2 = n/2;\nif(n2*2==n){\nrandlc(&q, q);\nn = n2;\n}else{\nrandlc(&r, q);\nn = n-1;\n}\n}\nrandlc(&r, q);\n*result = r;\n}\n\nstatic void print_timers(){\nint i;\ndouble t, t_m;\nchar* tstrings[T_MAX+1];\ntstrings[1] = (char*)"          total ";\ntstrings[2] = (char*)"          setup ";\ntstrings[3] = (char*)"            fft ";\ntstrings[4] = (char*)"         evolve ";\ntstrings[5] = (char*)"       checksum ";\ntstrings[6] = (char*)"           fftx ";\ntstrings[7] = (char*)"           ffty ";\ntstrings[8] = (char*)"           fftz ";\n\nt_m = timer_read(T_TOTAL);\nif(t_m <= 0.0){t_m = 1.00;}\nfor(i = 1; i <= T_MAX; i++){\nt = timer_read(i);\nprintf(" timer %2d(%16s) :%9.4f (%6.2f%%)\n",\ni, tstrings[i], t, t*100.0/t_m);\n}\n}\n\nstatic void setup(){\nFILE* fp;\ndebug = FALSE;\n\nif((fp = fopen("timer.flag", "r")) != NULL){\ntimers_enabled = TRUE;\nfclose(fp);\n}else{\ntimers_enabled = FALSE;\n}\n\nniter = NITER_DEFAULT;\n\nprintf("\n\nNAS Parallel Benchmarks 4.1 Parallel C++ version with OpenMP - FT Benchmark\n\n");\nprintf(" Size                : %4dx%4dx%4d\n", NX, NY, NZ);\nprintf(" Iterations                  :%7d\n", niter);\nprintf("\n");\n\ndims[0] = NX;\ndims[1] = NY;\ndims[2] = NZ;\n\n\n\n\n\n\n}
void adi(){\ncompute_rhs();\ntxinvr();\nx_solve();\ny_solve();\nz_solve();\nadd();\n}
static void sprnvc(int n, int nz, int nn1, double v[], int iv[]){\nint nzv, ii, i;\ndouble vecelt, vecloc;\n\nnzv = 0;\n\nwhile(nzv < nz){\nvecelt = randlc(&tran, amult);\n\n\nvecloc = randlc(&tran, amult);\ni = icnvrt(vecloc, nn1) + 1;\nif(i>n){continue;}\n\n\nboolean was_gen = FALSE;\nfor(ii = 0; ii < nzv; ii++){\nif(iv[ii] == i){\nwas_gen = TRUE;\nbreak;\n}\n}\nif(was_gen){continue;}\nv[nzv] = vecelt;\niv[nzv] = i;\nnzv = nzv + 1;\n}\n}
void ssor(int niter){\n\nint i, j, k, m, n;\nint istep;\ndouble tmp, tv[ISIZ2*(ISIZ1/2*2+1)*5];\ndouble delunm[5];\n\ntmp=1.0/(omega*(2.0-omega));\n\n\n#pragma omp parallel for private(i,j,n,m)\nfor(j=0; j<ISIZ2; j++){\nfor(i=0; i<ISIZ1; i++){\nfor(n=0; n<5; n++){\nfor(m=0; m<5; m++){\na[j][i][n][m]=0.0;\nb[j][i][n][m]=0.0;\nc[j][i][n][m]=0.0;\nd[j][i][n][m]=0.0;\n}\n}\n}\n}\nfor(i=1;i<=T_LAST;i++){timer_clear(i);}\n\n\n#pragma omp parallel\n{\n\nrhs();\n\n\nl2norm(	nx0,\nny0,\nnz0,\nist,\niend,\njst,\njend,\nrsd,\nrsdnm);\n} \n\n\nfor(i=1;i<=T_LAST;i++){timer_clear(i);}\ntimer_start(1);\n\n#pragma omp parallel private(istep,i,j,k,m)\n{\n\nfor(istep=1; istep<=niter; istep++){\nif((istep%20)==0||istep==itmax||istep==1){\n#pragma omp master\nif(niter>1){printf(" Time step %4d\n",istep);}\n}\n\nif(timeron){\n#pragma omp master\ntimer_start(T_RHS);\n}\n#pragma omp for\nfor(k=1; k<nz-1; k++){\nfor(j=jst; j<jend; j++){\nfor(i=ist; i<iend; i++){\nfor(m=0; m<5; m++){\nrsd[k][j][i][m]=dt*rsd[k][j][i][m];\n}\n}\n}\n}\nif(timeron){\n#pragma omp master\ntimer_stop(T_RHS);\n}\n\nfor(k=1; k<nz-1; k++){\n\nif(timeron){\n#pragma omp master\ntimer_start(T_JACLD);\n}\njacld(k);\nif(timeron){\n#pragma omp master\ntimer_stop(T_JACLD);\n}\n\n\nif(timeron){\n#pragma omp master\ntimer_start(T_BLTS);\n}\n\nblts(	nx,\nny,\nnz,\nk,\nomega,\nrsd,\na,\nb,\nc,\nd,\nist,\niend,\njst,\njend,\nnx0,\nny0);\n\nif(timeron){\n#pragma omp master\ntimer_stop(T_BLTS);\n}\n}\n\n#pragma omp barrier\n\nfor(k=nz-2; k>0; k--){\n\nif(timeron){\n#pragma omp master\ntimer_start(T_JACU);\n}\njacu(k);\nif(timeron){\n#pragma omp master\ntimer_stop(T_JACU);\n}\n\nif(timeron){\n#pragma omp master\ntimer_start(T_BUTS);\n}\n\nbuts(	nx,\nny,\nnz,\nk,\nomega,\nrsd,\ntv,\nd,\na,\nb,\nc,\nist,\niend,\njst,\njend,\nnx0,\nny0);\n\nif(timeron){\n#pragma omp master\ntimer_stop(T_BUTS);\n}\n}\n\n#pragma omp barrier\n\n\nif(timeron){\n#pragma omp master\ntimer_start(T_ADD);\n}\n\n#pragma omp for\nfor(k=1; k<nz-1; k++){\nfor(j=jst; j<jend; j++){\nfor(i=ist; i<iend; i++){\nfor(m=0; m<5; m++){\nu[k][j][i][m]=u[k][j][i][m]+tmp*rsd[k][j][i][m];\n}\n}\n}\n}\nif(timeron){\n#pragma omp master\ntimer_stop(T_ADD);\n}\n\n\nif((istep%inorm)==0){\nif(timeron){\n#pragma omp master\ntimer_start(T_L2NORM);\n}\nl2norm(	nx0,\nny0,\nnz0,\nist,\niend,\njst,\njend,\nrsd,\ndelunm);\nif(timeron){\n#pragma omp master\ntimer_stop(T_L2NORM);\n}\n}\n\nrhs();\n\n\nif(((istep%inorm)==0)||( istep == itmax)){\nif(timeron){\n#pragma omp master\ntimer_start(T_L2NORM);\n}\nl2norm(	nx0,\nny0,\nnz0,\nist,\niend,\njst,\njend,\nrsd,\nrsdnm);\nif(timeron){\n#pragma omp master\ntimer_stop(T_L2NORM);\n}\n}\n\nif((rsdnm[0]<tolrsd[0])&&\n(rsdnm[1]<tolrsd[1])&&\n(rsdnm[2]<tolrsd[2])&&\n(rsdnm[3]<tolrsd[3])&&\n(rsdnm[4]<tolrsd[4])){\n#pragma omp master\nprintf("\nconvergence was achieved after %4d pseudo-time steps\n",istep);\nbreak;\n}\n}\n} \n\ntimer_stop(1);\nmaxtime=timer_read(1);\n}
static void comm3(void* pointer_u, int n1, int n2, int n3, int kk){\n#ifdef __clang__\nusing custom_cast = double (*)[n2][n1];\ncustom_cast u = reinterpret_cast<custom_cast>(pointer_u);\n#else\ndouble (*u)[n2][n1] = (double (*)[n2][n1])pointer_u;\n#endif\n\nint i1, i2, i3;\nif(timeron){\n#pragma omp master\ntimer_start(T_COMM3);\n}\n#pragma omp for\nfor(i3 = 1; i3 < n3-1; i3++){\n\nfor(i2 = 1; i2 < n2-1; i2++){\nu[i3][i2][0] = u[i3][i2][n1-2];\nu[i3][i2][n1-1] = u[i3][i2][1];\n}\n\nfor(i1 = 0; i1 < n1; i1++){\nu[i3][0][i1] = u[i3][n2-2][i1];\nu[i3][n2-1][i1] = u[i3][1][i1];\n}\n}\n\n#pragma omp for\nfor(i2 = 0; i2 < n2; i2++){\nfor(i1 = 0; i1 < n1; i1++){\nu[0][i2][i1] = u[n3-2][i2][i1];\nu[n3-1][i2][i1] = u[1][i2][i1];\n}\n}\n\nif(timeron){\n#pragma omp master\ntimer_stop(T_COMM3);\n}\n}
void exact_solution(double xi, double eta, double zeta, double dtemp[]){\nint m;\nfor(m=0; m<5; m++){\ndtemp[m]=ce[0][m]+xi*\n(ce[1][m]+xi*\n(ce[4][m]+xi*\n(ce[7][m]+xi*\nce[10][m])))+eta*\n(ce[2][m]+eta*\n(ce[5][m]+eta*\n(ce[8][m]+eta*\nce[11][m])))+zeta*\n(ce[3][m]+zeta*\n(ce[6][m]+zeta*\n(ce[9][m]+zeta*\nce[12][m])));\n}\n}
static void compute_initial_conditions(void* pointer_u0,\nint d1,\nint d2,\nint d3){\ndcomplex (*u0)[NY][NX] = (dcomplex(*)[NY][NX])pointer_u0;\n\nint k, j;\ndouble x0, start, an, starts[NZ];\nstart = SEED;\n\n\nipow46(A, 0, &an);\nrandlc(&start, an);\nipow46(A, 2*NX*NY, &an);\n\nstarts[0] = start;\nfor(int k=1; k<dims[2]; k++){\nrandlc(&start, an);\nstarts[k] = start;\n}\n\n\n#pragma omp parallel for private(k,j,x0)\nfor(k=0; k<dims[2]; k++){\nx0 = starts[k];\nfor(j=0; j<dims[1]; j++){\nvranlc(2*NX, &x0, A, (double*)&u0[k][j][0]);\n}\n}\n}
void setiv(){\n\nint i, j, k, m;\ndouble xi, eta, zeta;\ndouble pxi, peta, pzeta;\ndouble ue_1jk[5], ue_nx0jk[5], ue_i1k[5];\ndouble ue_iny0k[5], ue_ij1[5], ue_ijnz[5];\n\n#pragma omp for\nfor(k=1; k<nz-1; k++){\nzeta=((double)k)/(nz-1);\nfor(j=1; j<ny-1; j++){\neta=((double)j)/(ny0-1);\nfor(i=1; i<nx-1; i++){\nxi=((double)i)/(nx0-1);\nexact(0, j, k, ue_1jk);\nexact(nx0-1, j, k, ue_nx0jk);\nexact(i, 0, k, ue_i1k);\nexact(i, ny0-1, k, ue_iny0k);\nexact(i, j, 0, ue_ij1);\nexact(i, j, nz-1, ue_ijnz);\nfor(m=0; m<5; m++){\npxi=(1.0-xi)*ue_1jk[m]\n+xi*ue_nx0jk[m];\npeta=(1.0-eta)*ue_i1k[m]\n+eta*ue_iny0k[m];\npzeta=(1.0-zeta)*ue_ij1[m]\n+zeta*ue_ijnz[m];\nu[k][j][i][m]=pxi+peta+pzeta\n-pxi*peta-peta*pzeta-pzeta*pxi\n+pxi*peta*pzeta;\n}\n}\n}\n}\n}
void add(){\nint i, j, k, m;\nint thread_id = omp_get_thread_num();\n\nif(timeron && thread_id==0){timer_start(T_ADD);}\n#pragma omp for\nfor(k=1; k<=grid_points[2]-2; k++){\nfor(j=1; j<=grid_points[1]-2; j++){\nfor(i=1; i<=grid_points[0]-2; i++){\nfor(m=0; m<5; m++){\nu[k][j][i][m]=u[k][j][i][m]+rhs[k][j][i][m];\n}\n}\n}\n}\nif(timeron && thread_id==0){timer_stop(T_ADD);}\n}
void txinvr(){\nint i, j, k;\ndouble t1, t2, t3, ac, ru1, uu, vv, ww, r1, r2, r3, r4, r5, ac2inv;\nint thread_id = omp_get_thread_num();\n\nif(timeron && thread_id==0){timer_start(T_TXINVR);}\n#pragma omp for\nfor(k=1; k<=nz2; k++){\nfor(j=1; j<=ny2; j++){\nfor(i=1; i<=nx2; i++){\nru1=rho_i[k][j][i];\nuu=us[k][j][i];\nvv=vs[k][j][i];\nww=ws[k][j][i];\nac=speed[k][j][i];\nac2inv=ac*ac;\nr1=rhs[k][j][i][0];\nr2=rhs[k][j][i][1];\nr3=rhs[k][j][i][2];\nr4=rhs[k][j][i][3];\nr5=rhs[k][j][i][4];\nt1=c2/ac2inv*(qs[k][j][i]*r1-uu*r2-vv*r3-ww*r4+r5);\nt2=bt*ru1*(uu*r1-r2);\nt3=(bt*ru1*ac)*t1;\nrhs[k][j][i][0]=r1-t1;\nrhs[k][j][i][1]=-ru1*(ww*r1-r4);\nrhs[k][j][i][2]=ru1*(vv*r1-r3);\nrhs[k][j][i][3]=-t2+t3;\nrhs[k][j][i][4]=t2+t3;\n}\n}\n}\nif(timeron && thread_id==0){timer_stop(T_TXINVR);}\n}
static void cffts2(int is,\nint d1,\nint d2,\nint d3,\nvoid* pointer_x,\nvoid* pointer_xout,\ndcomplex y1[][FFTBLOCKPAD],\ndcomplex y2[][FFTBLOCKPAD]){\ndcomplex (*x)[NY][NX] = (dcomplex(*)[NY][NX])pointer_x;\ndcomplex (*xout)[NY][NX] = (dcomplex(*)[NY][NX])pointer_xout;\n\nint logd2;\nint i, j, k, ii;\n\nlogd2 = ilog2(d2);\n\nif(timers_enabled){\n#pragma omp master\ntimer_start(T_FFTY);\n}\n\n#pragma omp for\nfor(k=0; k<d3; k++){\nfor(ii=0; ii<=d1-FFTBLOCK; ii+=FFTBLOCK){\nfor(j=0; j<d2; j++){\nfor(i=0; i<FFTBLOCK; i++){\ny1[j][i] = x[k][j][i+ii];\n}\n}\ncfftz(is, logd2, d2, y1, y2);\nfor(j=0; j<d2; j++){\nfor(i=0; i<FFTBLOCK; i++){\nxout[k][j][i+ii] = y1[j][i];\n}\n}\n}\n}\n\nif(timers_enabled){\n#pragma omp master\ntimer_stop(T_FFTY);\n}\n}
void setbv(){\n\nint i, j, k, m;\ndouble temp1[5], temp2[5];\n\n#pragma omp for\nfor(j=0; j<ny; j++){\nfor(i=0; i<nx; i++){\nexact(i, j, 0, temp1);\nexact(i, j, nz-1, temp2);\nfor(m=0; m<5; m++){\nu[0][j][i][m]=temp1[m];\nu[nz-1][j][i][m]=temp2[m];\n}\n}\n}\n\n#pragma omp for\nfor(k=0; k<nz; k++){\nfor(i=0; i<nx; i++){\nexact(i, 0, k, temp1);\nexact(i, ny-1, k, temp2);\nfor(m=0; m<5; m++){\nu[k][0][i][m]=temp1[m];\nu[k][ny-1][i][m]=temp2[m];\n}\n}\n}\n\n#pragma omp for\nfor(k=0; k<nz; k++){\nfor(j=0; j<ny; j++){\nexact(0, j, k, temp1);\nexact(nx-1, j, k, temp2);\nfor(m=0; m<5; m++){\nu[k][j][0][m]=temp1[m];\nu[k][j][nx-1][m]=temp2[m];\n}\n}\n}\n}
void adi(){\ncompute_rhs();\nx_solve();\ny_solve();\nz_solve();\nadd();\n}
static void vecset(int n, double v[], int iv[], int* nzv, int i, double val){\nint k;\nboolean set;\n\nset = FALSE;\nfor(k = 0; k < *nzv; k++){\nif(iv[k] == i){\nv[k] = val;\nset  = TRUE;\n}\n}\nif(set == FALSE){\nv[*nzv]  = val;\niv[*nzv] = i;\n*nzv     = *nzv + 1;\n}\n}
void error_norm(double rms[5]){\nint i, j, k, m, d;\ndouble xi, eta, zeta, u_exact[5], add;\nfor(m=0;m<5;m++){rms[m]=0.0;}\nfor(k=0; k<=grid_points[2]-1; k++){\nzeta=(double)(k)*dnzm1;\nfor(j=0; j<=grid_points[1]-1; j++){\neta=(double)(j)*dnym1;\nfor(i=0; i<=grid_points[0]-1; i++){\nxi=(double)(i)*dnxm1;\nexact_solution(xi, eta, zeta, u_exact);\nfor(m=0; m<5; m++){\nadd=u[k][j][i][m]-u_exact[m];\nrms[m]=rms[m]+add*add;\n}\n}\n}\n}\nfor(m=0; m<5; m++){\nfor(d=0; d<3; d++){\nrms[m]=rms[m]/(double)(grid_points[d]-2);\n}\nrms[m]=sqrt(rms[m]);\n}\n}
static void bubble(double ten[][MM], int j1[][MM], int j2[][MM], int j3[][MM], int m, int ind){\ndouble temp;\nint i, j_temp;\n\nif(ind == 1){\nfor(i = 0; i < m-1; i++){\nif(ten[ind][i] > ten[ind][i+1]){\ntemp = ten[ind][i+1];\nten[ind][i+1] = ten[ind][i];\nten[ind][i] = temp;\n\nj_temp = j1[ind][i+1];\nj1[ind][i+1] = j1[ind][i];\nj1[ind][i] = j_temp;\n\nj_temp = j2[ind][i+1];\nj2[ind][i+1] = j2[ind][i];\nj2[ind][i] = j_temp;\n\nj_temp = j3[ind][i+1];\nj3[ind][i+1] = j3[ind][i];\nj3[ind][i] = j_temp;\n}else{\nreturn;\n}\n}\n}else{\nfor(i = 0; i < m-1; i++){\nif(ten[ind][i] < ten[ind][i+1]){\ntemp = ten[ind][i+1];\nten[ind][i+1] = ten[ind][i];\nten[ind][i] = temp;\n\nj_temp = j1[ind][i+1];\nj1[ind][i+1] = j1[ind][i];\nj1[ind][i] = j_temp;\n\nj_temp = j2[ind][i+1];\nj2[ind][i+1] = j2[ind][i];\nj2[ind][i] = j_temp;\n\nj_temp = j3[ind][i+1];\nj3[ind][i+1] = j3[ind][i];\nj3[ind][i] = j_temp;\n}else{\nreturn;\n}\n}\n}\n}
static void showall(void* pointer_z, int n1, int n2, int n3){\n#ifdef __clang__\nusing custom_cast = double (*)[n2][n1];\ncustom_cast z = reinterpret_cast<custom_cast>(pointer_z);\n#else\ndouble (*z)[n2][n1] = (double (*)[n2][n1])pointer_z;\n#endif\n\nint i1,i2,i3;\nint m1, m2, m3;\n\nm1 = min(n1,18);\nm2 = min(n2,14);\nm3 = min(n3,18);\n\nprintf("\n");\nfor(i3 = 0; i3 < m3; i3++){\nfor(i2 = 0; i2 < m2; i2++){\nfor(i1 = 0; i1 < m1; i1++){\nprintf("%6.3f", z[i3][i2][i1]);\n}\nprintf("\n");\n}\nprintf(" - - - - - - -\n");\n}\nprintf("\n");\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(X,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(B,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++)\n{\nX[i][j] = ((DATA_TYPE) i*(j+1) + 1) / n;\nA[i][j] = ((DATA_TYPE) i*(j+2) + 2) / n;\nB[i][j] = ((DATA_TYPE) i*(j+3) + 3) / n;\n}\n}
void print_array(int ni, int nl,\nDATA_TYPE POLYBENCH_2D(D,NI,NL,ni,nl))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nl; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, D[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void kernel_durbin(int n,\nDATA_TYPE POLYBENCH_2D(y,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(sum,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(alpha,N,n),\nDATA_TYPE POLYBENCH_1D(beta,N,n),\nDATA_TYPE POLYBENCH_1D(r,N,n),\nDATA_TYPE POLYBENCH_1D(out,N,n))\n{\nint i, k;\n\n#pragma scop\ny[0][0] = r[0];\nbeta[0] = 1;\nalpha[0] = r[0];\nfor (k = 1; k < _PB_N; k++)\n{\nbeta[k] = beta[k-1] - alpha[k-1] * alpha[k-1] * beta[k-1];\nsum[0][k] = r[k];\nfor (i = 0; i <= k - 1; i++)\nsum[i+1][k] = sum[i][k] + r[k-i-1] * y[i][k-1];\nalpha[k] = -sum[k][k] * beta[k];\nfor (i = 0; i <= k-1; i++)\ny[i][k] = y[i][k-1] + alpha[k] * y[k-i-1][k-1];\ny[k][k] = alpha[k];\n}\nfor (i = 0; i < _PB_N; i++)\nout[i] = y[i][_PB_N-1];\n#pragma endscop\n\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++) {\nfprintf(stderr, DATA_PRINTF_MODIFIER, A[i][j]);\nif ((i * n + j) % 20 == 0) fprintf(stderr, "\n");\n}\nfprintf(stderr, "\n");\n}
void init_array(int ni, int nj,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NI,ni,ni),\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj))\n{\nint i, j;\n\n*alpha = 32412;\n*beta = 2123;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++)\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < ni; j++)\nC[i][j] = ((DATA_TYPE) i*j) / ni;\n}
void init_array(int ni, int nj,\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(R,NJ,NJ,nj,nj),\nDATA_TYPE POLYBENCH_2D(Q,NI,NJ,ni,nj))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nQ[i][j] = ((DATA_TYPE) i*(j+1)) / nj;\n}\nfor (i = 0; i < nj; i++)\nfor (j = 0; j < nj; j++)\nR[i][j] = ((DATA_TYPE) i*(j+2)) / nj;\n}
void init_array (int m,\nint n,\nDATA_TYPE *float_n,\nDATA_TYPE POLYBENCH_2D(data,M,N,m,n))\n{\nint i, j;\n\n*float_n = 1.2;\n\nfor (i = 0; i < m; i++)\nfor (j = 0; j < n; j++)\ndata[i][j] = ((DATA_TYPE) i*j) / M;\n}\n
void init_array (int m, int n,\nDATA_TYPE *float_n,\nDATA_TYPE POLYBENCH_2D(data,M,N,m,n))\n{\nint i, j;\n\n*float_n = 1.2;\n\nfor (i = 0; i < M; i++)\nfor (j = 0; j < N; j++)\ndata[i][j] = ((DATA_TYPE) i*j) / M;\n}
void print_array(int m,\nDATA_TYPE POLYBENCH_2D(symmat,M,M,m,m))\n\n{\nint i, j;\n\nfor (i = 0; i < m; i++)\nfor (j = 0; j < m; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, symmat[i][j]);\nif ((i * m + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void kernel_doitgen(int nr, int nq, int np,\nDATA_TYPE POLYBENCH_3D(A,NR,NQ,NP,nr,nq,np),\nDATA_TYPE POLYBENCH_2D(C4,NP,NP,np,np),\nDATA_TYPE POLYBENCH_3D(sum,NR,NQ,NP,nr,nq,np))\n{\nint r, q, p, s;\n\n#pragma scop\nfor (r = 0; r < _PB_NR; r++)\nfor (q = 0; q < _PB_NQ; q++)  {\nfor (p = 0; p < _PB_NP; p++)  {\nsum[r][q][p] = 0;\nfor (s = 0; s < _PB_NP; s++)\nsum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];\n}\nfor (p = 0; p < _PB_NR; p++)\nA[r][q][p] = sum[r][q][p];\n}\n#pragma endscop\n\n}
void kernel_trisolv(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(x,N,n),\nDATA_TYPE POLYBENCH_1D(c,N,n))\n{\nint i, j;\n\n#pragma scop\nfor (i = 0; i < _PB_N; i++)\n{\nx[i] = c[i];\nfor (j = 0; j <= i - 1; j++)\nx[i] = x[i] - A[i][j] * x[j];\nx[i] = x[i] / A[i][i];\n}\n#pragma endscop\n\n}
void init_array(int n,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(B,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(x,N,n))\n{\nint i, j;\n\n*alpha = 43532;\n*beta = 12313;\nfor (i = 0; i < n; i++)\n{\nx[i] = ((DATA_TYPE) i) / n;\nfor (j = 0; j < n; j++) {\nA[i][j] = ((DATA_TYPE) i*j) / n;\nB[i][j] = ((DATA_TYPE) i*j) / n;\n}\n}\n}
void print_array(int ni,\nDATA_TYPE POLYBENCH_2D(C,NI,NI,ni,ni))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < ni; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, C[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void kernel_syrk(int ni, int nj,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NI,ni,ni),\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj))\n{\nint i, j, k;\n\n#pragma scop\n/*  C := alpha*A*A' + beta*C */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NI; j++)\nC[i][j] *= beta;\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NI; j++)\nfor (k = 0; k < _PB_NJ; k++)\nC[i][j] += alpha * A[i][k] * A[j][k];\n#pragma endscop\n\n}
void init_array(int n,\nDATA_TYPE POLYBENCH_1D(x1,N,n),\nDATA_TYPE POLYBENCH_1D(x2,N,n),\nDATA_TYPE POLYBENCH_1D(y_1,N,n),\nDATA_TYPE POLYBENCH_1D(y_2,N,n),\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\n{\nx1[i] = ((DATA_TYPE) i) / n;\nx2[i] = ((DATA_TYPE) i + 1) / n;\ny_1[i] = ((DATA_TYPE) i + 3) / n;\ny_2[i] = ((DATA_TYPE) i + 4) / n;\nfor (j = 0; j < n; j++)\nA[i][j] = ((DATA_TYPE) i*j) / N;\n}\n}
void kernel_fdtd_apml(int cz,\nint cxm,\nint cym,\nDATA_TYPE mui,\nDATA_TYPE ch,\nDATA_TYPE POLYBENCH_2D(Ax,CZ+1,CYM+1,cz+1,cym+1),\nDATA_TYPE POLYBENCH_2D(Ry,CZ+1,CYM+1,cz+1,cym+1),\nDATA_TYPE POLYBENCH_2D(clf,CYM+1,CXM+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_2D(tmp,CYM+1,CXM+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Bza,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Ex,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Ey,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Hz,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_1D(czm,CZ+1,cz+1),\nDATA_TYPE POLYBENCH_1D(czp,CZ+1,cz+1),\nDATA_TYPE POLYBENCH_1D(cxmh,CXM+1,cxm+1),\nDATA_TYPE POLYBENCH_1D(cxph,CXM+1,cxm+1),\nDATA_TYPE POLYBENCH_1D(cymh,CYM+1,cym+1),\nDATA_TYPE POLYBENCH_1D(cyph,CYM+1,cym+1))\n{\nint iz, iy, ix;\n\n#pragma scop\nfor (iz = 0; iz < _PB_CZ; iz++)\n{\nfor (iy = 0; iy < _PB_CYM; iy++)\n{\nfor (ix = 0; ix < _PB_CXM; ix++)\n{\nclf[iz][iy] = Ex[iz][iy][ix] - Ex[iz][iy+1][ix] + Ey[iz][iy][ix+1] - Ey[iz][iy][ix];\ntmp[iz][iy] = (cymh[iy] / cyph[iy]) * Bza[iz][iy][ix] - (ch / cyph[iy]) * clf[iz][iy];\nHz[iz][iy][ix] = (cxmh[ix] /cxph[ix]) * Hz[iz][iy][ix]\n+ (mui * czp[iz] / cxph[ix]) * tmp[iz][iy]\n- (mui * czm[iz] / cxph[ix]) * Bza[iz][iy][ix];\nBza[iz][iy][ix] = tmp[iz][iy];\n}\nclf[iz][iy] = Ex[iz][iy][_PB_CXM] - Ex[iz][iy+1][_PB_CXM] + Ry[iz][iy] - Ey[iz][iy][_PB_CXM];\ntmp[iz][iy] = (cymh[iy] / cyph[iy]) * Bza[iz][iy][_PB_CXM] - (ch / cyph[iy]) * clf[iz][iy];\nHz[iz][iy][_PB_CXM]=(cxmh[_PB_CXM] / cxph[_PB_CXM]) * Hz[iz][iy][_PB_CXM]\n+ (mui * czp[iz] / cxph[_PB_CXM]) * tmp[iz][iy]\n- (mui * czm[iz] / cxph[_PB_CXM]) * Bza[iz][iy][_PB_CXM];\nBza[iz][iy][_PB_CXM] = tmp[iz][iy];\nfor (ix = 0; ix < _PB_CXM; ix++)\n{\nclf[iz][iy] = Ex[iz][_PB_CYM][ix] - Ax[iz][ix] + Ey[iz][_PB_CYM][ix+1] - Ey[iz][_PB_CYM][ix];\ntmp[iz][iy] = (cymh[_PB_CYM] / cyph[iy]) * Bza[iz][iy][ix] - (ch / cyph[iy]) * clf[iz][iy];\nHz[iz][_PB_CYM][ix] = (cxmh[ix] / cxph[ix]) * Hz[iz][_PB_CYM][ix]\n+ (mui * czp[iz] / cxph[ix]) * tmp[iz][iy]\n- (mui * czm[iz] / cxph[ix]) * Bza[iz][_PB_CYM][ix];\nBza[iz][_PB_CYM][ix] = tmp[iz][iy];\n}\nclf[iz][iy] = Ex[iz][_PB_CYM][_PB_CXM] - Ax[iz][_PB_CXM] + Ry[iz][_PB_CYM] - Ey[iz][_PB_CYM][_PB_CXM];\ntmp[iz][iy] = (cymh[_PB_CYM] / cyph[_PB_CYM]) * Bza[iz][_PB_CYM][_PB_CXM] - (ch / cyph[_PB_CYM]) * clf[iz][iy];\nHz[iz][_PB_CYM][_PB_CXM] = (cxmh[_PB_CXM] / cxph[_PB_CXM]) * Hz[iz][_PB_CYM][_PB_CXM]\n+ (mui * czp[iz] / cxph[_PB_CXM]) * tmp[iz][iy]\n- (mui * czm[iz] / cxph[_PB_CXM]) * Bza[iz][_PB_CYM][_PB_CXM];\nBza[iz][_PB_CYM][_PB_CXM] = tmp[iz][iy];\n}\n}\n#pragma endscop\n\n}
void print_array(int ni,\nDATA_TYPE POLYBENCH_2D(B,NI,NI,ni,ni))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < ni; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, B[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++)\nA[i][j] = ((DATA_TYPE) i*(j+2) + 2) / n;\n}
void init_array(int n,\nDATA_TYPE POLYBENCH_1D(p,N,n),\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\n{\np[i] = 1.0 / n;\nfor (j = 0; j < n; j++)\nA[i][j] = 1.0 / n;\n}\n}
void print_array(int ni, int nj,\nDATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, C[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, A[i][j]);\nif ((i * n + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}\n
void init_array (int n,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(u1,N,n),\nDATA_TYPE POLYBENCH_1D(v1,N,n),\nDATA_TYPE POLYBENCH_1D(u2,N,n),\nDATA_TYPE POLYBENCH_1D(v2,N,n),\nDATA_TYPE POLYBENCH_1D(w,N,n),\nDATA_TYPE POLYBENCH_1D(x,N,n),\nDATA_TYPE POLYBENCH_1D(y,N,n),\nDATA_TYPE POLYBENCH_1D(z,N,n))\n{\nint i, j;\n\n*alpha = 43532;\n*beta = 12313;\n\nfor (i = 0; i < n; i++)\n{\nu1[i] = i;\nu2[i] = (i+1)/n/2.0;\nv1[i] = (i+1)/n/4.0;\nv2[i] = (i+1)/n/6.0;\ny[i] = (i+1)/n/8.0;\nz[i] = (i+1)/n/9.0;\nx[i] = 0.0;\nw[i] = 0.0;\nfor (j = 0; j < n; j++)\nA[i][j] = ((DATA_TYPE) i*j) / n;\n}\n}
void print_array(int ni, int nj,\nDATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, C[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void init_array(int ni, int nj,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(A,NJ,NJ,nj,nj),\nDATA_TYPE POLYBENCH_2D(B,NI,NJ,ni,nj))\n{\nint i, j;\n\n*alpha = 32412;\n*beta = 2123;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nC[i][j] = ((DATA_TYPE) i*j) / ni;\nB[i][j] = ((DATA_TYPE) i*j) / ni;\n}\nfor (i = 0; i < nj; i++)\nfor (j = 0; j < nj; j++)\nA[i][j] = ((DATA_TYPE) i*j) / ni;\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(x,N,n))\n\n{\nint i;\n\nfor (i = 0; i < n; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, x[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(y,N,n))\n\n{\nint i;\n\nfor (i = 0; i < n; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, y[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\n}
void kernel_gramschmidt(int ni, int nj,\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(R,NJ,NJ,nj,nj),\nDATA_TYPE POLYBENCH_2D(Q,NI,NJ,ni,nj))\n{\nint i, j, k;\n\nDATA_TYPE nrm;\n\n#pragma scop\nfor (k = 0; k < _PB_NJ; k++)\n{\nnrm = 0;\nfor (i = 0; i < _PB_NI; i++)\nnrm += A[i][k] * A[i][k];\nR[k][k] = sqrt(nrm);\nfor (i = 0; i < _PB_NI; i++)\nQ[i][k] = A[i][k] / R[k][k];\nfor (j = k + 1; j < _PB_NJ; j++)\n{\nR[k][j] = 0;\nfor (i = 0; i < _PB_NI; i++)\nR[k][j] += Q[i][k] * A[i][j];\nfor (i = 0; i < _PB_NI; i++)\nA[i][j] = A[i][j] - Q[i][k] * R[k][j];\n}\n}\n#pragma endscop\n\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(w,N,n))\n{\nint i;\n\nfor (i = 0; i < n; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, w[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\n}
void kernel_covariance(int m, int n,\nDATA_TYPE float_n,\nDATA_TYPE POLYBENCH_2D(data,M,N,m,n),\nDATA_TYPE POLYBENCH_2D(symmat,M,M,m,m),\nDATA_TYPE POLYBENCH_1D(mean,M,m))\n{\nint i, j, j1, j2;\n\n#pragma scop\n/* Determine mean of column vectors of input data matrix */\nfor (j = 0; j < _PB_M; j++)\n{\nmean[j] = 0.0;\nfor (i = 0; i < _PB_N; i++)\nmean[j] += data[i][j];\nmean[j] /= float_n;\n}\n\n/* Center the column vectors. */\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_M; j++)\ndata[i][j] -= mean[j];\n\n/* Calculate the m * m covariance matrix. */\nfor (j1 = 0; j1 < _PB_M; j1++)\nfor (j2 = j1; j2 < _PB_M; j2++)\n{\nsymmat[j1][j2] = 0.0;\nfor (i = 0; i < _PB_N; i++)\nsymmat[j1][j2] += data[i][j1] * data[i][j2];\nsymmat[j2][j1] = symmat[j1][j2];\n}\n#pragma endscop\n\n}
void kernel_floyd_warshall(int n,\nDATA_TYPE POLYBENCH_2D(path,N,N,n,n))\n{\nint i, j, k;\n\n#pragma scop\nfor (k = 0; k < _PB_N; k++)\n{\nfor(i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_N; j++)\npath[i][j] = path[i][j] < path[i][k] + path[k][j] ?\npath[i][j] : path[i][k] + path[k][j];\n}\n#pragma endscop\n\n}
void kernel_jacobi_1d_imper(int tsteps,\nint n,\nDATA_TYPE POLYBENCH_1D(A,N,n),\nDATA_TYPE POLYBENCH_1D(B,N,n))\n{\nint t, i, j;\n\n#pragma scop\nfor (t = 0; t < _PB_TSTEPS; t++)\n{\nfor (i = 1; i < _PB_N - 1; i++)\nB[i] = 0.33333 * (A[i-1] + A[i] + A[i + 1]);\nfor (j = 1; j < _PB_N - 1; j++)\nA[j] = B[j];\n}\n#pragma endscop\n\n}
void print_array(DATA_TYPE out)\n{\nfprintf (stderr, DATA_PRINTF_MODIFIER, out);\nfprintf (stderr, "\n");\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_2D(path,N,N,n,n))\n\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, path[i][j]);\nif ((i * n + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void kernel_fdtd_2d(int tmax,\nint nx,\nint ny,\nDATA_TYPE POLYBENCH_2D(ex,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_2D(ey,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_2D(hz,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_1D(_fict_,TMAX,tmax))\n{\nint t, i, j;\n\n#pragma scop\n\nfor(t = 0; t < _PB_TMAX; t++)\n{\nfor (j = 0; j < _PB_NY; j++)\ney[0][j] = _fict_[t];\nfor (i = 1; i < _PB_NX; i++)\nfor (j = 0; j < _PB_NY; j++)\ney[i][j] = ey[i][j] - 0.5*(hz[i][j]-hz[i-1][j]);\nfor (i = 0; i < _PB_NX; i++)\nfor (j = 1; j < _PB_NY; j++)\nex[i][j] = ex[i][j] - 0.5*(hz[i][j]-hz[i][j-1]);\nfor (i = 0; i < _PB_NX - 1; i++)\nfor (j = 0; j < _PB_NY - 1; j++)\nhz[i][j] = hz[i][j] - 0.7*  (ex[i][j+1] - ex[i][j] +\ney[i+1][j] - ey[i][j]);\n}\n\n#pragma endscop\n}
void init_array(int length,\nDATA_TYPE POLYBENCH_2D(c,LENGTH,LENGTH,length,length),\nDATA_TYPE POLYBENCH_2D(W,LENGTH,LENGTH,length,length))\n{\nint i, j;\nfor (i = 0; i < length; i++)\nfor (j = 0; j < length; j++) {\nc[i][j] = i*j % 2;\nW[i][j] = ((DATA_TYPE) i-j) / length;\n}\n}\n
void kernel_syr2k(int ni, int nj,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NI,ni,ni),\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(B,NI,NJ,ni,nj))\n{\nint i, j, k;\n\n#pragma scop\n/*    C := alpha*A*B' + alpha*B*A' + beta*C */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NI; j++)\nC[i][j] *= beta;\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NI; j++)\nfor (k = 0; k < _PB_NJ; k++)\n{\nC[i][j] += alpha * A[i][k] * B[j][k];\nC[i][j] += alpha * B[i][k] * A[j][k];\n}\n#pragma endscop\n\n}
void init_array (int nx, int ny,\nDATA_TYPE POLYBENCH_2D(A,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_1D(x,NY,ny))\n{\nint i, j;\n\nfor (i = 0; i < ny; i++)\nx[i] = i * M_PI;\nfor (i = 0; i < nx; i++)\nfor (j = 0; j < ny; j++)\nA[i][j] = ((DATA_TYPE) i*(j+1)) / nx;\n}
void kernel_gemver(int n,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(u1,N,n),\nDATA_TYPE POLYBENCH_1D(v1,N,n),\nDATA_TYPE POLYBENCH_1D(u2,N,n),\nDATA_TYPE POLYBENCH_1D(v2,N,n),\nDATA_TYPE POLYBENCH_1D(w,N,n),\nDATA_TYPE POLYBENCH_1D(x,N,n),\nDATA_TYPE POLYBENCH_1D(y,N,n),\nDATA_TYPE POLYBENCH_1D(z,N,n))\n{\nint i, j;\n\n#pragma scop\n\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_N; j++)\nA[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];\n\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_N; j++)\nx[i] = x[i] + beta * A[j][i] * y[j];\n\nfor (i = 0; i < _PB_N; i++)\nx[i] = x[i] + z[i];\n\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_N; j++)\nw[i] = w[i] +  alpha * A[i][j] * x[j];\n\n#pragma endscop\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++) {\nfprintf(stderr, DATA_PRINTF_MODIFIER, A[i][j]);\nif ((i * n + j) % 20 == 0) fprintf(stderr, "\n");\n}\nfprintf(stderr, "\n");\n}
void kernel_lu(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j, k;\n\n#pragma scop\nfor (k = 0; k < _PB_N; k++)\n{\nfor (j = k + 1; j < _PB_N; j++)\nA[k][j] = A[k][j] / A[k][k];\nfor(i = k + 1; i < _PB_N; i++)\nfor (j = k + 1; j < _PB_N; j++)\nA[i][j] = A[i][j] - A[i][k] * A[k][j];\n}\n#pragma endscop\n\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(y,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(sum,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(alpha,N,n),\nDATA_TYPE POLYBENCH_1D(beta,N,n),\nDATA_TYPE POLYBENCH_1D(r,N,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\n{\nalpha[i] = i;\nbeta[i] = (i+1)/n/2.0;\nr[i] = (i+1)/n/4.0;\nfor (j = 0; j < n; j++) {\ny[i][j] = ((DATA_TYPE) i*j) / n;\nsum[i][j] = ((DATA_TYPE) i*j) / n;\n}\n}\n}
void kernel_gemm(int ni, int nj, int nk,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\nDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj))\n{\nint i, j, k;\n\n#pragma scop\n/* C := alpha*A*B + beta*C */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NJ; j++)\n{\nC[i][j] *= beta;\nfor (k = 0; k < _PB_NK; ++k)\nC[i][j] += alpha * A[i][k] * B[k][j];\n}\n#pragma endscop\n\n}
void print_array(int maxgrid,\nDATA_TYPE POLYBENCH_2D(path,MAXGRID,MAXGRID,maxgrid,maxgrid))\n{\nint i, j;\n\nfor (i = 0; i < maxgrid; i++)\nfor (j = 0; j < maxgrid; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, path[i][j]);\nif ((i * maxgrid + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void init_array(int ni,\nDATA_TYPE *alpha,\nDATA_TYPE POLYBENCH_2D(A,NI,NI,ni,ni),\nDATA_TYPE POLYBENCH_2D(B,NI,NI,ni,ni))\n{\nint i, j;\n\n*alpha = 32412;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < ni; j++) {\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nB[i][j] = ((DATA_TYPE) i*j) / ni;\n}\n}
void kernel_mvt(int n,\nDATA_TYPE POLYBENCH_1D(x1,N,n),\nDATA_TYPE POLYBENCH_1D(x2,N,n),\nDATA_TYPE POLYBENCH_1D(y_1,N,n),\nDATA_TYPE POLYBENCH_1D(y_2,N,n),\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j;\n\n#pragma scop\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_N; j++)\nx1[i] = x1[i] + A[i][j] * y_1[j];\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_N; j++)\nx2[i] = x2[i] + A[j][i] * y_2[j];\n#pragma endscop\n\n}
void init_array (int nx, int ny,\nDATA_TYPE POLYBENCH_2D(A,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_1D(r,NX,nx),\nDATA_TYPE POLYBENCH_1D(p,NY,ny))\n{\nint i, j;\n\nfor (i = 0; i < ny; i++)\np[i] = i * M_PI;\nfor (i = 0; i < nx; i++) {\nr[i] = i * M_PI;\nfor (j = 0; j < ny; j++)\nA[i][j] = ((DATA_TYPE) i*(j+1))/nx;\n}\n}
void init_array(int ni, int nj,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NI,ni,ni),\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(B,NI,NJ,ni,nj))\n{\nint i, j;\n\n*alpha = 32412;\n*beta = 2123;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nB[i][j] = ((DATA_TYPE) i*j) / ni;\n}\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < ni; j++)\nC[i][j] = ((DATA_TYPE) i*j) / ni;\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(out,N,n))\n\n{\nint i;\n\nfor (i = 0; i < n; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, out[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\n}
void init_array(int ni, int nj, int nk, int nl,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nl),\nDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),\nDATA_TYPE POLYBENCH_2D(C,NL,NJ,nl,nj),\nDATA_TYPE POLYBENCH_2D(D,NI,NL,ni,nl))\n{\nint i, j;\n\n*alpha = 32412;\n*beta = 2123;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nk; j++)\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nfor (i = 0; i < nk; i++)\nfor (j = 0; j < nj; j++)\nB[i][j] = ((DATA_TYPE) i*(j+1)) / nj;\nfor (i = 0; i < nl; i++)\nfor (j = 0; j < nj; j++)\nC[i][j] = ((DATA_TYPE) i*(j+3)) / nl;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nl; j++)\nD[i][j] = ((DATA_TYPE) i*(j+2)) / nk;\n}
void kernel_dynprog(int tsteps, int length,\nDATA_TYPE POLYBENCH_2D(c,LENGTH,LENGTH,length,length),\nDATA_TYPE POLYBENCH_2D(W,LENGTH,LENGTH,length,length),\nDATA_TYPE POLYBENCH_3D(sum_c,LENGTH,LENGTH,LENGTH,length,length,length),\nDATA_TYPE *out)\n{\nint iter, i, j, k;\n\nDATA_TYPE out_l = 0;\n\n#pragma scop\nfor (iter = 0; iter < _PB_TSTEPS; iter++)\n{\nfor (i = 0; i <= _PB_LENGTH - 1; i++)\nfor (j = 0; j <= _PB_LENGTH - 1; j++)\nc[i][j] = 0;\n\nfor (i = 0; i <= _PB_LENGTH - 2; i++)\n{\nfor (j = i + 1; j <= _PB_LENGTH - 1; j++)\n{\nsum_c[i][j][i] = 0;\nfor (k = i + 1; k <= j-1; k++)\nsum_c[i][j][k] = sum_c[i][j][k - 1] + c[i][k] + c[k][j];\nc[i][j] = sum_c[i][j][j-1] + W[i][j];\n}\n}\nout_l += c[0][_PB_LENGTH - 1];\n}\n#pragma endscop\n\n*out = out_l;\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(x1,N,n),\nDATA_TYPE POLYBENCH_1D(x2,N,n))\n\n{\nint i;\n\nfor (i = 0; i < n; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, x1[i]);\nfprintf (stderr, DATA_PRINTF_MODIFIER, x2[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(path,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++)\npath[i][j] = ((DATA_TYPE) (i+1)*(j+1)) / n;\n}
void init_array(int maxgrid,\nDATA_TYPE POLYBENCH_2D(sum_tang,MAXGRID,MAXGRID,maxgrid,maxgrid),\nDATA_TYPE POLYBENCH_2D(mean,MAXGRID,MAXGRID,maxgrid,maxgrid),\nDATA_TYPE POLYBENCH_2D(path,MAXGRID,MAXGRID,maxgrid,maxgrid))\n{\nint i, j;\n\nfor (i = 0; i < maxgrid; i++)\nfor (j = 0; j < maxgrid; j++) {\nsum_tang[i][j] = (DATA_TYPE)((i+1)*(j+1));\nmean[i][j] = ((DATA_TYPE) i-j) / maxgrid;\npath[i][j] = ((DATA_TYPE) i*(j-1)) / maxgrid;\n}\n}
void kernel_3mm(int ni, int nj, int nk, int nl, int nm,\nDATA_TYPE POLYBENCH_2D(E,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\nDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),\nDATA_TYPE POLYBENCH_2D(F,NJ,NL,nj,nl),\nDATA_TYPE POLYBENCH_2D(C,NJ,NM,nj,nm),\nDATA_TYPE POLYBENCH_2D(D,NM,NL,nm,nl),\nDATA_TYPE POLYBENCH_2D(G,NI,NL,ni,nl))\n{\nint i, j, k;\n\n#pragma scop\n/* E := A*B */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NJ; j++)\n{\nE[i][j] = 0;\nfor (k = 0; k < _PB_NK; ++k)\nE[i][j] += A[i][k] * B[k][j];\n}\n/* F := C*D */\nfor (i = 0; i < _PB_NJ; i++)\nfor (j = 0; j < _PB_NL; j++)\n{\nF[i][j] = 0;\nfor (k = 0; k < _PB_NM; ++k)\nF[i][j] += C[i][k] * D[k][j];\n}\n/* G := E*F */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NL; j++)\n{\nG[i][j] = 0;\nfor (k = 0; k < _PB_NJ; ++k)\nG[i][j] += E[i][k] * F[k][j];\n}\n#pragma endscop\n\n}
void kernel_adi(int tsteps,\nint n,\nDATA_TYPE POLYBENCH_2D(X,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(B,N,N,n,n))\n{\nint t, i1, i2;\n\n#pragma scop\nfor (t = 0; t < _PB_TSTEPS; t++)\n{\nfor (i1 = 0; i1 < _PB_N; i1++)\nfor (i2 = 1; i2 < _PB_N; i2++)\n{\nX[i1][i2] = X[i1][i2] - X[i1][i2-1] * A[i1][i2] / B[i1][i2-1];\nB[i1][i2] = B[i1][i2] - A[i1][i2] * A[i1][i2] / B[i1][i2-1];\n}\n\nfor (i1 = 0; i1 < _PB_N; i1++)\nX[i1][_PB_N-1] = X[i1][_PB_N-1] / B[i1][_PB_N-1];\n\nfor (i1 = 0; i1 < _PB_N; i1++)\nfor (i2 = 0; i2 < _PB_N-2; i2++)\nX[i1][_PB_N-i2-2] = (X[i1][_PB_N-2-i2] - X[i1][_PB_N-2-i2-1] * A[i1][_PB_N-i2-3]) / B[i1][_PB_N-3-i2];\n\nfor (i1 = 1; i1 < _PB_N; i1++)\nfor (i2 = 0; i2 < _PB_N; i2++) {\nX[i1][i2] = X[i1][i2] - X[i1-1][i2] * A[i1][i2] / B[i1-1][i2];\nB[i1][i2] = B[i1][i2] - A[i1][i2] * A[i1][i2] / B[i1-1][i2];\n}\n\nfor (i2 = 0; i2 < _PB_N; i2++)\nX[_PB_N-1][i2] = X[_PB_N-1][i2] / B[_PB_N-1][i2];\n\nfor (i1 = 0; i1 < _PB_N-2; i1++)\nfor (i2 = 0; i2 < _PB_N; i2++)\nX[_PB_N-2-i1][i2] = (X[_PB_N-2-i1][i2] - X[_PB_N-i1-3][i2] * A[_PB_N-3-i1][i2]) / B[_PB_N-2-i1][i2];\n}\n#pragma endscop\n\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(A,N+1,N+1,n+1,n+1),\nDATA_TYPE POLYBENCH_1D(b,N+1,n+1),\nDATA_TYPE POLYBENCH_1D(x,N+1,n+1),\nDATA_TYPE POLYBENCH_1D(y,N+1,n+1))\n{\nint i, j;\n\nfor (i = 0; i <= n; i++)\n{\nx[i] = i + 1;\ny[i] = (i+1)/n/2.0 + 1;\nb[i] = (i+1)/n/2.0 + 42;\nfor (j = 0; j <= n; j++) {\nA[i][j] = ((DATA_TYPE) (i+1)*(j+1)) / n;\n}\n}\n}
void init_array(int ni, int nj, int nk,\nDATA_TYPE *alpha,\nDATA_TYPE *beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\nDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj))\n{\nint i, j;\n\n*alpha = 32412;\n*beta = 2123;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++)\nC[i][j] = ((DATA_TYPE) i*j) / ni;\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nk; j++)\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nfor (i = 0; i < nk; i++)\nfor (j = 0; j < nj; j++)\nB[i][j] = ((DATA_TYPE) i*j) / ni;\n}
void kernel_symm(int ni, int nj,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(A,NJ,NJ,nj,nj),\nDATA_TYPE POLYBENCH_2D(B,NI,NJ,ni,nj))\n{\nint i, j, k;\nDATA_TYPE acc;\n\n#pragma scop\n/*  C := alpha*A*B + beta*C, A is symetric */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NJ; j++)\n{\nacc = 0;\nfor (k = 0; k < j - 1; k++)\n{\nC[k][j] += alpha * A[k][i] * B[i][j];\nacc += B[k][j] * A[k][i];\n}\nC[i][j] = beta * C[i][j] + alpha * A[i][i] * B[i][j] + alpha * acc;\n}\n#pragma endscop\n\n}
void kernel_atax(int nx, int ny,\nDATA_TYPE POLYBENCH_2D(A,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_1D(x,NY,ny),\nDATA_TYPE POLYBENCH_1D(y,NY,ny),\nDATA_TYPE POLYBENCH_1D(tmp,NX,nx))\n{\nint i, j;\n\n#pragma scop\nfor (i = 0; i < _PB_NY; i++)\ny[i] = 0;\nfor (i = 0; i < _PB_NX; i++)\n{\ntmp[i] = 0;\nfor (j = 0; j < _PB_NY; j++)\ntmp[i] = tmp[i] + A[i][j] * x[j];\nfor (j = 0; j < _PB_NY; j++)\ny[j] = y[j] + A[i][j] * tmp[i];\n}\n#pragma endscop\n\n}
void init_array(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(x,N,n),\nDATA_TYPE POLYBENCH_1D(c,N,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\n{\nc[i] = x[i] = ((DATA_TYPE) i) / n;\nfor (j = 0; j < n; j++)\nA[i][j] = ((DATA_TYPE) i*j) / n;\n}\n}
void print_array(int nx,\nDATA_TYPE POLYBENCH_1D(y,NX,nx))\n\n{\nint i;\n\nfor (i = 0; i < nx; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, y[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void init_array(int nr, int nq, int np,\nDATA_TYPE POLYBENCH_3D(A,NR,NQ,NP,nr,nq,np),\nDATA_TYPE POLYBENCH_2D(C4,NP,NP,np,np))\n{\nint i, j, k;\n\nfor (i = 0; i < nr; i++)\nfor (j = 0; j < nq; j++)\nfor (k = 0; k < np; k++)\nA[i][j][k] = ((DATA_TYPE) i*j + k) / np;\nfor (i = 0; i < np; i++)\nfor (j = 0; j < np; j++)\nC4[i][j] = ((DATA_TYPE) i*j) / np;\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, A[i][j]);\nif ((i * N + j) % 20 == 0) fprintf (stderr, "\n");\n}\n}
void kernel_reg_detect(int niter, int maxgrid, int length,\nDATA_TYPE POLYBENCH_2D(sum_tang,MAXGRID,MAXGRID,maxgrid,maxgrid),\nDATA_TYPE POLYBENCH_2D(mean,MAXGRID,MAXGRID,maxgrid,maxgrid),\nDATA_TYPE POLYBENCH_2D(path,MAXGRID,MAXGRID,maxgrid,maxgrid),\nDATA_TYPE POLYBENCH_3D(diff,MAXGRID,MAXGRID,LENGTH,maxgrid,maxgrid,length),\nDATA_TYPE POLYBENCH_3D(sum_diff,MAXGRID,MAXGRID,LENGTH,maxgrid,maxgrid,length))\n{\nint t, i, j, cnt;\n\n#pragma scop\nfor (t = 0; t < _PB_NITER; t++)\n{\nfor (j = 0; j <= _PB_MAXGRID - 1; j++)\nfor (i = j; i <= _PB_MAXGRID - 1; i++)\nfor (cnt = 0; cnt <= _PB_LENGTH - 1; cnt++)\ndiff[j][i][cnt] = sum_tang[j][i];\n\nfor (j = 0; j <= _PB_MAXGRID - 1; j++)\n{\nfor (i = j; i <= _PB_MAXGRID - 1; i++)\n{\nsum_diff[j][i][0] = diff[j][i][0];\nfor (cnt = 1; cnt <= _PB_LENGTH - 1; cnt++)\nsum_diff[j][i][cnt] = sum_diff[j][i][cnt - 1] + diff[j][i][cnt];\nmean[j][i] = sum_diff[j][i][_PB_LENGTH - 1];\n}\n}\n\nfor (i = 0; i <= _PB_MAXGRID - 1; i++)\npath[0][i] = mean[0][i];\n\nfor (j = 1; j <= _PB_MAXGRID - 1; j++)\nfor (i = j; i <= _PB_MAXGRID - 1; i++)\npath[j][i] = path[j - 1][i - 1] + mean[j][i];\n}\n#pragma endscop\n\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(B,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++)\n{\nA[i][j] = ((DATA_TYPE) i*(j+2) + 2) / n;\nB[i][j] = ((DATA_TYPE) i*(j+3) + 3) / n;\n}\n}
void kernel_correlation(int m, int n,\nDATA_TYPE float_n,\nDATA_TYPE POLYBENCH_2D(data,M,N,m,n),\nDATA_TYPE POLYBENCH_2D(symmat,M,M,m,m),\nDATA_TYPE POLYBENCH_1D(mean,M,m),\nDATA_TYPE POLYBENCH_1D(stddev,M,m))\n{\nint i, j, j1, j2;\n\nDATA_TYPE eps = 0.1f;\n\n#define sqrt_of_array_cell(x,j) sqrt(x[j])\n\n#pragma scop\n/* Determine mean of column vectors of input data matrix */\nfor (j = 0; j < _PB_M; j++)\n{\nmean[j] = 0.0;\nfor (i = 0; i < _PB_N; i++)\nmean[j] += data[i][j];\nmean[j] /= float_n;\n}\n\n/* Determine standard deviations of column vectors of data matrix. */\nfor (j = 0; j < _PB_M; j++)\n{\nstddev[j] = 0.0;\nfor (i = 0; i < _PB_N; i++)\nstddev[j] += (data[i][j] - mean[j]) * (data[i][j] - mean[j]);\nstddev[j] /= float_n;\nstddev[j] = sqrt_of_array_cell(stddev, j);\n/* The following in an inelegant but usual way to handle\nnear-zero std. dev. values, which below would cause a zero-\ndivide. */\nstddev[j] = stddev[j] <= eps ? 1.0 : stddev[j];\n}\n\n/* Center and reduce the column vectors. */\nfor (i = 0; i < _PB_N; i++)\nfor (j = 0; j < _PB_M; j++)\n{\ndata[i][j] -= mean[j];\ndata[i][j] /= sqrt(float_n) * stddev[j];\n}\n\n/* Calculate the m * m correlation matrix. */\nfor (j1 = 0; j1 < _PB_M-1; j1++)\n{\nsymmat[j1][j1] = 1.0;\nfor (j2 = j1+1; j2 < _PB_M; j2++)\n{\nsymmat[j1][j2] = 0.0;\nfor (i = 0; i < _PB_N; i++)\nsymmat[j1][j2] += (data[i][j1] * data[i][j2]);\nsymmat[j2][j1] = symmat[j1][j2];\n}\n}\nsymmat[_PB_M-1][_PB_M-1] = 1.0;\n#pragma endscop\n\n}
void print_array(int ni, int nl,\nDATA_TYPE POLYBENCH_2D(G,NI,NL,ni,nl))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nl; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, G[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void kernel_gesummv(int n,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(B,N,N,n,n),\nDATA_TYPE POLYBENCH_1D(tmp,N,n),\nDATA_TYPE POLYBENCH_1D(x,N,n),\nDATA_TYPE POLYBENCH_1D(y,N,n))\n{\nint i, j;\n\n#pragma scop\nfor (i = 0; i < _PB_N; i++)\n{\ntmp[i] = 0;\ny[i] = 0;\nfor (j = 0; j < _PB_N; j++)\n{\ntmp[i] = A[i][j] * x[j] + tmp[i];\ny[i] = B[i][j] * x[j] + y[i];\n}\ny[i] = alpha * tmp[i] + beta * y[i];\n}\n#pragma endscop\n\n}
void kernel_ludcmp(int n,\nDATA_TYPE POLYBENCH_2D(A,N+1,N+1,n+1,n+1),\nDATA_TYPE POLYBENCH_1D(b,N+1,n+1),\nDATA_TYPE POLYBENCH_1D(x,N+1,n+1),\nDATA_TYPE POLYBENCH_1D(y,N+1,n+1))\n{\nint i, j, k;\n\nDATA_TYPE w;\n\n#pragma scop\nb[0] = 1.0;\nfor (i = 0; i < _PB_N; i++)\n{\nfor (j = i+1; j <= _PB_N; j++)\n{\nw = A[j][i];\nfor (k = 0; k < i; k++)\nw = w- A[j][k] * A[k][i];\nA[j][i] = w / A[i][i];\n}\nfor (j = i+1; j <= _PB_N; j++)\n{\nw = A[i+1][j];\nfor (k = 0; k <= i; k++)\nw = w  - A[i+1][k] * A[k][j];\nA[i+1][j] = w;\n}\n}\ny[0] = b[0];\nfor (i = 1; i <= _PB_N; i++)\n{\nw = b[i];\nfor (j = 0; j < i; j++)\nw = w - A[i][j] * y[j];\ny[i] = w;\n}\nx[_PB_N] = y[_PB_N] / A[_PB_N][_PB_N];\nfor (i = 0; i <= _PB_N - 1; i++)\n{\nw = y[_PB_N - 1 - (i)];\nfor (j = _PB_N - i; j <= _PB_N; j++)\nw = w - A[_PB_N - 1 - i][j] * x[j];\nx[_PB_N - 1 - i] = w / A[_PB_N - 1 - (i)][_PB_N - 1-(i)];\n}\n#pragma endscop\n\n}
void print_array(int ni, int nj,\nDATA_TYPE POLYBENCH_2D(A,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(R,NJ,NJ,nj,nj),\nDATA_TYPE POLYBENCH_2D(Q,NI,NJ,ni,nj))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, A[i][j]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\nfor (i = 0; i < nj; i++)\nfor (j = 0; j < nj; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, R[i][j]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nj; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, Q[i][j]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void init_array (int cz,\nint cxm,\nint cym,\nDATA_TYPE *mui,\nDATA_TYPE *ch,\nDATA_TYPE POLYBENCH_2D(Ax,CZ+1,CYM+1,cz+1,cym+1),\nDATA_TYPE POLYBENCH_2D(Ry,CZ+1,CYM+1,cz+1,cym+1),\nDATA_TYPE POLYBENCH_3D(Ex,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Ey,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Hz,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_1D(czm,CZ+1,cz+1),\nDATA_TYPE POLYBENCH_1D(czp,CZ+1,cz+1),\nDATA_TYPE POLYBENCH_1D(cxmh,CXM+1,cxm+1),\nDATA_TYPE POLYBENCH_1D(cxph,CXM+1,cxm+1),\nDATA_TYPE POLYBENCH_1D(cymh,CYM+1,cym+1),\nDATA_TYPE POLYBENCH_1D(cyph,CYM+1,cym+1))\n{\nint i, j, k;\n*mui = 2341;\n*ch = 42;\nfor (i = 0; i <= cz; i++)\n{\nczm[i] = ((DATA_TYPE) i + 1) / cxm;\nczp[i] = ((DATA_TYPE) i + 2) / cxm;\n}\nfor (i = 0; i <= cxm; i++)\n{\ncxmh[i] = ((DATA_TYPE) i + 3) / cxm;\ncxph[i] = ((DATA_TYPE) i + 4) / cxm;\n}\nfor (i = 0; i <= cym; i++)\n{\ncymh[i] = ((DATA_TYPE) i + 5) / cxm;\ncyph[i] = ((DATA_TYPE) i + 6) / cxm;\n}\n\nfor (i = 0; i <= cz; i++)\nfor (j = 0; j <= cym; j++)\n{\nRy[i][j] = ((DATA_TYPE) i*(j+1) + 10) / cym;\nAx[i][j] = ((DATA_TYPE) i*(j+2) + 11) / cym;\nfor (k = 0; k <= cxm; k++)\n{\nEx[i][j][k] = ((DATA_TYPE) i*(j+3) + k + 1) / cxm;\nEy[i][j][k] = ((DATA_TYPE) i*(j+4) + k + 2) / cym;\nHz[i][j][k] = ((DATA_TYPE) i*(j+5) + k + 3) / cz;\n}\n}\n}
void kernel_cholesky(int n,\nDATA_TYPE POLYBENCH_1D(p,N,n),\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j, k;\n\nDATA_TYPE x;\n\n#pragma scop\nfor (i = 0; i < _PB_N; ++i)\n{\nx = A[i][i];\nfor (j = 0; j <= i - 1; ++j)\nx = x - A[i][j] * A[i][j];\np[i] = 1.0 / sqrt(x);\nfor (j = i + 1; j < _PB_N; ++j)\n{\nx = A[i][j];\nfor (k = 0; k <= i - 1; ++k)\nx = x - A[j][k] * A[i][k];\nA[j][i] = x * p[i];\n}\n}\n#pragma endscop\n\n}
void print_array(int nx,\nint ny,\nDATA_TYPE POLYBENCH_2D(ex,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_2D(ey,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_2D(hz,NX,NY,nx,ny))\n{\nint i, j;\n\nfor (i = 0; i < nx; i++)\nfor (j = 0; j < ny; j++) {\nfprintf(stderr, DATA_PRINTF_MODIFIER, ex[i][j]);\nfprintf(stderr, DATA_PRINTF_MODIFIER, ey[i][j]);\nfprintf(stderr, DATA_PRINTF_MODIFIER, hz[i][j]);\nif ((i * nx + j) % 20 == 0) fprintf(stderr, "\n");\n}\nfprintf(stderr, "\n");\n}
void print_array(int nr, int nq, int np,\nDATA_TYPE POLYBENCH_3D(A,NR,NQ,NP,nr,nq,np))\n{\nint i, j, k;\n\nfor (i = 0; i < nr; i++)\nfor (j = 0; j < nq; j++)\nfor (k = 0; k < np; k++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, A[i][j][k]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void print_array(int nx, int ny,\nDATA_TYPE POLYBENCH_1D(s,NY,ny),\nDATA_TYPE POLYBENCH_1D(q,NX,nx))\n\n{\nint i;\n\nfor (i = 0; i < ny; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, s[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfor (i = 0; i < nx; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, q[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_2D(X,N,N,n,n))\n\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++) {\nfprintf(stderr, DATA_PRINTF_MODIFIER, X[i][j]);\nif ((i * N + j) % 20 == 0) fprintf(stderr, "\n");\n}\nfprintf(stderr, "\n");\n}
void print_array(int ni,\nDATA_TYPE POLYBENCH_2D(C,NI,NI,ni,ni))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < ni; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, C[i][j]);\nif ((i * ni + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void init_array(int ni, int nj, int nk, int nl, int nm,\nDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\nDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),\nDATA_TYPE POLYBENCH_2D(C,NJ,NM,nj,nm),\nDATA_TYPE POLYBENCH_2D(D,NM,NL,nm,nl))\n{\nint i, j;\n\nfor (i = 0; i < ni; i++)\nfor (j = 0; j < nk; j++)\nA[i][j] = ((DATA_TYPE) i*j) / ni;\nfor (i = 0; i < nk; i++)\nfor (j = 0; j < nj; j++)\nB[i][j] = ((DATA_TYPE) i*(j+1)) / nj;\nfor (i = 0; i < nj; i++)\nfor (j = 0; j < nm; j++)\nC[i][j] = ((DATA_TYPE) i*(j+3)) / nl;\nfor (i = 0; i < nm; i++)\nfor (j = 0; j < nl; j++)\nD[i][j] = ((DATA_TYPE) i*(j+2)) / nk;\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(x,N+1,n+1))\n\n{\nint i;\n\nfor (i = 0; i <= n; i++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, x[i]);\nif (i % 20 == 0) fprintf (stderr, "\n");\n}\n}
void kernel_jacobi_2d_imper(int tsteps,\nint n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n),\nDATA_TYPE POLYBENCH_2D(B,N,N,n,n))\n{\nint t, i, j;\n\n#pragma scop\nfor (t = 0; t < _PB_TSTEPS; t++)\n{\nfor (i = 1; i < _PB_N - 1; i++)\nfor (j = 1; j < _PB_N - 1; j++)\nB[i][j] = 0.2 * (A[i][j] + A[i][j-1] + A[i][1+j] + A[1+i][j] + A[i-1][j]);\nfor (i = 1; i < _PB_N-1; i++)\nfor (j = 1; j < _PB_N-1; j++)\nA[i][j] = B[i][j];\n}\n#pragma endscop\n\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint i, j;\n\nfor (i = 0; i < n; i++)\nfor (j = 0; j < n; j++)\nA[i][j] = ((DATA_TYPE) (i+1)*(j+1)) / n;\n}
#include <stdio.h>\nchar a[100];\nint main()\n{\n  int i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n
#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf ("Fib(%d)=%d\n", input, result);\n  assert (result==832040);\n  return 0;\n}\n
#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n
#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n
#include <stdio.h>\nint a[100][100];\nint b[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for default(none) shared(a) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n\n#pragma omp parallel for default(shared) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      b[i][j]=b[i][j]+1;\n\n  return 0;\n}\n\n
#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf("x=%d\n",x);\n  printf("y=%d\n",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf("%d\n ",var);\n  return 0;\n}\n
#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf("x = %d\n", x); }\n  }\n  }\n  return 0;\n}\n
#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf("%d\n",var);\n\n  return 0;\n}\n
#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf("output[0]=%d\n", output[0]);\n  return 0;\n}\n
#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n{\na[i]= i+1;\n}\n}\n\nint main()\n{\nint i=0;\n#pragma omp parallel\n{\n#pragma omp single\n{\nfor (i=0; i<MYLEN; i++)\n{\ngen_task(i);\n}\n}\n}\n\n/* correctness checking */\nfor (i=0; i<MYLEN; i++)\n{\n//assert (a[i]==i+1);\nif (a[i]!= i+1)\n{\nprintf("warning: a[%d] = %d, not expected %d\n", i, a[i], i+1);\n}\n}\nreturn 0;\n}
#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf ("sum = %f\n", sum); \n  return 0;\n}\n
#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n  printf ("b[50][50]=%f\n",b[50][50]);\n\n  return 0;     \n}\n  \n
#include <stdio.h>\n/*\nTwo-dimension array computation with a vectorization directive\ncollapse(2) makes simd associate with 2 loops.\nLoop iteration variables should be predetermined as lastprivate. \n*/\nint main()\n{\n  int len=100;\n  double a[len][len], b[len][len], c[len][len];\n  int i,j;\n\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n    {\n      a[i][j]=((double)i)/2.0; \n      b[i][j]=((double)i)/3.0; \n      c[i][j]=((double)i)/7.0; \n    }\n\n#pragma omp simd collapse(2)\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n      c[i][j]=a[i][j]*b[i][j];\n\n  printf ("c[50][50]=%f\n",c[50][50]);\n  return 0;\n}\n
#include<stdio.h>\n\n/*  argument pass-by-reference */\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf ("i=%d\n",i);\n  return 0;   \n}\n
#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf("sum=%d; sum1=%d\n",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n
#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf("%d\n",var);\n  return 0;\n}\n
void add(){\nint i, j, k, m;\nint thread_id = omp_get_thread_num();\n\nif(timeron && thread_id==0){timer_start(T_ADD);}\n#pragma omp for\nfor(k=1; k<=nz2; k++){\nfor(j=1; j<=ny2; j++){\nfor(i=1; i<=nx2; i++){\nfor(m=0; m<5; m++){\nu[k][j][i][m]=u[k][j][i][m]+rhs[k][j][i][m];\n}\n}\n}\n}\nif(timeron && thread_id==0){timer_stop(T_ADD);}\n}
static void norm2u3(void* pointer_r, int n1, int n2, int n3, double* rnm2, double* rnmu, int nx, int ny, int nz){\n#ifdef __clang__\nusing custom_cast = double (*)[n2][n1];\ncustom_cast r = reinterpret_cast<custom_cast>(pointer_r);\n#else\ndouble (*r)[n2][n1] = (double (*)[n2][n1])pointer_r;\n#endif\n\nstatic double s, rnmu_local;\ndouble a;\nint i3, i2, i1;\n\ndouble dn;\n\nif(timeron){\n#pragma omp master\ntimer_start(T_NORM2);\n}\ndn = 1.0*nx*ny*nz;\n\n#pragma omp single\n{\ns = 0.0;\nrnmu_local = 0.0;\n}\n\n#pragma omp for reduction(+:s,rnmu_local)\nfor(i3 = 1; i3 < n3-1; i3++){\nfor(i2 = 1; i2 < n2-1; i2++){\nfor(i1 = 1; i1 < n1-1; i1++){\ns = s + r[i3][i2][i1] * r[i3][i2][i1];\na = fabs(r[i3][i2][i1]);\nif(a > rnmu_local){rnmu_local = a;}\n}\n}\n}\n\n*rnmu = rnmu_local;\n*rnm2 = sqrt(s/dn);\nif(timeron){\n#pragma omp master\ntimer_stop(T_NORM2);\n}\n}
void pintgr(){\n\nint i, j, k;\nint ibeg, ifin, ifin1;\nint jbeg, jfin, jfin1;\ndouble phi1[ISIZ3+2][ISIZ2+2];\ndouble phi2[ISIZ3+2][ISIZ2+2];\ndouble frc1, frc2, frc3;\n\nibeg=ii1;\nifin=ii2;\njbeg=ji1;\njfin=ji2;\nifin1=ifin-1;\njfin1=jfin-1;\n\nfor(i=0; i<=ISIZ2+1; i++){\nfor(k=0; k<=ISIZ3+1; k++){\nphi1[k][i]=0.0;\nphi2[k][i]=0.0;\n}\n}\nfor(j=jbeg; j<jfin; j++){\nfor(i=ibeg; i<ifin; i++){\nk=ki1;\nphi1[j][i]=C2*(u[k][j][i][4]\n-0.50*(u[k][j][i][1]*u[k][j][i][1]\n+u[k][j][i][2]*u[k][j][i][2]\n+u[k][j][i][3]*u[k][j][i][3])\n/u[k][j][i][0]);\nk=ki2-1;\nphi2[j][i]=C2*(u[k][j][i][4]\n-0.50*(u[k][j][i][1]*u[k][j][i][1]\n+u[k][j][i][2]*u[k][j][i][2]\n+u[k][j][i][3]*u[k][j][i][3])\n/u[k][j][i][0]);\n}\n}\nfrc1=0.0;\nfor(j=jbeg; j<jfin1; j++){\nfor(i=ibeg; i<ifin1; i++){\nfrc1=frc1+(phi1[j][i]\n+phi1[j][i+1]\n+phi1[j+1][i]\n+phi1[j+1][i+1]\n+phi2[j][i]\n+phi2[j][i+1]\n+phi2[j+1][i]\n+phi2[j+1][i+1]);\n}\n}\nfrc1=dxi*deta*frc1;\n\nfor(i=0; i<=ISIZ2+1; i++){\nfor(k=0; k<=ISIZ3+1; k++){\nphi1[k][i]=0.0;\nphi2[k][i]=0.0;\n}\n}\nif(jbeg==ji1){\nfor(k=ki1; k<ki2; k++){\nfor(i=ibeg; i<ifin; i++){\nphi1[k][i]=C2*(u[k][jbeg][i][4]\n-0.50*(u[k][jbeg][i][1]*u[k][jbeg][i][1]\n+u[k][jbeg][i][2]*u[k][jbeg][i][2]\n+u[k][jbeg][i][3]*u[k][jbeg][i][3])\n/u[k][jbeg][i][0]);\n}\n}\n}\nif(jfin==ji2){\nfor(k=ki1; k<ki2; k++){\nfor(i=ibeg; i<ifin; i++){\nphi2[k][i]=C2*(u[k][jfin-1][i][4]\n-0.50*(u[k][jfin-1][i][1]*u[k][jfin-1][i][1]\n+u[k][jfin-1][i][2]*u[k][jfin-1][i][2]\n+u[k][jfin-1][i][3]*u[k][jfin-1][i][3])\n/u[k][jfin-1][i][0]);\n}\n}\n}\nfrc2=0.0;\nfor(k=ki1; k<ki2-1; k++){\nfor(i=ibeg; i<ifin1; i++){\nfrc2=frc2+(phi1[k][i]\n+phi1[k][i+1]\n+phi1[k+1][i]\n+phi1[k+1][i+1]\n+phi2[k][i]\n+phi2[k][i+1]\n+phi2[k+1][i]\n+phi2[k+1][i+1]);\n}\n}\nfrc2=dxi*dzeta*frc2;\n\nfor(i=0; i<=ISIZ2+1; i++){\nfor(k=0; k<=ISIZ3+1; k++){\nphi1[k][i]=0.0;\nphi2[k][i]=0.0;\n}\n}\nif(ibeg==ii1){\nfor(k=ki1; k<ki2; k++){\nfor(j=jbeg; j<jfin; j++){\nphi1[k][j]=C2*(u[k][j][ibeg][4]\n-0.50*(u[k][j][ibeg][1]*u[k][j][ibeg][1]\n+u[k][j][ibeg][2]*u[k][j][ibeg][2]\n+u[k][j][ibeg][3]*u[k][j][ibeg][3])\n/u[k][j][ibeg][0]);\n}\n}\n}\nif(ifin==ii2){\nfor(k=ki1; k<ki2; k++){\nfor(j=jbeg; j<jfin; j++){\nphi2[k][j]=C2*(u[k][j][ifin-1][4]\n-0.50*(u[k][j][ifin-1][1]*u[k][j][ifin-1][1]\n+u[k][j][ifin-1][2]*u[k][j][ifin-1][2]\n+u[k][j][ifin-1][3]*u[k][j][ifin-1][3])\n/u[k][j][ifin-1][0]);\n}\n}\n}\nfrc3=0.0;\nfor(k=ki1; k<ki2-1; k++){\nfor(j=jbeg; j<jfin1; j++){\nfrc3=frc3+(phi1[k][j]\n+phi1[k][j+1]\n+phi1[k+1][j]\n+phi1[k+1][j+1]\n+phi2[k][j]\n+phi2[k][j+1]\n+phi2[k+1][j]\n+phi2[k+1][j+1]);\n}\n}\nfrc3=deta*dzeta*frc3;\nfrc=0.25*(frc1+frc2+frc3);\n}
void print_array(int m,\nDATA_TYPE POLYBENCH_2D(symmat,M,M,m,m))\n\n{\nint i, j;\n\nfor (i = 0; i < m; i++)\nfor (j = 0; j < m; j++) {\nfprintf (stderr, DATA_PRINTF_MODIFIER, symmat[i][j]);\nif ((i * m + j) % 20 == 0) fprintf (stderr, "\n");\n}\nfprintf (stderr, "\n");\n}
void print_array(int cz,\nint cxm,\nint cym,\nDATA_TYPE POLYBENCH_3D(Bza,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Ex,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Ey,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1),\nDATA_TYPE POLYBENCH_3D(Hz,CZ+1,CYM+1,CXM+1,cz+1,cym+1,cxm+1))\n{\nint i, j, k;\n\nfor (i = 0; i <= cz; i++)\nfor (j = 0; j <= cym; j++)\nfor (k = 0; k <= cxm; k++) {\nfprintf(stderr, DATA_PRINTF_MODIFIER, Bza[i][j][k]);\nfprintf(stderr, DATA_PRINTF_MODIFIER, Ex[i][j][k]);\nfprintf(stderr, DATA_PRINTF_MODIFIER, Ey[i][j][k]);\nfprintf(stderr, DATA_PRINTF_MODIFIER, Hz[i][j][k]);\nif ((i * cxm + j) % 20 == 0) fprintf(stderr, "\n");\n}\nfprintf(stderr, "\n");\n}
void kernel_2mm(int ni, int nj, int nk, int nl,\nDATA_TYPE alpha,\nDATA_TYPE beta,\nDATA_TYPE POLYBENCH_2D(tmp,NI,NJ,ni,nj),\nDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\nDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),\nDATA_TYPE POLYBENCH_2D(C,NL,NJ,nl,nj),\nDATA_TYPE POLYBENCH_2D(D,NI,NL,ni,nl))\n{\nint i, j, k;\n\n#pragma scop\n/* D := alpha*A*B*C + beta*D */\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NJ; j++)\n{\ntmp[i][j] = 0;\nfor (k = 0; k < _PB_NK; ++k)\ntmp[i][j] += alpha * A[i][k] * B[k][j];\n}\nfor (i = 0; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NL; j++)\n{\nD[i][j] *= beta;\nfor (k = 0; k < _PB_NJ; ++k)\nD[i][j] += tmp[i][k] * C[k][j];\n}\n#pragma endscop\n\n}
void print_array(int n,\nDATA_TYPE POLYBENCH_1D(A,N,n))\n\n{\nint i;\n\nfor (i = 0; i < n; i++)\n{\nfprintf(stderr, DATA_PRINTF_MODIFIER, A[i]);\nif (i % 20 == 0) fprintf(stderr, "\n");\n}\nfprintf(stderr, "\n");\n}
void kernel_seidel_2d(int tsteps,\nint n,\nDATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\nint t, i, j;\n\n#pragma scop\nfor (t = 0; t <= _PB_TSTEPS - 1; t++)\nfor (i = 1; i<= _PB_N - 2; i++)\nfor (j = 1; j <= _PB_N - 2; j++)\nA[i][j] = (A[i-1][j-1] + A[i-1][j] + A[i-1][j+1]\n+ A[i][j-1] + A[i][j] + A[i][j+1]\n+ A[i+1][j-1] + A[i+1][j] + A[i+1][j+1])/9.0;\n#pragma endscop\n\n}
void kernel_trmm(int ni,\nDATA_TYPE alpha,\nDATA_TYPE POLYBENCH_2D(A,NI,NI,ni,ni),\nDATA_TYPE POLYBENCH_2D(B,NI,NI,ni,ni))\n{\nint i, j, k;\n\n#pragma scop\n/*  B := alpha*A'*B, A triangular */\nfor (i = 1; i < _PB_NI; i++)\nfor (j = 0; j < _PB_NI; j++)\nfor (k = 0; k < i; k++)\nB[i][j] += alpha * A[i][k] * B[j][k];\n#pragma endscop\n\n}
void init_array (int tmax,\nint nx,\nint ny,\nDATA_TYPE POLYBENCH_2D(ex,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_2D(ey,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_2D(hz,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_1D(_fict_,TMAX,tmax))\n{\nint i, j;\n\nfor (i = 0; i < tmax; i++)\n_fict_[i] = (DATA_TYPE) i;\nfor (i = 0; i < nx; i++)\nfor (j = 0; j < ny; j++)\n{\nex[i][j] = ((DATA_TYPE) i*(j+1)) / nx;\ney[i][j] = ((DATA_TYPE) i*(j+2)) / ny;\nhz[i][j] = ((DATA_TYPE) i*(j+3)) / nx;\n}\n}
void init_array (int n,\nDATA_TYPE POLYBENCH_1D(A,N,n),\nDATA_TYPE POLYBENCH_1D(B,N,n))\n{\nint i;\n\nfor (i = 0; i < n; i++)\n{\nA[i] = ((DATA_TYPE) i+ 2) / n;\nB[i] = ((DATA_TYPE) i+ 3) / n;\n}\n}
void kernel_bicg(int nx, int ny,\nDATA_TYPE POLYBENCH_2D(A,NX,NY,nx,ny),\nDATA_TYPE POLYBENCH_1D(s,NY,ny),\nDATA_TYPE POLYBENCH_1D(q,NX,nx),\nDATA_TYPE POLYBENCH_1D(p,NY,ny),\nDATA_TYPE POLYBENCH_1D(r,NX,nx))\n{\nint i, j;\n\n#pragma scop\nfor (i = 0; i < _PB_NY; i++)\ns[i] = 0;\nfor (i = 0; i < _PB_NX; i++)\n{\nq[i] = 0;\nfor (j = 0; j < _PB_NY; j++)\n{\ns[j] = s[j] + r[i] * A[i][j];\nq[i] = q[i] + A[i][j] * p[j];\n}\n}\n#pragma endscop\n\n}