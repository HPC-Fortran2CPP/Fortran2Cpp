\n\n[C++]\n#include <cmath>\n#include <vector>\n\nbool has_close_elements(std::vector<double> numbers, double threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<double> a = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    if (!has_close_elements(a, 0.3)) {\n        std::cout << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.05)) {\n        std::cout << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    a = {1.0, 2.0, 5.9, 4.0, 5.0};\n    if (!has_close_elements(a, 0.95)) {\n        std::cout << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.8)) {\n        std::cout << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    a = {1.0, 2.0, 3.0, 4.0, 5.0};\n    if (!has_close_elements(a, 2.0)) {\n        std::cout << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    a = {1.1, 2.2, 3.1, 4.1, 5.1};\n    if (!has_close_elements(a, 1.0)) {\n        std::cout << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.5)) {\n        std::cout << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### Solution\n\n```c++\n#include <cmath>\n#include <vector>\n\nbool has_close_elements(std::vector<double> numbers, double threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<double> a = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    if (!has_close_elements(a, 0.3)) {\n        std::cout << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.05)) {\n        std::cout << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    a = {1.0, 2.0, 5.9, 4.0, 5.0};\n    if (!has_close_elements(a, 0.95)) {\n        std::cout << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.8)) {\n        std::cout << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    a = {1.0, 2.0, 3.0, 4.0, 5.0};\n    if (!has_close_elements(a, 2.0)) {\n        std::cout << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    a = {1.1, 2.2, 3.1, 4.1, 5.1};\n    if (!has_close_elements(a, 1.0)) {\n        std::cout << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.5)) {\n        std::cout << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### GitHub\n\n- [View](https://github.com/AndrewMBurns/daily-coding-problem/tree/main/arrays/10-has-close-elements/fortran)\n- [GitHub](https://github.com/AndrewMBurns/daily-coding-problem/edit/main/arrays/10-has-close-elements/fortran/main.f90)\n\n### References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Fortran)\n- [Fortran Wiki](https://fortranwiki.org/fortran/show/HomePage)\n- [Fortran 90/95/2003/2008 Tutorial](https://www.tutorialspoint.com/fortran/index.htm)\n- [Fortran 90/95/2003/2008 Reference](https://www.tutorialspoint.com/fortran/fortran_reference.pdf)\n- [Fortran 90/95/2003/2008 Examples](https://www.tutorialspoint.com/fortran/fortran_examples.htm)\n- [Fortran 90/95/2003/2008 Online Compiler](https://www.tutorialspoint.com/compile_fortran_online.php)\n- [Fortran 90/95/2003/2008 Programming](https://www.tutorialspoint.com/fortran/index.htm)\n- [Fortran 90/95/2003/2008 Programming Examples](https://www.tutorialspoint.com/fortran/fortran_examples.htm)\n- [Fortran 90/95/2003/2008 Programming Online Compiler](https://www.tutorialspoint.com/compile_fortran_online.php)\n- [Fortran 90/95/2003/2008 Programming Tutorial](https://www.tutorialspoint.com/fortran/index.htm)\n- [Fortran 90/95/2003/2008 Programming Reference](https://www.tutorialspoint.com/fortran/fortran_reference.pdf)\n- [Fortran 90/95/2003/2008 Programming Examples](https://www.tutorialspoint.com/fortran/fortran_examples.htm)\n- [Fortran 90/95/2003/2008 Programming Online Compiler](https://www.tutorialspoint.com/compile_fortran_online.php)\n- [Fortran 90/95/2003/2008 Programming Tutorial](https://www.tutorialspoint.com/fortran/index.htm)\n- [Fortran 90/95/2003/2008 Programming Reference](https://www.tutorialspoint.com/fortran/fortran_reference.pdf)\n- [Fortran 90/95/2003/2008 Programming Examples](https://www.tutorialspoint.com/fortran/fortran_examples.htm)\n- [Fortran 90/9
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int num = 0;\n    for (int i = 0; i < operations.size(); i++) {\n        num += operations[i];\n        if (num < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    vector<int> operations;\n    bool result;\n\n    // Test cases\n    operations = {};\n    result = below_zero(operations);\n    if (result != false) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    operations = {1, 2, -3, 1, 2, -3};\n    result = below_zero(operations);\n    if (result != false) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    operations = {1, 2, -4, 5, 6};\n    result = below_zero(operations);\n    if (result != true) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    operations = {1, -1, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != false) {\n        cout << "Test case 4 failed" << endl;\n        return 1;\n    }\n\n    operations = {1, -1, 2, -2, 5, -5, 4, -5};\n    result = below_zero(operations);\n    if (result != true) {\n        cout << "Test case 5 failed" << endl;\n        return 1;\n    }\n\n    operations = {1, -2, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != true) {\n        cout << "Test case 6 failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed" << endl;\n    return 0;\n}\n```\n\n### 2.3.2.2 练习：找出最大子数组和\n\n#### 2.3.2.2.1 题目\n\n给定一个整数数组，找出一个子数组，使得子数组中元素的和最大。\n\n#### 2.3.2.2.2 解答\n\n```c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint max_subarray_sum(vector<int> numbers) {\n    int max_sum = 0;\n    int sum = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        sum += numbers[i];\n        if (sum > max_sum) {\n            max_sum = sum;\n        }\n        if (sum < 0) {\n            sum = 0;\n        }\n    }\n    return max_sum;\n}\n\nint main() {\n    vector<int> numbers = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    cout << max_subarray_sum(numbers) << endl;\n    return 0;\n}\n```\n\n### 2.3.2.3 练习：找出最大子数组乘积\n\n#### 2.3.2.3.1 题目\n\n给定一个整数数组，找出一个子数组，使得子数组中元素的乘积最大。\n\n#### 2.3.2.3.2 解答\n\n```c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint max_subarray_product(vector<int> numbers) {\n    int max_product = 0;\n    int product = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        product *= numbers[i];\n        if (product > max_product) {\n            max_product = product;\n        }\n        if (product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\n\nint main() {\n    vector<int> numbers = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    cout << max_subarray_product(numbers) << endl;\n    return 0;\n}\n```\n\n### 2.3.2.4 练习：找出最大子数组和的区间\n\n#### 2.3.2.4.1 题目\n\n给定一个整数数组，找出一个子数组，使得子数组中元素的和最大。\n\n#### 2.3.2.4.2 解答\n\n```c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> max_subarray_sum_range(vector<int> numbers) {\n    vector<int> range;\n    int max_sum = 0;\n    int sum = 0;\n    int start = 0;\n    int end = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        sum += numbers[i];\n        if (sum > max_sum) {\n            max_sum = sum;\n            start = end + 1;\n            end = i;\n        }\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    range.push_back(start);\n    range.push_back(end);\n    return range;\n}\n\nint main() {\n    vector<int> numbers = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    vector<int> range = max_subarray_sum_range(numbers);\n    cout << range[0] << " " << range[1] << endl;\n    return 0;\n}\n```\n\n### 2.3.2.5 练习：找出最大子数组乘积的区间\n\n#### 2.3.2.5.1 题目\n\n给定一个整数数组，找出一个子数组，使得子数组中元素的乘积最大。\n\n#### 2.3.2.5.2 解答\n\n```c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> max_subarray_product_range(vector<int> numbers) {\n    vector<int> range;\n    int max_product = 0;\n    int product = 0;\n    int start = 0;\n    int end = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        product *= numbers[i];\n        if (product > max_product) {\n            max_product = product;\n            start = end + 1;\n            end = i;\n        }\n        if (product == 0) {\n            product = 1;\n            start = i + 1;\n        }\n    }\n    range.push_back(start);\n    range.push_back(end);\n    return range;\n}\n\nint main() {\n    vector<int> numbers = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    vector<int> range = max_subarray_product_range(numbers);\n    cout << range[0] << " " << range[1] << endl;\n    return 0;\n}\n```\n\n## 2.3.3 栈\n\n### 2.3.3.1 栈的抽象数据类型\n\n#### 2.3.3.1.1 栈的定义\n\n栈是一种特
\n\n[CPP]\n#include <cmath>\n#include <vector>\n\n// [FUNCTION]\ndouble mean_absolute_deviation(const std::vector<double> &numbers) {\n    double sum = 0.0;\n    for (double number : numbers) {\n        sum += number;\n    }\n    double avg = sum / numbers.size();\n\n    double msum = 0.0;\n    for (double number : numbers) {\n        msum += std::abs(number - avg);\n    }\n    return msum / numbers.size();\n}\n\n// [MAIN]\nint main() {\n    // Test cases\n    double result = mean_absolute_deviation({1.0, 2.0, 3.0});\n    if (std::abs(result - 2.0/3.0) > 1e-4) {\n        std::cout << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    result = mean_absolute_deviation({1.0, 2.0, 3.0, 4.0});\n    if (std::abs(result - 1.0) > 1e-4) {\n        std::cout << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    result = mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0});\n    if (std::abs(result - 6.0/5.0) > 1e-4) {\n        std::cout << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n[/CPP]\n\n[PY]\ndef mean_absolute_deviation(numbers):\n    sum = 0.0\n    for number in numbers:\n        sum += number\n    avg = sum / len(numbers)\n\n    msum = 0.0\n    for number in numbers:\n        msum += abs(number - avg)\n    return msum / len(numbers)\n\n# Test cases\nassert mean_absolute_deviation([1.0, 2.0, 3.0]) == 2.0/3.0\nassert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0\nassert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) == 6.0/5.0\nprint("All test cases passed")\n[/PY]\n\n[JAVA]\nimport java.util.Arrays;\n\nclass MeanAbsoluteDeviation {\n    public static double meanAbsoluteDeviation(double[] numbers) {\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double avg = sum / numbers.length;\n\n        double msum = 0.0;\n        for (double number : numbers) {\n            msum += Math.abs(number - avg);\n        }\n        return msum / numbers.length;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        double result = meanAbsoluteDeviation(new double[] {1.0, 2.0, 3.0});\n        if (Math.abs(result - 2.0/3.0) > 1e-4) {\n            System.out.println("Assertion failed for test case 1");\n            System.exit(1);\n        }\n\n        result = meanAbsoluteDeviation(new double[] {1.0, 2.0, 3.0, 4.0});\n        if (Math.abs(result - 1.0) > 1e-4) {\n            System.out.println("Assertion failed for test case 2");\n            System.exit(1);\n        }\n\n        result = meanAbsoluteDeviation(new double[] {1.0, 2.0, 3.0, 4.0, 5.0});\n        if (Math.abs(result - 6.0/5.0) > 1e-4) {\n            System.out.println("Assertion failed for test case 3");\n            System.exit(1);\n        }\n\n        System.out.println("All test cases passed");\n    }\n}\n[/JAVA]\n\n[JS]\nfunction meanAbsoluteDeviation(numbers) {\n    let sum = 0.0;\n    for (let number of numbers) {\n        sum += number;\n    }\n    let avg = sum / numbers.length;\n\n    let msum = 0.0;\n    for (let number of numbers) {\n        msum += Math.abs(number - avg);\n    }\n    return msum / numbers.length;\n}\n\n// Test cases\nconsole.assert(meanAbsoluteDeviation([1.0, 2.0, 3.0]) == 2.0/3.0);\nconsole.assert(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) == 1.0);\nconsole.assert(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) == 6.0/5.0);\nconsole.log("All test cases passed");\n[/JS]\n\n[GO]\npackage main\n\nimport (\n    "fmt"\n    "math"\n)\n\nfunc meanAbsoluteDeviation(numbers []float64) float64 {\n    sum := 0.0\n    for _, number := range numbers {\n        sum += number\n    }\n    avg := sum / float64(len(numbers))\n\n    msum := 0.0\n    for _, number := range numbers {\n        msum += math.Abs(number - avg)\n    }\n    return msum / float64(len(numbers))\n}\n\nfunc main() {\n    // Test cases\n    result := meanAbsoluteDeviation([]float64{1.0, 2.0, 3.0})\n    if math.Abs(result-2.0/3.0) > 1e-4 {\n        fmt.Println("Assertion failed for test case 1")\n        os.Exit(1)\n    }\n\n    result = meanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})\n    if math.Abs(result-1.0) > 1e-4 {\n        fmt.Println("Assertion failed for test case 2")\n        os.Exit(1)\n    }\n\n    result = meanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n    if math.Abs(result-6.0/5.0) > 1e-4 {\n        fmt.Println("Assertion failed for test case 3")\n        os.Exit(1)\n    }\n\n    fmt.Println("All test cases passed")\n}\n[/GO]\n\n[PHP]\nfunction mean_absolute_deviation($numbers) {\n    $sum = 0.0;\n    foreach ($number in $numbers) {\n        $sum += $number;\n    }\n    $avg = $sum / count($numbers);\n\n    $msum = 0.0;\n    foreach ($number in $numbers) {\n        $msum += abs($number - $avg);\n    }\n    return $msum / count($numbers);\n}\n\n// Test cases\nassert(mean_absolute_deviation([1.0, 2.0, 3.0]) == 2.0/3.0);\nassert(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0);\nassert(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) == 6.0/5.0);\necho "All test cases passed";\n[/PHP]\n\n[RUBY]\ndef mean_absolute_deviation(numbers)\n    sum = 0.0\n    numbers.each do |number|\n        sum += number\n
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid intersperse(vector<int> &numbers, int delimeter, vector<int> &result) {\n    int n = numbers.size();\n    if (n == 0) {\n        result.clear();\n        return;\n    }\n\n    result.resize(2 * n - 1);\n    result[0] = numbers[0];\n    for (int i = 1; i < n; i++) {\n        result[2 * i - 1] = delimeter;\n        result[2 * i] = numbers[i];\n    }\n}\n\nint main() {\n    vector<int> numbers;\n    vector<int> result;\n    vector<int> expected;\n\n    // Test case 1\n    numbers.clear();\n    numbers.push_back(0);\n    expected.clear();\n    intersperse(numbers, 7, result);\n    assert(result == expected);\n\n    // Test case 2\n    numbers.clear();\n    numbers.push_back(5);\n    numbers.push_back(6);\n    numbers.push_back(3);\n    numbers.push_back(2);\n    expected.clear();\n    expected.push_back(5);\n    expected.push_back(8);\n    expected.push_back(6);\n    expected.push_back(8);\n    expected.push_back(3);\n    expected.push_back(8);\n    expected.push_back(2);\n    intersperse(numbers, 8, result);\n    assert(result == expected);\n\n    // Test case 3\n    numbers.clear();\n    numbers.push_back(2);\n    numbers.push_back(2);\n    numbers.push_back(2);\n    expected.clear();\n    expected.push_back(2);\n    expected.push_back(2);\n    expected.push_back(2);\n    expected.push_back(2);\n    expected.push_back(2);\n    intersperse(numbers, 2, result);\n    assert(result == expected);\n\n    return 0;\n}\n\n[C]\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nvoid intersperse(int *numbers, int n, int delimeter, int *result) {\n    if (n == 0) {\n        result[0] = 0;\n        return;\n    }\n\n    int *p = result;\n    *p++ = numbers[0];\n    for (int i = 1; i < n; i++) {\n        *p++ = delimeter;\n        *p++ = numbers[i];\n    }\n}\n\nvoid assert_array_equal(int *a, int *b, int n) {\n    for (int i = 0; i < n; i++) {\n        assert(a[i] == b[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {5, 6, 3, 2};\n    int expected[] = {5, 8, 6, 8, 3, 8, 2};\n    int result[MAX(sizeof(numbers), sizeof(expected))];\n\n    intersperse(numbers, sizeof(numbers) / sizeof(numbers[0]), 8, result);\n    assert_array_equal(result, expected, sizeof(expected) / sizeof(expected[0]));\n\n    numbers[0] = 2;\n    numbers[1] = 2;\n    numbers[2] = 2;\n    expected[0] = 2;\n    expected[1] = 2;\n    expected[2] = 2;\n    expected[3] = 2;\n    expected[4] = 2;\n    intersperse(numbers, sizeof(numbers) / sizeof(numbers[0]), 2, result);\n    assert_array_equal(result, expected, sizeof(expected) / sizeof(expected[0]));\n\n    return 0;\n}\n\n[Python]\ndef intersperse(numbers, delimeter):\n    return [numbers[0]] + [delimeter] * (len(numbers) - 1) + numbers[1:]\n\ndef test_intersperse():\n    assert intersperse([], 7) == []\n    assert intersperse([5], 8) == [5]\n    assert intersperse([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert intersperse([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n\nif __name__ == '__main__':\n    test_intersperse()\n\n[JavaScript]\nfunction intersperse(numbers, delimeter) {\n    return [numbers[0]]\n        .concat(Array(numbers.length - 1).fill(delimeter))\n        .concat(numbers.slice(1));\n}\n\nfunction test_intersperse() {\n    assert.deepEqual(intersperse([], 7), []);\n    assert.deepEqual(intersperse([5], 8), [5]);\n    assert.deepEqual(intersperse([5, 6, 3, 2], 8), [5, 8, 6, 8, 3, 8, 2]);\n    assert.deepEqual(intersperse([2, 2, 2], 2), [2, 2, 2, 2, 2]);\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n    assert = require('assert');\n    test_intersperse();\n}\n\n[PHP]\nfunction intersperse(array $numbers, $delimeter) {\n    return array_merge(\n        [$numbers[0]],\n        array_fill(0, count($numbers) - 1, $delimeter),\n        array_slice($numbers, 1)\n    );\n}\n\nfunction test_intersperse() {\n    assert(intersperse([], 7) == []);\n    assert(intersperse([5], 8) == [5]);\n    assert(intersperse([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]);\n    assert(intersperse([2, 2, 2], 2) == [2, 2, 2, 2, 2]);\n}\n\nif (isset($argv)) {\n    test_intersperse();\n}\n\n[Ruby]\ndef intersperse(numbers, delimeter)\n    result = [numbers[0]]\n    (numbers.length - 1).times do |i|\n        result << delimeter\n    end\n    result.concat(numbers[1..-1])\nend\n\ndef test_intersperse()\n    assert_equal(intersperse([], 7), [])\n    assert_equal(intersperse([5], 8), [5])\n    assert_equal(intersperse([5, 6, 3, 2], 8), [5, 8, 6, 8, 3, 8, 2])\n    assert_equal(intersperse([2, 2, 2], 2), [2, 2, 2, 2, 2])\nend\n\nif __FILE__ == $0\n    test_intersperse()\nend\n\n[Swift]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    var result = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count {\n        result.append(delimeter)\n        result.append(numbers[i])\n    }\n    return result\n}\n\nfunc test_intersperse() {\n    assert(intersperse([], 7) == [])\n    assert(intersperse([5], 8) == [5])\n    assert(intersperse([5, 6, 3, 2], 8) == [5, 8, 6, 8, 
\n\n[/FOLD]\n\n[FOLD=Fortran 2003]\n\n[INST] Translate this Fortran code to C++: \nprogram nested_parens\n    implicit none\n    character(len=100) :: paren_string\n    integer, dimension(:), allocatable :: result\n    integer, dimension(4) :: expected1 = [2, 3, 1, 3]\n    integer, dimension(4) :: expected2 = [1, 2, 3, 4]\n    integer, dimension(1) :: expected3 = [4]\n    logical :: is_same\n\n    paren_string = '(()()) ((())) () ((())()())'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected1)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 1"\n        call exit(1)\n    end if\n\n    paren_string = '() (()) ((())) (((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected2)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 2"\n        call exit(1)\n    end if\n\n    paren_string = '(()(())((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected3)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 3"\n        call exit(1)\n    end if\n\ncontains\n\n    subroutine parse_nested_parens(paren_string, all_levels)\n        character(len=*), intent(in) :: paren_string\n        integer, dimension(:), allocatable, intent(out) :: all_levels\n        integer :: level, max_level, i, n\n        character(len=1) :: chr\n        integer, dimension(:), allocatable :: temp_levels\n\n        level = 0\n        max_level = 0\n        n = len_trim(paren_string)\n        allocate(temp_levels(n))\n        temp_levels = 0\n\n        do i = 1, n\n            chr = paren_string(i:i)\n            if (chr == '(') then\n                level = level + 1\n                if (level > max_level) max_level = level\n            else if (chr == ')') then\n                level = level - 1\n                if (level == 0) then\n                    temp_levels(i) = max_level\n                    max_level = 0\n                end if\n            end if\n        end do\n\n        ! Filter out zeros and allocate the result array\n        allocate(all_levels(count(temp_levels /= 0)))\n        all_levels = pack(temp_levels, temp_levels /= 0)\n    end subroutine parse_nested_parens\n\n    logical function issame(a, b)\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend program nested_parens [/INST]\n\n[/FOLD]\n\n[FOLD=Fortran 2008]\n\n[INST] Translate this Fortran code to C++: \nprogram nested_parens\n    implicit none\n    character(len=100) :: paren_string\n    integer, dimension(:), allocatable :: result\n    integer, dimension(4) :: expected1 = [2, 3, 1, 3]\n    integer, dimension(4) :: expected2 = [1, 2, 3, 4]\n    integer, dimension(1) :: expected3 = [4]\n    logical :: is_same\n\n    paren_string = '(()()) ((())) () ((())()())'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected1)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 1"\n        call exit(1)\n    end if\n\n    paren_string = '() (()) ((())) (((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected2)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 2"\n        call exit(1)\n    end if\n\n    paren_string = '(()(())((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected3)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 3"\n        call exit(1)\n    end if\n\ncontains\n\n    subroutine parse_nested_parens(paren_string, all_levels)\n        character(len=*), intent(in) :: paren_string\n        integer, dimension(:), allocatable, intent(out) :: all_levels\n        integer :: level, max_level, i, n\n        character(len=1) :: chr\n        integer, dimension(:), allocatable :: temp_levels\n\n        level = 0\n        max_level = 0\n        n = len_trim(paren_string)\n        allocate(temp_levels(n))\n        temp_levels = 0\n\n        do i = 1, n\n            chr = paren_string(i:i)\n            if (chr == '(') then\n                level = level + 1\n                if (level > max_level) max_level = level\n            else if (chr == ')') then\n                level = level - 1\n                if (level == 0) then\n                    temp_levels(i) = max_level\n                    max_level = 0\n                end if\n            end if\n        end do\n\n        ! Filter out zeros and allocate the result array\n        allocate(all_levels(count(temp_levels /= 0)))\n        all_levels = pack(temp_levels, temp_levels /= 0)\n    end subroutine parse_nested_parens\n\n    logical function issame(a, b)\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend program nested_parens [/INST]\n\n[/FOLD]\n\n[FOLD=Fortran 2018]\n\n[INST] Translate this Fortran code to C++: \nprogram nested_parens\n    implicit none\n    character(len=100) :: paren_string\n    integer, dimension(:), allocatable :: result\n    integer, dimension(4) :: expected1 = [2, 3, 1, 3]\n    integer, dimension(4) :: expected2 = [1, 2, 3, 4]\n    integer, dimension(1) :: expected3 = [4]\n    logical :: is_same\n\n    paren_string = '(()()) ((())) () ((())()())'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected1)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed for test case 1"\n        call exit(1)\n    end if\n\n    paren_string = '() (()) ((())) (((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected2)\n    if (.not. is_same)
\n\n[CPP]\n#include <vector>\n\n// [FUNCTIONS]\n\n// [CLASS1]\nclass Solution {\npublic:\n    // [METHOD1]\n    std::vector<int> sum_product(std::vector<int> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int i = 0; i < numbers.size(); i++) {\n            sum += numbers[i];\n            product *= numbers[i];\n        }\n\n        std::vector<int> result = {sum, product};\n        return result;\n    }\n\n    // [METHOD2]\n    bool issame(std::vector<int> a, std::vector<int> b) {\n        if (a.size() != b.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < a.size(); i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\n// [MAIN]\nint main() {\n    Solution solution;\n\n    std::vector<int> empty_array;\n    std::vector<int> array1 = {1, 1, 1};\n    std::vector<int> array2 = {100, 0};\n    std::vector<int> array3 = {3, 5, 7};\n    std::vector<int> array4 = {10};\n\n    std::vector<int> result = solution.sum_product(empty_array);\n    if (!solution.issame(result, {0, 1})) {\n        return 1;\n    }\n\n    result = solution.sum_product(array1);\n    if (!solution.issame(result, {3, 1})) {\n        return 1;\n    }\n\n    result = solution.sum_product(array2);\n    if (!solution.issame(result, {100, 0})) {\n        return 1;\n    }\n\n    result = solution.sum_product(array3);\n    if (!solution.issame(result, {3 + 5 + 7, 3 * 5 * 7})) {\n        return 1;\n    }\n\n    result = solution.sum_product(array4);\n    if (!solution.issame(result, {10, 10})) {\n        return 1;\n    }\n\n    return 0;\n}\n[/CPP]\n\n[PYTHON]\n# [FUNCTIONS]\n\n\n# [CLASS1]\nclass Solution:\n    # [METHOD1]\n    def sum_product(self, numbers):\n        sum = 0\n        product = 1\n\n        for i in range(len(numbers)):\n            sum += numbers[i]\n            product *= numbers[i]\n\n        return [sum, product]\n\n    # [METHOD2]\n    def issame(self, a, b):\n        if len(a) != len(b):\n            return False\n\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                return False\n\n        return True\n\n\n# [MAIN]\nsolution = Solution()\n\nempty_array = []\narray1 = [1, 1, 1]\narray2 = [100, 0]\narray3 = [3, 5, 7]\narray4 = [10]\n\nresult = solution.sum_product(empty_array)\nif not solution.issame(result, [0, 1]):\n    exit(1)\n\nresult = solution.sum_product(array1)\nif not solution.issame(result, [3, 1]):\n    exit(1)\n\nresult = solution.sum_product(array2)\nif not solution.issame(result, [100, 0]):\n    exit(1)\n\nresult = solution.sum_product(array3)\nif not solution.issame(result, [3 + 5 + 7, 3 * 5 * 7]):\n    exit(1)\n\nresult = solution.sum_product(array4)\nif not solution.issame(result, [10, 10]):\n    exit(1)\n\nprint("All test cases passed")\n[/PYTHON]\n\n[JAVA]\n// [FUNCTIONS]\n\n// [CLASS1]\nclass Solution {\n    // [METHOD1]\n    public int[] sum_product(int[] numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n            product *= numbers[i];\n        }\n\n        int[] result = {sum, product};\n        return result;\n    }\n\n    // [METHOD2]\n    public boolean issame(int[] a, int[] b) {\n        if (a.length != b.length) {\n            return false;\n        }\n\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// [MAIN]\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int[] empty_array = {};\n        int[] array1 = {1, 1, 1};\n        int[] array2 = {100, 0};\n        int[] array3 = {3, 5, 7};\n        int[] array4 = {10};\n\n        int[] result = solution.sum_product(empty_array);\n        if (!solution.issame(result, new int[] {0, 1})) {\n            System.exit(1);\n        }\n\n        result = solution.sum_product(array1);\n        if (!solution.issame(result, new int[] {3, 1})) {\n            System.exit(1);\n        }\n\n        result = solution.sum_product(array2);\n        if (!solution.issame(result, new int[] {100, 0})) {\n            System.exit(1);\n        }\n\n        result = solution.sum_product(array3);\n        if (!solution.issame(result, new int[] {3 + 5 + 7, 3 * 5 * 7})) {\n            System.exit(1);\n        }\n\n        result = solution.sum_product(array4);\n        if (!solution.issame(result, new int[] {10, 10})) {\n            System.exit(1);\n        }\n\n        System.out.println("All test cases passed");\n    }\n}\n[/JAVA]\n\n[RUBY]\n# [FUNCTIONS]\n\n# [CLASS1]\nclass Solution\n  # [METHOD1]\n  def sum_product(numbers)\n    sum = 0\n    product = 1\n\n    numbers.each do |number|\n      sum += number\n      product *= number\n    end\n\n    [sum, product]\n  end\n\n  # [METHOD2]\n  def issame(a, b)\n    return false if a.length != b.length\n\n    a.each_with_index do |value, index|\n      return false if value != b[index]\n    end\n\n    true\n  end\nend\n\n# [MAIN]\nsolution = Solution.new\n\nempty_array = []\narray1 = [1, 1, 1]\narray2 = [100, 0]\narray3 = [3, 5, 7]\narray4 = [10]\n\nresult = solution.sum_product(empty_array)\nif !solution.issame(result, [0, 1])\n  exit(1)\nend\n\nresult = solution.sum_product(array1)\nif !solution.issame(result, [3, 1])\n  exit(1)\nend\n\nresult = solution.sum_product(array2)\nif !solution.issame(result, [100, 0])\n  exit(1)\nend\n\nresult = solution.sum_product(array3)\nif !solution.issame(result, [3 + 5 + 7, 3 * 5 * 7])\n  exit
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid rolling_max(vector<int> &numbers, vector<int> &out) {\n    int max = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n}\n\nbool is_same(vector<int> a, vector<int> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    vector<int> numbers;\n    vector<int> result;\n    vector<int> expected;\n\n    // Test case 1\n    numbers.clear();\n    numbers.push_back(0);\n    expected.clear();\n    expected.push_back(0);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    // Test case 2\n    numbers.clear();\n    numbers.push_back(1);\n    numbers.push_back(2);\n    numbers.push_back(3);\n    numbers.push_back(4);\n    expected.clear();\n    expected.push_back(1);\n    expected.push_back(2);\n    expected.push_back(3);\n    expected.push_back(4);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    // Test case 3\n    numbers.clear();\n    numbers.push_back(4);\n    numbers.push_back(3);\n    numbers.push_back(2);\n    numbers.push_back(1);\n    expected.clear();\n    expected.push_back(4);\n    expected.push_back(4);\n    expected.push_back(4);\n    expected.push_back(4);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    // Test case 4\n    numbers.clear();\n    numbers.push_back(3);\n    numbers.push_back(2);\n    numbers.push_back(3);\n    numbers.push_back(100);\n    numbers.push_back(3);\n    expected.clear();\n    expected.push_back(3);\n    expected.push_back(3);\n    expected.push_back(3);\n    expected.push_back(100);\n    expected.push_back(100);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 4 failed" << endl;\n        return 1;\n    }\n\n    return 0;\n} [/C++]\n\n[C#]\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main()\n    {\n        // Test case 1\n        List<int> numbers = new List<int> { 0 };\n        List<int> expected = new List<int> { 0 };\n        List<int> result = new List<int>();\n        rolling_max(numbers, result);\n        if (!is_same(result, expected))\n        {\n            Console.WriteLine("Test case 1 failed");\n            return;\n        }\n\n        // Test case 2\n        numbers = new List<int> { 1, 2, 3, 4 };\n        expected = new List<int> { 1, 2, 3, 4 };\n        result = new List<int>();\n        rolling_max(numbers, result);\n        if (!is_same(result, expected))\n        {\n            Console.WriteLine("Test case 2 failed");\n            return;\n        }\n\n        // Test case 3\n        numbers = new List<int> { 4, 3, 2, 1 };\n        expected = new List<int> { 4, 4, 4, 4 };\n        result = new List<int>();\n        rolling_max(numbers, result);\n        if (!is_same(result, expected))\n        {\n            Console.WriteLine("Test case 3 failed");\n            return;\n        }\n\n        // Test case 4\n        numbers = new List<int> { 3, 2, 3, 100, 3 };\n        expected = new List<int> { 3, 3, 3, 100, 100 };\n        result = new List<int>();\n        rolling_max(numbers, result);\n        if (!is_same(result, expected))\n        {\n            Console.WriteLine("Test case 4 failed");\n            return;\n        }\n    }\n\n    static void rolling_max(List<int> numbers, List<int> out)\n    {\n        int max = 0;\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            if (numbers[i] > max) max = numbers[i];\n            out.Add(max);\n        }\n    }\n\n    static bool is_same(List<int> a, List<int> b)\n    {\n        if (a.Count != b.Count) return false;\n        for (int i = 0; i < a.Count; i++)\n        {\n            if (a[i] != b[i]) return false;\n        }\n        return true;\n    }\n} [/C#]\n\n[C++11]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid rolling_max(vector<int> &numbers, vector<int> &out) {\n    int max = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n}\n\nbool is_same(vector<int> a, vector<int> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    vector<int> numbers;\n    vector<int> result;\n    vector<int> expected;\n\n    // Test case 1\n    numbers.clear();\n    numbers.push_back(0);\n    expected.clear();\n    expected.push_back(0);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    // Test case 2\n    numbers.clear();\n    numbers.push_back(1);\n    numbers.push_back(2);\n    numbers.push_back(3);\n    numbers.push_back(4);\n    expected.clear();\n    expected.push_back(1);\n    expected.push_back(2);\n    expected.push_back(3);\n    expected.push_back(4);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    // Test case 3\n    numbers.clear();\n    numbers.push_back(4);\n    numbers.push_back(3);\n    numbers.push_back(2);\n    numbers.push_back(1);\n    expected.clear();\n    expected.push_back(4);\n    expected.push_back(4);\n    expected.push_back(4);\n    expected.push_back(4);\n    rolling_max(numbers, result);\n    if (!is_same(result, expected)) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    // Test case 4\n    numbers.clear();\n    numbers.push_back(3);\n    numbers.push_back(2);\n
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    string reversed_str = str;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return (str == reversed_str);\n}\n\nstring make_palindrome(const string& str) {\n    string palindrome_str;\n    string rstr, nstr, n2str;\n    int i;\n\n    for (i = 1; i <= str.length(); i++) {\n        rstr = str.substr(i, str.length() - i + 1);\n        if (is_palindrome(rstr)) {\n            nstr = str.substr(0, i - 1);\n            n2str = reverse_string(nstr);\n            palindrome_str = str + n2str;\n            return palindrome_str;\n        }\n    }\n\n    n2str = reverse_string(str);\n    palindrome_str = str + n2str;\n    return palindrome_str;\n}\n\nstring reverse_string(const string& str) {\n    string reversed_str;\n    int i;\n\n    for (i = 1; i <= str.length(); i++) {\n        reversed_str += str.substr(str.length() - i + 1, 1);\n    }\n\n    return reversed_str;\n}\n\nint main() {\n    assert(make_palindrome("") == "");\n    assert(make_palindrome("x") == "x");\n    assert(make_palindrome("xyz") == "xyzyx");\n    assert(make_palindrome("xyx") == "xyx");\n    assert(make_palindrome("jerry") == "jerryrrej");\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\nbool is_palindrome(const char* str) {\n    char* reversed_str = strdup(str);\n    reverse_string(reversed_str);\n    bool result = (strcmp(str, reversed_str) == 0);\n    free(reversed_str);\n    return result;\n}\n\nchar* make_palindrome(const char* str) {\n    char* palindrome_str = malloc(strlen(str) * 2 + 1);\n    char* rstr;\n    char* nstr;\n    char* n2str;\n    int i;\n\n    for (i = 1; i <= strlen(str); i++) {\n        rstr = malloc(strlen(str) - i + 1);\n        strncpy(rstr, str + i, strlen(str) - i);\n        rstr[strlen(str) - i] = '\0';\n        if (is_palindrome(rstr)) {\n            nstr = malloc(i);\n            strncpy(nstr, str, i - 1);\n            nstr[i - 1] = '\0';\n            n2str = reverse_string(nstr);\n            strcpy(palindrome_str, str);\n            strcat(palindrome_str, n2str);\n            free(rstr);\n            free(nstr);\n            free(n2str);\n            return palindrome_str;\n        }\n        free(rstr);\n    }\n\n    n2str = reverse_string(str);\n    strcpy(palindrome_str, str);\n    strcat(palindrome_str, n2str);\n    free(n2str);\n    return palindrome_str;\n}\n\nchar* reverse_string(const char* str) {\n    char* reversed_str = malloc(strlen(str) + 1);\n    int i;\n\n    for (i = 1; i <= strlen(str); i++) {\n        reversed_str[i - 1] = str[strlen(str) - i];\n    }\n    reversed_str[i - 1] = '\0';\n\n    return reversed_str;\n}\n\nint main() {\n    assert(strcmp(make_palindrome(""), "") == 0);\n    assert(strcmp(make_palindrome("x"), "x") == 0);\n    assert(strcmp(make_palindrome("xyz"), "xyzyx") == 0);\n    assert(strcmp(make_palindrome("xyx"), "xyx") == 0);\n    assert(strcmp(make_palindrome("jerry"), "jerryrrej") == 0);\n\n    return 0;\n}\n\n[Python]\ndef is_palindrome(str):\n    return str == str[::-1]\n\ndef make_palindrome(str):\n    palindrome_str = ""\n    rstr = ""\n    nstr = ""\n    n2str = ""\n    for i in range(1, len(str)):\n        rstr = str[i:]\n        if is_palindrome(rstr):\n            nstr = str[:i]\n            n2str = reverse_string(nstr)\n            palindrome_str = str + n2str\n            return palindrome_str\n    n2str = reverse_string(str)\n    palindrome_str = str + n2str\n    return palindrome_str\n\ndef reverse_string(str):\n    reversed_str = ""\n    for i in range(1, len(str)):\n        reversed_str += str[len(str) - i]\n    return reversed_str\n\nassert(make_palindrome("") == "")\nassert(make_palindrome("x") == "x")\nassert(make_palindrome("xyz") == "xyzyx")\nassert(make_palindrome("xyx") == "xyx")\nassert(make_palindrome("jerry") == "jerryrrej")\n\n[Ruby]\ndef is_palindrome(str)\n    str == str.reverse\nend\n\ndef make_palindrome(str)\n    palindrome_str = ""\n    rstr = ""\n    nstr = ""\n    n2str = ""\n    for i in 1..str.length\n        rstr = str[i..-1]\n        if is_palindrome(rstr)\n            nstr = str[0..i-1]\n            n2str = reverse_string(nstr)\n            palindrome_str = str + n2str\n            return palindrome_str\n        end\n    end\n    n2str = reverse_string(str)\n    palindrome_str = str + n2str\n    return palindrome_str\nend\n\ndef reverse_string(str)\n    reversed_str = ""\n    for i in 1..str.length\n        reversed_str += str[str.length - i]\n    end\n    return reversed_str\nend\n\nassert(make_palindrome("") == "")\nassert(make_palindrome("x") == "x")\nassert(make_palindrome("xyz") == "xyzyx")\nassert(make_palindrome("xyx") == "xyx")\nassert(make_palindrome("jerry") == "jerryrrej")\n\n[JavaScript]\nfunction isPalindrome(str) {\n    return str === str.split('').reverse().join('');\n}\n\nfunction makePalindrome(str) {\n    let palindromeStr = "";\n    let rstr = "";\n    let nstr = "";\n    let n2str = "";\n    for (let i = 1; i <= str.length; i++) {\n        rstr = str.substring(i);\n        if (isPalindrome(rstr)) {\n            nstr = str.substring(0, i - 1);\n            n2str = reverseString(nstr);\n            palindromeStr = str + n2str;\n            return palindromeStr;\n        }\n    }\n    n2str = reverseString(str);\n    palindromeStr = str + n2str;\n    return palindromeStr;\n}\n\nfunction reverseString(str) {\n    let reversedStr = "";\n    for (let i = 1; i <= str.length; i++) {\n        reversedStr +=
\n\n[INST] Translate this Fortran code to C++: \nprogram string_xor_program\n    implicit none\n    character(len=:), allocatable :: result\n\n    ! Test cases\n    result = string_xor("111000", "101010")\n    if (result /= "010010") then\n        write(*,*) "Assertion failed: string_xor('111000', '101010') /= '010010'"\n        call exit(1)\n    end if\n\n    result = string_xor("1", "1")\n    if (result /= "0") then\n        write(*,*) "Assertion failed: string_xor('1', '1') /= '0'"\n        call exit(1)\n    end if\n\n    result = string_xor("0101", "0000")\n    if (result /= "0101") then\n        write(*,*) "Assertion failed: string_xor('0101', '0000') /= '0101'"\n        call exit(1)\n    end if\n\ncontains\n\n    function string_xor(a, b) result(output)\n        character(len=*), intent(in) :: a, b\n        character(len=:), allocatable :: output\n        integer :: i, len_a, len_b, min_len\n\n        len_a = len(a)\n        len_b = len(b)\n        min_len = min(len_a, len_b)\n        output = ""\n\n        do i = 1, min_len\n            if (a(i:i) == b(i:i)) then\n                output = output // '0'\n            else\n                output = output // '1'\n            end if\n        end do\n\n        if (len_a > len_b) then\n            output = output // a(min_len+1:len_a)\n        else if (len_b > len_a) then\n            output = output // b(min_len+1:len_b)\n        end if\n    end function string_xor\n\nend program string_xor_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram string_xor_program\n    implicit none\n    character(len=:), allocatable :: result\n\n    ! Test cases\n    result = string_xor("111000", "101010")\n    if (result /= "010010") then\n        write(*,*) "Assertion failed: string_xor('111000', '101010') /= '010010'"\n        call exit(1)\n    end if\n\n    result = string_xor("1", "1")\n    if (result /= "0") then\n        write(*,*) "Assertion failed: string_xor('1', '1') /= '0'"\n        call exit(1)\n    end if\n\n    result = string_xor("0101", "0000")\n    if (result /= "0101") then\n        write(*,*) "Assertion failed: string_xor('0101', '0000') /= '0101'"\n        call exit(1)\n    end if\n\ncontains\n\n    function string_xor(a, b) result(output)\n        character(len=*), intent(in) :: a, b\n        character(len=:), allocatable :: output\n        integer :: i, len_a, len_b, min_len\n\n        len_a = len(a)\n        len_b = len(b)\n        min_len = min(len_a, len_b)\n        output = ""\n\n        do i = 1, min_len\n            if (a(i:i) == b(i:i)) then\n                output = output // '0'\n            else\n                output = output // '1'\n            end if\n        end do\n\n        if (len_a > len_b) then\n            output = output // a(min_len+1:len_a)\n        else if (len_b > len_a) then\n            output = output // b(min_len+1:len_b)\n        end if\n    end function string_xor\n\nend program string_xor_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram string_xor_program\n    implicit none\n    character(len=:), allocatable :: result\n\n    ! Test cases\n    result = string_xor("111000", "101010")\n    if (result /= "010010") then\n        write(*,*) "Assertion failed: string_xor('111000', '101010') /= '010010'"\n        call exit(1)\n    end if\n\n    result = string_xor("1", "1")\n    if (result /= "0") then\n        write(*,*) "Assertion failed: string_xor('1', '1') /= '0'"\n        call exit(1)\n    end if\n\n    result = string_xor("0101", "0000")\n    if (result /= "0101") then\n        write(*,*) "Assertion failed: string_xor('0101', '0000') /= '0101'"\n        call exit(1)\n    end if\n\ncontains\n\n    function string_xor(a, b) result(output)\n        character(len=*), intent(in) :: a, b\n        character(len=:), allocatable :: output\n        integer :: i, len_a, len_b, min_len\n\n        len_a = len(a)\n        len_b = len(b)\n        min_len = min(len_a, len_b)\n        output = ""\n\n        do i = 1, min_len\n            if (a(i:i) == b(i:i)) then\n                output = output // '0'\n            else\n                output = output // '1'\n            end if\n        end do\n\n        if (len_a > len_b) then\n            output = output // a(min_len+1:len_a)\n        else if (len_b > len_a) then\n            output = output // b(min_len+1:len_b)\n        end if\n    end function string_xor\n\nend program string_xor_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram string_xor_program\n    implicit none\n    character(len=:), allocatable :: result\n\n    ! Test cases\n    result = string_xor("111000", "101010")\n    if (result /= "010010") then\n        write(*,*) "Assertion failed: string_xor('111000', '101010') /= '010010'"\n        call exit(1)\n    end if\n\n    result = string_xor("1", "1")\n    if (result /= "0") then\n        write(*,*) "Assertion failed: string_xor('1', '1') /= '0'"\n        call exit(1)\n    end if\n\n    result = string_xor("0101", "0000")\n    if (result /= "0101") then\n        write(*,*) "Assertion failed: string_xor('0101', '0000') /= '0101'"\n        call exit(1)\n    end if\n\ncontains\n\n    function string_xor(a, b) result(output)\n        character(len=*), intent(in) :: a, b\n        character(len=:), allocatable :: output\n        integer :: i, len_a, len_b, min_len\n\n        len_a = len(a)\n        len_b = len(b)\n        min_len = min(len_a, len_b)\n        output = ""\n\n        do i = 1, min_len\n            if (a(i:i) == b(i:i)) then\n                output = output // '0'\n            else\n                output
\n\n[C++]\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string>& strings) {\n    std::string out;\n    for (const auto& s : strings) {\n        if (s.size() > out.size()) {\n            out = s;\n        }\n    }\n    return out;\n}\n\nint main() {\n    std::vector<std::string> strings;\n\n    // Test case 1: Empty array\n    strings.clear();\n    auto result = longest(strings);\n    if (result != "") {\n        std::cout << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2: Array with single character strings\n    strings = {"x", "y", "z"};\n    result = longest(strings);\n    if (result != "x") {\n        std::cout << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3: Array with varying length strings\n    strings = {"x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "};\n    result = longest(strings);\n    if (result != "zzzz    ") {\n        std::cout << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### 3.2.2. 抽象数据类型\n\n抽象数据类型（ADT）是一种数据类型，它把数据和操作数据的方法组合在一起。\n\n抽象数据类型的一个重要优点是，它可以隐藏数据的实现细节。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一个缺点是，它们通常比普通的数据类型更慢。\n\n抽象数据类型的一
\n\n// [COMPILE]\n// [ARM] aarch64-linux-android-g++ -std=c++17 -Wall -Wextra -Werror -c test.f90 -o test.o\n// [ARM] aarch64-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] x86_64-linux-android-g++ -std=c++17 -Wall -Wextra -Werror -c test.f90 -o test.o\n// [X86] x86_64-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] aarch64-linux-android-gfortran -c test.f90 -o test.o\n// [ARM] aarch64-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] x86_64-linux-android-gfortran -c test.f90 -o test.o\n// [X86] x86_64-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [X86] ./test\n\n// [ARM] arm-linux-androideabi-gfortran -c test.f90 -o test.o\n// [ARM] arm-linux-androideabi-g++ -std=c++17 -Wall -Wextra -Werror test.o -o test\n// [ARM] ./test\n// [X86] i686-linux-android-gfortran -c test.f90 -o test.o\n// [X86] i686-linux-android-g++ -std
\n\n[/FOLD]\n\n[FOLD=C++]\n\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid all_prefixes(const string &str, vector<string> &out) {\n    if (str.empty()) {\n        out.push_back("");\n        return;\n    }\n\n    for (int i = 0; i < str.size(); i++) {\n        string current = str.substr(0, i + 1);\n        out.push_back(current);\n    }\n}\n\nint main() {\n    string str;\n    vector<string> prefixes;\n    vector<string> expected;\n    int i;\n\n    // Test cases\n    str = "";\n    all_prefixes(str, prefixes);\n    expected = {""};\n    if (prefixes != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    str = "asdfgh";\n    all_prefixes(str, prefixes);\n    expected = {"a", "as", "asd", "asdf", "asdfg", "asdfgh"};\n    if (prefixes != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    str = "WWW";\n    all_prefixes(str, prefixes);\n    expected = {"W", "WW", "WWW"};\n    if (prefixes != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[/FOLD]\n\n[FOLD=Python]\n\ndef all_prefixes(str):\n    if len(str) == 0:\n        return [""]\n\n    prefixes = []\n    for i in range(len(str)):\n        prefixes.append(str[:i + 1])\n    return prefixes\n\n\ndef assert_same(a, b):\n    if len(a) != len(b):\n        print("Assertion failed")\n        exit(1)\n\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            print("Assertion failed")\n            exit(1)\n\n\ndef main():\n    str = ""\n    prefixes = all_prefixes(str)\n    expected = [""]\n    assert_same(prefixes, expected)\n\n    str = "asdfgh"\n    prefixes = all_prefixes(str)\n    expected = ["a", "as", "asd", "asdf", "asdfg", "asdfgh"]\n    assert_same(prefixes, expected)\n\n    str = "WWW"\n    prefixes = all_prefixes(str)\n    expected = ["W", "WW", "WWW"]\n    assert_same(prefixes, expected)\n\n\nif __name__ == "__main__":\n    main()\n\n[/FOLD]\n\n[FOLD=Rust]\n\nfn all_prefixes(str: &str) -> Vec<String> {\n    if str.is_empty() {\n        return vec!["".to_string()];\n    }\n\n    let mut prefixes = Vec::new();\n    for i in 0..str.len() {\n        prefixes.push(str[..i + 1].to_string());\n    }\n    prefixes\n}\n\nfn assert_same(a: &[String], b: &[String]) {\n    if a.len() != b.len() {\n        println!("Assertion failed");\n        std::process::exit(1);\n    }\n\n    for i in 0..a.len() {\n        if a[i] != b[i] {\n            println!("Assertion failed");\n            std::process::exit(1);\n        }\n    }\n}\n\nfn main() {\n    let str = "";\n    let prefixes = all_prefixes(str);\n    let expected = vec!["".to_string()];\n    assert_same(&prefixes, &expected);\n\n    let str = "asdfgh";\n    let prefixes = all_prefixes(str);\n    let expected = vec!["a".to_string(), "as".to_string(), "asd".to_string(), "asdf".to_string(), "asdfg".to_string(), "asdfgh".to_string()];\n    assert_same(&prefixes, &expected);\n\n    let str = "WWW";\n    let prefixes = all_prefixes(str);\n    let expected = vec!["W".to_string(), "WW".to_string(), "WWW".to_string()];\n    assert_same(&prefixes, &expected);\n}\n\n[/FOLD]\n\n[FOLD=C#]\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace AllPrefixes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = "";\n            var prefixes = AllPrefixes(str);\n            var expected = new List<string> { "" };\n            if (!Same(prefixes, expected))\n            {\n                Console.WriteLine("Assertion failed");\n                Environment.Exit(1);\n            }\n\n            str = "asdfgh";\n            prefixes = AllPrefixes(str);\n            expected = new List<string> { "a", "as", "asd", "asdf", "asdfg", "asdfgh" };\n            if (!Same(prefixes, expected))\n            {\n                Console.WriteLine("Assertion failed");\n                Environment.Exit(1);\n            }\n\n            str = "WWW";\n            prefixes = AllPrefixes(str);\n            expected = new List<string> { "W", "WW", "WWW" };\n            if (!Same(prefixes, expected))\n            {\n                Console.WriteLine("Assertion failed");\n                Environment.Exit(1);\n            }\n        }\n\n        static List<string> AllPrefixes(string str)\n        {\n            if (str.Length == 0)\n            {\n                return new List<string> { "" };\n            }\n\n            var prefixes = new List<string>();\n            for (int i = 0; i < str.Length; i++)\n            {\n                prefixes.Add(str.Substring(0, i + 1));\n            }\n            return prefixes;\n        }\n\n        static bool Same(List<string> a, List<string> b)\n        {\n            if (a.Count != b.Count)\n            {\n                return false;\n            }\n\n            for (int i = 0; i < a.Count; i++)\n            {\n                if (a[i] != b[i])\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n\n[/FOLD]\n\n[FOLD=Java]\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        String str = "";\n        List<String> prefixes = allPrefixes(str);\n        List<String> expected = new ArrayList<>();\n        expected.add("");\n        if (!same(prefixes, expected)) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n\n        str = "asdfgh";\n        prefixes = allPrefixes(str);\n        expected = new ArrayList<>();\n        expected.add("a");\n        expected.add("as");\n        expected.add("asd");\n        expected.add("asdf");\n        expected.add("asdfg");\n        expected.add("asdfgh");\n        if (!same(prefixes, expected)) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n\n        str = "WWW";\n        prefixes = allPrefixes(str);\n        expected = new ArrayList<>();\n        expected.add("W");\n        expected.add("WW");\n        expected.add("WWW");\n        if (!same(prefixes, expected)) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n    }\n\n    static List<String> allPrefixes(String str) {\n        if (str.length() == 0) {\n            return List.of("");\n       
\n\n[C++]\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_sequence(0);\n    if (result != "0") {\n        std::cout << "Assertion failed: string_sequence(0) == '0'" << std::endl;\n        return 1;\n    }\n\n    result = string_sequence(3);\n    if (result != "0 1 2 3") {\n        std::cout << "Assertion failed: string_sequence(3) == '0 1 2 3'" << std::endl;\n        return 1;\n    }\n\n    result = string_sequence(10);\n    if (result != "0 1 2 3 4 5 6 7 8 9 10") {\n        std::cout << "Assertion failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nstd::string string_sequence(int n) {\n    std::string out = "0";\n    for (int i = 1; i <= n; i++) {\n        out += " " + std::to_string(i);\n    }\n    return out;\n}\n[/C++]\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n\n    // Test cases\n    string_sequence(0, result);\n    if (strcmp(result, "0") != 0) {\n        printf("Assertion failed: string_sequence(0) == '0'\n");\n        return 1;\n    }\n\n    string_sequence(3, result);\n    if (strcmp(result, "0 1 2 3") != 0) {\n        printf("Assertion failed: string_sequence(3) == '0 1 2 3'\n");\n        return 1;\n    }\n\n    string_sequence(10, result);\n    if (strcmp(result, "0 1 2 3 4 5 6 7 8 9 10") != 0) {\n        printf("Assertion failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'\n");\n        return 1;\n    }\n\n    printf("All tests passed.\n");\n\n    return 0;\n}\n\nvoid string_sequence(int n, char *out) {\n    sprintf(out, "0");\n    for (int i = 1; i <= n; i++) {\n        char temp[10];\n        sprintf(temp, " %d", i);\n        strcat(out, temp);\n    }\n}\n[/C]\n\n[Python]\ndef string_sequence(n):\n    out = "0"\n    for i in range(1, n + 1):\n        out += " " + str(i)\n    return out\n\n\n# Test cases\nassert string_sequence(0) == "0"\nassert string_sequence(3) == "0 1 2 3"\nassert string_sequence(10) == "0 1 2 3 4 5 6 7 8 9 10"\n\nprint("All tests passed.")\n[/Python]\n\n[JavaScript]\nfunction string_sequence(n) {\n    let out = "0";\n    for (let i = 1; i <= n; i++) {\n        out += " " + i;\n    }\n    return out;\n}\n\n// Test cases\nconsole.assert(string_sequence(0) === "0");\nconsole.assert(string_sequence(3) === "0 1 2 3");\nconsole.assert(string_sequence(10) === "0 1 2 3 4 5 6 7 8 9 10");\n\nconsole.log("All tests passed.");\n[/JavaScript]\n\n[PHP]\nfunction string_sequence($n) {\n    $out = "0";\n    for ($i = 1; $i <= $n; $i++) {\n        $out .= " " . $i;\n    }\n    return $out;\n}\n\n// Test cases\nassert(string_sequence(0) === "0");\nassert(string_sequence(3) === "0 1 2 3");\nassert(string_sequence(10) === "0 1 2 3 4 5 6 7 8 9 10");\n\necho "All tests passed.\n";\n[/PHP]\n\n[Go]\npackage main\n\nimport "fmt"\n\nfunc string_sequence(n int) string {\n    out := "0"\n    for i := 1; i <= n; i++ {\n        out += " " + fmt.Sprintf("%d", i)\n    }\n    return out\n}\n\n// Test cases\nfunc main() {\n    assert(string_sequence(0) == "0")\n    assert(string_sequence(3) == "0 1 2 3")\n    assert(string_sequence(10) == "0 1 2 3 4 5 6 7 8 9 10")\n\n    fmt.Println("All tests passed.")\n}\n\nfunc assert(b bool) {\n    if !b {\n        panic("Assertion failed")\n    }\n}\n[/Go]\n\n[Ruby]\ndef string_sequence(n)\n    out = "0"\n    for i in 1..n\n        out += " " + i.to_s\n    end\n    return out\nend\n\n# Test cases\nassert(string_sequence(0) == "0")\nassert(string_sequence(3) == "0 1 2 3")\nassert(string_sequence(10) == "0 1 2 3 4 5 6 7 8 9 10")\n\nputs "All tests passed."\n[/Ruby]\n\n[Swift]\nfunc string_sequence(_ n: Int) -> String {\n    var out = "0"\n    for i in 1...n {\n        out += " " + String(i)\n    }\n    return out\n}\n\n// Test cases\nassert(string_sequence(0) == "0")\nassert(string_sequence(3) == "0 1 2 3")\nassert(string_sequence(10) == "0 1 2 3 4 5 6 7 8 9 10")\n\nprint("All tests passed.")\n[/Swift]\n\n[Rust]\nfn string_sequence(n: i32) -> String {\n    let mut out = "0".to_string();\n    for i in 1..=n {\n        out += " " + i.to_string().as_str();\n    }\n    out\n}\n\n// Test cases\nfn main() {\n    assert_eq!(string_sequence(0), "0");\n    assert_eq!(string_sequence(3), "0 1 2 3");\n    assert_eq!(string_sequence(10), "0 1 2 3 4 5 6 7 8 9 10");\n\n    println!("All tests passed.");\n}\n\n#[test]\nfn test_string_sequence() {\n    assert_eq!(string_sequence(0), "0");\n    assert_eq!(string_sequence(3), "0 1 2 3");\n    assert_eq!(string_sequence(10), "0 1 2 3 4 5 6 7 8 9 10");\n}\n[/Rust]\n\n[Kotlin]\nfun stringSequence(n: Int): String {\n    var out = "0"\n    for (i in 1..n) {\n        out += " " + i.toString()\n    }\n    return out\n}\n\n// Test cases\nfun main() {\n    assert(stringSequence(0) == "0")\n    assert(stringSequence(3) == "0 1 2 3")\n    assert(stringSequence(10) == "0 1 2 3 4 5 6 7 8 9 10")\n\n   
\n\end{code}\n\nComment: I think you should ask this on [codereview.se] instead.\n\nComment: @HighPerformanceMark I'm not sure if it's a good fit for Code Review. It's not a working program, and it's not a complete program.\n\nComment: @Barmar - I think it is.  It's a program that works and is being asked for a review.  The OP has already said that it's not a complete program.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "it's a program that works". It's a program that's not complete.\n\nComment: @Barmar - I think you're being a bit pedantic.  The OP has said that it's not a complete program.  That's what I meant by "it's a program that works".  The OP has also said that it's not a complete program.  That's what I meant by "it's a program that's not complete".  I think you're being a bit pedantic.\n\nComment: @HighPerformanceMark I'm not being pedantic. I'm trying to understand what you're saying.\n\nComment: @Barmar - I'm not sure what you mean by "I'm trying to understand what you're saying".  I'm not trying to understand anything.  I'm just saying that I think the OP's program works and is being asked for a review.  That's what I meant by "it's a program that works".  I'm not sure what you mean by "I'm not being pedantic".  I'm not being pedantic.  I'm just saying that I think the OP's program works and is being asked for a review.  That's what I meant by "it's a program that works".  I'm not sure what you mean by "I'm not being pedantic".  I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic.\n\nComment: @HighPerformanceMark I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I meant by "it's a program that works". I'm not sure what you mean by "I'm not being pedantic". I'm not being pedantic. I'm just saying that I think the OP's program works and is being asked for a review. That's what I
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> parse_music(const string& music_string) {\n    vector<int> result;\n    string current;\n    stringstream ss(music_string);\n    string token;\n\n    while (ss >> token) {\n        if (token == "o") {\n            result.push_back(4);\n        } else if (token == "o|") {\n            result.push_back(2);\n        } else if (token == ".|") {\n            result.push_back(1);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert(parse_music("") == vector<int>());\n    assert(parse_music("o o o o") == vector<int>{4, 4, 4, 4});\n    assert(parse_music(".| .| .| .|") == vector<int>{1, 1, 1, 1});\n    assert(parse_music("o| o| .| .| o o o o") == vector<int>{2, 2, 1, 1, 4, 4, 4, 4});\n    assert(parse_music("o| .| o| .| o o| o o|") == vector<int>{2, 1, 2, 1, 4, 2, 4, 2});\n    return 0;\n}\n```\n\n### 2.3.2. 循环\n\n```\n[Fortran]\nprogram loop_test\n    implicit none\n    integer :: i\n\n    do i = 1, 10\n        print *, i\n    end do\nend program loop_test\n\n[C++]\n#include <iostream>\n\nint main() {\n    for (int i = 1; i <= 10; i++) {\n        std::cout << i << std::endl;\n    }\n    return 0;\n}\n```\n\n### 2.3.3. 条件语句\n\n```\n[Fortran]\nprogram if_test\n    implicit none\n    integer :: i\n\n    i = 10\n    if (i == 10) then\n        print *, "i is 10"\n    else if (i == 20) then\n        print *, "i is 20"\n    else\n        print *, "i is neither 10 nor 20"\n    end if\nend program if_test\n\n[C++]\n#include <iostream>\n\nint main() {\n    int i = 10;\n    if (i == 10) {\n        std::cout << "i is 10" << std::endl;\n    } else if (i == 20) {\n        std::cout << "i is 20" << std::endl;\n    } else {\n        std::cout << "i is neither 10 nor 20" << std::endl;\n    }\n    return 0;\n}\n```\n\n### 2.3.4. 函数\n\n```\n[Fortran]\nprogram function_test\n    implicit none\n    integer :: i\n\n    i = 10\n    print *, "i is ", i\n    i = i + 1\n    print *, "i is ", i\nend program function_test\n\n[C++]\n#include <iostream>\n\nint main() {\n    int i = 10;\n    std::cout << "i is " << i << std::endl;\n    i = i + 1;\n    std::cout << "i is " << i << std::endl;\n    return 0;\n}\n```\n\n### 2.3.5. 数组\n\n```\n[Fortran]\nprogram array_test\n    implicit none\n    integer, dimension(10) :: a\n    integer :: i\n\n    do i = 1, 10\n        a(i) = i\n    end do\n    do i = 1, 10\n        print *, a(i)\n    end do\nend program array_test\n\n[C++]\n#include <iostream>\n\nint main() {\n    int a[10];\n    for (int i = 0; i < 10; i++) {\n        a[i] = i;\n    }\n    for (int i = 0; i < 10; i++) {\n        std::cout << a[i] << std::endl;\n    }\n    return 0;\n}\n```\n\n### 2.3.6. 字符串\n\n```\n[Fortran]\nprogram string_test\n    implicit none\n    character(len=100) :: s\n\n    s = "Hello, world!"\n    print *, s\nend program string_test\n\n[C++]\n#include <iostream>\n\nint main() {\n    std::string s = "Hello, world!";\n    std::cout << s << std::endl;\n    return 0;\n}\n```\n\n### 2.3.7. 结构体\n\n```\n[Fortran]\nprogram struct_test\n    implicit none\n    type point\n        real :: x\n        real :: y\n    end type point\n    type(point) :: p\n\n    p%x = 10\n    p%y = 20\n    print *, p%x, p%y\nend program struct_test\n\n[C++]\n#include <iostream>\n\nstruct Point {\n    float x;\n    float y;\n};\n\nint main() {\n    Point p;\n    p.x = 10;\n    p.y = 20;\n    std::cout << p.x << " " << p.y << std::endl;\n    return 0;\n}\n```\n\n### 2.3.8. 枚举\n\n```\n[Fortran]\nprogram enum_test\n    implicit none\n    enum, bind(c)\n        enumerator :: red, green, blue\n    end enum\n    integer(c_int) :: color\n\n    color = red\n    print *, color\nend program enum_test\n\n[C++]\n#include <iostream>\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\n\nint main() {\n    Color color = RED;\n    std::cout << color << std::endl;\n    return 0;\n}\n```\n\n### 2.3.9. 类\n\n```\n[Fortran]\nprogram class_test\n    implicit none\n    type point\n        real :: x\n        real :: y\n    contains\n        procedure :: distance\n    end type point\n    type(point) :: p1, p2\n    real :: distance\n\n    p1%x = 10\n    p1%y = 20\n    p2%x = 10\n    p2%y = 20\n    distance = p1%distance(p2)\n    print *, distance\nend program class_test\n\n[C++]\n#include <iostream>\n\nstruct Point {\n    float x;\n    float y;\n    float distance(Point p) {\n        return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n    }\n};\n\nint main() {\n    Point p1, p2;\n    p1.x = 10;\n    p1.y = 20;\n    p2.x = 10;\n    p2.y = 20;\n    std::cout << p1.distance(p2) << std::endl;\n    return 0;\n}\n```\n\n### 2.3.10. 模块\n\n```\n[Fortran]\nmodule math_module\n    implicit none\n    contains\n        function add(a, b) result(c)\n            integer, intent(in) :: a, b\n            integer :: c\n            c = a + b\n        end function add\nend module math_module\n\nprogram module_test\n    use math_module\n    implicit none\n    integer :: a, b, c\n\n    a = 10\n    b = 20\n    c = add(a, b)\n    print *, c\nend program module_test\n\n[C++]\n#include <
\n\n[CPP]\n#include <iostream>\n#include <string>\n\nint how_many_times(std::string str, std::string substring) {\n    int out = 0;\n    int str_len = str.length();\n    int sub_len = substring.length();\n\n    if (str_len == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i < str_len - sub_len + 1; i++) {\n        if (str.substr(i, sub_len) == substring) {\n            out++;\n        }\n    }\n\n    return out;\n}\n\nint main() {\n    // Test cases\n    int result = how_many_times("", "x");\n    if (result != 0) {\n        std::cout << "Assertion failed: how_many_times('', 'x') == 0" << std::endl;\n        return 1;\n    }\n\n    result = how_many_times("xyxyxyx", "x");\n    if (result != 4) {\n        std::cout << "Assertion failed: how_many_times('xyxyxyx', 'x') == 4" << std::endl;\n        return 1;\n    }\n\n    result = how_many_times("cacacacac", "cac");\n    if (result != 4) {\n        std::cout << "Assertion failed: how_many_times('cacacacac', 'cac') == 4" << std::endl;\n        return 1;\n    }\n\n    result = how_many_times("john doe", "john");\n    if (result != 1) {\n        std::cout << "Assertion failed: how_many_times('john doe', 'john') == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n[/CPP]\n\n[PYTHON]\ndef how_many_times(str, substring):\n    out = 0\n    str_len = len(str)\n    sub_len = len(substring)\n\n    if str_len == 0:\n        return 0\n\n    for i in range(str_len - sub_len + 1):\n        if str[i:i+sub_len] == substring:\n            out += 1\n\n    return out\n\n\n# Test cases\nassert how_many_times("", "x") == 0\nassert how_many_times("xyxyxyx", "x") == 4\nassert how_many_times("cacacacac", "cac") == 4\nassert how_many_times("john doe", "john") == 1\n\nprint("All tests passed.")\n[/PYTHON]\n\n[JAVA]\npublic class StringUtils {\n    public static int howManyTimes(String str, String substring) {\n        int out = 0;\n        int str_len = str.length();\n        int sub_len = substring.length();\n\n        if (str_len == 0) {\n            return 0;\n        }\n\n        for (int i = 0; i < str_len - sub_len + 1; i++) {\n            if (str.substring(i, i + sub_len).equals(substring)) {\n                out++;\n            }\n        }\n\n        return out;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        assert howManyTimes("", "x") == 0;\n        assert howManyTimes("xyxyxyx", "x") == 4;\n        assert howManyTimes("cacacacac", "cac") == 4;\n        assert howManyTimes("john doe", "john") == 1;\n\n        System.out.println("All tests passed.");\n    }\n}\n[/JAVA]\n\n[RUBY]\ndef how_many_times(str, substring)\n    out = 0\n    str_len = str.length\n    sub_len = substring.length\n\n    if str_len == 0\n        return 0\n    end\n\n    for i in 0..str_len - sub_len\n        if str[i, sub_len] == substring\n            out += 1\n        end\n    end\n\n    return out\nend\n\n# Test cases\nassert how_many_times("", "x") == 0\nassert how_many_times("xyxyxyx", "x") == 4\nassert how_many_times("cacacacac", "cac") == 4\nassert how_many_times("john doe", "john") == 1\n\nputs "All tests passed."\n[/RUBY]\n\n[CSHARP]\nusing System;\n\npublic class StringUtils\n{\n    public static int HowManyTimes(string str, string substring)\n    {\n        int out = 0;\n        int str_len = str.Length;\n        int sub_len = substring.Length;\n\n        if (str_len == 0)\n        {\n            return 0;\n        }\n\n        for (int i = 0; i < str_len - sub_len + 1; i++)\n        {\n            if (str.Substring(i, sub_len) == substring)\n            {\n                out++;\n            }\n        }\n\n        return out;\n    }\n\n    public static void Main(string[] args)\n    {\n        // Test cases\n        assert HowManyTimes("", "x") == 0;\n        assert HowManyTimes("xyxyxyx", "x") == 4;\n        assert HowManyTimes("cacacacac", "cac") == 4;\n        assert HowManyTimes("john doe", "john") == 1;\n\n        Console.WriteLine("All tests passed.");\n    }\n}\n[/CSHARP]\n\n[PHP]\nfunction how_many_times($str, $substring)\n{\n    $out = 0;\n    $str_len = strlen($str);\n    $sub_len = strlen($substring);\n\n    if ($str_len == 0) {\n        return 0;\n    }\n\n    for ($i = 0; $i < $str_len - $sub_len + 1; $i++) {\n        if (substr($str, $i, $sub_len) == $substring) {\n            $out++;\n        }\n    }\n\n    return $out;\n}\n\n// Test cases\nassert(how_many_times("", "x") == 0);\nassert(how_many_times("xyxyxyx", "x") == 4);\nassert(how_many_times("cacacacac", "cac") == 4);\nassert(how_many_times("john doe", "john") == 1);\n\necho "All tests passed.";\n[/PHP]\n\n[GO]\npackage main\n\nimport "fmt"\n\nfunc howManyTimes(str, substring string) int {\n    out := 0\n    str_len := len(str)\n    sub_len := len(substring)\n\n    if str_len == 0 {\n        return 0\n    }\n\n    for i := 0; i < str_len-sub_len+1; i++ {\n        if str[i:i+sub_len] == substring {\n            out++\n        }\n    }\n\n    return out\n}\n\nfunc main() {\n    // Test cases\n    assert(howManyTimes("", "x") == 0)\n    assert(howManyTimes("xyxyxyx", "x") == 4)\n    assert(howManyTimes("cacacacac", "cac") == 4)\n    assert(howManyTimes("john doe", "john") == 1)\n\n    fmt.Println("All tests passed.")\n}\n\nfunc assert(b bool) {\n    if !b {\n        panic("Assertion failed")\n    }\n}\n[/GO]\n\n[MATLAB]\nfunction out = how_many_times(str, substring)\n    out = 0;\n    str_len = length(str);\n    sub_len = length(substring);\n\n    if str_len == 0\n        return 0;\n    end\n\n    for i = 1:str_len - sub_len + 1\n        if str(i:i+sub_len-1
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<double> find_closest_elements(vector<double> numbers) {\n    vector<double> out(2);\n    double min_diff = numeric_limits<double>::max();\n\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < min_diff) {\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n                min_diff = abs(numbers[i] - numbers[j]);\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        swap(out[0], out[1]);\n    }\n\n    return out;\n}\n\nbool issame(vector<double> a, vector<double> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (abs(a[i] - b[i]) > 1e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    vector<double> test1 = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    vector<double> test2 = {1.0, 2.0, 5.9, 4.0, 5.0};\n    vector<double> test3 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    vector<double> test4 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    vector<double> test5 = {1.1, 2.2, 3.1, 4.1, 5.1};\n\n    vector<double> result = find_closest_elements(test1);\n    if (!issame(result, {3.9, 4.0})) {\n        cout << "Assertion failed for test1" << endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test2);\n    if (!issame(result, {5.0, 5.9})) {\n        cout << "Assertion failed for test2" << endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test3);\n    if (!issame(result, {2.0, 2.2})) {\n        cout << "Assertion failed for test3" << endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test4);\n    if (!issame(result, {2.0, 2.0})) {\n        cout << "Assertion failed for test4" << endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test5);\n    if (!issame(result, {2.2, 3.1})) {\n        cout << "Assertion failed for test5" << endl;\n        return 1;\n    }\n\n    cout << "All tests passed" << endl;\n    return 0;\n}\n```\n\n### 3.1.3. 배열 초기화\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer, dimension(3) :: a = [1, 2, 3]\n    integer, dimension(3) :: b = [1, 2, 3]\n    integer, dimension(3) :: c = [1, 2, 3]\n    integer, dimension(3) :: d = [1, 2, 3]\n    integer, dimension(3) :: e = [1, 2, 3]\n    integer, dimension(3) :: f = [1, 2, 3]\n    integer, dimension(3) :: g = [1, 2, 3]\n    integer, dimension(3) :: h = [1, 2, 3]\n    integer, dimension(3) :: i = [1, 2, 3]\n    integer, dimension(3) :: j = [1, 2, 3]\n    integer, dimension(3) :: k = [1, 2, 3]\n    integer, dimension(3) :: l = [1, 2, 3]\n    integer, dimension(3) :: m = [1, 2, 3]\n    integer, dimension(3) :: n = [1, 2, 3]\n    integer, dimension(3) :: o = [1, 2, 3]\n    integer, dimension(3) :: p = [1, 2, 3]\n    integer, dimension(3) :: q = [1, 2, 3]\n    integer, dimension(3) :: r = [1, 2, 3]\n    integer, dimension(3) :: s = [1, 2, 3]\n    integer, dimension(3) :: t = [1, 2, 3]\n    integer, dimension(3) :: u = [1, 2, 3]\n    integer, dimension(3) :: v = [1, 2, 3]\n    integer, dimension(3) :: w = [1, 2, 3]\n    integer, dimension(3) :: x = [1, 2, 3]\n    integer, dimension(3) :: y = [1, 2, 3]\n    integer, dimension(3) :: z = [1, 2, 3]\nend program main\n```\n\n```\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<int> a = {1, 2, 3};\n    vector<int> b = {1, 2, 3};\n    vector<int> c = {1, 2, 3};\n    vector<int> d = {1, 2, 3};\n    vector<int> e = {1, 2, 3};\n    vector<int> f = {1, 2, 3};\n    vector<int> g = {1, 2, 3};\n    vector<int> h = {1, 2, 3};\n    vector<int> i = {1, 2, 3};\n    vector<int> j = {1, 2, 3};\n    vector<int> k = {1, 2, 3};\n    vector<int> l = {1, 2, 3};\n    vector<int> m = {1, 2, 3};\n    vector<int> n = {1, 2, 3};\n    vector<int> o = {1, 2, 3};\n    vector<int> p = {1, 2, 3};\n    vector<int> q = {1, 2, 3};\n    vector<int> r = {1, 2, 3};\n    vector<int> s = {1, 2, 3};\n    vector<int> t = {1, 2, 3};\n    vector<int> u = {1, 2, 3};\n    vector<int> v = {1, 2, 3};\n    vector<int> w = {1, 2, 3};\n    vector<int> x = {1, 2, 3};\n    vector<int> y = {1, 2, 3};\n    vector<int> z = {1, 2, 3};\n}\n```\n\n### 3.1.4. 배열 생성\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer, dimension(3) :: a\n    integer, dimension(3) :: b\n    integer, dimension(3) :: c\n    integer, dimension(3) :: d\n    integer, dimension(3) :: e\n    integer, dimension(3) :: f\n    integer, dimension(3) :: g\n    integer, dimension(3) :: h\n    integer, dimension(3) :: i\n    integer, dimension(3) :: j\n    integer, dimension(3) :: k\n    integer, dimension(3) :: l\n    integer, dimension
\n\n```\n\n### C++\n\n```cpp\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<double> rescale_to_unit(const vector<double> &numbers) {\n    double min_val = *min_element(numbers.begin(), numbers.end());\n    double max_val = *max_element(numbers.begin(), numbers.end());\n    vector<double> rescaled(numbers.size());\n\n    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return rescaled;\n}\n\nbool issame(const vector<double> &a, const vector<double> &b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); i++) {\n        if (abs(a[i] - b[i]) > 1.0e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    vector<double> numbers = {2.0, 49.9};\n    vector<double> expected1 = {0.0, 1.0};\n    vector<double> result = rescale_to_unit(numbers);\n    if (!issame(result, expected1)) {\n        cout << "Assertion failed for test case 1" << endl;\n        exit(1);\n    }\n\n    numbers = {100.0, 49.9};\n    vector<double> expected2 = {1.0, 0.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected2)) {\n        cout << "Assertion failed for test case 2" << endl;\n        exit(1);\n    }\n\n    numbers = {1.0, 2.0, 3.0, 4.0, 5.0};\n    vector<double> expected3 = {0.0, 0.25, 0.5, 0.75, 1.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected3)) {\n        cout << "Assertion failed for test case 3" << endl;\n        exit(1);\n    }\n\n    numbers = {2.0, 1.0, 5.0, 3.0, 4.0};\n    vector<double> expected4 = {0.25, 0.0, 1.0, 0.5, 0.75};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected4)) {\n        cout << "Assertion failed for test case 4" << endl;\n        exit(1);\n    }\n\n    numbers = {12.0, 11.0, 15.0, 13.0, 14.0};\n    vector<double> expected5 = {0.25, 0.0, 1.0, 0.5, 0.75};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected5)) {\n        cout << "Assertion failed for test case 5" << endl;\n        exit(1);\n    }\n\n    cout << "All tests passed successfully" << endl;\n    return 0;\n}\n\n```\n\n### Python\n\n```python\ndef rescale_to_unit(numbers):\n    min_val = min(numbers)\n    max_val = max(numbers)\n    rescaled = []\n\n    for number in numbers:\n        rescaled.append((number - min_val) / (max_val - min_val))\n\n    return rescaled\n\n\ndef issame(a, b):\n    if len(a) != len(b):\n        return False\n\n    for i in range(len(a)):\n        if abs(a[i] - b[i]) > 1.0e-4:\n            return False\n\n    return True\n\n\nnumbers = [2.0, 49.9]\nexpected1 = [0.0, 1.0]\nresult = rescale_to_unit(numbers)\nif not issame(result, expected1):\n    print("Assertion failed for test case 1")\n    exit(1)\n\nnumbers = [100.0, 49.9]\nexpected2 = [1.0, 0.0]\nresult = rescale_to_unit(numbers)\nif not issame(result, expected2):\n    print("Assertion failed for test case 2")\n    exit(1)\n\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nexpected3 = [0.0, 0.25, 0.5, 0.75, 1.0]\nresult = rescale_to_unit(numbers)\nif not issame(result, expected3):\n    print("Assertion failed for test case 3")\n    exit(1)\n\nnumbers = [2.0, 1.0, 5.0, 3.0, 4.0]\nexpected4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nresult = rescale_to_unit(numbers)\nif not issame(result, expected4):\n    print("Assertion failed for test case 4")\n    exit(1)\n\nnumbers = [12.0, 11.0, 15.0, 13.0, 14.0]\nexpected5 = [0.25, 0.0, 1.0, 0.5, 0.75]\nresult = rescale_to_unit(numbers)\nif not issame(result, expected5):\n    print("Assertion failed for test case 5")\n    exit(1)\n\nprint("All tests passed successfully")\n\n```\n\n### Ruby\n\n```ruby\ndef rescale_to_unit(numbers)\n    min_val = numbers.min\n    max_val = numbers.max\n    rescaled = []\n\n    numbers.each do |number|\n        rescaled.push((number - min_val) / (max_val - min_val))\n    end\n\n    return rescaled\nend\n\ndef issame(a, b)\n    if a.length != b.length\n        return false\n    end\n\n    for i in 0...a.length\n        if (a[i] - b[i]).abs > 1.0e-4\n            return false\n        end\n    end\n\n    return true\nend\n\nnumbers = [2.0, 49.9]\nexpected1 = [0.0, 1.0]\nresult = rescale_to_unit(numbers)\nif !issame(result, expected1)\n    puts "Assertion failed for test case 1"\n    exit(1)\nend\n\nnumbers = [100.0, 49.9]\nexpected2 = [1.0, 0.0]\nresult = rescale_to_unit(numbers)\nif !issame(result, expected2)\n    puts "Assertion failed for test case 2"\n    exit(1)\nend\n\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nexpected3 = [0.0, 0.25, 0.5, 0.75, 1.0]\nresult = rescale_to_unit(numbers)\nif !issame(result, expected3)\n    puts "Assertion failed for test case 3"\n    exit(1)\nend\n\nnumbers = [2.0, 1.0, 5.0, 3.0, 4.0]\nexpected4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nresult = rescale_to_unit(numbers)\nif !issame(result, expected4)\n    puts "Assertion failed for test case 4"\n    exit(1)\nend\n\nnumbers = [12.0, 
\n\n[C++]\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n\nint strlen(const char* str) {\n    return strlen(str);\n}\n\nint main() {\n    // Assertions\n    assert(strlen("") == 0);\n    assert(strlen("x") == 1);\n    assert(strlen("asdasnakj") == 9);\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\n[C]\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint strlen(const char* str) {\n    return strlen(str);\n}\n\nint main() {\n    // Assertions\n    assert(strlen("") == 0);\n    assert(strlen("x") == 1);\n    assert(strlen("asdasnakj") == 9);\n\n    printf("All assertions passed.\n");\n}\n\n[Python]\ndef strlen(str):\n    return len(str)\n\ndef run_assertions():\n    # Assertions\n    assert strlen('') == 0\n    assert strlen('x') == 1\n    assert strlen('asdasnakj') == 9\n\n    print('All assertions passed.')\n\nrun_assertions()\n\n[Ruby]\ndef strlen(str)\n    return str.length\nend\n\ndef run_assertions\n    # Assertions\n    assert strlen('') == 0\n    assert strlen('x') == 1\n    assert strlen('asdasnakj') == 9\n\n    puts 'All assertions passed.'\nend\n\nrun_assertions\n\n[PHP]\nfunction strlen($str) {\n    return strlen($str);\n}\n\nfunction run_assertions() {\n    // Assertions\n    assert(strlen('') == 0);\n    assert(strlen('x') == 1);\n    assert(strlen('asdasnakj') == 9);\n\n    echo 'All assertions passed.' . PHP_EOL;\n}\n\nrun_assertions();\n\n[Swift]\nfunc strlen(_ str: String) -> Int {\n    return str.count\n}\n\nfunc run_assertions() {\n    // Assertions\n    assert(strlen("") == 0)\n    assert(strlen("x") == 1)\n    assert(strlen("asdasnakj") == 9)\n\n    print("All assertions passed.")\n}\n\nrun_assertions()\n\n[Java]\npublic class Main {\n    public static void main(String[] args) {\n        // Assertions\n        assert strlen("").equals(0);\n        assert strlen("x").equals(1);\n        assert strlen("asdasnakj").equals(9);\n\n        System.out.println("All assertions passed.");\n    }\n\n    public static Integer strlen(String str) {\n        return str.length();\n    }\n}\n\n[C#]\nusing System;\n\npublic class Main {\n    public static void Main() {\n        // Assertions\n        assert(strlen("") == 0);\n        assert(strlen("x") == 1);\n        assert(strlen("asdasnakj") == 9);\n\n        Console.WriteLine("All assertions passed.");\n    }\n\n    public static int strlen(string str) {\n        return str.Length;\n    }\n}\n\n[Go]\npackage main\n\nimport "fmt"\n\nfunc strlen(str string) int {\n    return len(str)\n}\n\nfunc run_assertions() {\n    // Assertions\n    if strlen("") != 0 {\n        fmt.Println("Assertion failed: strlen(\"\") == 0")\n        os.Exit(1)\n    }\n\n    if strlen("x") != 1 {\n        fmt.Println("Assertion failed: strlen(\"x\") == 1")\n        os.Exit(1)\n    }\n\n    if strlen("asdasnakj") != 9 {\n        fmt.Println("Assertion failed: strlen(\"asdasnakj\") == 9")\n        os.Exit(1)\n    }\n\n    fmt.Println("All assertions passed.")\n}\n\nfunc main() {\n    run_assertions()\n}\n\n[Scala]\nobject Main {\n    def strlen(str: String): Int = str.length\n\n    def run_assertions(): Unit = {\n        // Assertions\n        assert(strlen("") == 0)\n        assert(strlen("x") == 1)\n        assert(strlen("asdasnakj") == 9)\n\n        println("All assertions passed.")\n    }\n\n    def main(args: Array[String]): Unit = {\n        run_assertions()\n    }\n}\n\n[Kotlin]\nfun strlen(str: String): Int = str.length\n\nfun run_assertions() {\n    // Assertions\n    assert(strlen("") == 0)\n    assert(strlen("x") == 1)\n    assert(strlen("asdasnakj") == 9)\n\n    println("All assertions passed.")\n}\n\nfun main(args: Array<String>) {\n    run_assertions()\n}\n\n[Rust]\nfn strlen(str: &str) -> usize {\n    str.len()\n}\n\nfn run_assertions() {\n    // Assertions\n    assert_eq!(strlen(""), 0);\n    assert_eq!(strlen("x"), 1);\n    assert_eq!(strlen("asdasnakj"), 9);\n\n    println!("All assertions passed.");\n}\n\nfn main() {\n    run_assertions();\n}\n\n[D]\nimport std.stdio;\n\nint strlen(string str) {\n    return str.length;\n}\n\nvoid run_assertions() {\n    // Assertions\n    assert(strlen("") == 0);\n    assert(strlen("x") == 1);\n    assert(strlen("asdasnakj") == 9);\n\n    writeln("All assertions passed.");\n}\n\nvoid main() {\n    run_assertions();\n}\n\n[TypeScript]\nfunction strlen(str: string): number {\n    return str.length;\n}\n\nfunction run_assertions() {\n    // Assertions\n    assert(strlen('') == 0);\n    assert(strlen('x') == 1);\n    assert(strlen('asdasnakj') == 9);\n\n    console.log('All assertions passed.');\n}\n\nrun_assertions();\n\n[Clojure]\n(defn strlen [str]\n  (count str))\n\n(defn run-assertions []\n  (let [strlen (fn [str]\n                 (count str))]\n    ;; Assertions\n    (assert (= (strlen "") 0))\n    (assert (= (strlen "x") 1))\n    (assert (= (strlen "asdasnakj") 9))\n\n    (println "All assertions passed.")))\n\n(defn -main []\n  (run-assertions))\n\n[Lua]\nfunction strlen(str)\n    return #str\nend\n\nfunction run_assertions()\n    -- Assertions\n    assert(strlen("") == 0)\n    assert(strlen("x") == 1)\n    assert(strlen("asdasnakj") == 9)\n\n    print("All assertions passed.")\nend\n\nrun_assertions()\n\n[Elixir]\ndefmodule Main do\n  def strlen(str) do\n    String.length(str)\n  end\n\n  def run_assertions do\n    # Assertions\n    assert strlen("") == 0\n    assert strlen("x") == 1\n    assert strlen("asdasnakj") == 9\n\n    IO.puts("All assertions passed.")\n  end\n\n  def main(_args) do\n    run_assertions()\n  end\nend\n\n[Julia]\nfunction strlen(str::String)\n    return length(str)\nend\n\nfunction run_assertions()\n    # Assertions\n    @assert strlen("") == 0\n    @assert strlen("x") == 1\n    @assert strlen("asdasnakj") == 9\n\n    println("All assertions passed.")\nend\n\n
\n\n[EXP]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main()\n{\n  int result;\n\n  // Test cases\n  result = largest_divisor(3);\n  if (result != 1) {\n    std::cerr << "Assertion failed: largest_divisor(3) == 1" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(7);\n  if (result != 1) {\n    std::cerr << "Assertion failed: largest_divisor(7) == 1" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(10);\n  if (result != 5) {\n    std::cerr << "Assertion failed: largest_divisor(10) == 5" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(100);\n  if (result != 50) {\n    std::cerr << "Assertion failed: largest_divisor(100) == 50" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(49);\n  if (result != 7) {\n    std::cerr << "Assertion failed: largest_divisor(49) == 7" << std::endl;\n    std::exit(1);\n  }\n\n  std::cout << "All tests passed." << std::endl;\n\n  return 0;\n}\n\nint largest_divisor(int n)\n{\n  int i;\n\n  for (i = 2; i <= std::sqrt(n); ++i) {\n    if (n % i == 0) {\n      return n / i;\n    }\n  }\n\n  return 1;\n}\n[/EXP]\n\n[SOL]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main()\n{\n  int result;\n\n  // Test cases\n  result = largest_divisor(3);\n  if (result != 1) {\n    std::cerr << "Assertion failed: largest_divisor(3) == 1" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(7);\n  if (result != 1) {\n    std::cerr << "Assertion failed: largest_divisor(7) == 1" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(10);\n  if (result != 5) {\n    std::cerr << "Assertion failed: largest_divisor(10) == 5" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(100);\n  if (result != 50) {\n    std::cerr << "Assertion failed: largest_divisor(100) == 50" << std::endl;\n    std::exit(1);\n  }\n\n  result = largest_divisor(49);\n  if (result != 7) {\n    std::cerr << "Assertion failed: largest_divisor(49) == 7" << std::endl;\n    std::exit(1);\n  }\n\n  std::cout << "All tests passed." << std::endl;\n\n  return 0;\n}\n\nint largest_divisor(int n)\n{\n  int i;\n\n  for (i = 2; i <= std::sqrt(n); ++i) {\n    if (n % i == 0) {\n      return n / i;\n    }\n  }\n\n  return 1;\n}\n[/SOL]\n\n[M]\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n[ERROR]\n[/ERROR]\n\n
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool issame(vector<int> a, vector<int> b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid factorize(int n, vector<int> &out) {\n    int m = n;\n    int count = 0;\n    out.clear();\n\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (m <= 1) break;\n        while (m % i == 0) {\n            m /= i;\n            count++;\n            out.push_back(i);\n        }\n    }\n\n    if (m > 1) {\n        count++;\n        out.push_back(m);\n    }\n}\n\nint main() {\n    vector<int> factors;\n    bool result;\n\n    factorize(2, factors);\n    result = issame(factors, vector<int>{2});\n    if (!result) {\n        cout << "Assertion failed for factorize(2)" << endl;\n        return 1;\n    }\n\n    factorize(4, factors);\n    result = issame(factors, vector<int>{2, 2});\n    if (!result) {\n        cout << "Assertion failed for factorize(4)" << endl;\n        return 1;\n    }\n\n    factorize(8, factors);\n    result = issame(factors, vector<int>{2, 2, 2});\n    if (!result) {\n        cout << "Assertion failed for factorize(8)" << endl;\n        return 1;\n    }\n\n    factorize(3 * 19, factors);\n    result = issame(factors, vector<int>{3, 19});\n    if (!result) {\n        cout << "Assertion failed for factorize(3 * 19)" << endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19, factors);\n    result = issame(factors, vector<int>{3, 3, 19, 19});\n    if (!result) {\n        cout << "Assertion failed for factorize(3 * 19 * 3 * 19)" << endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19 * 3 * 19, factors);\n    result = issame(factors, vector<int>{3, 3, 3, 19, 19, 19});\n    if (!result) {\n        cout << "Assertion failed for factorize(3 * 19 * 3 * 19 * 3 * 19)" << endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 19 * 19, factors);\n    result = issame(factors, vector<int>{3, 19, 19, 19});\n    if (!result) {\n        cout << "Assertion failed for factorize(3 * 19 * 19 * 19)" << endl;\n        return 1;\n    }\n\n    factorize(3 * 2 * 3, factors);\n    result = issame(factors, vector<int>{2, 3, 3});\n    if (!result) {\n        cout << "Assertion failed for factorize(3 * 2 * 3)" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <math.h>\n\nbool issame(int *a, int *b, int size) {\n    int i;\n    for (i = 0; i < size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid factorize(int n, int *out, int *size) {\n    int m = n;\n    int count = 0;\n    *size = 0;\n\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (m <= 1) break;\n        while (m % i == 0) {\n            m /= i;\n            count++;\n            out[*size] = i;\n            *size = *size + 1;\n        }\n    }\n\n    if (m > 1) {\n        count++;\n        out[*size] = m;\n        *size = *size + 1;\n    }\n}\n\nint main() {\n    int factors[100];\n    int size;\n    bool result;\n\n    factorize(2, factors, &size);\n    result = issame(factors, (int[]){2}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(2)\n");\n        return 1;\n    }\n\n    factorize(4, factors, &size);\n    result = issame(factors, (int[]){2, 2}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(4)\n");\n        return 1;\n    }\n\n    factorize(8, factors, &size);\n    result = issame(factors, (int[]){2, 2, 2}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(8)\n");\n        return 1;\n    }\n\n    factorize(3 * 19, factors, &size);\n    result = issame(factors, (int[]){3, 19}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(3 * 19)\n");\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19, factors, &size);\n    result = issame(factors, (int[]){3, 3, 19, 19}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(3 * 19 * 3 * 19)\n");\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19 * 3 * 19, factors, &size);\n    result = issame(factors, (int[]){3, 3, 3, 19, 19, 19}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(3 * 19 * 3 * 19 * 3 * 19)\n");\n        return 1;\n    }\n\n    factorize(3 * 19 * 19 * 19, factors, &size);\n    result = issame(factors, (int[]){3, 19, 19, 19}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(3 * 19 * 19 * 19)\n");\n        return 1;\n    }\n\n    factorize(3 * 2 * 3, factors, &size);\n    result = issame(factors, (int[]){2, 3, 3}, size);\n    if (!result) {\n        printf("Assertion failed for factorize(3 * 2 * 3)\n");\n        return 1;\n    }\n\n    return 0;\n}\n\n[Python]\ndef issame(a, b):\n    return a == b\n\ndef factorize(n):\n    m = n\n    factors = []\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if m <= 1:\n            break\n        while m % i == 0:\n            m //= i\n            factors.append(i)\n\n    if m > 1:\n        factors.append(m)\n\n    return factors\n\ndef main():\n    assert issame(factorize(2), [2])\n    assert issame(factorize(4), [2, 2])\n    assert issame(factorize(8), [2, 2, 2])\n   
\n\n[INST] Translate this Fortran code to C++: \nprogram remove_duplicates_program\n    implicit none\n    integer, dimension(:), allocatable :: numbers, result\n    integer :: i\n    integer, dimension(0) :: empty_array\n\n    ! Test cases\n    call assert(issame(remove_duplicates([1, 2, 3, 4]), [1, 2, 3, 4]))\n    call assert(issame(remove_duplicates([1, 2, 3, 2, 4, 3, 5]), [1, 4, 5]))\n    call assert(issame(remove_duplicates(empty_array), empty_array))\n\ncontains\n\n    function remove_duplicates(numbers) result(out)\n        integer, dimension(:), intent(in) :: numbers\n        integer, dimension(:), allocatable :: out\n        integer, dimension(:), allocatable :: has1, has2\n        integer :: i, j, num\n        logical :: found\n\n        allocate(has1(0))\n        allocate(has2(0))\n        allocate(out(0))\n\n        if (size(numbers) == 0) return\n\n        do i = 1, size(numbers)\n            num = numbers(i)\n            found = .false.\n            do j = 1, size(has2)\n                if (has2(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) cycle\n\n            found = .false.\n            do j = 1, size(has1)\n                if (has1(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                call append(has2, num)\n            else\n                call append(has1, num)\n            end if\n        end do\n\n        do i = 1, size(numbers)\n            num = numbers(i)\n            found = .false.\n            do j = 1, size(has2)\n                if (has2(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                call append(out, num)\n            end if\n        end do\n    end function remove_duplicates\n\n    subroutine append(array, value)\n        integer, dimension(:), allocatable, intent(inout) :: array\n        integer, intent(in) :: value\n        integer, dimension(:), allocatable :: temp\n\n        allocate(temp(size(array) + 1))\n        temp(1:size(array)) = array\n        temp(size(array) + 1) = value\n        deallocate(array)\n        allocate(array(size(temp)))\n        array = temp\n    end subroutine append\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                exit\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program remove_duplicates_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram remove_duplicates_program\n    implicit none\n    integer, dimension(:), allocatable :: numbers, result\n    integer :: i\n    integer, dimension(0) :: empty_array\n\n    ! Test cases\n    call assert(issame(remove_duplicates([1, 2, 3, 4]), [1, 2, 3, 4]))\n    call assert(issame(remove_duplicates([1, 2, 3, 2, 4, 3, 5]), [1, 4, 5]))\n    call assert(issame(remove_duplicates(empty_array), empty_array))\n\ncontains\n\n    function remove_duplicates(numbers) result(out)\n        integer, dimension(:), intent(in) :: numbers\n        integer, dimension(:), allocatable :: out\n        integer, dimension(:), allocatable :: has1, has2\n        integer :: i, j, num\n        logical :: found\n\n        allocate(has1(0))\n        allocate(has2(0))\n        allocate(out(0))\n\n        if (size(numbers) == 0) return\n\n        do i = 1, size(numbers)\n            num = numbers(i)\n            found = .false.\n            do j = 1, size(has2)\n                if (has2(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) cycle\n\n            found = .false.\n            do j = 1, size(has1)\n                if (has1(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                call append(has2, num)\n            else\n                call append(has1, num)\n            end if\n        end do\n\n        do i = 1, size(numbers)\n            num = numbers(i)\n            found = .false.\n            do j = 1, size(has2)\n                if (has2(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                call append(out, num)\n            end if\n        end do\n    end function remove_duplicates\n\n    subroutine append(array, value)\n        integer, dimension(:), allocatable, intent(inout) :: array\n        integer, intent(in) :: value\n        integer, dimension(:), allocatable :: temp\n\n        allocate(temp(size(array) + 1))\n        temp(1:size(array)) = array\n        temp(size(array) + 1) = value\n        deallocate(array)\n        allocate(array(size(temp)))\n        array = temp\n    end subroutine append\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                exit\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program remove_duplicates_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram remove_duplicates_program\n    implicit none\n    integer, dimension(:), allocatable :: numbers, result\n    integer :: i\n    integer, dimension(0) :: empty_array\n\n    ! Test cases\n    call assert(issame(remove_duplicates([1, 2, 3, 4]), [1, 2, 3, 4]))\n    call assert(issame(remove_duplicates([1, 2, 3, 2, 4, 3, 5]), [1, 4, 5]))\n    call assert(issame(remove_duplicates(empty_array), empty_array))\n\ncontains\n\n    function remove_duplicates(numbers) result(out)\n        integer, dimension(:), intent(in) :: numbers\n        integer, dimension(:), allocatable :: out\n        integer, dimension(:), allocatable :: has1, has2\n        integer :: i, j, num\n        logical :: found\n\n        allocate(has1(0))\n        allocate(has2(0))\n        allocate(out(0))\n\n        if (size(numbers) == 
\n\n[CPP]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring flip_case(string str) {\n    string result;\n    for (int i = 0; i < str.length(); i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w = w - 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w = w + 32;\n        }\n        result += w;\n    }\n    return result;\n}\n\nint main() {\n    assert(flip_case("") == "");\n    assert(flip_case("Hello!") == "hELLO!");\n    assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n    return 0;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n[/CPP]\n\n[PY]\ndef flip_case(str):\n    result = ""\n    for w in str:\n        if w >= 'a' and w <= 'z':\n            w = chr(ord(w) - 32)\n        elif w >= 'A' and w <= 'Z':\n            w = chr(ord(w) + 32)\n        result += w\n    return result\n\nassert(flip_case("") == "")\nassert(flip_case("Hello!") == "hELLO!")\nassert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")\n[/PY]\n\n[JAVA]\npublic class FlipCase {\n    public static String flipCase(String str) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            char w = str.charAt(i);\n            if (w >= 'a' && w <= 'z') {\n                w = (char) (w - 32);\n            } else if (w >= 'A' && w <= 'Z') {\n                w = (char) (w + 32);\n            }\n            result.append(w);\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        assert(flipCase("").equals(""));\n        assert(flipCase("Hello!").equals("hELLO!"));\n        assert(flipCase("These violent delights have violent ends").equals("tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"));\n    }\n\n    public static void assert(boolean condition) {\n        if (!condition) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n    }\n}\n[/JAVA]\n\n[RUBY]\ndef flip_case(str)\n    result = ""\n    str.each_char do |w|\n        if w >= 'a' and w <= 'z'\n            w = w.ord - 32\n        elsif w >= 'A' and w <= 'Z'\n            w = w.ord + 32\n        end\n        result << w\n    end\n    result\nend\n\nassert(flip_case("") == "")\nassert(flip_case("Hello!") == "hELLO!")\nassert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")\n[/RUBY]\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *flip_case(char *str) {\n    char *result = malloc(strlen(str) + 1);\n    for (int i = 0; i < strlen(str); i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w = w - 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w = w + 32;\n        }\n        result[i] = w;\n    }\n    result[strlen(str)] = '\0';\n    return result;\n}\n\nint main() {\n    assert(strcmp(flip_case(""), "") == 0);\n    assert(strcmp(flip_case("Hello!"), "hELLO!") == 0);\n    assert(strcmp(flip_case("These violent delights have violent ends"), "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS") == 0);\n    return 0;\n}\n\nvoid assert(int condition) {\n    if (!condition) {\n        printf("Assertion failed\n");\n        exit(1);\n    }\n}\n[/C]\n\n[C#]\nusing System;\n\npublic class Program {\n    public static string FlipCase(string str) {\n        string result = "";\n        for (int i = 0; i < str.Length; i++) {\n            char w = str[i];\n            if (w >= 'a' && w <= 'z') {\n                w = (char) (w - 32);\n            } else if (w >= 'A' && w <= 'Z') {\n                w = (char) (w + 32);\n            }\n            result += w;\n        }\n        return result;\n    }\n\n    public static void Main() {\n        Assert(FlipCase("") == "");\n        Assert(FlipCase("Hello!") == "hELLO!");\n        Assert(FlipCase("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n    }\n\n    public static void Assert(bool condition) {\n        if (!condition) {\n            Console.WriteLine("Assertion failed");\n            Environment.Exit(1);\n        }\n    }\n}\n[/C#]\n\n[PHP]\nfunction flip_case($str) {\n    $result = "";\n    for ($i = 0; $i < strlen($str); $i++) {\n        $w = $str[$i];\n        if ($w >= 'a' && $w <= 'z') {\n            $w = chr(ord($w) - 32);\n        } else if ($w >= 'A' && $w <= 'Z') {\n            $w = chr(ord($w) + 32);\n        }\n        $result .= $w;\n    }\n    return $result;\n}\n\nassert(flip_case("") == "");\nassert(flip_case("Hello!") == "hELLO!");\nassert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n[/PHP]\n\n[GO]\npackage main\n\nimport (\n    "fmt"\n    "strings"\n)\n\nfunc flipCase(str string) string {\n    result := ""\n    for _, w := range strings.Split(str, "") {\n        if w >= "a" && w <= "z" {\n            w = string([]rune(w)[0] - 32)\n        } else if w >= "A" && w <= "Z" {\n            w = string([]rune(w)[0] + 32)\n        }\n        result += w\n    }\n    return result\n}\n\nfunc main() {\n    assert(flipCase("") == "")\n    assert(flipCase("Hello!") == "hELLO!")\n    assert(flipCase("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")\n}\n\nfunc assert(condition bool) {\n    if !condition {\n        fmt.Println("Assertion failed")\n        os.Exit(1)\n    }\n}\n[/GO]\n\n[MATLAB]\nfunction result = flip_case(str)\n    result = '';\n    for i = 1:length(str)\n        w = str(i
\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test with an empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = concatenate(strings)\n    if (result /= "") then\n        write(*,*) "Assertion failed: concatenate([]) /= ''"\n        call exit(1)\n    end if\n\n    ! Test with an array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(3))\n    strings = ["x", "y", "z"]\n    result = concatenate(strings)\n    if (result /= "xyz") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'"\n        call exit(1)\n    end if\n\n    ! Test with a larger array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(5))\n    strings = ["x", "y", "z", "w", "k"]\n    result = concatenate(strings)\n    if (result /= "xyzwk") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'"\n        call exit(1)\n    end if\n\ncontains\n\n    function concatenate(strings) result(out)\n        character(len=10), dimension(:), intent(in) :: strings\n        character(len=:), allocatable :: out\n        integer :: i\n\n        if (size(strings) == 0) then\n            out = ""\n        else\n            out = ""\n            do i = 1, size(strings)\n                out = out // trim(strings(i))\n            end do\n        end if\n    end function concatenate\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test with an empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = concatenate(strings)\n    if (result /= "") then\n        write(*,*) "Assertion failed: concatenate([]) /= ''"\n        call exit(1)\n    end if\n\n    ! Test with an array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(3))\n    strings = ["x", "y", "z"]\n    result = concatenate(strings)\n    if (result /= "xyz") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'"\n        call exit(1)\n    end if\n\n    ! Test with a larger array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(5))\n    strings = ["x", "y", "z", "w", "k"]\n    result = concatenate(strings)\n    if (result /= "xyzwk") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'"\n        call exit(1)\n    end if\n\ncontains\n\n    function concatenate(strings) result(out)\n        character(len=10), dimension(:), intent(in) :: strings\n        character(len=:), allocatable :: out\n        integer :: i\n\n        if (size(strings) == 0) then\n            out = ""\n        else\n            out = ""\n            do i = 1, size(strings)\n                out = out // trim(strings(i))\n            end do\n        end if\n    end function concatenate\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test with an empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = concatenate(strings)\n    if (result /= "") then\n        write(*,*) "Assertion failed: concatenate([]) /= ''"\n        call exit(1)\n    end if\n\n    ! Test with an array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(3))\n    strings = ["x", "y", "z"]\n    result = concatenate(strings)\n    if (result /= "xyz") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'"\n        call exit(1)\n    end if\n\n    ! Test with a larger array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(5))\n    strings = ["x", "y", "z", "w", "k"]\n    result = concatenate(strings)\n    if (result /= "xyzwk") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'"\n        call exit(1)\n    end if\n\ncontains\n\n    function concatenate(strings) result(out)\n        character(len=10), dimension(:), intent(in) :: strings\n        character(len=:), allocatable :: out\n        integer :: i\n\n        if (size(strings) == 0) then\n            out = ""\n        else\n            out = ""\n            do i = 1, size(strings)\n                out = out // trim(strings(i))\n            end do\n        end if\n    end function concatenate\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test with an empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = concatenate(strings)\n    if (result /= "") then\n        write(*,*) "Assertion failed: concatenate([]) /= ''"\n        call exit(1)\n    end if\n\n    ! Test with an array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(3))\n    strings = ["x", "y", "z"]\n    result = concatenate(strings)\n    if (result /= "xyz") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'"\n        call exit(1)\n    end if\n\n    ! Test with a larger array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(5))\n    strings = ["x", "y", "z", "w", "k"]\n    result = concatenate(strings)\n    if (result /= "xyzwk") then\n        write(*,*) "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'"\n        call exit(1)\n    end if\n\ncontains\n\n    function concatenate(strings) result(out)\n        character(len=10), dimension(:), intent(in) :: strings\n        character(len=:), allocatable :: out\n        integer :: i\n\n        if (size(strings) == 0) then\n            out = ""\n        else\n            out = ""\n            do i = 1, size(strings)\n                out = out // trim(strings(i))\n            end do\n        end if\n    end function concatenate\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test with an empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = concatenate(strings)\n    if (result /= "") then\n        write(*,*) "Assertion failed: concatenate([]) /= ''"\n        call exit
\n\n[CPP]\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> out;\n    for (string s : strings) {\n        if (s.substr(0, prefix.length()) == prefix) {\n            out.push_back(s);\n        }\n    }\n    return out;\n}\n\nint main() {\n    vector<string> strings;\n    string prefix;\n    vector<string> result;\n\n    // Test case 1\n    result = filter_by_prefix(strings, prefix);\n    if (result != strings) {\n        cout << "Assertion failed: filter_by_prefix({}, 'john')" << endl;\n        return 1;\n    }\n\n    // Test case 2\n    strings = {"xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "};\n    prefix = "xxx";\n    result = filter_by_prefix(strings, prefix);\n    vector<string> expected = {"xxx     ", "xxxAAA  ", "xxx     "};\n    if (result != expected) {\n        cout << "Assertion failed: filter_by_prefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')" << endl;\n        return 1;\n    }\n\n    return 0;\n} [/CPP]\n\n[PYTHON]\ndef filter_by_prefix(strings, prefix):\n    return [s for s in strings if s.startswith(prefix)]\n\n\ndef test_cases():\n    # Test case 1\n    strings = []\n    prefix = ""\n    result = filter_by_prefix(strings, prefix)\n    expected = []\n    assert result == expected\n\n    # Test case 2\n    strings = ["xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "]\n    prefix = "xxx"\n    result = filter_by_prefix(strings, prefix)\n    expected = ["xxx     ", "xxxAAA  ", "xxx     "]\n    assert result == expected\n\n\nif __name__ == "__main__":\n    test_cases()\n[/PYTHON]\n\n[JAVA]\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static List<String> filterByPrefix(List<String> strings, String prefix) {\n        List<String> out = new ArrayList<>();\n        for (String s : strings) {\n            if (s.startsWith(prefix)) {\n                out.add(s);\n            }\n        }\n        return out;\n    }\n\n    public static void main(String[] args) {\n        // Test case 1\n        List<String> strings = new ArrayList<>();\n        String prefix = "";\n        List<String> result = filterByPrefix(strings, prefix);\n        List<String> expected = new ArrayList<>();\n        assert result.equals(expected);\n\n        // Test case 2\n        strings = Arrays.asList("xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     ");\n        prefix = "xxx";\n        result = filterByPrefix(strings, prefix);\n        expected = Arrays.asList("xxx     ", "xxxAAA  ", "xxx     ");\n        assert result.equals(expected);\n    }\n} [/JAVA]\n\n[C#]\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n    public static List<string> FilterByPrefix(List<string> strings, string prefix) {\n        List<string> out = new List<string>();\n        foreach (string s in strings) {\n            if (s.StartsWith(prefix)) {\n                out.Add(s);\n            }\n        }\n        return out;\n    }\n\n    public static void Main() {\n        // Test case 1\n        List<string> strings = new List<string>();\n        string prefix = "";\n        List<string> result = FilterByPrefix(strings, prefix);\n        List<string> expected = new List<string>();\n        if (result.Count != expected.Count) {\n            Console.WriteLine("Assertion failed: FilterByPrefix({}, 'john')");\n            Environment.Exit(1);\n        }\n\n        // Test case 2\n        strings = new List<string> { "xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     " };\n        prefix = "xxx";\n        result = FilterByPrefix(strings, prefix);\n        expected = new List<string> { "xxx     ", "xxxAAA  ", "xxx     " };\n        if (result.Count != expected.Count) {\n            Console.WriteLine("Assertion failed: FilterByPrefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')");\n            Environment.Exit(1);\n        }\n    }\n} [/C#]\n\n[GO]\npackage main\n\nimport (\n    "fmt"\n    "strings"\n)\n\nfunc filterByPrefix(strings []string, prefix string) []string {\n    out := []string{}\n    for _, s := range strings {\n        if strings.HasPrefix(s, prefix) {\n            out = append(out, s)\n        }\n    }\n    return out\n}\n\nfunc main() {\n    // Test case 1\n    strings := []string{}\n    prefix := ""\n    result := filterByPrefix(strings, prefix)\n    expected := []string{}\n    if len(result) != len(expected) {\n        fmt.Println("Assertion failed: filterByPrefix({}, 'john')")\n        return\n    }\n\n    // Test case 2\n    strings = []string{"xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "}\n    prefix = "xxx"\n    result = filterByPrefix(strings, prefix)\n    expected = []string{"xxx     ", "xxxAAA  ", "xxx     "}\n    if len(result) != len(expected) {\n        fmt.Println("Assertion failed: filterByPrefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')")\n        return\n    }\n} [/GO]\n\n[PHP]\nfunction filterByPrefix($strings, $prefix) {\n    $out = [];\n    foreach ($strings as $s) {\n        if (strpos($s, $prefix) === 0) {\n            $out[] = $s;\n        }\n    }\n    return $out;\n}\n\nfunction testCases() {\n    // Test case 1\n    $strings = [];\n    $prefix = "";\n    $result = filterByPrefix($strings, $prefix);\n    $expected = [];\n    if ($result != $expected) {\n        echo "Assertion failed: filterByPrefix({}, 'john')";\n        exit(1);\n    }\n\n    // Test case 2\n    $strings = ["xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "];\n    $prefix = "xxx";\n    $result = filterByPrefix($strings, $prefix);\n    $expected = ["xxx     ", "xxxAAA  ", "xxx     "];\n    if ($result != $expected) {\n        echo "Assertion failed: filterByPrefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')";\n        exit(1);\n    }\n}\n\ntestCases(); [/PHP]\n\n[RUBY]\ndef filter_by_prefix(strings, prefix)\n    out = []\n    strings.each do |s|\n        if s.start_with?(prefix)\n            out.push(s)\n        end\n    end\n    out\nend\n\ndef test_cases\n    # Test case 1\n    strings = []\n    prefix = ""\n    result = filter_by_prefix(strings, prefix)\n    expected = []\n    assert_equal(result, expected)\n\n    # Test case 2\n    strings = ["xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "
\n\n[CPP]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<double> get_positive(vector<double> l) {\n    vector<double> out;\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] > 0.0) {\n            out.push_back(l[i]);\n        }\n    }\n    return out;\n}\n\nbool issame(vector<double> a, vector<double> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (abs(a[i] - b[i]) > 1.0e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    vector<double> input = {-1.0, -2.0, 4.0, 5.0, 6.0};\n    vector<double> expected = {4.0, 5.0, 6.0};\n    vector<double> result = get_positive(input);\n    bool is_same = issame(result, expected);\n    if (!is_same) {\n        cout << "Test case 1: assertion failed" << endl;\n        return 1;\n    }\n\n    input = {5.0, 3.0, -5.0, 2.0, 3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    expected = {5.0, 3.0, 2.0, 3.0, 3.0, 9.0, 123.0, 1.0};\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        cout << "Test case 2: assertion failed" << endl;\n        return 1;\n    }\n\n    input = {-1.0, -2.0};\n    expected.clear();\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        cout << "Test case 3: assertion failed" << endl;\n        return 1;\n    }\n\n    input.clear();\n    expected.clear();\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        cout << "Test case 4: assertion failed" << endl;\n        return 1;\n    }\n\n    cout << "All tests passed" << endl;\n    return 0;\n} [/CPP]\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_SIZE 1000\n\ndouble *get_positive(double *l, int size) {\n    double *out = malloc(size * sizeof(double));\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (l[i] > 0.0) {\n            out[count] = l[i];\n            count++;\n        }\n    }\n    return out;\n}\n\nbool issame(double *a, double *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1.0e-4) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    double input[] = {-1.0, -2.0, 4.0, 5.0, 6.0};\n    double expected[] = {4.0, 5.0, 6.0};\n    double *result = get_positive(input, 5);\n    bool is_same = issame(result, expected, 3);\n    if (!is_same) {\n        printf("Test case 1: assertion failed\n");\n        return 1;\n    }\n\n    double input2[] = {5.0, 3.0, -5.0, 2.0, 3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    double expected2[] = {5.0, 3.0, 2.0, 3.0, 3.0, 9.0, 123.0, 1.0};\n    double *result2 = get_positive(input2, 11);\n    is_same = issame(result2, expected2, 8);\n    if (!is_same) {\n        printf("Test case 2: assertion failed\n");\n        return 1;\n    }\n\n    double input3[] = {-1.0, -2.0};\n    double *expected3 = malloc(0);\n    double *result3 = get_positive(input3, 2);\n    is_same = issame(result3, expected3, 0);\n    if (!is_same) {\n        printf("Test case 3: assertion failed\n");\n        return 1;\n    }\n\n    double *input4 = malloc(0);\n    double *expected4 = malloc(0);\n    double *result4 = get_positive(input4, 0);\n    is_same = issame(result4, expected4, 0);\n    if (!is_same) {\n        printf("Test case 4: assertion failed\n");\n        return 1;\n    }\n\n    printf("All tests passed\n");\n    return 0;\n} [/C]\n\n[JAVA]\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static double[] getPositive(double[] l) {\n        List<Double> out = new ArrayList<>();\n        for (double v : l) {\n            if (v > 0.0) {\n                out.add(v);\n            }\n        }\n        double[] result = new double[out.size()];\n        for (int i = 0; i < out.size(); i++) {\n            result[i] = out.get(i);\n        }\n        return result;\n    }\n\n    public static boolean isSame(double[] a, double[] b) {\n        if (a.length != b.length) {\n            return false;\n        }\n\n        for (int i = 0; i < a.length; i++) {\n            if (Math.abs(a[i] - b[i]) > 1.0e-4) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        double[] input = {-1.0, -2.0, 4.0, 5.0, 6.0};\n        double[] expected = {4.0, 5.0, 6.0};\n        double[] result = getPositive(input);\n        boolean isSame = isSame(result, expected);\n        if (!isSame) {\n            System.out.println("Test case 1: assertion failed");\n            System.exit(1);\n        }\n\n        input = new double[] {5.0, 3.0, -5.0, 2.0, 3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n        expected = new double[] {5.0, 3.0, 2.0, 3.0, 3.0, 9.0, 123.0, 1.0};\n        result = getPositive(input);\n        isSame = isSame(result, expected);\n        if (!isSame) {\n            System.out.println("Test case 2: assertion failed");\n            System.exit(1);\n        }\n\n        input = new double[] {-1.0, -2.0};\n        expected = new double[] {};\n        result = getPositive(input);\n        isSame = isSame(result, expected);\n        if (!isSame) {\n            System
\n\n[SOLUTION]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nbool is_prime(int n) {\n  if (n < 2) {\n    return false;\n  }\n\n  for (int i = 2; i <= std::sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nint main() {\n  if (!is_prime(6)) {\n    std::cout << "Assertion failed: is_prime(6) == false" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(101)) {\n    std::cout << "Assertion failed: is_prime(101) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(11)) {\n    std::cout << "Assertion failed: is_prime(11) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(13441)) {\n    std::cout << "Assertion failed: is_prime(13441) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(61)) {\n    std::cout << "Assertion failed: is_prime(61) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(4)) {\n    std::cout << "Assertion failed: is_prime(4) == false" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(1)) {\n    std::cout << "Assertion failed: is_prime(1) == false" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(5)) {\n    std::cout << "Assertion failed: is_prime(5) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(11)) {\n    std::cout << "Assertion failed: is_prime(11) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(17)) {\n    std::cout << "Assertion failed: is_prime(17) == true" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(5 * 17)) {\n    std::cout << "Assertion failed: is_prime(5 * 17) == false" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(11 * 7)) {\n    std::cout << "Assertion failed: is_prime(11 * 7) == false" << std::endl;\n    std::exit(1);\n  }\n\n  if (!is_prime(13441 * 19)) {\n    std::cout << "Assertion failed: is_prime(13441 * 19) == false" << std::endl;\n    std::exit(1);\n  }\n\n  std::cout << "All assertions passed." << std::endl;\n}\n[/SOLUTION]\n\n[CHECK]\n\n[/CHECK]\n\n[META]\nname = Prime Check\nfunction = is_prime\n[/META]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[INPUT]\n\n[/INPUT]\n\n[OUTPUT]\n\n[/OUTPUT]\n\n[SOLUTION]\n\n[/SOLUTION]\n\n[/PROBLEM]\n\n[PROBLEM]\n\n[DESCRIPTION]\n\n[/DESCRIPTION]\n\n[
\n\n[C++]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\n// Define the poly function\ndouble poly(const std::vector<double>& xs, int n, double x) {\n    double sum = 0.0;\n    for (int i = 1; i <= n; ++i) {\n        sum += xs[i - 1] * pow(x, i - 1);\n    }\n    return sum;\n}\n\n// Define the find_zero function\ndouble find_zero(const std::vector<double>& xs, int n) {\n    double ans = 0.0;\n    double value = poly(xs, n, ans);\n    while (std::abs(value) > 1e-6) {\n        double driv = 0.0;\n        for (int i = 2; i <= n; ++i) {\n            driv += xs[i - 1] * (i - 1) * pow(ans, i - 2);\n        }\n        ans -= value / driv;\n        value = poly(xs, n, ans);\n    }\n    return ans;\n}\n\nint main() {\n    srand(time(NULL));\n    for (int i = 0; i < 100; ++i) {\n        int ncoeff = 2 * (1 + rand() % 4);\n        std::vector<double> coeffs(ncoeff);\n        for (int j = 0; j < ncoeff; ++j) {\n            coeffs[j] = -10 + rand() % 21;\n            if (coeffs[j] == 0) coeffs[j] = 1;\n        }\n\n        double solution = find_zero(coeffs, ncoeff);\n        if (std::abs(poly(coeffs, ncoeff, solution)) >= 1e-3) {\n            std::cout << "Assertion failed: abs(poly(coeffs, solution)) < 1e-3"\n                      << std::endl;\n            return 1;\n        }\n    }\n    return 0;\n}\n```\n\n### 1.2.2. 循环展开\n\n循环展开是指将循环体中的代码复制到循环体外，然后将循环变量的值替换为循环变量的初始值、末尾值和步长，从而消除循环。\n\n循环展开的优点是可以消除循环，从而提高程序的执行效率。\n\n循环展开的缺点是程序变得复杂，增加了代码量。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n### 1.2.3. 循环展开的替代方法\n\n循环展开的替代方法是使用编译器提供的循环展开功能。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n### 1.2.4. 循环展开的替代方法\n\n循环展开的替代方法是使用编译器提供的循环展开功能。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n### 1.2.5. 循环展开的替代方法\n\n循环展开的替代方法是使用编译器提供的循环展开功能。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n### 1.2.6. 循环展开的替代方法\n\n循环展开的替代方法是使用编译器提供的循环展开功能。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n### 1.2.7. 循环展开的替代方法\n\n循环展开的替代方法是使用编译器提供的循环展开功能。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n### 1.2.8. 循环展开的替代方法\n\n循环展开的替代方法是使用编译器提供的循环展开功能。\n\n```\n[C]\nvoid sum_array(int n, double *a, double *b) {\n    int i;\n    for (i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n\n[C++]\nvoid sum_array(int n, double *a, double *b) {\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i] + b[i];\n    }\n}\n```\n\n###
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid sort_third(vector<int> &l) {\n    vector<int> third;\n    vector<int> out;\n    int i, n, temp;\n\n    n = l.size();\n    third.resize((n + 2) / 3);\n    out.resize(n);\n\n    // Extract every third element\n    for (i = 0; i < third.size(); i++) {\n        third[i] = l[i * 3];\n    }\n\n    // Sort the third array\n    sort(third.begin(), third.end());\n\n    // Reconstruct the output array\n    for (i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    l = out;\n}\n\nint main() {\n    vector<int> l;\n    vector<int> sorted_l;\n    int i;\n\n    l = {1, 2, 3};\n    sort_third(l);\n    sorted_l = {1, 2, 3};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    l = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    sort_third(l);\n    sorted_l = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    l = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    sort_third(l);\n    sorted_l = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    l = {5, 6, 3, 4, 8, 9, 2};\n    sort_third(l);\n    sorted_l = {2, 6, 3, 4, 8, 9, 5};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    l = {5, 8, 3, 4, 6, 9, 2};\n    sort_third(l);\n    sorted_l = {2, 8, 3, 4, 6, 9, 5};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    l = {5, 6, 9, 4, 8, 3, 2};\n    sort_third(l);\n    sorted_l = {2, 6, 9, 4, 8, 3, 5};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    l = {5, 6, 3, 4, 8, 9, 2, 1};\n    sort_third(l);\n    sorted_l = {2, 6, 3, 4, 8, 9, 5, 1};\n    if (l != sorted_l) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### 1.3.1.1. 循环\n\n```\n[Fortran]\ndo i = 1, 10\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    cout << i << endl;\n}\n```\n\n### 1.3.1.2. 条件语句\n\n```\n[Fortran]\nif (i == 1) then\n    print *, "i is 1"\nelse if (i == 2) then\n    print *, "i is 2"\nelse\n    print *, "i is neither 1 nor 2"\nend if\n\n[C++]\nif (i == 1) {\n    cout << "i is 1" << endl;\n} else if (i == 2) {\n    cout << "i is 2" << endl;\n} else {\n    cout << "i is neither 1 nor 2" << endl;\n}\n```\n\n### 1.3.1.3. 函数\n\n```\n[Fortran]\nfunction sort_third(l) result(out)\n    implicit none\n    integer, intent(in) :: l(:)\n    integer, allocatable :: third(:), out(:)\n    integer :: i, n, temp\n\n    n = size(l)\n    allocate(third((n + 2) / 3))\n    allocate(out(n))\n\n    ! Extract every third element\n    do i = 1, size(third)\n        third(i) = l((i - 1) * 3 + 1)\n    end do\n\n    ! Sort the third array\n    call sort_array(third)\n\n    ! Reconstruct the output array\n    do i = 1, n\n        if (mod(i - 1, 3) == 0) then\n            out(i) = third((i - 1) / 3 + 1)\n        else\n            out(i) = l(i)\n        end if\n    end do\nend function sort_third\n\n[C++]\nvector<int> sort_third(vector<int> &l) {\n    vector<int> third;\n    vector<int> out;\n    int i, n, temp;\n\n    n = l.size();\n    third.resize((n + 2) / 3);\n    out.resize(n);\n\n    // Extract every third element\n    for (i = 0; i < third.size(); i++) {\n        third[i] = l[i * 3];\n    }\n\n    // Sort the third array\n    sort(third.begin(), third.end());\n\n    // Reconstruct the output array\n    for (i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n```\n\n### 1.3.1.4. 子程序\n\n```\n[Fortran]\nsubroutine sort_array(arr)\n    implicit none\n    integer, intent(inout) :: arr(:)\n    integer :: i, j, temp\n\n    do i = 1, size(arr) - 1\n        do j = i + 1, size(arr)\n            if (arr(i) > arr(j)) then\n                temp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n            end if\n        end do\n    end do\nend subroutine sort_array\n\n[C++]\nvoid sort_array(vector<int> &arr) {\n    int i, j, temp;\n\n    for (i = 0; i < arr.size() - 1; i++) {\n        for (j = i + 1; j < arr.size(); j++) {\n            if (arr[i] > arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}\n```\n\n### 1.3.1.5. 数组\n\n```\n[Fortran]\ninteger, allocatable :: l(:), sorted_l(:)\ninteger :: i\n\n[C++]\nvector<int
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    std::vector<int> expected = {0, 2, 3, 5, 9, 123};\n    std::vector<int> result;\n    bool is_same;\n\n    // Call the unique function\n    unique(input, result);\n\n    // Check if the result is the same as expected\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cout << "Assertion failed: result is not as expected" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\nvoid unique(const std::vector<int>& l, std::vector<int>& out) {\n    std::vector<int> temp;\n    int count = 0;\n\n    // Remove duplicates\n    for (int i = 0; i < l.size(); i++) {\n        if (std::find(temp.begin(), temp.end(), l[i]) == temp.end()) {\n            count++;\n            temp.push_back(l[i]);\n        }\n    }\n\n    // Allocate output array with the correct size\n    out.resize(count);\n    out = temp;\n\n    // Sort the output array\n    std::sort(out.begin(), out.end());\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare_int(const void *a, const void *b) {\n    return *(const int *)a - *(const int *)b;\n}\n\nbool issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint *unique(int *l, int size, int *out_size) {\n    int *temp = malloc(sizeof(int) * size);\n    int count = 0;\n\n    // Remove duplicates\n    for (int i = 0; i < size; i++) {\n        if (!contains(temp, count, l[i])) {\n            count++;\n            temp[count - 1] = l[i];\n        }\n    }\n\n    // Allocate output array with the correct size\n    *out_size = count;\n    int *out = malloc(sizeof(int) * count);\n    memcpy(out, temp, sizeof(int) * count);\n\n    // Sort the output array\n    qsort(out, count, sizeof(int), compare_int);\n\n    return out;\n}\n\nbool contains(int *arr, int size, int value) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == value) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int input[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected[] = {0, 2, 3, 5, 9, 123};\n    int *result;\n    int result_size;\n    bool is_same;\n\n    // Call the unique function\n    result = unique(input, sizeof(input) / sizeof(int), &result_size);\n\n    // Check if the result is the same as expected\n    is_same = issame(result, expected, result_size);\n    if (!is_same) {\n        printf("Assertion failed: result is not as expected\n");\n        return 1;\n    }\n\n    return 0;\n}\n\n[Python]\ndef unique(l):\n    temp = []\n    count = 0\n\n    # Remove duplicates\n    for i in l:\n        if i not in temp:\n            count += 1\n            temp.append(i)\n\n    # Allocate output array with the correct size\n    out = [0] * count\n    for i in range(count):\n        out[i] = temp[i]\n\n    # Sort the output array\n    out.sort()\n    return out\n\ndef issame(a, b):\n    if len(a) != len(b):\n        return False\n\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            return False\n\n    return True\n\ndef main():\n    input = [5, 3, 5, 2, 3, 3, 9, 0, 123]\n    expected = [0, 2, 3, 5, 9, 123]\n    result = unique(input)\n\n    # Check if the result is the same as expected\n    is_same = issame(result, expected)\n    if not is_same:\n        print("Assertion failed: result is not as expected")\n        exit(1)\n\nif __name__ == "__main__":\n    main()\n\n[Java]\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] input = new int[] {5, 3, 5, 2, 3, 3, 9, 0, 123};\n        int[] expected = new int[] {0, 2, 3, 5, 9, 123};\n        int[] result = unique(input);\n\n        // Check if the result is the same as expected\n        if (!issame(result, expected)) {\n            System.out.println("Assertion failed: result is not as expected");\n            System.exit(1);\n        }\n    }\n\n    public static int[] unique(int[] l) {\n        int[] temp = new int[l.length];\n        int count = 0;\n\n        // Remove duplicates\n        for (int i = 0; i < l.length; i++) {\n            if (!contains(temp, count, l[i])) {\n                count++;\n                temp[count - 1] = l[i];\n            }\n        }\n\n        // Allocate output array with the correct size\n        int[] out = new int[count];\n        for (int i = 0; i < count; i++) {\n            out[i] = temp[i];\n        }\n\n        // Sort the output array\n        Arrays.sort(out);\n        return out;\n    }\n\n    public static boolean contains(int[] arr, int size, int value) {\n        for (int i = 0; i < size; i++) {\n            if (arr[i] == value) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static boolean issame(int[] a, int[] b) {\n        if (a.length != b.length) {\n            return false;\n        }\n\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n[JavaScript]\nfunction unique(l) {\n    let temp = [];\n    let count = 0;\n\n    // Remove duplicates\n    for (let i = 0; i < l.length; i++) {\n        if (!contains(temp, count, l[i])) {\n            count++;\n            temp.push(l[i]);\n        }\n    }\n\n    // Allocate output array with the correct size\n    let out = new Array(count);\n    for (let i = 0; i < count; i++) {\n        out[i] = temp[i];\n    }\n\n    // Sort the output array\n    out.sort((a, b) => a - b);
\n\n[CPP]\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> arr) {\n  float max_val = -10000.0;\n  for (int i = 0; i < arr.size(); i++) {\n    if (max_val < arr[i]) max_val = arr[i];\n  }\n  return max_val;\n}\n\nint main() {\n  vector<float> arr;\n\n  // Test case 1\n  arr.clear();\n  arr.push_back(1.0);\n  arr.push_back(2.0);\n  arr.push_back(3.0);\n  float result = max_element(arr);\n  if (abs(result - 3.0) > 1e-4) {\n    cout << "Test case 1: assertion failed" << endl;\n    exit(1);\n  }\n\n  // Test case 2\n  arr.clear();\n  arr.push_back(5.0);\n  arr.push_back(3.0);\n  arr.push_back(-5.0);\n  arr.push_back(2.0);\n  arr.push_back(-3.0);\n  arr.push_back(3.0);\n  arr.push_back(9.0);\n  arr.push_back(0.0);\n  arr.push_back(124.0);\n  arr.push_back(1.0);\n  arr.push_back(-10.0);\n  result = max_element(arr);\n  if (abs(result - 124.0) > 1e-4) {\n    cout << "Test case 2: assertion failed" << endl;\n    exit(1);\n  }\n\n  cout << "All tests passed" << endl;\n  return 0;\n} [/CPP]\n\n[C]\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\nfloat max_element(float *arr, int size) {\n  float max_val = -10000.0;\n  for (int i = 0; i < size; i++) {\n    if (max_val < arr[i]) max_val = arr[i];\n  }\n  return max_val;\n}\n\nint main() {\n  float arr[] = {1.0, 2.0, 3.0};\n  float result = max_element(arr, 3);\n  if (fabs(result - 3.0) > 1e-4) {\n    printf("Test case 1: assertion failed\n");\n    exit(1);\n  }\n\n  float arr2[] = {5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 124.0, 1.0, -10.0};\n  result = max_element(arr2, 11);\n  if (fabs(result - 124.0) > 1e-4) {\n    printf("Test case 2: assertion failed\n");\n    exit(1);\n  }\n\n  printf("All tests passed\n");\n  return 0;\n} [/C]\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> arr) {\n  float max_val = -10000.0;\n  for (int i = 0; i < arr.size(); i++) {\n    if (max_val < arr[i]) max_val = arr[i];\n  }\n  return max_val;\n}\n\nint main() {\n  vector<float> arr;\n\n  // Test case 1\n  arr.clear();\n  arr.push_back(1.0);\n  arr.push_back(2.0);\n  arr.push_back(3.0);\n  float result = max_element(arr);\n  if (abs(result - 3.0) > 1e-4) {\n    cout << "Test case 1: assertion failed" << endl;\n    exit(1);\n  }\n\n  // Test case 2\n  arr.clear();\n  arr.push_back(5.0);\n  arr.push_back(3.0);\n  arr.push_back(-5.0);\n  arr.push_back(2.0);\n  arr.push_back(-3.0);\n  arr.push_back(3.0);\n  arr.push_back(9.0);\n  arr.push_back(0.0);\n  arr.push_back(124.0);\n  arr.push_back(1.0);\n  arr.push_back(-10.0);\n  result = max_element(arr);\n  if (abs(result - 124.0) > 1e-4) {\n    cout << "Test case 2: assertion failed" << endl;\n    exit(1);\n  }\n\n  cout << "All tests passed" << endl;\n  return 0;\n} [/C++]\n\n[Python]\ndef max_element(arr):\n  max_val = -10000.0\n  for i in range(len(arr)):\n    if max_val < arr[i]:\n      max_val = arr[i]\n  return max_val\n\nif __name__ == "__main__":\n  arr = [1.0, 2.0, 3.0]\n  result = max_element(arr)\n  if abs(result - 3.0) > 1e-4:\n    print("Test case 1: assertion failed")\n    exit(1)\n\n  arr = [5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 124.0, 1.0, -10.0]\n  result = max_element(arr)\n  if abs(result - 124.0) > 1e-4:\n    print("Test case 2: assertion failed")\n    exit(1)\n\n  print("All tests passed")\n[/Python]\n\n[Java]\nimport java.util.Scanner;\n\nclass MaxElement {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int size = sc.nextInt();\n    float[] arr = new float[size];\n    for (int i = 0; i < size; i++) {\n      arr[i] = sc.nextFloat();\n    }\n    float result = maxElement(arr);\n    if (Math.abs(result - 3.0) > 1e-4) {\n      System.out.println("Test case 1: assertion failed");\n      System.exit(1);\n    }\n\n    size = sc.nextInt();\n    arr = new float[size];\n    for (int i = 0; i < size; i++) {\n      arr[i] = sc.nextFloat();\n    }\n    result = maxElement(arr);\n    if (Math.abs(result - 124.0) > 1e-4) {\n      System.out.println("Test case 2: assertion failed");\n      System.exit(1);\n    }\n\n    System.out.println("All tests passed");\n  }\n\n  public static float maxElement(float[] arr) {\n    float max_val = -10000.0;\n    for (int i = 0; i < arr.length; i++) {\n      if (max_val < arr[i]) max_val = arr[i];\n    }\n    return max_val;\n  }\n} [/Java]\n\n[JavaScript]\nfunction maxElement(arr) {\n  var max_val = -10000.0;\n  for (var i = 0; i < arr.length; i++) {\n    if (max_val < arr[i]) max_val = arr[i];\n  }\n  return max_val;\n}\n\nif (typeof process === "undefined") {\n  var arr = [1.0, 2.0, 3.0];\n  var result = maxElement(arr);\n  if (
\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECTED]\n\n[EXPECTED]\n[SYNTAX_ERROR]\n[/EXPECT
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid sort_even(vector<double> &l) {\n    vector<double> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    sort(even.begin(), even.end());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            l[i] = even[i / 2];\n        }\n    }\n}\n\nint main() {\n    vector<double> l;\n    vector<double> expected;\n    vector<double> result;\n\n    // Test case 1\n    l = {1.0, 2.0, 3.0};\n    expected = {1.0, 2.0, 3.0};\n    sort_even(l);\n    result = l;\n    if (result != expected) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    // Test case 2\n    l = {5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    expected = {-10.0, 3.0, -5.0, 2.0, -3.0, 3.0, 5.0, 0.0, 9.0, 1.0, 123.0};\n    sort_even(l);\n    result = l;\n    if (result != expected) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    // Test case 3\n    l = {5.0, 8.0, -12.0, 4.0, 23.0, 2.0, 3.0, 11.0, 12.0, -10.0};\n    expected = {-12.0, 8.0, 3.0, 4.0, 5.0, 2.0, 12.0, 11.0, 23.0, -10.0};\n    sort_even(l);\n    result = l;\n    if (result != expected) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed" << endl;\n    return 0;\n}\n\end{code}\n\nComment: I'm not sure what you mean by "the C++ code is not correct".  Can you be more specific?\n\nComment: @NathanOliver I mean that the C++ code does not give the same output as the Fortran code.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output and the actual output.\n\nComment: @NathanOliver I have added the expected output
\n\n[INST] Translate this Fortran code to C++: \nprogram car_race\n  implicit none\n\n  ! Assertions\n  if (car_race_collision(2) /= 4) then\n    write(*,*) "Assertion failed: car_race_collision(2) == 4"\n    call exit(1)\n  end if\n\n  if (car_race_collision(3) /= 9) then\n    write(*,*) "Assertion failed: car_race_collision(3) == 9"\n    call exit(1)\n  end if\n\n  if (car_race_collision(4) /= 16) then\n    write(*,*) "Assertion failed: car_race_collision(4) == 16"\n    call exit(1)\n  end if\n\n  if (car_race_collision(8) /= 64) then\n    write(*,*) "Assertion failed: car_race_collision(8) == 64"\n    call exit(1)\n  end if\n\n  if (car_race_collision(10) /= 100) then\n    write(*,*) "Assertion failed: car_race_collision(10) == 100"\n    call exit(1)\n  end if\n\ncontains\n\n  ! Function definition\n  integer function car_race_collision(n)\n    integer, intent(in) :: n\n    car_race_collision = n * n\n  end function car_race_collision\n\nend program car_race [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram car_race\n  implicit none\n\n  ! Assertions\n  if (car_race_collision(2) /= 4) then\n    write(*,*) "Assertion failed: car_race_collision(2) == 4"\n    call exit(1)\n  end if\n\n  if (car_race_collision(3) /= 9) then\n    write(*,*) "Assertion failed: car_race_collision(3) == 9"\n    call exit(1)\n  end if\n\n  if (car_race_collision(4) /= 16) then\n    write(*,*) "Assertion failed: car_race_collision(4) == 16"\n    call exit(1)\n  end if\n\n  if (car_race_collision(8) /= 64) then\n    write(*,*) "Assertion failed: car_race_collision(8) == 64"\n    call exit(1)\n  end if\n\n  if (car_race_collision(10) /= 100) then\n    write(*,*) "Assertion failed: car_race_collision(10) == 100"\n    call exit(1)\n  end if\n\ncontains\n\n  ! Function definition\n  integer function car_race_collision(n)\n    integer, intent(in) :: n\n    car_race_collision = n * n\n  end function car_race_collision\n\nend program car_race [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram car_race\n  implicit none\n\n  ! Assertions\n  if (car_race_collision(2) /= 4) then\n    write(*,*) "Assertion failed: car_race_collision(2) == 4"\n    call exit(1)\n  end if\n\n  if (car_race_collision(3) /= 9) then\n    write(*,*) "Assertion failed: car_race_collision(3) == 9"\n    call exit(1)\n  end if\n\n  if (car_race_collision(4) /= 16) then\n    write(*,*) "Assertion failed: car_race_collision(4) == 16"\n    call exit(1)\n  end if\n\n  if (car_race_collision(8) /= 64) then\n    write(*,*) "Assertion failed: car_race_collision(8) == 64"\n    call exit(1)\n  end if\n\n  if (car_race_collision(10) /= 100) then\n    write(*,*) "Assertion failed: car_race_collision(10) == 100"\n    call exit(1)\n  end if\n\ncontains\n\n  ! Function definition\n  integer function car_race_collision(n)\n    integer, intent(in) :: n\n    car_race_collision = n * n\n  end function car_race_collision\n\nend program car_race [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram car_race\n  implicit none\n\n  ! Assertions\n  if (car_race_collision(2) /= 4) then\n    write(*,*) "Assertion failed: car_race_collision(2) == 4"\n    call exit(1)\n  end if\n\n  if (car_race_collision(3) /= 9) then\n    write(*,*) "Assertion failed: car_race_collision(3) == 9"\n    call exit(1)\n  end if\n\n  if (car_race_collision(4) /= 16) then\n    write(*,*) "Assertion failed: car_race_collision(4) == 16"\n    call exit(1)\n  end if\n\n  if (car_race_collision(8) /= 64) then\n    write(*,*) "Assertion failed: car_race_collision(8) == 64"\n    call exit(1)\n  end if\n\n  if (car_race_collision(10) /= 100) then\n    write(*,*) "Assertion failed: car_race_collision(10) == 100"\n    call exit(1)\n  end if\n\ncontains\n\n  ! Function definition\n  integer function car_race_collision(n)\n    integer, intent(in) :: n\n    car_race_collision = n * n\n  end function car_race_collision\n\nend program car_race [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram car_race\n  implicit none\n\n  ! Assertions\n  if (car_race_collision(2) /= 4) then\n    write(*,*) "Assertion failed: car_race_collision(2) == 4"\n    call exit(1)\n  end if\n\n  if (car_race_collision(3) /= 9) then\n    write(*,*) "Assertion failed: car_race_collision(3) == 9"\n    call exit(1)\n  end if\n\n  if (car_race_collision(4) /= 16) then\n    write(*,*) "Assertion failed: car_race_collision(4) == 16"\n    call exit(1)\n  end if\n\n  if (car_race_collision(8) /= 64) then\n    write(*,*) "Assertion failed: car_race_collision(8) == 64"\n    call exit(1)\n  end if\n\n  if (car_race_collision(10) /= 100) then\n    write(*,*) "Assertion failed: car_race_collision(10) == 100"\n    call exit(1)\n  end if\n\ncontains\n\n  ! Function definition\n  integer function car_race_collision(n)\n    integer, intent(in) :: n\n    car_race_collision = n * n\n  end function car_race_collision\n\nend program car_race [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram car_race\n  implicit none\n\n  ! Assertions\n  if (car_race_collision(2) /= 4) then\n    write(*,*) "Assertion failed: car_race_collision(2) == 4"\n    call exit(1)\n  end if\n\n  if (car_race_collision(3) /= 9) then\n    write(*,*) "Assertion failed: car_race_collision(3) == 9"\n    call exit(1)\n  end if\n\n  if (car_race
\n\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]
\n\n[CPP]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool pairs_sum_to_zero(std::vector<int> &l) {\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> l = {1, 3, 5, 0};\n    if (pairs_sum_to_zero(l)) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    l = {1, 3, -2, 1};\n    if (pairs_sum_to_zero(l)) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    l = {1, 2, 3, 7};\n    if (pairs_sum_to_zero(l)) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    l = {2, 4, -5, 3, 5, 7};\n    if (!pairs_sum_to_zero(l)) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    l = {1};\n    if (pairs_sum_to_zero(l)) {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    l = {-3, 9, -1, 3, 2, 30};\n    if (!pairs_sum_to_zero(l)) {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    l = {-3, 9, -1, 3, 2, 31};\n    if (!pairs_sum_to_zero(l)) {\n        std::cout << "Test case 7 failed" << std::endl;\n        return 1;\n    }\n\n    l = {-3, 9, -1, 4, 2, 30};\n    if (pairs_sum_to_zero(l)) {\n        std::cout << "Test case 8 failed" << std::endl;\n        return 1;\n    }\n\n    l = {-3, 9, -1, 4, 2, 31};\n    if (pairs_sum_to_zero(l)) {\n        std::cout << "Test case 9 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n} [/CPP]\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nbool pairs_sum_to_zero(int *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int l[] = {1, 3, 5, 0};\n    if (pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 1 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {1, 3, -2, 1};\n    if (pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 2 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {1, 2, 3, 7};\n    if (pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 3 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {2, 4, -5, 3, 5, 7};\n    if (!pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 4 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {1};\n    if (pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 5 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {-3, 9, -1, 3, 2, 30};\n    if (!pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 6 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {-3, 9, -1, 3, 2, 31};\n    if (!pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 7 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {-3, 9, -1, 4, 2, 30};\n    if (pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 8 failed\n");\n        return 1;\n    }\n\n    l = (int[]) {-3, 9, -1, 4, 2, 31};\n    if (pairs_sum_to_zero(l, sizeof(l) / sizeof(l[0]))) {\n        printf("Test case 9 failed\n");\n        return 1;\n    }\n\n    printf("All test cases passed\n");\n    return 0;\n} [/C]\n\n[JAVA]\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] l = {1, 3, 5, 0};\n        if (pairsSumToZero(l)) {\n            System.out.println("Test case 1 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {1, 3, -2, 1};\n        if (pairsSumToZero(l)) {\n            System.out.println("Test case 2 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {1, 2, 3, 7};\n        if (pairsSumToZero(l)) {\n            System.out.println("Test case 3 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {2, 4, -5, 3, 5, 7};\n        if (!pairsSumToZero(l)) {\n            System.out.println("Test case 4 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {1};\n        if (pairsSumToZero(l)) {\n            System.out.println("Test case 5 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {-3, 9, -1, 3, 2, 30};\n        if (!pairsSumToZero(l)) {\n            System.out.println("Test case 6 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {-3, 9, -1, 3, 2, 31};\n        if (!pairsSumToZero(l)) {\n            System.out.println("Test case 7 failed");\n            System.exit(1);\n        }\n\n        l = new int[] {-3, 9, -1, 4, 2, 30};\n        if (pairsSumToZero(l)) {\n            System.out.println("Test case 8 failed");\n            System.exit(1);\n        }\n\n        l =
\n\n[INST] Translate this Fortran code to C++: \nprogram change_base_program\n    implicit none\n    character(len=100) :: result\n    integer :: x\n\n    ! Assertions\n    if (trim(change_base(8, 3)) /= "22") then\n        write(*,*) "Assertion failed: change_base(8, 3) == '22'"\n        call exit(1)\n    end if\n    if (trim(change_base(9, 3)) /= "100") then\n        write(*,*) "Assertion failed: change_base(9, 3) == '100'"\n        call exit(1)\n    end if\n    if (trim(change_base(234, 2)) /= "11101010") then\n        write(*,*) "Assertion failed: change_base(234, 2) == '11101010'"\n        call exit(1)\n    end if\n    if (trim(change_base(16, 2)) /= "10000") then\n        write(*,*) "Assertion failed: change_base(16, 2) == '10000'"\n        call exit(1)\n    end if\n    if (trim(change_base(8, 2)) /= "1000") then\n        write(*,*) "Assertion failed: change_base(8, 2) == '1000'"\n        call exit(1)\n    end if\n    if (trim(change_base(7, 2)) /= "111") then\n        write(*,*) "Assertion failed: change_base(7, 2) == '111'"\n        call exit(1)\n    end if\n\n    do x = 2, 7\n        if (trim(change_base(x, x + 1)) /= trim(adjustl(itoa(x)))) then\n            write(*,*) "Assertion failed: change_base(", x, ", ", x + 1, ") == ", x\n            call exit(1)\n        end if\n    end do\n\ncontains\n    ! Function to change base\n    character(len=100) function change_base(x, base)\n        implicit none\n        integer, intent(in) :: x, base\n        integer :: temp_x, remainder\n        character(len=100) :: out, temp_str\n        out = ""\n        temp_x = x\n        do while (temp_x > 0)\n            remainder = mod(temp_x, base)\n            write(temp_str, '(I0)') remainder\n            out = trim(adjustl(temp_str)) // out\n            temp_x = temp_x / base\n        end do\n        change_base = out\n    end function change_base\n\n    ! Integer to string conversion function\n    character(len=100) function itoa(num)\n        implicit none\n        integer, intent(in) :: num\n        write(itoa, '(I0)') num\n    end function itoa\n\nend program change_base_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram change_base_program\n    implicit none\n    character(len=100) :: result\n    integer :: x\n\n    ! Assertions\n    if (trim(change_base(8, 3)) /= "22") then\n        write(*,*) "Assertion failed: change_base(8, 3) == '22'"\n        call exit(1)\n    end if\n    if (trim(change_base(9, 3)) /= "100") then\n        write(*,*) "Assertion failed: change_base(9, 3) == '100'"\n        call exit(1)\n    end if\n    if (trim(change_base(234, 2)) /= "11101010") then\n        write(*,*) "Assertion failed: change_base(234, 2) == '11101010'"\n        call exit(1)\n    end if\n    if (trim(change_base(16, 2)) /= "10000") then\n        write(*,*) "Assertion failed: change_base(16, 2) == '10000'"\n        call exit(1)\n    end if\n    if (trim(change_base(8, 2)) /= "1000") then\n        write(*,*) "Assertion failed: change_base(8, 2) == '1000'"\n        call exit(1)\n    end if\n    if (trim(change_base(7, 2)) /= "111") then\n        write(*,*) "Assertion failed: change_base(7, 2) == '111'"\n        call exit(1)\n    end if\n\n    do x = 2, 7\n        if (trim(change_base(x, x + 1)) /= trim(adjustl(itoa(x)))) then\n            write(*,*) "Assertion failed: change_base(", x, ", ", x + 1, ") == ", x\n            call exit(1)\n        end if\n    end do\n\ncontains\n    ! Function to change base\n    character(len=100) function change_base(x, base)\n        implicit none\n        integer, intent(in) :: x, base\n        integer :: temp_x, remainder\n        character(len=100) :: out, temp_str\n        out = ""\n        temp_x = x\n        do while (temp_x > 0)\n            remainder = mod(temp_x, base)\n            write(temp_str, '(I0)') remainder\n            out = trim(adjustl(temp_str)) // out\n            temp_x = temp_x / base\n        end do\n        change_base = out\n    end function change_base\n\n    ! Integer to string conversion function\n    character(len=100) function itoa(num)\n        implicit none\n        integer, intent(in) :: num\n        write(itoa, '(I0)') num\n    end function itoa\n\nend program change_base_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram change_base_program\n    implicit none\n    character(len=100) :: result\n    integer :: x\n\n    ! Assertions\n    if (trim(change_base(8, 3)) /= "22") then\n        write(*,*) "Assertion failed: change_base(8, 3) == '22'"\n        call exit(1)\n    end if\n    if (trim(change_base(9, 3)) /= "100") then\n        write(*,*) "Assertion failed: change_base(9, 3) == '100'"\n        call exit(1)\n    end if\n    if (trim(change_base(234, 2)) /= "11101010") then\n        write(*,*) "Assertion failed: change_base(234, 2) == '11101010'"\n        call exit(1)\n    end if\n    if (trim(change_base(16, 2)) /= "10000") then\n        write(*,*) "Assertion failed: change_base(16, 2) == '10000'"\n        call exit(1)\n    end if\n    if (trim(change_base(8, 2)) /= "1000") then\n        write(*,*) "Assertion failed: change_base(8, 2) == '1000'"\n        call exit(1)\n    end if\n    if (trim(change_base(7, 2)) /= "111") then\n        write(*,*) "Assertion failed: change_base(7, 2) == '111'"\n        call exit(1)\n    end if\n\n    do x = 2, 7\n        if (trim(change_base(x, x + 1)) /= trim(adjustl(itoa(x)))) then\n            write(*,*) "Assertion failed: change_base(", x, ", ", x + 1, ") == ", x\n            call exit(1)\n        end if\n    end do\n\ncontains\n    ! Function to change base\n    character(len=100) function change_base(x,
\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n        real :: area\n        area = (a * h) * 0.5\n    end function triangle_area\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n        real :: area\n        area = (a * h) * 0.5\n    end function triangle_area\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n        real :: area\n        area = (a * h) * 0.5\n    end function triangle_area\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n        real :: area\n        area = (a * h) * 0.5\n    end function triangle_area\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n        real :: area\n        area = (a * h) * 0.5\n    end function triangle_area\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Assertion failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n
\n\n[INST] Translate this Fortran code to C++: \nprogram fib5_program\n    implicit none\n\n    ! Assertions\n    if (fib5(5) /= 4) then\n        write(*,*) "fib5(5) == 4: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib5(8) /= 28) then\n        write(*,*) "fib5(8) == 28: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib5(10) /= 104) then\n        write(*,*) "fib5(10) == 104: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib5(12) /= 386) then\n        write(*,*) "fib5(12) == 386: assertion failed"\n        call exit(1)\n    end if\n\ncontains\n\n    ! Function definition\n    integer function fib5(n)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(0:99) :: f\n        integer :: i\n\n        ! Initialize the first four elements\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\n        ! Compute the sequence\n        do i = 4, n\n            f(i) = f(i-1) + f(i-2) + f(i-3) + f(i-4)\n        end do\n\n        fib5 = f(n)\n    end function fib5\n\nend program fib5_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram fib6_program\n    implicit none\n\n    ! Assertions\n    if (fib6(5) /= 4) then\n        write(*,*) "fib6(5) == 4: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib6(8) /= 28) then\n        write(*,*) "fib6(8) == 28: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib6(10) /= 104) then\n        write(*,*) "fib6(10) == 104: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib6(12) /= 386) then\n        write(*,*) "fib6(12) == 386: assertion failed"\n        call exit(1)\n    end if\n\ncontains\n\n    ! Function definition\n    integer function fib6(n)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(0:99) :: f\n        integer :: i\n\n        ! Initialize the first four elements\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\n        ! Compute the sequence\n        do i = 4, n\n            f(i) = f(i-1) + f(i-2) + f(i-3) + f(i-4)\n        end do\n\n        fib6 = f(n)\n    end function fib6\n\nend program fib6_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram fib7_program\n    implicit none\n\n    ! Assertions\n    if (fib7(5) /= 4) then\n        write(*,*) "fib7(5) == 4: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib7(8) /= 28) then\n        write(*,*) "fib7(8) == 28: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib7(10) /= 104) then\n        write(*,*) "fib7(10) == 104: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib7(12) /= 386) then\n        write(*,*) "fib7(12) == 386: assertion failed"\n        call exit(1)\n    end if\n\ncontains\n\n    ! Function definition\n    integer function fib7(n)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(0:99) :: f\n        integer :: i\n\n        ! Initialize the first four elements\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\n        ! Compute the sequence\n        do i = 4, n\n            f(i) = f(i-1) + f(i-2) + f(i-3) + f(i-4)\n        end do\n\n        fib7 = f(n)\n    end function fib7\n\nend program fib7_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram fib8_program\n    implicit none\n\n    ! Assertions\n    if (fib8(5) /= 4) then\n        write(*,*) "fib8(5) == 4: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib8(8) /= 28) then\n        write(*,*) "fib8(8) == 28: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib8(10) /= 104) then\n        write(*,*) "fib8(10) == 104: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib8(12) /= 386) then\n        write(*,*) "fib8(12) == 386: assertion failed"\n        call exit(1)\n    end if\n\ncontains\n\n    ! Function definition\n    integer function fib8(n)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(0:99) :: f\n        integer :: i\n\n        ! Initialize the first four elements\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\n        ! Compute the sequence\n        do i = 4, n\n            f(i) = f(i-1) + f(i-2) + f(i-3) + f(i-4)\n        end do\n\n        fib8 = f(n)\n    end function fib8\n\nend program fib8_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram fib9_program\n    implicit none\n\n    ! Assertions\n    if (fib9(5) /= 4) then\n        write(*,*) "fib9(5) == 4: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib9(8) /= 28) then\n        write(*,*) "fib9(8) == 28: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib9(10) /= 104) then\n        write(*,*) "fib9(10) == 104: assertion failed"\n        call exit(1)\n    end if\n\n    if (fib9(12) /= 386) then\n        write(*,*) "fib9(12) == 386: assertion failed"\n        call exit(1)\n    end if\n\ncontains\n\n    ! Function definition\n    integer function fib9(n)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(0:99) :: f\n        integer :: i\n\n        ! Initialize the first four elements\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\n        ! Compute the sequence\n        do i = 4, n\n            f(i) = f(i-1) + f(i-2) + f(i-3) + f(i-4)\n        end do\n
\n\n[CPP]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid sort(vector<double> &arr) {\n    for (int i = 0; i < arr.size() - 1; i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (arr[i] > arr[j]) {\n                double temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}\n\ndouble median(vector<double> arr) {\n    sort(arr);\n    int n = arr.size();\n\n    if (n % 2 == 1) {\n        return arr[n / 2];\n    } else {\n        return (arr[n / 2] + arr[n / 2 + 1]) / 2.0;\n    }\n}\n\nint main() {\n    // Test cases\n    double result = median({3.0, 1.0, 2.0, 4.0, 5.0});\n    if (abs(result - 3.0) > 1e-4) {\n        cout << "Test case 1 failed: assertion failed" << endl;\n        return 1;\n    }\n\n    result = median({-10.0, 4.0, 6.0, 1000.0, 10.0, 20.0});\n    if (abs(result - 8.0) > 1e-4) {\n        cout << "Test case 2 failed: assertion failed" << endl;\n        return 1;\n    }\n\n    result = median({5.0});\n    if (abs(result - 5.0) > 1e-4) {\n        cout << "Test case 3 failed: assertion failed" << endl;\n        return 1;\n    }\n\n    result = median({6.0, 5.0});\n    if (abs(result - 5.5) > 1e-4) {\n        cout << "Test case 4 failed: assertion failed" << endl;\n        return 1;\n    }\n\n    result = median({8.0, 1.0, 3.0, 9.0, 9.0, 2.0, 7.0});\n    if (abs(result - 7.0) > 1e-4) {\n        cout << "Test case 5 failed: assertion failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed." << endl;\n    return 0;\n}\n[/CPP]\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define swap(a, b) { double temp = a; a = b; b = temp; }\n\nvoid sort(double *arr, int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                swap(arr[i], arr[j]);\n            }\n        }\n    }\n}\n\ndouble median(double *arr, int n) {\n    sort(arr, n);\n\n    if (n % 2 == 1) {\n        return arr[n / 2];\n    } else {\n        return (arr[n / 2] + arr[n / 2 + 1]) / 2.0;\n    }\n}\n\nint main() {\n    // Test cases\n    double result = median((double[]){3.0, 1.0, 2.0, 4.0, 5.0}, 5);\n    if (fabs(result - 3.0) > 1e-4) {\n        printf("Test case 1 failed: assertion failed\n");\n        return 1;\n    }\n\n    result = median((double[]){-10.0, 4.0, 6.0, 1000.0, 10.0, 20.0}, 6);\n    if (fabs(result - 8.0) > 1e-4) {\n        printf("Test case 2 failed: assertion failed\n");\n        return 1;\n    }\n\n    result = median((double[]){5.0}, 1);\n    if (fabs(result - 5.0) > 1e-4) {\n        printf("Test case 3 failed: assertion failed\n");\n        return 1;\n    }\n\n    result = median((double[]){6.0, 5.0}, 2);\n    if (fabs(result - 5.5) > 1e-4) {\n        printf("Test case 4 failed: assertion failed\n");\n        return 1;\n    }\n\n    result = median((double[]){8.0, 1.0, 3.0, 9.0, 9.0, 2.0, 7.0}, 7);\n    if (fabs(result - 7.0) > 1e-4) {\n        printf("Test case 5 failed: assertion failed\n");\n        return 1;\n    }\n\n    printf("All test cases passed.\n");\n    return 0;\n}\n[/C]\n\n[JAVA]\nimport java.util.Arrays;\n\npublic class Median {\n    public static void sort(double[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[i] > arr[j]) {\n                    double temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n\n    public static double median(double[] arr) {\n        sort(arr);\n        int n = arr.length;\n\n        if (n % 2 == 1) {\n            return arr[n / 2];\n        } else {\n            return (arr[n / 2] + arr[n / 2 + 1]) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        double result = median(new double[]{3.0, 1.0, 2.0, 4.0, 5.0});\n        if (Math.abs(result - 3.0) > 1e-4) {\n            System.out.println("Test case 1 failed: assertion failed");\n            System.exit(1);\n        }\n\n        result = median(new double[]{-10.0, 4.0, 6.0, 1000.0, 10.0, 20.0});\n        if (Math.abs(result - 8.0) > 1e-4) {\n            System.out.println("Test case 2 failed: assertion failed");\n            System.exit(1);\n        }\n\n        result = median(new double[]{5.0});\n        if (Math.abs(result - 5.0) > 1e-4) {\n            System.out.println("Test case 3 failed: assertion failed");\n            System.exit(1);\n        }\n\n        result = median(new double[]{6.0, 5.0});\n        if (Math.abs(result - 5.5) > 1e-4) {\n            System.out.println("Test case 4 failed: assertion failed");\n            System.exit(1);\n        }\n\n        result = median(new double[]{8.0, 1.0, 3.0, 9.0, 9.0, 2.0, 7.0});\n        if (Math.abs(result - 7.0) > 1e-4) {\n            System.out.println("Test case 5 failed: assertion failed");\n            System.exit(1);\n        }\n\n        System.out.println("All test cases passed.");\n    }\n}\n[/JAVA]\n\n[PYTHON]\ndef sort(arr):\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n
\n\n[C++]\n#include <cstdlib>\n#include <string>\n\nbool is_palindrome(const std::string& text)\n{\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return reversed_text == text;\n}\n\nint main()\n{\n    if (!is_palindrome("")) {\n        std::cerr << "Assertion failed: is_palindrome('') == true" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    if (!is_palindrome("aba")) {\n        std::cerr << "Assertion failed: is_palindrome('aba') == true" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        std::cerr << "Assertion failed: is_palindrome('aaaaa') == true" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    if (is_palindrome("zbcd")) {\n        std::cerr << "Assertion failed: is_palindrome('zbcd') == false" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyx') == true" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    if (is_palindrome("xywyz")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyz') == false" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    if (is_palindrome("xywzx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywzx') == false" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return EXIT_SUCCESS;\n}\n\n[C]\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\nbool is_palindrome(const char* text)\n{\n    size_t n = strlen(text);\n    char* reversed_text = malloc(n + 1);\n    if (reversed_text == NULL) {\n        return false;\n    }\n\n    for (size_t i = 0; i < n; i++) {\n        reversed_text[i] = text[n - i - 1];\n    }\n    reversed_text[n] = '\0';\n\n    bool result = strcmp(reversed_text, text) == 0;\n    free(reversed_text);\n    return result;\n}\n\nint main()\n{\n    if (!is_palindrome("")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('') == true\n");\n        return EXIT_FAILURE;\n    }\n\n    if (!is_palindrome("aba")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('aba') == true\n");\n        return EXIT_FAILURE;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('aaaaa') == true\n");\n        return EXIT_FAILURE;\n    }\n\n    if (is_palindrome("zbcd")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('zbcd') == false\n");\n        return EXIT_FAILURE;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('xywyx') == true\n");\n        return EXIT_FAILURE;\n    }\n\n    if (is_palindrome("xywyz")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('xywyz') == false\n");\n        return EXIT_FAILURE;\n    }\n\n    if (is_palindrome("xywzx")) {\n        fprintf(stderr, "Assertion failed: is_palindrome('xywzx') == false\n");\n        return EXIT_FAILURE;\n    }\n\n    printf("All tests passed.\n");\n    return EXIT_SUCCESS;\n}\n\n[Python]\ndef is_palindrome(text):\n    return text == text[::-1]\n\n\ndef main():\n    assert is_palindrome("")\n    assert is_palindrome("aba")\n    assert is_palindrome("aaaaa")\n    assert not is_palindrome("zbcd")\n    assert is_palindrome("xywyx")\n    assert not is_palindrome("xywyz")\n    assert not is_palindrome("xywzx")\n    print("All tests passed.")\n\n\nif __name__ == "__main__":\n    main()\n\n[Java]\npublic class Palindrome {\n    public static boolean isPalindrome(String text) {\n        return text.equals(new StringBuilder(text).reverse().toString());\n    }\n\n    public static void main(String[] args) {\n        assert isPalindrome("");\n        assert isPalindrome("aba");\n        assert isPalindrome("aaaaa");\n        assert !isPalindrome("zbcd");\n        assert isPalindrome("xywyx");\n        assert !isPalindrome("xywyz");\n        assert !isPalindrome("xywzx");\n        System.out.println("All tests passed.");\n    }\n}\n\n[JavaScript]\nfunction isPalindrome(text) {\n    return text === text.split("").reverse().join("");\n}\n\nfunction main() {\n    assert(isPalindrome(""));\n    assert(isPalindrome("aba"));\n    assert(isPalindrome("aaaaa"));\n    assert(!isPalindrome("zbcd"));\n    assert(isPalindrome("xywyx"));\n    assert(!isPalindrome("xywyz"));\n    assert(!isPalindrome("xywzx"));\n    console.log("All tests passed.");\n}\n\nmain();\n\n[PHP]\nfunction isPalindrome($text)\n{\n    return $text === strrev($text);\n}\n\nfunction main()\n{\n    assert(isPalindrome(""));\n    assert(isPalindrome("aba"));\n    assert(isPalindrome("aaaaa"));\n    assert(!isPalindrome("zbcd"));\n    assert(isPalindrome("xywyx"));\n    assert(!isPalindrome("xywyz"));\n    assert(!isPalindrome("xywzx"));\n    echo "All tests passed.\n";\n}\n\nmain();\n\n[Ruby]\ndef is_palindrome(text)\n    text == text.reverse\nend\n\ndef main\n    assert(is_palindrome(""))\n    assert(is_palindrome("aba"))\n    assert(is_palindrome("aaaaa"))\n    assert(!is_palindrome("zbcd"))\n    assert(is_palindrome("xywyx"))\n    assert(!is_palindrome("xywyz"))\n    assert(!is_palindrome("xywzx"))\n    puts "All tests passed."\nend\n\nmain\n\n[Swift]\nfunc isPalindrome(_ text: String) -> Bool {\n    return text == String(text.reversed())\n}\n\nfunc main() {\n    assert(isPalindrome(""))\n    assert(isPalindrome("aba"))\n    assert(isPalindrome("aaaaa"))\n    assert(!isPalindrome("zbcd"))\n    assert(isPalindrome("xywyx"))\n    assert(!isPalindrome("xywyz"))\n    assert(!isPalindrome("xywzx"))\n    print("All tests passed.")\n}\n\nmain()\n\n[Go]\nfunc isPalindrome(text string) bool {\n    return text == string([]rune(text)[len(text)-1:0:-1])\n}\n\nfunc main() {\n    assert(isPalindrome(""))\n    assert(isPalind
\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n\nint modp(int n, int p) {\n    int modp = 1;\n    for (int i = 1; i <= n; i++) {\n        modp = (modp * 2) % p;\n    }\n    return modp;\n}\n\nint main() {\n    int result;\n\n    result = modp(3, 5);\n    if (result != 3) {\n        std::cout << "modp(3, 5) == 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(1101, 101);\n    if (result != 2) {\n        std::cout << "modp(1101, 101) == 2: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(0, 101);\n    if (result != 1) {\n        std::cout << "modp(0, 101) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(3, 11);\n    if (result != 8) {\n        std::cout << "modp(3, 11) == 8: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(100, 101);\n    if (result != 1) {\n        std::cout << "modp(100, 101) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(30, 5);\n    if (result != 4) {\n        std::cout << "modp(30, 5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(31, 5);\n    if (result != 3) {\n        std::cout << "modp(31, 5) == 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n\nint modp(int n, int p) {\n    int modp = 1;\n    for (int i = 1; i <= n; i++) {\n        modp = (modp * 2) % p;\n    }\n    return modp;\n}\n\nint main() {\n    int result;\n\n    result = modp(3, 5);\n    if (result != 3) {\n        printf("modp(3, 5) == 3: assertion failed\n");\n        exit(1);\n    }\n\n    result = modp(1101, 101);\n    if (result != 2) {\n        printf("modp(1101, 101) == 2: assertion failed\n");\n        exit(1);\n    }\n\n    result = modp(0, 101);\n    if (result != 1) {\n        printf("modp(0, 101) == 1: assertion failed\n");\n        exit(1);\n    }\n\n    result = modp(3, 11);\n    if (result != 8) {\n        printf("modp(3, 11) == 8: assertion failed\n");\n        exit(1);\n    }\n\n    result = modp(100, 101);\n    if (result != 1) {\n        printf("modp(100, 101) == 1: assertion failed\n");\n        exit(1);\n    }\n\n    result = modp(30, 5);\n    if (result != 4) {\n        printf("modp(30, 5) == 4: assertion failed\n");\n        exit(1);\n    }\n\n    result = modp(31, 5);\n    if (result != 3) {\n        printf("modp(31, 5) == 3: assertion failed\n");\n        exit(1);\n    }\n\n    printf("All assertions passed.\n");\n\n    return 0;\n}\n\n[Python]\ndef modp(n, p):\n    modp = 1\n    for i in range(1, n + 1):\n        modp = (modp * 2) % p\n    return modp\n\n\nif __name__ == "__main__":\n    result = modp(3, 5)\n    if result != 3:\n        print("modp(3, 5) == 3: assertion failed")\n        exit(1)\n\n    result = modp(1101, 101)\n    if result != 2:\n        print("modp(1101, 101) == 2: assertion failed")\n        exit(1)\n\n    result = modp(0, 101)\n    if result != 1:\n        print("modp(0, 101) == 1: assertion failed")\n        exit(1)\n\n    result = modp(3, 11)\n    if result != 8:\n        print("modp(3, 11) == 8: assertion failed")\n        exit(1)\n\n    result = modp(100, 101)\n    if result != 1:\n        print("modp(100, 101) == 1: assertion failed")\n        exit(1)\n\n    result = modp(30, 5)\n    if result != 4:\n        print("modp(30, 5) == 4: assertion failed")\n        exit(1)\n\n    result = modp(31, 5)\n    if result != 3:\n        print("modp(31, 5) == 3: assertion failed")\n        exit(1)\n\n    print("All assertions passed.")\n\n[JavaScript]\nfunction modp(n, p) {\n    let modp = 1;\n    for (let i = 1; i <= n; i++) {\n        modp = (modp * 2) % p;\n    }\n    return modp;\n}\n\nif (modp(3, 5) != 3) {\n    console.log("modp(3, 5) == 3: assertion failed");\n    process.exit(1);\n}\n\nif (modp(1101, 101) != 2) {\n    console.log("modp(1101, 101) == 2: assertion failed");\n    process.exit(1);\n}\n\nif (modp(0, 101) != 1) {\n    console.log("modp(0, 101) == 1: assertion failed");\n    process.exit(1);\n}\n\nif (modp(3, 11) != 8) {\n    console.log("modp(3, 11) == 8: assertion failed");\n    process.exit(1);\n}\n\nif (modp(100, 101) != 1) {\n    console.log("modp(100, 101) == 1: assertion failed");\n    process.exit(1);\n}\n\nif (modp(30, 5) != 4) {\n    console.log("modp(30, 5) == 4: assertion failed");\n    process.exit(1);\n}\n\nif (modp(31, 5) != 3) {\n    console.log("modp(31, 5) == 3: assertion failed");\n    process.exit(1);\n}\n\nconsole.log("All assertions passed.");\n\n[Ruby]\ndef modp(n, p)\n    modp = 1\n    for i in 1..n\n        modp = (modp * 2) % p\n    end\n    return modp\nend\n\nif modp(3, 5) != 3\n    puts "modp(3, 5) == 3
\n\n[INST] Translate this Fortran code to C++: \nprogram encode_decode_vigenere\n    implicit none\n    integer :: i, j, l\n    character(len=21) :: str, encoded_str, decoded_str\n    character(len=1) :: chr\n    real :: rand_val\n\n    call random_seed()\n\n    do i = 1, 100\n        call random_number(rand_val)\n        l = 10 + int(rand_val * 11)\n        str = ""\n        do j = 1, l\n            call random_number(rand_val)\n            chr = char(97 + int(rand_val * 26))\n            str(j:j) = chr\n        end do\n\n        encoded_str = encode_vigenere(trim(str))\n        decoded_str = decode_vigenere(trim(encoded_str))\n\n        if (trim(decoded_str) /= trim(str)) then\n            write(*,*) "Assertion failed: decoded string does not match original"\n            stop 1\n        end if\n    end do\ncontains\n    function encode_vigenere(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 5 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function encode_vigenere\n\n    function decode_vigenere(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 21 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function decode_vigenere\nend program encode_decode_vigenere [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram encode_decode_caesar\n    implicit none\n    integer :: i, j, l\n    character(len=21) :: str, encoded_str, decoded_str\n    character(len=1) :: chr\n    real :: rand_val\n\n    call random_seed()\n\n    do i = 1, 100\n        call random_number(rand_val)\n        l = 10 + int(rand_val * 11)\n        str = ""\n        do j = 1, l\n            call random_number(rand_val)\n            chr = char(97 + int(rand_val * 26))\n            str(j:j) = chr\n        end do\n\n        encoded_str = encode_caesar(trim(str))\n        decoded_str = decode_caesar(trim(encoded_str))\n\n        if (trim(decoded_str) /= trim(str)) then\n            write(*,*) "Assertion failed: decoded string does not match original"\n            stop 1\n        end if\n    end do\ncontains\n    function encode_caesar(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 5 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function encode_caesar\n\n    function decode_caesar(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 21 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function decode_caesar\nend program encode_decode_caesar [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram encode_decode_atbash\n    implicit none\n    integer :: i, j, l\n    character(len=21) :: str, encoded_str, decoded_str\n    character(len=1) :: chr\n    real :: rand_val\n\n    call random_seed()\n\n    do i = 1, 100\n        call random_number(rand_val)\n        l = 10 + int(rand_val * 11)\n        str = ""\n        do j = 1, l\n            call random_number(rand_val)\n            chr = char(97 + int(rand_val * 26))\n            str(j:j) = chr\n        end do\n\n        encoded_str = encode_atbash(trim(str))\n        decoded_str = decode_atbash(trim(encoded_str))\n\n        if (trim(decoded_str) /= trim(str)) then\n            write(*,*) "Assertion failed: decoded string does not match original"\n            stop 1\n        end if\n    end do\ncontains\n    function encode_atbash(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 5 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function encode_atbash\n\n    function decode_atbash(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 21 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function decode_atbash\nend program encode_decode_atbash [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram encode_decode_rot13\n    implicit none\n    integer :: i, j, l\n    character(len=21) :: str, encoded_str, decoded_str\n    character(len=1) :: chr\n    real :: rand_val\n\n    call random_seed()\n\n    do i = 1, 100\n        call random_number(rand_val)\n        l = 10 + int(rand_val * 11)\n        str = ""\n        do j = 1, l\n            call random_number(rand_val)\n            chr = char(97 + int(rand_val * 26))\n            str(j:j) = chr\n        end do\n\n        encoded_str = encode_rot13(trim(str))\n        decoded_str = decode_rot13(trim(encoded_str))\n\n        if (trim(decoded_str) /= trim(str)) then\n            write(*,*) "Assertion failed: decoded string does not match original"\n            stop 1\n        end if\n    end do\ncontains\n    function encode_rot13(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 5 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function encode_rot13\n\n    function decode_rot13(s) result(out)\n        character(len=*), intent(in) :: s\n       
\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: " << result << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = "AEIOUaeiou";\n    string result = "";\n    for (int i = 0; i < text.length(); i++) {\n        bool is_vowel = false;\n        for (int j = 0; j < vowels.length(); j++) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            result += text[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    string text = "abcdef//nghijklm";\n    string result = remove_vowels(text);\n    cout << "Result: "
\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_threshold(const vector<int>& l, int t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  vector<int> l = {1, 2, 4, 10};\n  int t = 100;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 5;\n  if (below_threshold(l, t)) {\n    cout << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 21;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 22;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << endl;\n    return 1;\n  }\n\n  l = {1, 8, 4, 10};\n  t = 11;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << endl;\n    return 1;\n  }\n\n  l = {1, 8, 4, 10};\n  t = 10;\n  if (below_threshold(l, t)) {\n    cout << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << endl;\n    return 1;\n  }\n\n  return 0;\n}\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_threshold(const vector<int>& l, int t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  vector<int> l = {1, 2, 4, 10};\n  int t = 100;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 5;\n  if (below_threshold(l, t)) {\n    cout << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 21;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 22;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << endl;\n    return 1;\n  }\n\n  l = {1, 8, 4, 10};\n  t = 11;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << endl;\n    return 1;\n  }\n\n  l = {1, 8, 4, 10};\n  t = 10;\n  if (below_threshold(l, t)) {\n    cout << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << endl;\n    return 1;\n  }\n\n  return 0;\n}\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_threshold(const vector<int>& l, int t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  vector<int> l = {1, 2, 4, 10};\n  int t = 100;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 5;\n  if (below_threshold(l, t)) {\n    cout << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 21;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 22;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << endl;\n    return 1;\n  }\n\n  l = {1, 8, 4, 10};\n  t = 11;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << endl;\n    return 1;\n  }\n\n  l = {1, 8, 4, 10};\n  t = 10;\n  if (below_threshold(l, t)) {\n    cout << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << endl;\n    return 1;\n  }\n\n  return 0;\n}\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_threshold(const vector<int>& l, int t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  vector<int> l = {1, 2, 4, 10};\n  int t = 100;\n  if (!below_threshold(l, t)) {\n    cout << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << endl;\n    return 1;\n  }\n\n  l = {1, 20, 4, 10};\n  t = 5;\n  if (below_threshold(l,
\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    integer :: i, x, y\n    real :: rand_val\n\n    ! Assertions\n    if (add(0, 1) /= 1) then\n        write(*,*) "Assertion failed: add(0, 1) == 1"\n        call exit(1)\n    end if\n\n    if (add(1, 0) /= 1) then\n        write(*,*) "Assertion failed: add(1, 0) == 1"\n        call exit(1)\n    end if\n\n    if (add(2, 3) /= 5) then\n        write(*,*) "Assertion failed: add(2, 3) == 5"\n        call exit(1)\n    end if\n\n    if (add(5, 7) /= 12) then\n        write(*,*) "Assertion failed: add(5, 7) == 12"\n        call exit(1)\n    end if\n\n    if (add(7, 5) /= 12) then\n        write(*,*) "Assertion failed: add(7, 5) == 12"\n        call exit(1)\n    end if\n\n    ! Loop with random number generation and assertions\n    do i = 1, 100\n        call random_number(rand_val)\n        x = int(rand_val * 1000)\n        call random_number(rand_val)\n        y = int(rand_val * 1000)\n        if (add(x, y) /= x + y) then\n            write(*,*) "Assertion failed: add(", x, ", ", y, ") == ", x + y\n            call exit(1)\n        end if\n    end do\n\ncontains\n\n    integer function add(x, y)\n        integer, intent(in) :: x, y\n        add = x + y\n    end function add\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    integer :: i, x, y\n    real :: rand_val\n\n    ! Assertions\n    if (add(0, 1) /= 1) then\n        write(*,*) "Assertion failed: add(0, 1) == 1"\n        call exit(1)\n    end if\n\n    if (add(1, 0) /= 1) then\n        write(*,*) "Assertion failed: add(1, 0) == 1"\n        call exit(1)\n    end if\n\n    if (add(2, 3) /= 5) then\n        write(*,*) "Assertion failed: add(2, 3) == 5"\n        call exit(1)\n    end if\n\n    if (add(5, 7) /= 12) then\n        write(*,*) "Assertion failed: add(5, 7) == 12"\n        call exit(1)\n    end if\n\n    if (add(7, 5) /= 12) then\n        write(*,*) "Assertion failed: add(7, 5) == 12"\n        call exit(1)\n    end if\n\n    ! Loop with random number generation and assertions\n    do i = 1, 100\n        call random_number(rand_val)\n        x = int(rand_val * 1000)\n        call random_number(rand_val)\n        y = int(rand_val * 1000)\n        if (add(x, y) /= x + y) then\n            write(*,*) "Assertion failed: add(", x, ", ", y, ") == ", x + y\n            call exit(1)\n        end if\n    end do\n\ncontains\n\n    integer function add(x, y)\n        integer, intent(in) :: x, y\n        add = x + y\n    end function add\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    integer :: i, x, y\n    real :: rand_val\n\n    ! Assertions\n    if (add(0, 1) /= 1) then\n        write(*,*) "Assertion failed: add(0, 1) == 1"\n        call exit(1)\n    end if\n\n    if (add(1, 0) /= 1) then\n        write(*,*) "Assertion failed: add(1, 0) == 1"\n        call exit(1)\n    end if\n\n    if (add(2, 3) /= 5) then\n        write(*,*) "Assertion failed: add(2, 3) == 5"\n        call exit(1)\n    end if\n\n    if (add(5, 7) /= 12) then\n        write(*,*) "Assertion failed: add(5, 7) == 12"\n        call exit(1)\n    end if\n\n    if (add(7, 5) /= 12) then\n        write(*,*) "Assertion failed: add(7, 5) == 12"\n        call exit(1)\n    end if\n\n    ! Loop with random number generation and assertions\n    do i = 1, 100\n        call random_number(rand_val)\n        x = int(rand_val * 1000)\n        call random_number(rand_val)\n        y = int(rand_val * 1000)\n        if (add(x, y) /= x + y) then\n            write(*,*) "Assertion failed: add(", x, ", ", y, ") == ", x + y\n            call exit(1)\n        end if\n    end do\n\ncontains\n\n    integer function add(x, y)\n        integer, intent(in) :: x, y\n        add = x + y\n    end function add\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    integer :: i, x, y\n    real :: rand_val\n\n    ! Assertions\n    if (add(0, 1) /= 1) then\n        write(*,*) "Assertion failed: add(0, 1) == 1"\n        call exit(1)\n    end if\n\n    if (add(1, 0) /= 1) then\n        write(*,*) "Assertion failed: add(1, 0) == 1"\n        call exit(1)\n    end if\n\n    if (add(2, 3) /= 5) then\n        write(*,*) "Assertion failed: add(2, 3) == 5"\n        call exit(1)\n    end if\n\n    if (add(5, 7) /= 12) then\n        write(*,*) "Assertion failed: add(5, 7) == 12"\n        call exit(1)\n    end if\n\n    if (add(7, 5) /= 12) then\n        write(*,*) "Assertion failed: add(7, 5) == 12"\n        call exit(1)\n    end if\n\n    ! Loop with random number generation and assertions\n    do i = 1, 100\n        call random_number(rand_val)\n        x = int(rand_val * 1000)\n        call random_number(rand_val)\n        y = int(rand_val * 1000)\n        if (add(x, y) /= x + y) then\n            write(*,*) "Assertion failed: add(", x, ", ", y, ") == ", x + y\n            call exit(1)\n        end if\n    end do\n\ncontains\n\n    integer function add(x, y)\n        integer, intent(in) :: x, y\n        add = x + y\n    end function add\n\nend program main [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram main\n    implicit none\n    integer :: i, x, y\n    real :: rand_val\n\n    ! Assertions\n    if (add(0, 1) /= 1) then\n        write(*,*) "Assertion failed: add(0, 1) == 1"\n        call exit(1)\n    end if\n\n    if (add(1, 0) /
\n\n[CPP]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nbool same_chars(const std::string &s0, const std::string &s1) {\n    for (size_t i = 0; i < s0.size(); ++i) {\n        if (s1.find(s0[i]) == std::string::npos) {\n            return false;\n        }\n    }\n\n    for (size_t i = 0; i < s1.size(); ++i) {\n        if (s0.find(s1[i]) == std::string::npos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    if (!same_chars("eabcdzzzz", "dddzzzzzzzddeddabc")) {\n        std::cerr << "Assertion failed: same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!same_chars("abcd", "dddddddabc")) {\n        std::cerr << "Assertion failed: same_chars(\"abcd\", \"dddddddabc\") == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!same_chars("dddddddabc", "abcd")) {\n        std::cerr << "Assertion failed: same_chars(\"dddddddabc\", \"abcd\") == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (same_chars("eabcd", "dddddddabc")) {\n        std::cerr << "Assertion failed: same_chars(\"eabcd\", \"dddddddabc\") == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (same_chars("abcd", "dddddddabcf")) {\n        std::cerr << "Assertion failed: same_chars(\"abcd\", \"dddddddabcf\") == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (same_chars("eabcdzzzz", "dddzzzzzzzddddabc")) {\n        std::cerr << "Assertion failed: same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (same_chars("aabb", "aaccc")) {\n        std::cerr << "Assertion failed: same_chars(\"aabb\", \"aaccc\") == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\n[Fortran]\nprogram main\n    implicit none\n    logical :: result\n\n    ! Declare the function interface\n    interface\n        logical function same_chars(s0, s1)\n            character(len=*), intent(in) :: s0, s1\n        end function same_chars\n    end interface\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddeddabc")\n    if (.not. result) then\n        write(*,*) "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == true"\n        call exit(1)\n    end if\n\n    result = same_chars("abcd", "dddddddabc")\n    if (.not. result) then\n        write(*,*) "Assertion failed: same_chars('abcd', 'dddddddabc') == true"\n        call exit(1)\n    end if\n\n    result = same_chars("dddddddabc", "abcd")\n    if (.not. result) then\n        write(*,*) "Assertion failed: same_chars('dddddddabc', 'abcd') == true"\n        call exit(1)\n    end if\n\n    result = same_chars("eabcd", "dddddddabc")\n    if (result) then\n        write(*,*) "Assertion failed: same_chars('eabcd', 'dddddddabc') == false"\n        call exit(1)\n    end if\n\n    result = same_chars("abcd", "dddddddabcf")\n    if (result) then\n        write(*,*) "Assertion failed: same_chars('abcd', 'dddddddabcf') == false"\n        call exit(1)\n    end if\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddddabc")\n    if (result) then\n        write(*,*) "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == false"\n        call exit(1)\n    end if\n\n    result = same_chars("aabb", "aaccc")\n    if (result) then\n        write(*,*) "Assertion failed: same_chars('aabb', 'aaccc') == false"\n        call exit(1)\n    end if\n\n    write(*,*) "All assertions passed."\nend program main\n\nlogical function same_chars(s0, s1)\n    implicit none\n    character(len=*), intent(in) :: s0, s1\n    integer :: i\n\n    do i = 1, len_trim(s0)\n        if (index(s1, s0(i:i)) == 0) then\n            same_chars = .false.\n            return\n        end if\n    end do\n\n    do i = 1, len_trim(s1)\n        if (index(s0, s1(i:i)) == 0) then\n            same_chars = .false.\n            return\n        end if\n    end do\n\n    same_chars = .true.\nend function same_chars [/Fortran]\n\n[C]\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nbool same_chars(const char *s0, const char *s1) {\n    size_t i;\n\n    for (i = 0; i < strlen(s0); ++i) {\n        if (strchr(s1, s0[i]) == NULL) {\n            return false;\n        }\n    }\n\n    for (i = 0; i < strlen(s1); ++i) {\n        if (strchr(s0, s1[i]) == NULL) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    if (!same_chars("eabcdzzzz", "dddzzzzzzzddeddabc")) {\n        fprintf(stderr, "Assertion failed: same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true\n");\n        exit(1);\n    }\n\n    if (!same_chars("abcd", "dddddddabc")) {\n        fprintf(stderr, "Assertion failed: same_chars(\"abcd\", \"dddddddabc\") == true\n");\n        exit(1);\n    }\n\n    if (!same_chars("dddddddabc", "abcd")) {\n        fprintf(stderr, "Assertion failed: same_chars(\"dddddddabc\", \"abcd\") == true\n");\n        exit(1);\n    }\n\n    if (same_chars("eabcd", "dddddddabc")) {\n        fprintf(stderr, "Assertion failed: same_chars(\"eabcd\", \"dddddddabc\") == false\n");\n        exit(1);\n    }\n\n    if (same_chars("abcd", "dddddddabcf")) {\n        fprintf(stderr, "Assertion failed: same_chars(\"abcd\", \"dddddddabcf\") == false\n");\n        exit(1);\n    }\n\n    if (same_chars("eabcdzzzz", "dddzzzzzzzddddabc")) {\n        fprintf(stderr, "
\n\n[C++]\n#include <iostream>\n\nint fib(int n) {\n  int f[1000];\n  f[1] = 0;\n  f[2] = 1;\n  for (int i = 3; i <= n + 1; i++) {\n    f[i] = f[i-1] + f[i-2];\n  }\n  return f[n+1];\n}\n\nint main() {\n  int result;\n\n  // Test cases\n  result = fib(10);\n  if (result != 55) {\n    std::cout << "fib(10) == 55: assertion failed" << std::endl;\n    return 1;\n  }\n\n  result = fib(1);\n  if (result != 1) {\n    std::cout << "fib(1) == 1: assertion failed" << std::endl;\n    return 1;\n  }\n\n  result = fib(8);\n  if (result != 21) {\n    std::cout << "fib(8) == 21: assertion failed" << std::endl;\n    return 1;\n  }\n\n  result = fib(11);\n  if (result != 89) {\n    std::cout << "fib(11) == 89: assertion failed" << std::endl;\n    return 1;\n  }\n\n  result = fib(12);\n  if (result != 144) {\n    std::cout << "fib(12) == 144: assertion failed" << std::endl;\n    return 1;\n  }\n\n  std::cout << "All tests passed successfully." << std::endl;\n\n  return 0;\n}\n[/C++]\n\n[C]\n#include <stdio.h>\n\nint fib(int n) {\n  int f[1000];\n  f[1] = 0;\n  f[2] = 1;\n  for (int i = 3; i <= n + 1; i++) {\n    f[i] = f[i-1] + f[i-2];\n  }\n  return f[n+1];\n}\n\nint main() {\n  int result;\n\n  // Test cases\n  result = fib(10);\n  if (result != 55) {\n    printf("fib(10) == 55: assertion failed\n");\n    return 1;\n  }\n\n  result = fib(1);\n  if (result != 1) {\n    printf("fib(1) == 1: assertion failed\n");\n    return 1;\n  }\n\n  result = fib(8);\n  if (result != 21) {\n    printf("fib(8) == 21: assertion failed\n");\n    return 1;\n  }\n\n  result = fib(11);\n  if (result != 89) {\n    printf("fib(11) == 89: assertion failed\n");\n    return 1;\n  }\n\n  result = fib(12);\n  if (result != 144) {\n    printf("fib(12) == 144: assertion failed\n");\n    return 1;\n  }\n\n  printf("All tests passed successfully.\n");\n\n  return 0;\n}\n[/C]\n\n[Go]\npackage main\n\nimport "fmt"\n\nfunc fib(n int) int {\n  f := make([]int, 1000)\n  f[1] = 0\n  f[2] = 1\n  for i := 3; i <= n + 1; i++ {\n    f[i] = f[i-1] + f[i-2]\n  }\n  return f[n+1]\n}\n\nfunc main() {\n  result := fib(10)\n  if result != 55 {\n    fmt.Printf("fib(10) == 55: assertion failed\n")\n  }\n\n  result = fib(1)\n  if result != 1 {\n    fmt.Printf("fib(1) == 1: assertion failed\n")\n  }\n\n  result = fib(8)\n  if result != 21 {\n    fmt.Printf("fib(8) == 21: assertion failed\n")\n  }\n\n  result = fib(11)\n  if result != 89 {\n    fmt.Printf("fib(11) == 89: assertion failed\n")\n  }\n\n  result = fib(12)\n  if result != 144 {\n    fmt.Printf("fib(12) == 144: assertion failed\n")\n  }\n\n  fmt.Printf("All tests passed successfully.\n")\n}\n[/Go]\n\n[Java]\npublic class Fibonacci {\n  public static void main(String[] args) {\n    int result;\n\n    // Test cases\n    result = fib(10);\n    if (result != 55) {\n      System.out.println("fib(10) == 55: assertion failed");\n      System.exit(1);\n    }\n\n    result = fib(1);\n    if (result != 1) {\n      System.out.println("fib(1) == 1: assertion failed");\n      System.exit(1);\n    }\n\n    result = fib(8);\n    if (result != 21) {\n      System.out.println("fib(8) == 21: assertion failed");\n      System.exit(1);\n    }\n\n    result = fib(11);\n    if (result != 89) {\n      System.out.println("fib(11) == 89: assertion failed");\n      System.exit(1);\n    }\n\n    result = fib(12);\n    if (result != 144) {\n      System.out.println("fib(12) == 144: assertion failed");\n      System.exit(1);\n    }\n\n    System.out.println("All tests passed successfully.");\n  }\n\n  public static int fib(int n) {\n    int[] f = new int[1000];\n    f[1] = 0;\n    f[2] = 1;\n    for (int i = 3; i <= n + 1; i++) {\n      f[i] = f[i-1] + f[i-2];\n    }\n    return f[n+1];\n  }\n}\n[/Java]\n\n[JavaScript]\nfunction fib(n) {\n  var f = [0, 1];\n  for (var i = 2; i <= n + 1; i++) {\n    f[i] = f[i-1] + f[i-2];\n  }\n  return f[n+1];\n}\n\nfunction main() {\n  var result;\n\n  // Test cases\n  result = fib(10);\n  if (result != 55) {\n    console.log("fib(10) == 55: assertion failed");\n    process.exit(1);\n  }\n\n  result = fib(1);\n  if (result != 1) {\n    console.log("fib(1) == 1: assertion failed");\n    process.exit(1);\n  }\n\n  result = fib(8);\n  if (result != 21) {\n    console.log("fib(8) == 21: assertion failed");\n    process.exit(1);\n  }\n\n  result = fib(11);\n  if (result != 89) {\n    console.log("fib(11) == 89: assertion failed");\n    process.exit(1);\n  }\n\n  result = fib(12);\n  if (result != 144) {\n    console.log("fib(12) == 144: assertion failed");\n    process.exit(1);\n  }\n\n  console.log("All tests passed successfully.");\n}\n\nmain();\n[/JavaScript]\n\n[PHP]\n<?php\nfunction fib($n) {\n  $f = [0, 1];\n  for ($i = 2; $i <= $n + 1; $i++) {\n    $f[$i] = $f[$i-1] + $f[$i-
\n\n// clang-format on\n\n#include "test_runner.h"\n\n#include <vector>\n\nusing std::vector;\n\nbool IsMonotonic(const vector<double>& l) {\n  bool incr = false;\n  bool decr = false;\n  for (size_t i = 1; i < l.size(); ++i) {\n    if (l[i] > l[i - 1]) {\n      incr = true;\n    }\n    if (l[i] < l[i - 1]) {\n      decr = true;\n    }\n  }\n  return !(incr && decr);\n}\n\nvoid Test() {\n  vector<double> l = {1.0, 2.0, 4.0, 10.0};\n  ASSERT_EQUAL(IsMonotonic(l), true);\n  l = {1.0, 2.0, 4.0, 20.0};\n  ASSERT_EQUAL(IsMonotonic(l), true);\n  l = {1.0, 20.0, 4.0, 10.0};\n  ASSERT_EQUAL(IsMonotonic(l), false);\n  l = {4.0, 1.0, 0.0, -10.0};\n  ASSERT_EQUAL(IsMonotonic(l), true);\n  l = {4.0, 1.0, 1.0, 0.0};\n  ASSERT_EQUAL(IsMonotonic(l), true);\n  l = {1.0, 2.0, 3.0, 2.0, 5.0, 60.0};\n  ASSERT_EQUAL(IsMonotonic(l), false);\n  l = {1.0, 2.0, 3.0, 4.0, 5.0, 60.0};\n  ASSERT_EQUAL(IsMonotonic(l), true);\n  l = {9.0, 9.0, 9.0, 9.0};\n  ASSERT_EQUAL(IsMonotonic(l), true);\n}\n\nint main() {\n  TestRunner tr;\n  RUN_TEST(tr, Test);\n  return 0;\n}\n\n/*\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid common(vector<int> l1, vector<int> l2, vector<int> &out) {\n    vector<int> temp;\n    int n = 0;\n    bool found;\n\n    for (int i = 0; i < l1.size(); i++) {\n        found = false;\n        for (int j = 0; j < n; j++) {\n            if (temp[j] == l1[i]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (any_of(l2.begin(), l2.end(), [&](int x) { return x == l1[i]; })) {\n                n++;\n                temp.push_back(l1[i]);\n            }\n        }\n    }\n\n    if (n > 0) {\n        sort(temp.begin(), temp.end());\n        out = temp;\n    } else {\n        out.clear();\n    }\n}\n\nint main() {\n    vector<int> l1 = {1, 4, 3, 34, 653, 2, 5};\n    vector<int> l2 = {5, 7, 1, 5, 9, 653, 121};\n    vector<int> result;\n    vector<int> expected = {1, 5, 653};\n    common(l1, l2, result);\n    if (result != expected) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    l1 = {5, 3, 2, 8};\n    l2 = {3, 2};\n    expected = {2, 3};\n    common(l1, l2, result);\n    if (result != expected) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    l1 = {4, 3, 2, 8};\n    l2 = {3, 2, 4};\n    expected = {2, 3, 4};\n    common(l1, l2, result);\n    if (result != expected) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    l1 = {4, 3, 2, 8};\n    l2.clear();\n    expected.clear();\n    common(l1, l2, result);\n    if (result != expected) {\n        cout << "Test case 4 failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed" << endl;\n    return 0;\n}\n```\n\n### 3.2.2.3 循环变量\n\n```\n[Fortran]\ndo i = 1, 10\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    cout << i << endl;\n}\n```\n\n### 3.2.2.4 循环控制\n\n```\n[Fortran]\ndo i = 1, 10\n    if (i == 5) exit\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) break;\n    cout << i << endl;\n}\n```\n\n### 3.2.2.5 循环嵌套\n\n```\n[Fortran]\ndo i = 1, 10\n    do j = 1, 10\n        print *, i, j\n    end do\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    for (int j = 1; j <= 10; j++) {\n        cout << i << " " << j << endl;\n    }\n}\n```\n\n### 3.2.2.6 循环中的分支\n\n```\n[Fortran]\ndo i = 1, 10\n    if (i == 5) exit\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) break;\n    cout << i << endl;\n}\n```\n\n### 3.2.2.7 循环中的循环\n\n```\n[Fortran]\ndo i = 1, 10\n    do j = 1, 10\n        print *, i, j\n    end do\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    for (int j = 1; j <= 10; j++) {\n        cout << i << " " << j << endl;\n    }\n}\n```\n\n### 3.2.2.8 循环中的分支\n\n```\n[Fortran]\ndo i = 1, 10\n    if (i == 5) exit\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) break;\n    cout << i << endl;\n}\n```\n\n### 3.2.2.9 循环中的循环\n\n```\n[Fortran]\ndo i = 1, 10\n    do j = 1, 10\n        print *, i, j\n    end do\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    for (int j = 1; j <= 10; j++) {\n        cout << i << " " << j << endl;\n    }\n}\n```\n\n### 3.2.2.10 循环中的分支\n\n```\n[Fortran]\ndo i = 1, 10\n    if (i == 5) exit\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) break;\n    cout << i << endl;\n}\n```\n\n### 3.2.2.11 循环中的循环\n\n```\n[Fortran]\ndo i = 1, 10\n    do j = 1, 10\n        print *, i, j\n    end do\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    for (int j = 1; j <= 10; j++) {\n        cout << i << " " << j << endl;\n    }\n}\n```\n\n### 3.2.2.12 循环中的分支\n\n```\n[Fortran]\ndo i = 1, 10\n    if (i == 5) exit\n    print *, i\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) break;\n    cout << i << endl;\n}\n```\n\n### 3.2.2.13 循环中的循环\n\n```\n[Fortran]\ndo i = 1, 10\n    do j = 1, 10\n        print *, i, j\n    end do\nend do\n\n[C++]\nfor (int i = 1; i <= 10; i++) {\n    for (int j = 1; j <= 10; j++) {\n        cout << i << " " << j << endl;\n    }\n}\n```\n\n### 3.2.2.14 循环中的分支\n\n```\n[Fortran]\ndo i = 1, 10\n    if (i == 5) exit\n    print *, i\nend do\n\n[C
\n\n[SOL]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n  if (largest_prime_factor(15) != 5) {\n    std::cout << "Assertion failed: largest_prime_factor(15) == 5" << std::endl;\n    std::exit(1);\n  }\n\n  if (largest_prime_factor(27) != 3) {\n    std::cout << "Assertion failed: largest_prime_factor(27) == 3" << std::endl;\n    std::exit(1);\n  }\n\n  if (largest_prime_factor(63) != 7) {\n    std::cout << "Assertion failed: largest_prime_factor(63) == 7" << std::endl;\n    std::exit(1);\n  }\n\n  if (largest_prime_factor(330) != 11) {\n    std::cout << "Assertion failed: largest_prime_factor(330) == 11" << std::endl;\n    std::exit(1);\n  }\n\n  if (largest_prime_factor(13195) != 29) {\n    std::cout << "Assertion failed: largest_prime_factor(13195) == 29" << std::endl;\n    std::exit(1);\n  }\n\n  return 0;\n}\n\nint largest_prime_factor(int n) {\n  int num = n;\n  for (int i = 2; i <= sqrt(n); i++) {\n    while (num % i == 0 && num > i) {\n      num /= i;\n    }\n  }\n  return num;\n}\n[/SOL]\n\n[MORAL]\nThe C++ standard library provides a lot of useful functions.\n[/MORAL]\n\n[SOURCE]\nhttps://projecteuler.net/problem=3\n[/SOURCE]\n\n[PROBLEM]\nFind the largest prime factor of the number 600851475143.\n[/PROBLEM]\n\n[SOLUTION]\n[INST]\nprogram main\n  implicit none\n\n  integer :: n, largest_prime_factor\n\n  n = 600851475143\n  largest_prime_factor = largest_prime_factor_of(n)\n  write(*,*) "Largest prime factor of ", n, " is ", largest_prime_factor\n\ncontains\n\n  integer function largest_prime_factor_of(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: i, num\n\n    num = n\n    do i = 2, int(sqrt(real(n)))\n      do while (mod(num, i) == 0 .and. num > i)\n        num = num / i\n      end do\n    end do\n    largest_prime_factor_of = num\n  end function largest_prime_factor_of\n\nend program main [/INST]\n\n[SOL]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n  int n = 600851475143;\n  int largest_prime_factor = largest_prime_factor_of(n);\n  std::cout << "Largest prime factor of " << n << " is " << largest_prime_factor << std::endl;\n  return 0;\n}\n\nint largest_prime_factor_of(int n) {\n  int num = n;\n  for (int i = 2; i <= sqrt(n); i++) {\n    while (num % i == 0 && num > i) {\n      num /= i;\n    }\n  }\n  return num;\n}\n[/SOL]\n\n[MORAL]\nThe C++ standard library provides a lot of useful functions.\n[/MORAL]\n\n[SOURCE]\nhttps://projecteuler.net/problem=3\n[/SOURCE]\n\n[PROBLEM]\nFind the largest prime factor of the number 600851475143.\n[/PROBLEM]\n\n[SOLUTION]\n[INST]\nprogram main\n  implicit none\n\n  integer :: n, largest_prime_factor\n\n  n = 600851475143\n  largest_prime_factor = largest_prime_factor_of(n)\n  write(*,*) "Largest prime factor of ", n, " is ", largest_prime_factor\n\ncontains\n\n  integer function largest_prime_factor_of(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: i, num\n\n    num = n\n    do i = 2, int(sqrt(real(n)))\n      do while (mod(num, i) == 0 .and. num > i)\n        num = num / i\n      end do\n    end do\n    largest_prime_factor_of = num\n  end function largest_prime_factor_of\n\nend program main [/INST]\n\n[SOL]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n  int n = 600851475143;\n  int largest_prime_factor = largest_prime_factor_of(n);\n  std::cout << "Largest prime factor of " << n << " is " << largest_prime_factor << std::endl;\n  return 0;\n}\n\nint largest_prime_factor_of(int n) {\n  int num = n;\n  for (int i = 2; i <= sqrt(n); i++) {\n    while (num % i == 0 && num > i) {\n      num /= i;\n    }\n  }\n  return num;\n}\n[/SOL]\n\n[MORAL]\nThe C++ standard library provides a lot of useful functions.\n[/MORAL]\n\n[SOURCE]\nhttps://projecteuler.net/problem=3\n[/SOURCE]\n\n[PROBLEM]\nFind the largest prime factor of the number 600851475143.\n[/PROBLEM]\n\n[SOLUTION]\n[INST]\nprogram main\n  implicit none\n\n  integer :: n, largest_prime_factor\n\n  n = 600851475143\n  largest_prime_factor = largest_prime_factor_of(n)\n  write(*,*) "Largest prime factor of ", n, " is ", largest_prime_factor\n\ncontains\n\n  integer function largest_prime_factor_of(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: i, num\n\n    num = n\n    do i = 2, int(sqrt(real(n)))\n      do while (mod(num, i) == 0 .and. num > i)\n        num = num / i\n      end do\n    end do\n    largest_prime_factor_of = num\n  end function largest_prime_factor_of\n\nend program main [/INST]\n\n[SOL]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n  int n = 600851475143;\n  int largest_prime_factor = largest_prime_factor_of(n);\n  std::cout << "Largest prime factor of " << n << " is " << largest_prime_factor << std::endl;\n  return 0;\n}\n\nint largest_prime_factor_of(int n) {\n  int num = n;\n  for (int i = 2; i <= sqrt(n); i++) {\n    while (num % i == 0 && num > i) {\n      num /= i;\n    }\n  }\n  return num;\n}\n[/SOL]\n\n[MORAL]\nThe C++ standard library provides a lot of useful functions.\n[/MORAL]\n\n[SOURCE]\nhttps://projecteuler.net/problem=3\n[/SOURCE]\n\n[PROBLEM]\nFind the largest prime factor of the number 600851475143.\n[/PROBLEM]\n\n[SOLUTION]\n[INST]\nprogram
\n\n[SOLUTION]\n#include <iostream>\n\nint main() {\n  if (sum_to_n(1) != 1) {\n    std::cout << "sum_to_n(1) == 1: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_to_n(6) != 21) {\n    std::cout << "sum_to_n(6) == 21: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_to_n(11) != 66) {\n    std::cout << "sum_to_n(11) == 66: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_to_n(30) != 465) {\n    std::cout << "sum_to_n(30) == 465: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_to_n(100) != 5050) {\n    std::cout << "sum_to_n(100) == 5050: assertion failed" << std::endl;\n    return 1;\n  }\n\n  return 0;\n}\n\nint sum_to_n(int n) {\n  return n * (n + 1) / 2;\n}\n[/SOLUTION]\n\n[CHALLENGE]\nWrite a function that takes a number and returns the sum of all numbers from 1 to that number.\n\nFor example, sum_to_n(6) should return 21, because 1 + 2 + 3 + 4 + 5 + 6 = 21.\n\n[/CHALLENGE]\n\n[META]\nentity;\n[/META]\n\n[DESCRIPTION]\nYou will be given a number n, and you should return the sum of all numbers from 1 to n.\n\nFor example, sum_to_n(6) should return 21, because 1 + 2 + 3 + 4 + 5 + 6 = 21.\n\n[/DESCRIPTION]\n\n[INPUT]\nn: an integer\n[/INPUT]\n\n[OUTPUT]\nThe sum of all numbers from 1 to n.\n[/OUTPUT]\n\n[IO]\nExample 1:\n\nInput:\n1\n\nOutput:\n1\n\nExample 2:\n\nInput:\n6\n\nOutput:\n21\n\nExample 3:\n\nInput:\n11\n\nOutput:\n66\n\nExample 4:\n\nInput:\n30\n\nOutput:\n465\n\nExample 5:\n\nInput:\n100\n\nOutput:\n5050\n[/IO]\n\n[REFERENCE]\n[/REFERENCE]\n\n[TEST]\n[/TEST]\n\n[CATEGORY]\nFunctions\n[/CATEGORY]\n\n[TAGS]\nfunctions, arithmetic\n[/TAGS]\n\n[SOURCE]\n\n[/SOURCE]\n\n[/QUESTION]\n\n\n[QUESTION]\n[TITLE]\nWrite a function that takes two numbers and returns the sum of all numbers between them.\n[/TITLE]\n\n[INST]\nprogram main\n  implicit none\n\n  ! Assertions\n  if (sum_between(1, 1) /= 1) then\n    write(*,*) "sum_between(1, 1) == 1: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(1, 6) /= 21) then\n    write(*,*) "sum_between(1, 6) == 21: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(1, 11) /= 66) then\n    write(*,*) "sum_between(1, 11) == 66: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(1, 30) /= 465) then\n    write(*,*) "sum_between(1, 30) == 465: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(1, 100) /= 5050) then\n    write(*,*) "sum_between(1, 100) == 5050: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(6, 11) /= 36) then\n    write(*,*) "sum_between(6, 11) == 36: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(11, 30) /= 244) then\n    write(*,*) "sum_between(11, 30) == 244: assertion failed"\n    call exit(1)\n  end if\n\n  if (sum_between(30, 100) /= 2650) then\n    write(*,*) "sum_between(30, 100) == 2650: assertion failed"\n    call exit(1)\n  end if\n\ncontains\n\n  ! Function definition\n  integer function sum_between(a, b)\n    integer, intent(in) :: a, b\n    sum_between = (b - a + 1) * (a + b) / 2\n  end function sum_between\n\nend program main [/INST]\n\n[SOLUTION]\n#include <iostream>\n\nint main() {\n  if (sum_between(1, 1) != 1) {\n    std::cout << "sum_between(1, 1) == 1: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(1, 6) != 21) {\n    std::cout << "sum_between(1, 6) == 21: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(1, 11) != 66) {\n    std::cout << "sum_between(1, 11) == 66: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(1, 30) != 465) {\n    std::cout << "sum_between(1, 30) == 465: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(1, 100) != 5050) {\n    std::cout << "sum_between(1, 100) == 5050: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(6, 11) != 36) {\n    std::cout << "sum_between(6, 11) == 36: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(11, 30) != 244) {\n    std::cout << "sum_between(11, 30) == 244: assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (sum_between(30, 100) != 2650) {\n    std::cout << "sum_between(30, 100) == 2650: assertion failed" << std::endl;\n    return 1;\n  }\n\n  return 0;\n}\n\nint sum_between(int a, int b) {\n  return (b - a + 1) * (a + b) / 2;\n}\n[/SOLUTION]\n\n[CHALLENGE]\nWrite a function that takes two numbers and returns the sum of all numbers between them.\n\nFor example, sum_between(1, 6) should return 21, because 1 + 2 + 3 + 4 + 5 + 6 = 21.\n\n[/CHALLENGE]\n\n[META]\nentity;\n[/META]\n\n[DESCRIPTION]\nYou
\n\n[CPP]\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n\nbool correct_bracketing(const std::string& brackets)\n{\n    int level = 0;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            level += 1;\n        } else if (brackets[i] == ')') {\n            level -= 1;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nint main()\n{\n    // Test cases\n    if (!correct_bracketing("()")) {\n        std::fprintf(stderr, "Assertion failed: ()\n");\n        std::exit(1);\n    }\n\n    if (!correct_bracketing("(()())")) {\n        std::fprintf(stderr, "Assertion failed: (()())\n");\n        std::exit(1);\n    }\n\n    if (!correct_bracketing("()()(()())()")) {\n        std::fprintf(stderr, "Assertion failed: ()()(()())()\n");\n        std::exit(1);\n    }\n\n    if (!correct_bracketing("()()((()()())())(()()(()))")) {\n        std::fprintf(stderr, "Assertion failed: ()()((()()())())(()()(()))\n");\n        std::exit(1);\n    }\n\n    if (correct_bracketing("((()())))")) {\n        std::fprintf(stderr, "Assertion failed: ((()())))");\n        std::exit(1);\n    }\n\n    if (correct_bracketing(")(()")) {\n        std::fprintf(stderr, "Assertion failed: )(()");\n        std::exit(1);\n    }\n\n    if (correct_bracketing("(")) {\n        std::fprintf(stderr, "Assertion failed: (");\n        std::exit(1);\n    }\n\n    if (correct_bracketing("((((")) {\n        std::fprintf(stderr, "Assertion failed: ((((");\n        std::exit(1);\n    }\n\n    if (correct_bracketing(")")) {\n        std::fprintf(stderr, "Assertion failed: )");\n        std::exit(1);\n    }\n\n    if (correct_bracketing("(()")) {\n        std::fprintf(stderr, "Assertion failed: (()");\n        std::exit(1);\n    }\n\n    if (correct_bracketing("()()(()())())(()")) {\n        std::fprintf(stderr, "Assertion failed: ()()(()())())(()");\n        std::exit(1);\n    }\n\n    if (correct_bracketing("()()(()())()))()")) {\n        std::fprintf(stderr, "Assertion failed: ()()(()())()))()");\n        std::exit(1);\n    }\n\n    std::printf("All tests passed.\n");\n    return 0;\n}\n[/CPP]\n\n[PY]\ndef correct_bracketing(brackets):\n    level = 0\n    for bracket in brackets:\n        if bracket == '(':\n            level += 1\n        elif bracket == ')':\n            level -= 1\n        if level < 0:\n            return False\n    return level == 0\n\n\nif __name__ == '__main__':\n    # Test cases\n    assert correct_bracketing("()")\n    assert correct_bracketing("(()())")\n    assert correct_bracketing("()()(()())()")\n    assert correct_bracketing("()()((()()())())(()()(()))")\n    assert not correct_bracketing("((()())))")\n    assert not correct_bracketing(")(()")\n    assert not correct_bracketing("(")\n    assert not correct_bracketing("((((")\n    assert not correct_bracketing(")")\n    assert not correct_bracketing("(()")\n    assert not correct_bracketing("()()(()())())(()")\n    assert not correct_bracketing("()()(()())()))()")\n    print("All tests passed.")\n[/PY]\n\n[JAVA]\nimport java.util.Scanner;\n\npublic class CorrectBracketing {\n    public static boolean correctBracketing(String brackets) {\n        int level = 0;\n        for (int i = 0; i < brackets.length(); i++) {\n            if (brackets.charAt(i) == '(') {\n                level++;\n            } else if (brackets.charAt(i) == ')') {\n                level--;\n            }\n            if (level < 0) {\n                return false;\n            }\n        }\n        return level == 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String brackets = scanner.nextLine();\n        System.out.println(correctBracketing(brackets));\n    }\n}\n[/JAVA]\n\n[RUBY]\ndef correct_bracketing(brackets)\n    level = 0\n    brackets.each_char do |bracket|\n        if bracket == '('\n            level += 1\n        elsif bracket == ')'\n            level -= 1\n        end\n        return false if level < 0\n    end\n    level == 0\nend\n\nif __FILE__ == $0\n    # Test cases\n    assert correct_bracketing('()')\n    assert correct_bracketing('(()())')\n    assert correct_bracketing('()()(()())()')\n    assert correct_bracketing('()()((()()())())(()()(()))')\n    assert !correct_bracketing('((()())))')\n    assert !correct_bracketing(')(()')\n    assert !correct_bracketing('(')\n    assert !correct_bracketing('((((')\n    assert !correct_bracketing(')')\n    assert !correct_bracketing('(()')\n    assert !correct_bracketing('()()(()())())(()')\n    assert !correct_bracketing('()()(()())()))()')\n    puts 'All tests passed'\nend\n[/RUBY]\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool correct_bracketing(const char* brackets)\n{\n    int level = 0;\n    for (size_t i = 0; i < strlen(brackets); ++i) {\n        if (brackets[i] == '(') {\n            level += 1;\n        } else if (brackets[i] == ')') {\n            level -= 1;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nint main(void)\n{\n    // Test cases\n    if (!correct_bracketing("()")) {\n        fprintf(stderr, "Assertion failed: ()\n");\n        return 1;\n    }\n\n    if (!correct_bracketing("(()())")) {\n        fprintf(stderr, "Assertion failed: (()())\n");\n        return 1;\n    }\n\n    if (!correct_bracketing("()()(()())()")) {\n        fprintf(stderr, "Assertion failed: ()()(()())()\n");\n        return 1;\n    }\n\n    if (!correct_bracketing("()()((()()())())(()()(()))")) {\n        fprintf(stderr, "Assertion failed: ()()((()()())())(()()(()))\n");\n        return 1;\n    }\n\n    if (correct_bracketing("((()())))")) {\n        fprintf(stderr, "Assertion failed: ((()())))");\n        return 1;\n    }\n\n    if (correct_bracketing(")(()")) {\n        fprintf(stderr, "Assertion failed: )(()");\n        return 1;\n    }\n\n    if (correct_bracketing("(")) {\n        fprintf(stderr, "Assertion failed: (");\n        return 1;\n    }\n\n    if (correct_bracketing("((((")) {\n        fprintf(stderr, "Assert
\n\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]\n[SKIP]\n[/EXPECTED]\n[EXPECTED]
\n\n[C++]\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    std::string vowels = "aeiouAEIOU";\n    for (int i = 0; i < s.length(); i++) {\n        if (vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n    if (s[s.length() - 1] == 'y' || s[s.length() - 1] == 'Y') {\n        count++;\n    }\n    return count;\n}\n\nint main() {\n    std::string s = "abcde";\n    int count = vowels_count(s);\n    if (count != 2) {\n        std::cout << "Assertion failed for 'abcde'" << std::endl;\n        return 1;\n    }\n\n    s = "Alone";\n    count = vowels_count(s);\n    if (count != 3) {\n        std::cout << "Assertion failed for 'Alone'" << std::endl;\n        return 1;\n    }\n\n    s = "key";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cout << "Assertion failed for 'key'" << std::endl;\n        return 1;\n    }\n\n    s = "bye";\n    count = vowels_count(s);\n    if (count != 1) {\n        std::cout << "Assertion failed for 'bye'" << std::endl;\n        return 1;\n    }\n\n    s = "keY";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cout << "Assertion failed for 'keY'" << std::endl;\n        return 1;\n    }\n\n    s = "bYe";\n    count = vowels_count(s);\n    if (count != 1) {\n        std::cout << "Assertion failed for 'bYe'" << std::endl;\n        return 1;\n    }\n\n    s = "ACEDY";\n    count = vowels_count(s);\n    if (count != 3) {\n        std::cout << "Assertion failed for 'ACEDY'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\n### 2.1.2. 함수 호출\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer :: i\n\n    i = 10\n    call print_i(i)\n\ncontains\n\n    subroutine print_i(i)\n        implicit none\n        integer, intent(in) :: i\n\n        write(*,*) i\n    end subroutine print_i\n\nend program main\n\n[C++]\n#include <iostream>\n\nvoid print_i(int i) {\n    std::cout << i << std::endl;\n}\n\nint main() {\n    int i = 10;\n    print_i(i);\n    return 0;\n}\n```\n\n### 2.1.3. 함수 호출 및 반환\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer :: i\n\n    i = 10\n    i = add_i(i, 20)\n    call print_i(i)\n\ncontains\n\n    function add_i(i, j) result(sum)\n        implicit none\n        integer, intent(in) :: i, j\n        integer :: sum\n\n        sum = i + j\n    end function add_i\n\n    subroutine print_i(i)\n        implicit none\n        integer, intent(in) :: i\n\n        write(*,*) i\n    end subroutine print_i\n\nend program main\n\n[C++]\n#include <iostream>\n\nint add_i(int i, int j) {\n    return i + j;\n}\n\nvoid print_i(int i) {\n    std::cout << i << std::endl;\n}\n\nint main() {\n    int i = 10;\n    i = add_i(i, 20);\n    print_i(i);\n    return 0;\n}\n```\n\n### 2.1.4. 함수 호출 및 반환 2\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer :: i\n\n    i = 10\n    i = add_i(i, 20)\n    call print_i(i)\n\ncontains\n\n    function add_i(i, j) result(sum)\n        implicit none\n        integer, intent(in) :: i, j\n        integer :: sum\n\n        sum = i + j\n    end function add_i\n\n    subroutine print_i(i)\n        implicit none\n        integer, intent(in) :: i\n\n        write(*,*) i\n    end subroutine print_i\n\nend program main\n\n[C++]\n#include <iostream>\n\nint add_i(int i, int j) {\n    return i + j;\n}\n\nvoid print_i(int i) {\n    std::cout << i << std::endl;\n}\n\nint main() {\n    int i = 10;\n    i = add_i(i, 20);\n    print_i(i);\n    return 0;\n}\n```\n\n### 2.1.5. 함수 호출 및 반환 3\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer :: i\n\n    i = 10\n    i = add_i(i, 20)\n    call print_i(i)\n\ncontains\n\n    function add_i(i, j) result(sum)\n        implicit none\n        integer, intent(in) :: i, j\n        integer :: sum\n\n        sum = i + j\n    end function add_i\n\n    subroutine print_i(i)\n        implicit none\n        integer, intent(in) :: i\n\n        write(*,*) i\n    end subroutine print_i\n\nend program main\n\n[C++]\n#include <iostream>\n\nint add_i(int i, int j) {\n    return i + j;\n}\n\nvoid print_i(int i) {\n    std::cout << i << std::endl;\n}\n\nint main() {\n    int i = 10;\n    i = add_i(i, 20);\n    print_i(i);\n    return 0;\n}\n```\n\n### 2.1.6. 함수 호출 및 반환 4\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer :: i\n\n    i = 10\n    i = add_i(i, 20)\n    call print_i(i)\n\ncontains\n\n    function add_i(i, j) result(sum)\n        implicit none\n        integer, intent(in) :: i, j\n        integer :: sum\n\n        sum = i + j\n    end function add_i\n\n    subroutine print_i(i)\n        implicit none\n        integer, intent(in) :: i\n\n        write(*,*) i\n    end subroutine print_i\n\nend program main\n\n[C++]\n#include <iostream>\n\nint add_i(int i, int j) {\n    return i + j;\n}\n\nvoid print_i(int i) {\n    std::cout << i << std::endl;\n}\n\nint main() {\n    int i = 10;\n    i = add_i(i, 20);\n    print_i(i);\n    return 0;\n}\n```\n\n### 2.1.7. 함수 호출 및 반환 5\n\n```\n[Fortran]\nprogram main\n    implicit none\n    integer :: i\n\n    i = 10\n    i = add_i(
\n\n[C++]\n#include <cstdlib>\n#include <string>\n#include <sstream>\n\nint main()\n{\n    std::string result;\n\n    result = circular_shift(100, 2);\n    if (result != "001") {\n        std::cout << "Assertion failed: circular_shift(100, 2) == '001'" << std::endl;\n        return 1;\n    }\n\n    result = circular_shift(12, 2);\n    if (result != "12") {\n        std::cout << "Assertion failed: circular_shift(12, 2) == '12'" << std::endl;\n        return 1;\n    }\n\n    result = circular_shift(97, 8);\n    if (result != "79") {\n        std::cout << "Assertion failed: circular_shift(97, 8) == '79'" << std::endl;\n        return 1;\n    }\n\n    result = circular_shift(12, 1);\n    if (result != "21") {\n        std::cout << "Assertion failed: circular_shift(12, 1) == '21'" << std::endl;\n        return 1;\n    }\n\n    result = circular_shift(11, 101);\n    if (result != "11") {\n        std::cout << "Assertion failed: circular_shift(11, 101) == '11'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nstd::string circular_shift(int x, int shift)\n{\n    std::stringstream ss;\n    std::string xs, shifted;\n    int len_xs, actual_shift;\n\n    ss << x;\n    ss >> xs;\n    len_xs = xs.length();\n\n    if (len_xs < shift) {\n        shifted = reverse_string(xs);\n    } else {\n        actual_shift = shift % len_xs;\n        shifted = xs.substr(len_xs-actual_shift, actual_shift) + xs.substr(0, len_xs-actual_shift);\n    }\n\n    return shifted;\n}\n\nstd::string reverse_string(std::string s)\n{\n    std::string reversed;\n    int i, len_s;\n\n    len_s = s.length();\n    for (i = 0; i < len_s; i++) {\n        reversed += s[len_s-i-1];\n    }\n\n    return reversed;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    char result[100];\n\n    strcpy(result, circular_shift(100, 2));\n    if (strcmp(result, "001") != 0) {\n        printf("Assertion failed: circular_shift(100, 2) == '001'\n");\n        return 1;\n    }\n\n    strcpy(result, circular_shift(12, 2));\n    if (strcmp(result, "12") != 0) {\n        printf("Assertion failed: circular_shift(12, 2) == '12'\n");\n        return 1;\n    }\n\n    strcpy(result, circular_shift(97, 8));\n    if (strcmp(result, "79") != 0) {\n        printf("Assertion failed: circular_shift(97, 8) == '79'\n");\n        return 1;\n    }\n\n    strcpy(result, circular_shift(12, 1));\n    if (strcmp(result, "21") != 0) {\n        printf("Assertion failed: circular_shift(12, 1) == '21'\n");\n        return 1;\n    }\n\n    strcpy(result, circular_shift(11, 101));\n    if (strcmp(result, "11") != 0) {\n        printf("Assertion failed: circular_shift(11, 101) == '11'\n");\n        return 1;\n    }\n\n    printf("All tests passed.\n");\n\n    return 0;\n}\n\nchar *circular_shift(int x, int shift)\n{\n    char xs[100];\n    char shifted[100];\n    int len_xs, actual_shift;\n\n    sprintf(xs, "%d", x);\n    len_xs = strlen(xs);\n\n    if (len_xs < shift) {\n        strcpy(shifted, reverse_string(xs));\n    } else {\n        actual_shift = shift % len_xs;\n        strncpy(shifted, xs+len_xs-actual_shift, actual_shift);\n        strncpy(shifted+actual_shift, xs, len_xs-actual_shift);\n        shifted[len_xs] = '\0';\n    }\n\n    return shifted;\n}\n\nchar *reverse_string(char *s)\n{\n    char *reversed = malloc(strlen(s)+1);\n    int i, len_s;\n\n    len_s = strlen(s);\n    for (i = 0; i < len_s; i++) {\n        reversed[i] = s[len_s-i-1];\n    }\n    reversed[len_s] = '\0';\n\n    return reversed;\n}\n\n[Python]\ndef circular_shift(x, shift):\n    xs = str(x)\n    len_xs = len(xs)\n\n    if len_xs < shift:\n        shifted = reverse_string(xs)\n    else:\n        actual_shift = shift % len_xs\n        shifted = xs[len_xs-actual_shift:] + xs[:len_xs-actual_shift]\n\n    return shifted\n\ndef reverse_string(s):\n    reversed = s[::-1]\n    return reversed\n\ndef main():\n    result = circular_shift(100, 2)\n    if result != "001":\n        print("Assertion failed: circular_shift(100, 2) == '001'")\n        exit(1)\n\n    result = circular_shift(12, 2)\n    if result != "12":\n        print("Assertion failed: circular_shift(12, 2) == '12'")\n        exit(1)\n\n    result = circular_shift(97, 8)\n    if result != "79":\n        print("Assertion failed: circular_shift(97, 8) == '79'")\n        exit(1)\n\n    result = circular_shift(12, 1)\n    if result != "21":\n        print("Assertion failed: circular_shift(12, 1) == '21'")\n        exit(1)\n\n    result = circular_shift(11, 101)\n    if result != "11":\n        print("Assertion failed: circular_shift(11, 101) == '11'")\n        exit(1)\n\n    print("All tests passed.")\n\nif __name__ == "__main__":\n    main()\n\n[Ruby]\ndef circular_shift(x, shift)\n    xs = x.to_s\n    len_xs = xs.length\n\n    if len_xs < shift\n        shifted = reverse_string(xs)\n    else\n        actual_shift = shift % len_xs\n        shifted = xs[len_xs-actual_shift..len_xs-1] + xs[0..len_xs-actual_shift-1]\n    end\n\n    return shifted\nend\n\ndef reverse_string(s)\n    reversed = s.reverse\n    return reversed\nend\n\ndef main\n    result = circular_shift(100, 2)\n    if result != "001"\n        puts "Assertion failed: circular_shift(100, 2) == '001'"\n        exit(1)\n    end\n\n    result = circular_shift(12, 2)\n    if result != "12"\n        puts "Assertion failed: circular_shift(12, 
\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string &s) {\n    int digitSum = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            digitSum += s[i];\n        }\n    }\n    return digitSum;\n}\n\nint main() {\n    if (digitSum("") != 0) {\n        cout << "Assertion failed: digitSum('') == 0" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abAB") != 131) {\n        cout << "Assertion failed: digitSum('abAB') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abcCd") != 67) {\n        cout << "Assertion failed: digitSum('abcCd') == 67" << endl;\n        exit(1);\n    }\n\n    if (digitSum("helloE") != 69) {\n        cout << "Assertion failed: digitSum('helloE') == 69" << endl;\n        exit(1);\n    }\n\n    if (digitSum("woArBld") != 131) {\n        cout << "Assertion failed: digitSum('woArBld') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("aAaaaXa") != 153) {\n        cout << "Assertion failed: digitSum('aAaaaXa') == 153" << endl;\n        exit(1);\n    }\n\n    if (digitSum(" How are yOu?") != 151) {\n        cout << "Assertion failed: digitSum(' How are yOu?') == 151" << endl;\n        exit(1);\n    }\n\n    if (digitSum("You arE Very Smart") != 327) {\n        cout << "Assertion failed: digitSum('You arE Very Smart') == 327" << endl;\n        exit(1);\n    }\n\n    cout << "All assertions passed." << endl;\n\n    return 0;\n}\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string &s) {\n    int digitSum = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            digitSum += s[i];\n        }\n    }\n    return digitSum;\n}\n\nint main() {\n    if (digitSum("") != 0) {\n        cout << "Assertion failed: digitSum('') == 0" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abAB") != 131) {\n        cout << "Assertion failed: digitSum('abAB') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abcCd") != 67) {\n        cout << "Assertion failed: digitSum('abcCd') == 67" << endl;\n        exit(1);\n    }\n\n    if (digitSum("helloE") != 69) {\n        cout << "Assertion failed: digitSum('helloE') == 69" << endl;\n        exit(1);\n    }\n\n    if (digitSum("woArBld") != 131) {\n        cout << "Assertion failed: digitSum('woArBld') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("aAaaaXa") != 153) {\n        cout << "Assertion failed: digitSum('aAaaaXa') == 153" << endl;\n        exit(1);\n    }\n\n    if (digitSum(" How are yOu?") != 151) {\n        cout << "Assertion failed: digitSum(' How are yOu?') == 151" << endl;\n        exit(1);\n    }\n\n    if (digitSum("You arE Very Smart") != 327) {\n        cout << "Assertion failed: digitSum('You arE Very Smart') == 327" << endl;\n        exit(1);\n    }\n\n    cout << "All assertions passed." << endl;\n\n    return 0;\n}\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string &s) {\n    int digitSum = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            digitSum += s[i];\n        }\n    }\n    return digitSum;\n}\n\nint main() {\n    if (digitSum("") != 0) {\n        cout << "Assertion failed: digitSum('') == 0" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abAB") != 131) {\n        cout << "Assertion failed: digitSum('abAB') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abcCd") != 67) {\n        cout << "Assertion failed: digitSum('abcCd') == 67" << endl;\n        exit(1);\n    }\n\n    if (digitSum("helloE") != 69) {\n        cout << "Assertion failed: digitSum('helloE') == 69" << endl;\n        exit(1);\n    }\n\n    if (digitSum("woArBld") != 131) {\n        cout << "Assertion failed: digitSum('woArBld') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("aAaaaXa") != 153) {\n        cout << "Assertion failed: digitSum('aAaaaXa') == 153" << endl;\n        exit(1);\n    }\n\n    if (digitSum(" How are yOu?") != 151) {\n        cout << "Assertion failed: digitSum(' How are yOu?') == 151" << endl;\n        exit(1);\n    }\n\n    if (digitSum("You arE Very Smart") != 327) {\n        cout << "Assertion failed: digitSum('You arE Very Smart') == 327" << endl;\n        exit(1);\n    }\n\n    cout << "All assertions passed." << endl;\n\n    return 0;\n}\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string &s) {\n    int digitSum = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            digitSum += s[i];\n        }\n    }\n    return digitSum;\n}\n\nint main() {\n    if (digitSum("") != 0) {\n        cout << "Assertion failed: digitSum('') == 0" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abAB") != 131) {\n        cout << "Assertion failed: digitSum('abAB') == 131" << endl;\n        exit(1);\n    }\n\n    if (digitSum("abcCd") != 67) {\n        cout << "Assertion failed: digitSum('abcCd') == 67" << endl;\n        exit(1);\n    }\n\n    if (digitSum("helloE") != 69) {\n        cout << "Assertion failed: digitSum('helloE') == 69" << endl;\n        exit(1);\n    }\n\n    if (digitSum("woArBld") != 131)
\n\n[C++]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int num1 = 0, num2 = 0, is12 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= '0' && s[i] <= '9') {\n            if (is12 == 0) {\n                num1 = num1 * 10 + (s[i] - '0');\n            } else if (is12 == 1) {\n                num2 = num2 * 10 + (s[i] - '0');\n            }\n        } else if (is12 == 0 && num1 > 0) {\n            is12 = 1;\n        }\n    }\n\n    return n - num1 - num2;\n}\n\nint main() {\n    string s;\n    int n;\n\n    // Test cases\n    s = "5 apples and 6 oranges";\n    n = 19;\n    if (fruit_distribution(s, n) != 8) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    s = "5 apples and 6 oranges";\n    n = 21;\n    if (fruit_distribution(s, n) != 10) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    s = "0 apples and 1 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    s = "1 apples and 0 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        cout << "Test case 4 failed" << endl;\n        return 1;\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 100;\n    if (fruit_distribution(s, n) != 95) {\n        cout << "Test case 5 failed" << endl;\n        return 1;\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 5;\n    if (fruit_distribution(s, n) != 0) {\n        cout << "Test case 6 failed" << endl;\n        return 1;\n    }\n\n    s = "1 apples and 100 oranges";\n    n = 120;\n    if (fruit_distribution(s, n) != 19) {\n        cout << "Test case 7 failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed" << endl;\n    return 0;\n}\n```\n\n### 2.2.2. 알고리즘 분석\n\n#### 2.2.2.1. 시간 복잡도\n\n- 입력 크기: `n`\n- 시간 복잡도: `O(n)`\n\n#### 2.2.2.2. 공간 복잡도\n\n- 입력 크기: `n`\n- 공간 복잡도: `O(n)`\n\n### 2.2.3. 프로그래밍 팁\n\n- 문자열 처리 함수: `string::length()`, `string::substr()`, `string::find()`\n- 문자열 변환 함수: `stringstream::strtoi()`\n\n## 2.3. 풀이 별 프로그래밍 팁\n\n### 2.3.1. C++\n\n- 문자열 처리 함수: `string::length()`, `string::substr()`, `string::find()`\n- 문자열 변환 함수: `stringstream::strtoi()`\n\n### 2.3.2. C\n\n- 문자열 처리 함수: `strlen()`, `strncpy()`, `strstr()`\n- 문자열 변환 함수: `atoi()`\n\n### 2.3.3. Java\n\n- 문자열 처리 함수: `String.length()`, `String.substring()`, `String.indexOf()`\n- 문자열 변환 함수: `Integer.parseInt()`\n\n### 2.3.4. Python\n\n- 문자열 처리 함수: `len()`, `str[:]`, `str.index()`\n- 문자열 변환 함수: `int()`\n\n### 2.3.5. Go\n\n- 문자열 처리 함수: `len()`, `string[:]`, `strings.Index()`\n- 문자열 변환 함수: `strconv.Atoi()`\n\n### 2.3.6. JavaScript\n\n- 문자열 처리 함수: `String.length`, `String.substr()`, `String.indexOf()`\n- 문자열 변환 함수: `parseInt()`\n\n### 2.3.7. Ruby\n\n- 문자열 처리 함수: `String#length`, `String#[]`, `String#index()`\n- 문자열 변환 함수: `Integer()`\n\n### 2.3.8. PHP\n\n- 문자열 처리 함수: `strlen()`, `substr()`, `strstr()`\n- 문자열 변환 함수: `intval()`\n\n### 2.3.9. Swift\n\n- 문자열 처리 함수: `String.count`, `String.prefix()`, `String.firstIndex()`\n- 문자열 변환 함수: `Int()`\n\n### 2.3.10. Rust\n\n- 문자열 처리 함수: `String.len()`, `String.get()`, `String.find()`\n- 문자열 변환 함수: `str::parse()`\n\n### 2.3.11. Kotlin\n\n- 문자열 처리 함수: `String.length`, `String.substring()`, `String.indexOf()`\n- 문자열 변환 함수: `Integer.parseInt()`\n\n### 2.3.12. C#\n\n- 문자열 처리 함수: `String.Length`, `String.Substring()`, `String.IndexOf()`\n- 문자열 변환 함수: `int.Parse()`\n\n### 2.3.13. Visual Basic\n\n- 문자열 처리 함수: `Len()`, `Mid()`, `InStr()`\n- 문자열 변환 함수: `CInt()`\n\n### 2.3.14. Perl\n\n- 문자열 처리 함수: `length()`, `substr()`, `index()`\n- 문자열 변환 함수: `int()`\n\n### 2.3.15. Lua\n\n- 문자열 처리 함수: `string.len()`, `string
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && (result.size() == 0 || arr[i] < result[0])) {\n            result.clear();\n            result.push_back(arr[i]);\n            result.push_back(i-1);\n        }\n    }\n    return result;\n}\n\nint main() {\n    vector<int> arr;\n    vector<int> result;\n\n    // Test cases\n    arr = {4, 2, 3};\n    result = pluck(arr);\n    assert(result == vector<int>({2, 1}));\n\n    arr = {1, 2, 3};\n    result = pluck(arr);\n    assert(result == vector<int>({2, 1}));\n\n    arr = {};\n    result = pluck(arr);\n    assert(result == vector<int>());\n\n    arr = {5, 0, 3, 0, 4, 2};\n    result = pluck(arr);\n    assert(result == vector<int>({0, 1}));\n\n    arr = {1, 2, 3, 0, 5, 3};\n    result = pluck(arr);\n    assert(result == vector<int>({0, 3}));\n\n    arr = {5, 4, 8, 4, 8};\n    result = pluck(arr);\n    assert(result == vector<int>({4, 1}));\n\n    arr = {7, 6, 7, 1};\n    result = pluck(arr);\n    assert(result == vector<int>({6, 1}));\n\n    arr = {7, 9, 7, 1};\n    result = pluck(arr);\n    assert(result == vector<int>());\n\n    return 0;\n}\n\n[C#]\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        // Test cases\n        var arr = new[] {4, 2, 3};\n        var result = Pluck(arr);\n        Assert(result, new[] {2, 1});\n\n        arr = new[] {1, 2, 3};\n        result = Pluck(arr);\n        Assert(result, new[] {2, 1});\n\n        arr = new int[] {};\n        result = Pluck(arr);\n        Assert(result, new int[] {});\n\n        arr = new[] {5, 0, 3, 0, 4, 2};\n        result = Pluck(arr);\n        Assert(result, new[] {0, 1});\n\n        arr = new[] {1, 2, 3, 0, 5, 3};\n        result = Pluck(arr);\n        Assert(result, new[] {0, 3});\n\n        arr = new[] {5, 4, 8, 4, 8};\n        result = Pluck(arr);\n        Assert(result, new[] {4, 1});\n\n        arr = new[] {7, 6, 7, 1};\n        result = Pluck(arr);\n        Assert(result, new[] {6, 1});\n\n        arr = new[] {7, 9, 7, 1};\n        result = Pluck(arr);\n        Assert(result, new int[] {});\n    }\n\n    static void Assert(int[] result, int[] expected)\n    {\n        if (result.Length != expected.Length)\n        {\n            Console.WriteLine("Assertion failed");\n            Environment.Exit(1);\n        }\n\n        for (int i = 0; i < result.Length; i++)\n        {\n            if (result[i] != expected[i])\n            {\n                Console.WriteLine("Assertion failed");\n                Environment.Exit(1);\n            }\n        }\n    }\n\n    static int[] Pluck(int[] arr)\n    {\n        var result = new int[] {};\n\n        for (int i = 0; i < arr.Length; i++)\n        {\n            if (arr[i] % 2 == 0 && (result.Length == 0 || arr[i] < result[0]))\n            {\n                result = new[] {arr[i], i - 1};\n            }\n        }\n\n        return result;\n    }\n}\n\n[Python]\ndef pluck(arr):\n    result = []\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0 and (len(result) == 0 or arr[i] < result[0]):\n            result = [arr[i], i-1]\n    return result\n\ndef main():\n    # Test cases\n    arr = [4, 2, 3]\n    result = pluck(arr)\n    assert result == [2, 1]\n\n    arr = [1, 2, 3]\n    result = pluck(arr)\n    assert result == [2, 1]\n\n    arr = []\n    result = pluck(arr)\n    assert result == []\n\n    arr = [5, 0, 3, 0, 4, 2]\n    result = pluck(arr)\n    assert result == [0, 1]\n\n    arr = [1, 2, 3, 0, 5, 3]\n    result = pluck(arr)\n    assert result == [0, 3]\n\n    arr = [5, 4, 8, 4, 8]\n    result = pluck(arr)\n    assert result == [4, 1]\n\n    arr = [7, 6, 7, 1]\n    result = pluck(arr)\n    assert result == [6, 1]\n\n    arr = [7, 9, 7, 1]\n    result = pluck(arr)\n    assert result == []\n\nif __name__ == "__main__":\n    main()\n\n[JavaScript]\nfunction pluck(arr) {\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] % 2 == 0 && (result.length == 0 || arr[i] < result[0])) {\n            result = [arr[i], i-1];\n        }\n    }\n    return result;\n}\n\nfunction main() {\n    // Test cases\n    var arr = [4, 2, 3];\n    var result = pluck(arr);\n    console.assert(result.toString() == [2, 1].toString());\n\n    arr = [1, 2, 3];\n    result = pluck(arr);\n    console.assert(result.toString() == [2, 1].toString());\n\n    arr = [];\n    result = pluck(arr);\n    console.assert(result.toString() == [].toString());\n\n    arr = [5, 0, 3, 0, 4, 2];\n    result = pluck(arr);\n    console.assert(result.toString() == [0, 1].toString());\n\n    arr = [1, 2, 3, 0, 5, 3];\n    result = pluck(arr);\n    console.assert(result.toString() == [0, 3].toString());\n\n    arr = [5, 4, 8, 4, 8];\n    result = pluck(arr);\n    console.assert(result.toString() == [4, 1].toString());\n\n    arr = [7, 6, 7, 1];\n    result = pluck(arr);\n    console.assert(result.toString() == [6, 1].toString());\n\n    arr = [7, 9, 7, 1];\n    result = pluck(arr);\n    console.assert(result.toString() == [].toString());\n}\n\nmain();\n\n[PHP]\nfunction pluck($arr) {\n    $result = [];\n    for ($i = 0; $i < count($arr); $i++) {\n        if ($arr[$i] % 2 == 0 && (count($result) == 0 || $arr[$i] < $result[0])) {\n
\n\n[CPP]\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    vector<int> freq(2, 0);\n    int max = -1;\n\n    for (int i = 0; i < lst.size(); i++) {\n        bool has = false;\n        for (int j = 0; j < freq.size(); j += 2) {\n            if (lst[i] == freq[j]) {\n                freq[j + 1]++;\n                has = true;\n                if (freq[j + 1] >= freq[j] && freq[j] > max) max = freq[j];\n            }\n        }\n        if (!has) {\n            freq.push_back(lst[i]);\n            freq.push_back(1);\n            if (max == -1 && lst[i] == 1) max = 1;\n        }\n    }\n\n    return max;\n}\n\nint main() {\n    int result;\n\n    result = search({5, 5, 5, 5, 1});\n    if (result != 1) {\n        cout << "Assertion failed: search({5, 5, 5, 5, 1}) == 1" << endl;\n        return 1;\n    }\n\n    result = search({4, 1, 4, 1, 4, 4});\n    if (result != 4) {\n        cout << "Assertion failed: search({4, 1, 4, 1, 4, 4}) == 4" << endl;\n        return 1;\n    }\n\n    result = search({3, 3});\n    if (result != -1) {\n        cout << "Assertion failed: search({3, 3}) == -1" << endl;\n        return 1;\n    }\n\n    result = search({8, 8, 8, 8, 8, 8, 8, 8});\n    if (result != 8) {\n        cout << "Assertion failed: search({8, 8, 8, 8, 8, 8, 8, 8}) == 8" << endl;\n        return 1;\n    }\n\n    result = search({2, 3, 3, 2, 2});\n    if (result != 2) {\n        cout << "Assertion failed: search({2, 3, 3, 2, 2}) == 2" << endl;\n        return 1;\n    }\n\n    // Add more assertions as needed...\n\n    cout << "All tests passed." << endl;\n    return 0;\n} [/CPP]\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int value;\n    int count;\n} Freq;\n\nint search(int *lst, int size) {\n    Freq *freq = malloc(sizeof(Freq));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        bool has = false;\n        for (int j = 0; j < freq->count; j++) {\n            if (lst[i] == freq[j].value) {\n                freq[j].count++;\n                has = true;\n                if (freq[j].count >= freq[j].value && freq[j].value > max) max = freq[j].value;\n            }\n        }\n        if (!has) {\n            freq->value = lst[i];\n            freq->count = 1;\n            if (max == -1 && lst[i] == 1) max = 1;\n        }\n    }\n\n    return max;\n}\n\nint main() {\n    int result;\n\n    int lst1[] = {5, 5, 5, 5, 1};\n    result = search(lst1, sizeof(lst1) / sizeof(int));\n    if (result != 1) {\n        printf("Assertion failed: search({5, 5, 5, 5, 1}) == 1\n");\n        return 1;\n    }\n\n    int lst2[] = {4, 1, 4, 1, 4, 4};\n    result = search(lst2, sizeof(lst2) / sizeof(int));\n    if (result != 4) {\n        printf("Assertion failed: search({4, 1, 4, 1, 4, 4}) == 4\n");\n        return 1;\n    }\n\n    int lst3[] = {3, 3};\n    result = search(lst3, sizeof(lst3) / sizeof(int));\n    if (result != -1) {\n        printf("Assertion failed: search({3, 3}) == -1\n");\n        return 1;\n    }\n\n    int lst4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    result = search(lst4, sizeof(lst4) / sizeof(int));\n    if (result != 8) {\n        printf("Assertion failed: search({8, 8, 8, 8, 8, 8, 8, 8}) == 8\n");\n        return 1;\n    }\n\n    int lst5[] = {2, 3, 3, 2, 2};\n    result = search(lst5, sizeof(lst5) / sizeof(int));\n    if (result != 2) {\n        printf("Assertion failed: search({2, 3, 3, 2, 2}) == 2\n");\n        return 1;\n    }\n\n    // Add more assertions as needed...\n\n    printf("All tests passed.\n");\n    return 0;\n} [/C]\n\n[Go]\npackage main\n\nimport "fmt"\n\ntype Freq struct {\n    value int\n    count int\n}\n\nfunc search(lst []int) int {\n    freq := make([]Freq, 0)\n    max := -1\n\n    for i := 0; i < len(lst); i++ {\n        has := false\n        for j := 0; j < len(freq); j++ {\n            if lst[i] == freq[j].value {\n                freq[j].count++\n                has = true\n                if freq[j].count >= freq[j].value && freq[j].value > max {\n                    max = freq[j].value\n                }\n            }\n        }\n        if !has {\n            freq = append(freq, Freq{lst[i], 1})\n            if max == -1 && lst[i] == 1 {\n                max = 1\n            }\n        }\n    }\n\n    return max\n}\n\nfunc main() {\n    result := search([]int{5, 5, 5, 5, 1})\n    if result != 1 {\n        fmt.Printf("Assertion failed: search({5, 5, 5, 5, 1}) == 1\n")\n        return\n    }\n\n    result = search([]int{4, 1, 4, 1, 4, 4})\n    if result != 4 {\n        fmt.Printf("Assertion failed: search({4, 1, 4, 1, 4, 4}) == 4\n")\n        return\n    }\n\n    result = search([]int{3, 3})\n    if result != -1 {\n        fmt.Printf("Assertion failed: search({3, 3}) == -1\n")\n        return\n    }\n\n    result = search([]int{8, 8, 8, 8, 8, 8, 8, 8})\n    if result != 8 {\n        fmt.Printf("Assertion failed: search({8, 8, 8, 8, 8, 8, 8, 8}) == 8\n")\n        return\n    }\n\n    result = search([]int{2, 3, 3, 2, 2})\n    if result != 2 {\n        fmt.Printf("Assertion failed: search({2, 3, 3, 2, 2}) == 2\n")\n
\n\n// [COMPILE]\n// [OUTPUT]\n// [
\n\n[EXPECTED]\n[SKIP]\n[OUTPUT]\n[SKIP]\n[BACKEND]\n[SKIP]\n[SUMMARY]\n[SKIP]\n[COMMENT]\n[SKIP]\n[TABS]\n[SKIP]\n[ENV]\n[SKIP]\n[FILE_EXTERNALITY]\n[SKIP]\n[BUILTIN]\n[SKIP]\n[BUILTIN_ATTR]\n[SKIP]\n[STDLIB]\n[SKIP]\n[COPYRIGHT]\n[SKIP]\n[VERSION]\n[SKIP]\n[SUBROUTINE]\n[SKIP]\n[FUNCTION]\n[SKIP]\n[MACRO]\n[SKIP]\n[SOURCE_DIR]\n[SKIP]\n[BINARY_DIR]\n[SKIP]\n[TEST_DIR]\n[SKIP]\n[TEST_NAME]\n[SKIP]\n[FILE_NAME]\n[SKIP]\n[FILE_NAME_LEAF]\n[SKIP]\n[FILE_NAME_EXT]\n[SKIP]\n[FILE_NAME_BASE]\n[SKIP]\n[FILE_NAME_BASE_NAME]\n[SKIP]\n[FILE_NAME_BASE_EXT]\n[SKIP]\n[FILE_NAME_DIR]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME]\n[SKIP]\n[FILE_NAME_DIR_EXT]\n[SKIP]\n[FILE_NAME_DIR_LEAF]\n[SKIP]\n[FILE_NAME_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_DIR]\n[SKIP]\n[FILE_NAME_BASE_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_BASE_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_BASE_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_BASE_DIR_NAME]\n[SKIP]\n[FILE_NAME_BASE_DIR_EXT]\n[SKIP]\n[FILE_NAME_BASE_DIR_LEAF]\n[SKIP]\n[FILE_NAME_BASE_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_NAME]\n[SKIP]\n[FILE_NAME_NAME_LEAF]\n[SKIP]\n[FILE_NAME_NAME_EXT]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_NAME]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_EXT]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_LEAF]\n[SKIP]\n[FILE_NAME_NAME_BASE_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_NAME_BASE_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_NAME_EXT]\n[SKIP]\n[FILE_NAME_NAME_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_NAME_LEAF]\n[SKIP]\n[FILE_NAME_NAME_LEAF_EXT]\n[SKIP]\n[FILE_NAME_EXT]\n[SKIP]\n[FILE_NAME_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_LEAF]\n[SKIP]\n[FILE_NAME_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_NAME]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_EXT]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_LEAF]\n[SKIP]\n[FILE_NAME_DIR_BASE_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_BASE_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME]\n[SKIP]\n[FILE_NAME_DIR_NAME_LEAF]\n[SKIP]\n[FILE_NAME_DIR_NAME_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_NAME]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_LEAF]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_BASE_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_NAME_LEAF]\n[SKIP]\n[FILE_NAME_DIR_NAME_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_EXT]\n[SKIP]\n[FILE_NAME_DIR_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_LEAF]\n[SKIP]\n[FILE_NAME_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_DIR_LEAF_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_BASE_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_BASE_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_BASE_DIR_NAME]\n[SKIP]\n[FILE_NAME_BASE_DIR_EXT]\n[SKIP]\n[FILE_NAME_BASE_DIR_LEAF]\n[SKIP]\n[FILE_NAME_BASE_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME]\n[SKIP]\n[FILE_NAME_BASE_NAME_LEAF]\n[SKIP]\n[FILE_NAME_BASE_NAME_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_BASE_DIR]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_BASE_NAME]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_BASE_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_NAME]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_LEAF]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_DIR_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_BASE_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_EXT_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_NAME_LEAF]\n[SKIP]\n[FILE_NAME_BASE_NAME_LEAF_EXT]\n[SKIP]\n[FILE_NAME_BASE_EXT]
\n\n[CPP]\n#include <iostream>\n#include <vector>\n\nbool will_it_fly(std::vector<int> q, int w)\n{\n    int sum = 0;\n    int n = q.size();\n\n    for (int i = 0; i < n; i++)\n    {\n        if (q[i] != q[n - 1 - i])\n            return false;\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n\nint main()\n{\n    std::vector<int> q;\n    int w;\n\n    // Test cases\n    q = {3, 2, 3};\n    w = 9;\n    if (!will_it_fly(q, w))\n    {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2};\n    w = 5;\n    if (will_it_fly(q, w))\n    {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3};\n    w = 5;\n    if (!will_it_fly(q, w))\n    {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3, 2, 3};\n    w = 1;\n    if (will_it_fly(q, w))\n    {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2, 3};\n    w = 6;\n    if (will_it_fly(q, w))\n    {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    q = {5};\n    w = 5;\n    if (!will_it_fly(q, w))\n    {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n} [/CPP]\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n\nbool will_it_fly(int *q, int w, int n)\n{\n    int sum = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (q[i] != q[n - 1 - i])\n            return false;\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n\nint main()\n{\n    int q[] = {3, 2, 3};\n    int w = 9;\n    if (!will_it_fly(q, w, 3))\n    {\n        printf("Test case 1 failed\n");\n        return 1;\n    }\n\n    int q2[] = {1, 2};\n    int w2 = 5;\n    if (will_it_fly(q2, w2, 2))\n    {\n        printf("Test case 2 failed\n");\n        return 1;\n    }\n\n    int q3[] = {3};\n    int w3 = 5;\n    if (!will_it_fly(q3, w3, 1))\n    {\n        printf("Test case 3 failed\n");\n        return 1;\n    }\n\n    int q4[] = {3, 2, 3};\n    int w4 = 1;\n    if (will_it_fly(q4, w4, 3))\n    {\n        printf("Test case 4 failed\n");\n        return 1;\n    }\n\n    int q5[] = {1, 2, 3};\n    int w5 = 6;\n    if (will_it_fly(q5, w5, 3))\n    {\n        printf("Test case 5 failed\n");\n        return 1;\n    }\n\n    int q6[] = {5};\n    int w6 = 5;\n    if (!will_it_fly(q6, w6, 1))\n    {\n        printf("Test case 6 failed\n");\n        return 1;\n    }\n\n    printf("All test cases passed\n");\n    return 0;\n} [/C]\n\n[JAVA]\nimport java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] q = new int[n];\n        for (int i = 0; i < n; i++) {\n            q[i] = sc.nextInt();\n        }\n        int w = sc.nextInt();\n        sc.close();\n\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (q[i] != q[n - 1 - i]) {\n                System.out.println("false");\n                return;\n            }\n            sum += q[i];\n        }\n\n        if (sum > w) {\n            System.out.println("false");\n        } else {\n            System.out.println("true");\n        }\n    }\n} [/JAVA]\n\n[PYTHON]\nimport sys\n\ndef will_it_fly(q, w):\n    sum = 0\n    for i in range(len(q)):\n        if q[i] != q[len(q) - 1 - i]:\n            return False\n        sum += q[i]\n    return sum <= w\n\nif __name__ == "__main__":\n    q = list(map(int, input().split()))\n    w = int(input())\n    print(will_it_fly(q, w)) [/PYTHON]\n\n[PHP]\n<?php\n$q = explode(' ', readline());\n$w = (int) readline();\n\n$sum = 0;\nfor ($i = 0; $i < count($q); $i++) {\n    if ($q[$i] != $q[count($q) - 1 - $i]) {\n        echo "false";\n        exit;\n    }\n    $sum += $q[$i];\n}\n\nif ($sum > $w) {\n    echo "false";\n} else {\n    echo "true";\n}\n?> [/PHP]\n\n[RUBY]\n#!/usr/bin/env ruby\n\ndef will_it_fly(q, w)\n    sum = 0\n    n = q.length\n    for i in 0..n-1\n        if q[i] != q[n - 1 - i]\n            return false\n        end\n        sum += q[i]\n    end\n    return sum <= w\nend\n\nq = gets.split.map(&:to_i)\nw = gets.to_i\nputs will_it_fly(q, w) [/RUBY]\n\n[SWIFT]\nimport Foundation\n\nfunc willItFly(_ q: [Int], _ w: Int) -> Bool {\n    var sum = 0\n    for i in 0..<q.count {\n        if q[i] != q[q.count - 1 - i] {\n            return false\n        }\n        sum += q[i]\n    }\n    return sum <= w\n}\n\nlet q = readLine()!.split(separator: " ").map{ Int(String($0))! }\nlet w = Int(readLine()!)!\nprint(willItFly(q, w)) [/SWIFT]\n\n[GO]\npackage main\n\nimport (\n    "fmt"\n    "strings"\n)\n\nfunc willItFly(q []int, w int) bool {\n    sum := 0\n    for i := 0; i < len(q); i++ {\n        if q[i] != q[len(q)-1-i] {\n            return false\n        }\n        sum += q[i]\n    }\n    return sum <= w\n}\n\nfunc main() {\n    var q []int\n    var w int\n    fmt.Scan(&q, &w)\n    q = strings.Split(q, " ")\n    for i := 0; i
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint smallest_change(const std::vector<int>& arr) {\n    int out = 0;\n    for (int i = 0; i < arr.size() / 2; i++) {\n        if (arr[i] != arr[arr.size() - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 3, 5, 4, 7, 9, 6};\n    if (smallest_change(arr1) != 4) {\n        std::cout << "Assertion failed: smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr2 = {1, 2, 3, 4, 3, 2, 2};\n    if (smallest_change(arr2) != 1) {\n        std::cout << "Assertion failed: smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr3 = {1, 4, 2};\n    if (smallest_change(arr3) != 1) {\n        std::cout << "Assertion failed: smallest_change([1, 4, 2]) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr4 = {1, 4, 4, 2};\n    if (smallest_change(arr4) != 1) {\n        std::cout << "Assertion failed: smallest_change([1, 4, 4, 2]) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr5 = {1, 2, 3, 2, 1};\n    if (smallest_change(arr5) != 0) {\n        std::cout << "Assertion failed: smallest_change([1, 2, 3, 2, 1]) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr6 = {3, 1, 1, 3};\n    if (smallest_change(arr6) != 0) {\n        std::cout << "Assertion failed: smallest_change([3, 1, 1, 3]) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr7 = {1};\n    if (smallest_change(arr7) != 0) {\n        std::cout << "Assertion failed: smallest_change([1]) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr8 = {0, 1};\n    if (smallest_change(arr8) != 1) {\n        std::cout << "Assertion failed: smallest_change([0, 1]) == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n\nint smallest_change(int* arr, int arr_size) {\n    int out = 0;\n    for (int i = 0; i < arr_size / 2; i++) {\n        if (arr[i] != arr[arr_size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}\n\nint main() {\n    int arr1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    if (smallest_change(arr1, 8) != 4) {\n        printf("Assertion failed: smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n");\n        return 1;\n    }\n\n    int arr2[] = {1, 2, 3, 4, 3, 2, 2};\n    if (smallest_change(arr2, 7) != 1) {\n        printf("Assertion failed: smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n");\n        return 1;\n    }\n\n    int arr3[] = {1, 4, 2};\n    if (smallest_change(arr3, 3) != 1) {\n        printf("Assertion failed: smallest_change([1, 4, 2]) == 1\n");\n        return 1;\n    }\n\n    int arr4[] = {1, 4, 4, 2};\n    if (smallest_change(arr4, 4) != 1) {\n        printf("Assertion failed: smallest_change([1, 4, 4, 2]) == 1\n");\n        return 1;\n    }\n\n    int arr5[] = {1, 2, 3, 2, 1};\n    if (smallest_change(arr5, 5) != 0) {\n        printf("Assertion failed: smallest_change([1, 2, 3, 2, 1]) == 0\n");\n        return 1;\n    }\n\n    int arr6[] = {3, 1, 1, 3};\n    if (smallest_change(arr6, 4) != 0) {\n        printf("Assertion failed: smallest_change([3, 1, 1, 3]) == 0\n");\n        return 1;\n    }\n\n    int arr7[] = {1};\n    if (smallest_change(arr7, 1) != 0) {\n        printf("Assertion failed: smallest_change([1]) == 0\n");\n        return 1;\n    }\n\n    int arr8[] = {0, 1};\n    if (smallest_change(arr8, 2) != 1) {\n        printf("Assertion failed: smallest_change([0, 1]) == 1\n");\n        return 1;\n    }\n\n    printf("All tests passed.\n");\n    return 0;\n}\n\n[Python]\ndef smallest_change(arr):\n    out = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - 1 - i]:\n            out += 1\n    return out\n\n\ndef main():\n    arr1 = [1, 2, 3, 5, 4, 7, 9, 6]\n    if smallest_change(arr1) != 4:\n        print("Assertion failed: smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4")\n        return 1\n\n    arr2 = [1, 2, 3, 4, 3, 2, 2]\n    if smallest_change(arr2) != 1:\n        print("Assertion failed: smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1")\n        return 1\n\n    arr3 = [1, 4, 2]\n    if smallest_change(arr3) != 1:\n        print("Assertion failed: smallest_change([1, 4, 2]) == 1")\n        return 1\n\n    arr4 = [1, 4, 4, 2]\n    if smallest_change(arr4) != 1:\n        print("Assertion failed: smallest_change([1, 4, 4, 2]) == 1")\n        return 1\n\n    arr5 = [1, 2, 3, 2, 1]\n    if smallest_change(arr5) != 0:\n        print("Assertion failed: smallest_change([1, 2, 3, 2, 1]) == 0")\n        return 1\n\n    arr6 = [3, 1, 1, 3]\n    if smallest_
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool issame(vector<string> a, vector<string> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvector<string> total_match(vector<string> a, vector<string> b) {\n    vector<string> res;\n\n    if (a.size() > b.size()) {\n        res = b;\n    } else {\n        res = a;\n    }\n\n    return res;\n}\n\nint main() {\n    vector<string> lst1 = {"hi", "admin"};\n    vector<string> lst2 = {"hi", "hi", "admin", "project"};\n    vector<string> result = {"hi", "admin"};\n    vector<string> empty;\n\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hi", "hi", "admin", "project"};\n    result = {"hi", "admin"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"4"};\n    lst2 = {"1", "2", "3", "4", "5"};\n    result = {"4"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "Hi"};\n    result = {"hI", "Hi"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "hi", "hi"};\n    result = {"hI", "hi", "hi"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "hi", "hii"};\n    result = {"hi", "admin"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {};\n    lst2 = {"this"};\n    result = {};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"this"};\n    lst2 = {};\n    result = {};\n    assert(issame(total_match(lst1, lst2), result));\n\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool issame(vector<string> a, vector<string> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvector<string> total_match(vector<string> a, vector<string> b) {\n    vector<string> res;\n\n    if (a.size() > b.size()) {\n        res = b;\n    } else {\n        res = a;\n    }\n\n    return res;\n}\n\nint main() {\n    vector<string> lst1 = {"hi", "admin"};\n    vector<string> lst2 = {"hi", "hi", "admin", "project"};\n    vector<string> result = {"hi", "admin"};\n    vector<string> empty;\n\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hi", "hi", "admin", "project"};\n    result = {"hi", "admin"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"4"};\n    lst2 = {"1", "2", "3", "4", "5"};\n    result = {"4"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "Hi"};\n    result = {"hI", "Hi"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "hi", "hi"};\n    result = {"hI", "hi", "hi"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "hi", "hii"};\n    result = {"hi", "admin"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {};\n    lst2 = {"this"};\n    result = {};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"this"};\n    lst2 = {};\n    result = {};\n    assert(issame(total_match(lst1, lst2), result));\n\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool issame(vector<string> a, vector<string> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvector<string> total_match(vector<string> a, vector<string> b) {\n    vector<string> res;\n\n    if (a.size() > b.size()) {\n        res = b;\n    } else {\n        res = a;\n    }\n\n    return res;\n}\n\nint main() {\n    vector<string> lst1 = {"hi", "admin"};\n    vector<string> lst2 = {"hi", "hi", "admin", "project"};\n    vector<string> result = {"hi", "admin"};\n    vector<string> empty;\n\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hi", "hi", "admin", "project"};\n    result = {"hi", "admin"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"4"};\n    lst2 = {"1", "2", "3", "4", "5"};\n    result = {"4"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "Hi"};\n    result = {"hI", "Hi"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "hi", "hi"};\n    result = {"hI", "hi", "hi"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"hi", "admin"};\n    lst2 = {"hI", "hi", "hii"};\n    result = {"hi", "admin"};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {};\n    lst2 = {"this"};\n    result = {};\n    assert(issame(total_match(lst1, lst2), result));\n\n    lst1 = {"this"};\n    lst2 = {};\n    result = {};\n    assert(issame(total_match(lst1, lst2), result));\n\n    return 0;\n}\n\n[C++]\n#include <iostream
\n\n[SOLUTION]\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n  // Test cases\n  if (!is_simple_power(1, 4)) {\n    std::cout << "Assertion failed: is_simple_power(1, 4) == true" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(2, 2)) {\n    std::cout << "Assertion failed: is_simple_power(2, 2) == true" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(8, 2)) {\n    std::cout << "Assertion failed: is_simple_power(8, 2) == true" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(3, 2)) {\n    std::cout << "Assertion failed: is_simple_power(3, 2) == false" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(3, 1)) {\n    std::cout << "Assertion failed: is_simple_power(3, 1) == false" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(5, 3)) {\n    std::cout << "Assertion failed: is_simple_power(5, 3) == false" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(16, 2)) {\n    std::cout << "Assertion failed: is_simple_power(16, 2) == true" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(143214, 16)) {\n    std::cout << "Assertion failed: is_simple_power(143214, 16) == false" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(4, 2)) {\n    std::cout << "Assertion failed: is_simple_power(4, 2) == true" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(9, 3)) {\n    std::cout << "Assertion failed: is_simple_power(9, 3) == true" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(16, 4)) {\n    std::cout << "Assertion failed: is_simple_power(16, 4) == true" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(24, 2)) {\n    std::cout << "Assertion failed: is_simple_power(24, 2) == false" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(128, 4)) {\n    std::cout << "Assertion failed: is_simple_power(128, 4) == false" << std::endl;\n    std::exit(1);\n  }\n  if (is_simple_power(12, 6)) {\n    std::cout << "Assertion failed: is_simple_power(12, 6) == false" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(1, 1)) {\n    std::cout << "Assertion failed: is_simple_power(1, 1) == true" << std::endl;\n    std::exit(1);\n  }\n  if (!is_simple_power(1, 12)) {\n    std::cout << "Assertion failed: is_simple_power(1, 12) == true" << std::endl;\n    std::exit(1);\n  }\n}\n\nbool is_simple_power(int x, int n) {\n  int p = 1;\n  int count = 0;\n  while (p <= x && count < 100) {\n    if (p == x) {\n      return true;\n    }\n    p *= n;\n    count++;\n  }\n  return false;\n}\n[/SOLUTION]\n\n[CHALLENGE]\nWrite a function that takes two integers x and n and returns true if x is a simple power of n, and false otherwise.\n\nA simple power of n is a power of n that is not a multiple of n.\n\nFor example:\n\nis_simple_power(1, 4) == true\nis_simple_power(2, 2) == true\nis_simple_power(8, 2) == true\nis_simple_power(3, 2) == false\nis_simple_power(3, 1) == false\nis_simple_power(5, 3) == false\nis_simple_power(16, 2) == true\nis_simple_power(143214, 16) == false\nis_simple_power(4, 2) == true\nis_simple_power(9, 3) == true\nis_simple_power(16, 4) == true\nis_simple_power(24, 2) == false\nis_simple_power(128, 4) == false\nis_simple_power(12, 6) == false\nis_simple_power(1, 1) == true\nis_simple_power(1, 12) == true\n[/CHALLENGE]\n\n[META]\nentity = challenge\ntitle = Simple power\n[/META]\n\n[DESCRIPTION]\nWrite a function that takes two integers x and n and returns true if x is a simple power of n, and false otherwise.\n\nA simple power of n is a power of n that is not a multiple of n.\n\nFor example:\n\nis_simple_power(1, 4) == true\nis_simple_power(2, 2) == true\nis_simple_power(8, 2) == true\nis_simple_power(3, 2) == false\nis_simple_power(3, 1) == false\nis_simple_power(5, 3) == false\nis_simple_power(16, 2) == true\nis_simple_power(143214, 16) == false\nis_simple_power(4, 2) == true\nis_simple_power(9, 3) == true\nis_simple_power(16, 4) == true\nis_simple_power(24, 2) == false\nis_simple_power(128, 4) == false\nis_simple_power(12, 6) == false\nis_simple_power(1, 1) == true\nis_simple_power(1, 12) == true\n[/DESCRIPTION]\n\n[INPUT]\nTwo integers x and n.\n[/INPUT]\n\n[OUTPUT]\nA boolean value.\n[/OUTPUT]\n\n[IO]\nInput:\n1 4\n\nOutput:\ntrue\n\nInput:\n2 2\n\nOutput:\ntrue\n\nInput:\n8 2\n\nOutput:\ntrue\n\nInput:\n3 2\n\nOutput:\nfalse\n\nInput:\n3 1\n\nOutput:\nfalse\n\nInput:\n5 3\n\nOutput:\nfalse\n\nInput:\n16 2\n\nOutput:\ntrue\n\nInput:\n143214 16\n\nOutput:\nfalse\n\nInput:\n4 2\n\nOutput:\ntrue\n\nInput:\n9 3\n\nOutput:\ntrue\n\nInput:\n16 4\n\nOutput:\ntrue\n\nInput:\n24 2\n\nOutput:\nfalse\n\nInput:\n128 4\n\nOutput:\nfalse\n\nInput:\n12 6\n\nOutput:\nfalse\n\nInput:\n1 1\n\nOutput:\ntrue\n\nInput:\n1 12\n\nOutput:\ntrue\n[/IO]\n\n[REFERENCE]\n[/REFERENCE]\n\n[TEST]\n[/TEST]\n\n[CATEGORY]\nProgramming skills\n[/CATEGORY]\n\n[TAGS]\nlogic\n[/TAGS]\n\n[COMP
\n\n[C++]\n#include <cmath>\n\nbool iscuber(int a) {\n  int i;\n  for (i = 0; i <= std::abs(a) / 3; i++) {\n    if (i * i * i == std::abs(a)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  // Assertions\n  if (!iscuber(1)) {\n    std::cout << "iscuber(1): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (iscuber(2)) {\n    std::cout << "iscuber(2): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (!iscuber(-1)) {\n    std::cout << "iscuber(-1): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (!iscuber(64)) {\n    std::cout << "iscuber(64): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (iscuber(180)) {\n    std::cout << "iscuber(180): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (!iscuber(1000)) {\n    std::cout << "iscuber(1000): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (!iscuber(0)) {\n    std::cout << "iscuber(0): assertion failed" << std::endl;\n    return 1;\n  }\n\n  if (iscuber(1729)) {\n    std::cout << "iscuber(1729): assertion failed" << std::endl;\n    return 1;\n  }\n\n  std::cout << "All tests passed." << std::endl;\n\n  return 0;\n}\n\n[C]\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nbool iscuber(int a) {\n  int i;\n  for (i = 0; i <= abs(a) / 3; i++) {\n    if (i * i * i == abs(a)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  // Assertions\n  if (!iscuber(1)) {\n    printf("iscuber(1): assertion failed\n");\n    return 1;\n  }\n\n  if (iscuber(2)) {\n    printf("iscuber(2): assertion failed\n");\n    return 1;\n  }\n\n  if (!iscuber(-1)) {\n    printf("iscuber(-1): assertion failed\n");\n    return 1;\n  }\n\n  if (!iscuber(64)) {\n    printf("iscuber(64): assertion failed\n");\n    return 1;\n  }\n\n  if (iscuber(180)) {\n    printf("iscuber(180): assertion failed\n");\n    return 1;\n  }\n\n  if (!iscuber(1000)) {\n    printf("iscuber(1000): assertion failed\n");\n    return 1;\n  }\n\n  if (!iscuber(0)) {\n    printf("iscuber(0): assertion failed\n");\n    return 1;\n  }\n\n  if (iscuber(1729)) {\n    printf("iscuber(1729): assertion failed\n");\n    return 1;\n  }\n\n  printf("All tests passed.\n");\n\n  return 0;\n}\n\n[Python]\ndef iscuber(a):\n  for i in range(0, abs(a) / 3 + 1):\n    if i * i * i == abs(a):\n      return True\n  return False\n\n\n# Assertions\nassert iscuber(1)\nassert not iscuber(2)\nassert iscuber(-1)\nassert iscuber(64)\nassert not iscuber(180)\nassert iscuber(1000)\nassert iscuber(0)\nassert not iscuber(1729)\n\nprint("All tests passed.")\n\n[Java]\npublic class Cube {\n  public static void main(String[] args) {\n    // Assertions\n    assert isCuber(1);\n    assert !isCuber(2);\n    assert isCuber(-1);\n    assert isCuber(64);\n    assert !isCuber(180);\n    assert isCuber(1000);\n    assert isCuber(0);\n    assert !isCuber(1729);\n\n    System.out.println("All tests passed.");\n  }\n\n  public static boolean isCuber(int a) {\n    for (int i = 0; i <= Math.abs(a) / 3; i++) {\n      if (i * i * i == Math.abs(a)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n[JavaScript]\nfunction isCuber(a) {\n  for (let i = 0; i <= Math.abs(a) / 3; i++) {\n    if (i * i * i == Math.abs(a)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Assertions\nconsole.assert(isCuber(1));\nconsole.assert(!isCuber(2));\nconsole.assert(isCuber(-1));\nconsole.assert(isCuber(64));\nconsole.assert(!isCuber(180));\nconsole.assert(isCuber(1000));\nconsole.assert(isCuber(0));\nconsole.assert(!isCuber(1729));\n\nconsole.log("All tests passed.");\n\n[PHP]\nfunction isCuber($a) {\n  for ($i = 0; $i <= abs($a) / 3; $i++) {\n    if ($i * $i * $i == abs($a)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Assertions\nassert(isCuber(1));\nassert(!isCuber(2));\nassert(isCuber(-1));\nassert(isCuber(64));\nassert(!isCuber(180));\nassert(isCuber(1000));\nassert(isCuber(0));\nassert(!isCuber(1729));\n\necho "All tests passed.";\n\n[Ruby]\ndef is_cuber(a)\n  for i in 0..(a.abs / 3)\n    return true if i * i * i == a.abs\n  end\n  false\nend\n\n# Assertions\nassert(is_cuber(1))\nassert(!is_cuber(2))\nassert(is_cuber(-1))\nassert(is_cuber(64))\nassert(!is_cuber(180))\nassert(is_cuber(1000))\nassert(is_cuber(0))\nassert(!is_cuber(1729))\n\nputs "All tests passed."\n\n[Swift]\nfunc isCuber(_ a: Int) -> Bool {\n  for i in 0..<(abs(a) / 3 + 1) {\n    if i * i * i == abs(a) {\n      return true\n    }\n  }\n  return false\n}\n\n// Assertions\nassert(isCuber(1))\nassert(!isCuber(2))\nassert(isCuber(-1))\nassert(isCuber(64))\nassert(!isCuber(180))\nassert(isCuber(1000))\nassert(isCuber(0))\nassert(!isCuber(1729))\n\nprint("All tests passed.")\n\n[Go]\npackage main\n\nimport (\n  "fmt"\n  "math"\n)\n\nfunc isCuber(a int) bool {\n  for i := 0; i <= int(math.Abs(float64(a)) / 3); i++ {\n    if i*i*i == int(math.Abs(float64(a))) {\n      return true\n    }\n  }\n  return false\n}\n\nfunc main() {\n  // Assertions\n  if !isCuber(1) {\n    fmt.Print
\n\n[C++]\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string key = "2357BD";\n    std::string num;\n    int result;\n\n    // Main program body\n    num = "AB";\n    result = hex_key(num);\n    if (result != 1) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    num = "1077E";\n    result = hex_key(num);\n    if (result != 2) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    num = "ABED1A33";\n    result = hex_key(num);\n    if (result != 4) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    num = "2020";\n    result = hex_key(num);\n    if (result != 2) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    num = "123456789ABCDEF0";\n    result = hex_key(num);\n    if (result != 6) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    num = "112233445566778899AABBCCDDEEFF00";\n    result = hex_key(num);\n    if (result != 12) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    num = "";\n    result = hex_key(num);\n    if (result != 0) {\n        std::cout << "Assertion failed" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\nint hex_key(std::string num)\n{\n    std::string key = "2357BD";\n    int out = 0;\n    for (int i = 0; i < num.length(); i++) {\n        if (key.find(num[i]) != std::string::npos) {\n            out++;\n        }\n    }\n    return out;\n}\n[/C++]\n\n[C]\n#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n    char key[] = "2357BD";\n    char num[100];\n    int result;\n\n    // Main program body\n    strcpy(num, "AB");\n    result = hex_key(num);\n    if (result != 1) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    strcpy(num, "1077E");\n    result = hex_key(num);\n    if (result != 2) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    strcpy(num, "ABED1A33");\n    result = hex_key(num);\n    if (result != 4) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    strcpy(num, "2020");\n    result = hex_key(num);\n    if (result != 2) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    strcpy(num, "123456789ABCDEF0");\n    result = hex_key(num);\n    if (result != 6) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    strcpy(num, "112233445566778899AABBCCDDEEFF00");\n    result = hex_key(num);\n    if (result != 12) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    strcpy(num, "");\n    result = hex_key(num);\n    if (result != 0) {\n        printf("Assertion failed\n");\n        return 1;\n    }\n\n    return 0;\n}\n\nint hex_key(char *num)\n{\n    char key[] = "2357BD";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i]) != NULL) {\n            out++;\n        }\n    }\n    return out;\n}\n[/C]\n\n[Python]\ndef hex_key(num):\n    key = "2357BD"\n    out = 0\n    for i in range(len(num)):\n        if num[i] in key:\n            out += 1\n    return out\n\n\ndef main():\n    assert(hex_key("AB") == 1)\n    assert(hex_key("1077E") == 2)\n    assert(hex_key("ABED1A33") == 4)\n    assert(hex_key("2020") == 2)\n    assert(hex_key("123456789ABCDEF0") == 6)\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12)\n    assert(hex_key("") == 0)\n\n\nif __name__ == "__main__":\n    main()\n[/Python]\n\n[JavaScript]\nfunction hex_key(num) {\n    var key = "2357BD";\n    var out = 0;\n    for (var i = 0; i < num.length; i++) {\n        if (key.indexOf(num[i]) != -1) {\n            out++;\n        }\n    }\n    return out;\n}\n\nfunction main() {\n    assert(hex_key("AB") == 1);\n    assert(hex_key("1077E") == 2);\n    assert(hex_key("ABED1A33") == 4);\n    assert(hex_key("2020") == 2);\n    assert(hex_key("123456789ABCDEF0") == 6);\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert(hex_key("") == 0);\n}\n\nmain();\n[/JavaScript]\n\n[PHP]\nfunction hex_key($num) {\n    $key = "2357BD";\n    $out = 0;\n    for ($i = 0; $i < strlen($num); $i++) {\n        if (strpos($key, $num[$i]) !== false) {\n            $out++;\n        }\n    }\n    return $out;\n}\n\nfunction main() {\n    assert(hex_key("AB") == 1);\n    assert(hex_key("1077E") == 2);\n    assert(hex_key("ABED1A33") == 4);\n    assert(hex_key("2020") == 2);\n    assert(hex_key("123456789ABCDEF0") == 6);\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert(hex_key("") == 0);\n}\n\nmain();\n[/PHP]\n\n[Ruby]\ndef hex_key(num)\n    key = "2357BD"\n    out = 0\n    num.each_char do |char|\n        if key.include?(char)\n            out += 1\n        end\n    end\n    return out\nend\n\ndef main()\n    assert(hex_key("AB") == 1)\n    assert(hex_key("1077E") == 2)\n    assert(hex_key("ABED1A33") == 4)\n    assert(hex_key("2020") == 2)\n    assert(hex_key("1234
\n\n[INST] Translate this Fortran code to C++: \nprogram decimal_to_binary_program\n    implicit none\n    call test_decimal_to_binary\n    write(*,*) "All assertions passed."\n\ncontains\n\n    character(len=100) function decimal_to_binary(decimal)\n        implicit none\n        integer, intent(in) :: decimal\n        integer :: temp\n        character(len=100) :: out\n        character(len=1) :: digit\n\n        out = ""\n        if (decimal == 0) then\n            decimal_to_binary = "db0db"\n            return\n        end if\n\n        temp = decimal\n        do while (temp > 0)\n            write(digit, '(I1)') mod(temp, 2)\n            out = trim(digit) // out\n            temp = temp / 2\n        end do\n\n        decimal_to_binary = "db" // trim(out) // "db"\n    end function decimal_to_binary\n\n    subroutine test_decimal_to_binary\n        implicit none\n        character(len=100) :: result\n\n        result = decimal_to_binary(0)\n        if (trim(result) /= "db0db") then\n            write(*,*) "Assertion failed: decimal_to_binary(0) == 'db0db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(32)\n        if (trim(result) /= "db100000db") then\n            write(*,*) "Assertion failed: decimal_to_binary(32) == 'db100000db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(103)\n        if (trim(result) /= "db1100111db") then\n            write(*,*) "Assertion failed: decimal_to_binary(103) == 'db1100111db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(15)\n        if (trim(result) /= "db1111db") then\n            write(*,*) "Assertion failed: decimal_to_binary(15) == 'db1111db'"\n            call exit(1)\n        end if\n    end subroutine test_decimal_to_binary\n\nend program decimal_to_binary_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram decimal_to_binary_program\n    implicit none\n    call test_decimal_to_binary\n    write(*,*) "All assertions passed."\n\ncontains\n\n    character(len=100) function decimal_to_binary(decimal)\n        implicit none\n        integer, intent(in) :: decimal\n        integer :: temp\n        character(len=100) :: out\n        character(len=1) :: digit\n\n        out = ""\n        if (decimal == 0) then\n            decimal_to_binary = "db0db"\n            return\n        end if\n\n        temp = decimal\n        do while (temp > 0)\n            write(digit, '(I1)') mod(temp, 2)\n            out = trim(digit) // out\n            temp = temp / 2\n        end do\n\n        decimal_to_binary = "db" // trim(out) // "db"\n    end function decimal_to_binary\n\n    subroutine test_decimal_to_binary\n        implicit none\n        character(len=100) :: result\n\n        result = decimal_to_binary(0)\n        if (trim(result) /= "db0db") then\n            write(*,*) "Assertion failed: decimal_to_binary(0) == 'db0db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(32)\n        if (trim(result) /= "db100000db") then\n            write(*,*) "Assertion failed: decimal_to_binary(32) == 'db100000db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(103)\n        if (trim(result) /= "db1100111db") then\n            write(*,*) "Assertion failed: decimal_to_binary(103) == 'db1100111db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(15)\n        if (trim(result) /= "db1111db") then\n            write(*,*) "Assertion failed: decimal_to_binary(15) == 'db1111db'"\n            call exit(1)\n        end if\n    end subroutine test_decimal_to_binary\n\nend program decimal_to_binary_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram decimal_to_binary_program\n    implicit none\n    call test_decimal_to_binary\n    write(*,*) "All assertions passed."\n\ncontains\n\n    character(len=100) function decimal_to_binary(decimal)\n        implicit none\n        integer, intent(in) :: decimal\n        integer :: temp\n        character(len=100) :: out\n        character(len=1) :: digit\n\n        out = ""\n        if (decimal == 0) then\n            decimal_to_binary = "db0db"\n            return\n        end if\n\n        temp = decimal\n        do while (temp > 0)\n            write(digit, '(I1)') mod(temp, 2)\n            out = trim(digit) // out\n            temp = temp / 2\n        end do\n\n        decimal_to_binary = "db" // trim(out) // "db"\n    end function decimal_to_binary\n\n    subroutine test_decimal_to_binary\n        implicit none\n        character(len=100) :: result\n\n        result = decimal_to_binary(0)\n        if (trim(result) /= "db0db") then\n            write(*,*) "Assertion failed: decimal_to_binary(0) == 'db0db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(32)\n        if (trim(result) /= "db100000db") then\n            write(*,*) "Assertion failed: decimal_to_binary(32) == 'db100000db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(103)\n        if (trim(result) /= "db1100111db") then\n            write(*,*) "Assertion failed: decimal_to_binary(103) == 'db1100111db'"\n            call exit(1)\n        end if\n\n        result = decimal_to_binary(15)\n        if (trim(result) /= "db1111db") then\n            write(*,*) "Assertion failed: decimal_to_binary(15) == 'db1111db'"\n            call exit(1)\n        end if\n    end subroutine test_decimal_to_binary\n\nend program decimal_to_binary_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram decimal_to_binary_program\n    implicit none\n    call test_decimal_to_binary\n    write(*,*) "All assertions passed."\n\ncontains\n\n    character(len=100) function decimal_to_binary(decimal)\n        implicit none\n        integer, intent(in) :: decimal\n        integer :: temp\n        character(len=100) :: out\n        character(len=1) :: digit\n\n        out = ""\n        if (decimal == 0) then\n            decimal_to_binary = "db0db"\n            return\n        end if\n\n        temp = decimal\n        do while (temp > 0)\n            write(digit, '(I1)') mod(temp, 2)\n            out = trim(digit) // out\n            temp = temp / 2\n        end do\n\n        decimal_to_binary = "db" // trim(out) // "db"\n    end function decimal_to_binary\n\n    subroutine test_decimal_to_binary\n        implicit none\n
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (int i = 3; i < s.length(); i++) {\n        if (s[i] == s[i-1] || s[i] == s[i-2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    if (!is_happy(s)) {\n        cout << "Test 1 passed" << endl;\n    } else {\n        cout << "Test 1 failed" << endl;\n        return 1;\n    }\n\n    s = "aa";\n    if (!is_happy(s)) {\n        cout << "Test 2 passed" << endl;\n    } else {\n        cout << "Test 2 failed" << endl;\n        return 1;\n    }\n\n    s = "abcd";\n    if (is_happy(s)) {\n        cout << "Test 3 passed" << endl;\n    } else {\n        cout << "Test 3 failed" << endl;\n        return 1;\n    }\n\n    s = "aabb";\n    if (!is_happy(s)) {\n        cout << "Test 4 passed" << endl;\n    } else {\n        cout << "Test 4 failed" << endl;\n        return 1;\n    }\n\n    s = "adb";\n    if (is_happy(s)) {\n        cout << "Test 5 passed" << endl;\n    } else {\n        cout << "Test 5 failed" << endl;\n        return 1;\n    }\n\n    s = "xyy";\n    if (!is_happy(s)) {\n        cout << "Test 6 passed" << endl;\n    } else {\n        cout << "Test 6 failed" << endl;\n        return 1;\n    }\n\n    s = "iopaxpoi";\n    if (is_happy(s)) {\n        cout << "Test 7 passed" << endl;\n    } else {\n        cout << "Test 7 failed" << endl;\n        return 1;\n    }\n\n    s = "iopaxioi";\n    if (!is_happy(s)) {\n        cout << "Test 8 passed" << endl;\n    } else {\n        cout << "Test 8 failed" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool is_happy(char *s) {\n    if (strlen(s) < 3) {\n        return false;\n    }\n\n    for (int i = 3; i < strlen(s); i++) {\n        if (s[i] == s[i-1] || s[i] == s[i-2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    char s[100];\n    scanf("%s", s);\n\n    if (!is_happy(s)) {\n        printf("Test 1 passed\n");\n    } else {\n        printf("Test 1 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "aa");\n    if (!is_happy(s)) {\n        printf("Test 2 passed\n");\n    } else {\n        printf("Test 2 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "abcd");\n    if (is_happy(s)) {\n        printf("Test 3 passed\n");\n    } else {\n        printf("Test 3 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "aabb");\n    if (!is_happy(s)) {\n        printf("Test 4 passed\n");\n    } else {\n        printf("Test 4 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "adb");\n    if (is_happy(s)) {\n        printf("Test 5 passed\n");\n    } else {\n        printf("Test 5 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "xyy");\n    if (!is_happy(s)) {\n        printf("Test 6 passed\n");\n    } else {\n        printf("Test 6 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "iopaxpoi");\n    if (is_happy(s)) {\n        printf("Test 7 passed\n");\n    } else {\n        printf("Test 7 failed\n");\n        return 1;\n    }\n\n    strcpy(s, "iopaxioi");\n    if (!is_happy(s)) {\n        printf("Test 8 passed\n");\n    } else {\n        printf("Test 8 failed\n");\n        return 1;\n    }\n\n    return 0;\n}\n\n[Python]\ndef is_happy(s):\n    if len(s) < 3:\n        return False\n\n    for i in range(3, len(s)):\n        if s[i] == s[i-1] or s[i] == s[i-2]:\n            return False\n\n    return True\n\n\ndef main():\n    s = input()\n\n    if not is_happy(s):\n        print("Test 1 passed")\n    else:\n        print("Test 1 failed")\n        return 1\n\n    s = "aa"\n    if not is_happy(s):\n        print("Test 2 passed")\n    else:\n        print("Test 2 failed")\n        return 1\n\n    s = "abcd"\n    if is_happy(s):\n        print("Test 3 passed")\n    else:\n        print("Test 3 failed")\n        return 1\n\n    s = "aabb"\n    if not is_happy(s):\n        print("Test 4 passed")\n    else:\n        print("Test 4 failed")\n        return 1\n\n    s = "adb"\n    if is_happy(s):\n        print("Test 5 passed")\n    else:\n        print("Test 5 failed")\n        return 1\n\n    s = "xyy"\n    if not is_happy(s):\n        print("Test 6 passed")\n    else:\n        print("Test 6 failed")\n        return 1\n\n    s = "iopaxpoi"\n    if is_happy(s):\n        print("Test 7 passed")\n    else:\n        print("Test 7 failed")\n        return 1\n\n    s = "iopaxioi"\n    if not is_happy(s):\n        print("Test 8 passed")\n    else:\n        print("Test 8 failed")\n        return 1\n\n    return 0\n\nif __name__ == "__main__":\n    main()\n\n[JavaScript]\nfunction isHappy(s) {\n    if (s.length < 3) {\n        return false;\n    }\n\n    for (let i = 3; i < s.length; i++) {\n        if (s[i] == s[i-1] || s[i] == s[i-2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction main() {\n    let s = readline();\n\n    if (!isHappy(s)) {\n        console.log("Test 1 passed");\n    } else {\n        console.log("Test 1 failed");\n        return 1;\n    }\n\n    s = "aa";\n    if (!isHappy(s)) {\n        console.log("Test 2 passed");\n    } else {\n        console.log("Test 2 failed");\n        return 1;\n    }\n\n    s = "abcd";\n    if (isHappy(s)) {\n        console.log("Test 3 passed");\n    } else {\n        console.log("Test 3 failed");\n        return 1;\n    }\n\n    s = "aabb";\n    if (!isHappy(
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(const vector<double> &grades) {\n    vector<string> out(grades.size());\n\n    for (int i = 0; i < grades.size(); i++) {\n        if (grades[i] >= 3.9999) {\n            out[i] = "A+";\n        } else if (grades[i] > 3.7001 && grades[i] < 3.9999) {\n            out[i] = "A ";\n        } else if (grades[i] > 3.3001 && grades[i] <= 3.7001) {\n            out[i] = "A-";\n        } else if (grades[i] > 3.0001 && grades[i] <= 3.3001) {\n            out[i] = "B+";\n        } else if (grades[i] > 2.7001 && grades[i] <= 3.0001) {\n            out[i] = "B ";\n        } else if (grades[i] > 2.3001 && grades[i] <= 2.7001) {\n            out[i] = "B-";\n        } else if (grades[i] > 2.0001 && grades[i] <= 2.3001) {\n            out[i] = "C+";\n        } else if (grades[i] > 1.7001 && grades[i] <= 2.0001) {\n            out[i] = "C ";\n        } else if (grades[i] > 1.3001 && grades[i] <= 1.7001) {\n            out[i] = "C-";\n        } else if (grades[i] > 1.0001 && grades[i] <= 1.3001) {\n            out[i] = "D+";\n        } else if (grades[i] > 0.7001 && grades[i] <= 1.0001) {\n            out[i] = "D ";\n        } else if (grades[i] > 0.0001 && grades[i] <= 0.7001) {\n            out[i] = "D-";\n        } else {\n            out[i] = "E ";\n        }\n    }\n\n    return out;\n}\n\nint main() {\n    vector<double> grades1 = {4.0, 3.0, 1.7, 2.0, 3.5};\n    vector<string> expected1 = {"A+", "B ", "C-", "C ", "A-"};\n    if (numerical_letter_grade(grades1) != expected1) {\n        cout << "Assertion failed for test case 1" << endl;\n        return 1;\n    }\n\n    vector<double> grades2 = {1.2};\n    vector<string> expected2 = {"D+"};\n    if (numerical_letter_grade(grades2) != expected2) {\n        cout << "Assertion failed for test case 2" << endl;\n        return 1;\n    }\n\n    vector<double> grades3 = {0.5};\n    vector<string> expected3 = {"D-"};\n    if (numerical_letter_grade(grades3) != expected3) {\n        cout << "Assertion failed for test case 3" << endl;\n        return 1;\n    }\n\n    vector<double> grades4 = {0.0};\n    vector<string> expected4 = {"E "};\n    if (numerical_letter_grade(grades4) != expected4) {\n        cout << "Assertion failed for test case 4" << endl;\n        return 1;\n    }\n\n    vector<double> grades5 = {1.0, 0.3, 1.5, 2.8, 3.3};\n    vector<string> expected5 = {"D ", "D-", "C-", "B ", "B+"};\n    if (numerical_letter_grade(grades5) != expected5) {\n        cout << "Assertion failed for test case 5" << endl;\n        return 1;\n    }\n\n    vector<double> grades6 = {0.0, 0.7};\n    vector<string> expected6 = {"E ", "D-"};\n    if (numerical_letter_grade(grades6) != expected6) {\n        cout << "Assertion failed for test case 6" << endl;\n        return 1;\n    }\n\n    cout << "All tests passed." << endl;\n    return 0;\n}\n```\n\n### 3.1.2. 声明\n\n#### 3.1.2.1. 变量\n\n##### 3.1.2.1.1. 变量声明\n\n```c++\nint a;\ndouble b;\n```\n\n##### 3.1.2.1.2. 变量初始化\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.3. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.4. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.5. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.6. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.7. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.8. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.9. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.10. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.11. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.12. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.13. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.14. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.15. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0;\n```\n\n##### 3.1.2.1.16. 变量初始化（带默认值）\n\n```c++\nint a = 1;\ndouble b = 2.0
\n\n[C++]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nbool is_prime_length(const std::string& s) {\n  int l = s.length();\n  if (l < 2) {\n    return false;\n  }\n\n  for (int i = 2; i <= std::sqrt(l); i++) {\n    if (l % i == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvoid run_tests() {\n  std::string str = "Hello";\n  bool result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('Hello') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "abcdcba";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('abcdcba') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "kittens";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('kittens') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "orange";\n  result = is_prime_length(str);\n  if (result) {\n    std::cout << "is_prime_length('orange') == false: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "wow";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('wow') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "world";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('world') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "MadaM";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('MadaM') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "Wow";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('Wow') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "";\n  result = is_prime_length(str);\n  if (result) {\n    std::cout << "is_prime_length('') == false: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "HI";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('HI') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "go";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('go') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "gogo";\n  result = is_prime_length(str);\n  if (result) {\n    std::cout << "is_prime_length('gogo') == false: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "aaaaaaaaaaaaaaa";\n  result = is_prime_length(str);\n  if (result) {\n    std::cout << "is_prime_length('aaaaaaaaaaaaaaa') == false: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "Madam";\n  result = is_prime_length(str);\n  if (!result) {\n    std::cout << "is_prime_length('Madam') == true: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "M";\n  result = is_prime_length(str);\n  if (result) {\n    std::cout << "is_prime_length('M') == false: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  str = "0";\n  result = is_prime_length(str);\n  if (result) {\n    std::cout << "is_prime_length('0') == false: assertion failed" << std::endl;\n    exit(1);\n  }\n\n  std::cout << "All tests passed successfully." << std::endl;\n}\n\nint main() {\n  run_tests();\n  return 0;\n}\n\n[C#]\nusing System;\n\nclass Program {\n  static bool IsPrimeLength(string s) {\n    int l = s.Length;\n    if (l < 2) {\n      return false;\n    }\n\n    for (int i = 2; i <= Math.Sqrt(l); i++) {\n      if (l % i == 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static void RunTests() {\n    string str = "Hello";\n    bool result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('Hello') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "abcdcba";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('abcdcba') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "kittens";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('kittens') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "orange";\n    result = IsPrimeLength(str);\n    if (result) {\n      Console.WriteLine("IsPrimeLength('orange') == false: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "wow";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('wow') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "world";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('world') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "MadaM";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('MadaM') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "Wow";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('Wow') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "";\n    result = IsPrimeLength(str);\n    if (result) {\n      Console.WriteLine("IsPrimeLength('') == false: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "HI";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('HI') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "go";\n    result = IsPrimeLength(str);\n    if (!result) {\n      Console.WriteLine("IsPrimeLength('go') == true: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "gogo";\n    result = IsPrimeLength(str);\n    if (result) {\n      Console.WriteLine("IsPrimeLength('gogo') == false: assertion failed");\n      Environment.Exit(1);\n    }\n\n    str = "aaaaaaaaaaaaaaa";\n    result = IsPrimeLength(str);\n    if (result) {\n      Console.
\n\n[EXPECTED]\n[TXT]\nAll assertions passed.\n[/TXT]\n\n[CMD]\n./instrumented\n[/CMD]\n\n[STDERR]\n[TXT]\n[/TXT]\n\n[FILE]\n[TXT]\n<?xml version="1.0" encoding="UTF-8"?>\n<checker name="instrumented" version="1.0">\n  <function name="starts_one_ends">\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="1" />\n      </arg>\n      <return type="int">\n        <int value="1" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="2" />\n      </arg>\n      <return type="int">\n        <int value="18" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="3" />\n      </arg>\n      <return type="int">\n        <int value="180" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="4" />\n      </arg>\n      <return type="int">\n        <int value="1800" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="5" />\n      </arg>\n      <return type="int">\n        <int value="18000" />\n      </return>\n    </call>\n  </function>\n</checker>\n[/FILE]\n\n[STDERR]\n[TXT]\n[/TXT]\n\n[FILE]\n[TXT]\n<?xml version="1.0" encoding="UTF-8"?>\n<checker name="instrumented" version="1.0">\n  <function name="starts_one_ends">\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="1" />\n      </arg>\n      <return type="int">\n        <int value="1" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="2" />\n      </arg>\n      <return type="int">\n        <int value="18" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="3" />\n      </arg>\n      <return type="int">\n        <int value="180" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="4" />\n      </arg>\n      <return type="int">\n        <int value="1800" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="5" />\n      </arg>\n      <return type="int">\n        <int value="18000" />\n      </return>\n    </call>\n  </function>\n</checker>\n[/FILE]\n\n[STDERR]\n[TXT]\n[/TXT]\n\n[FILE]\n[TXT]\n<?xml version="1.0" encoding="UTF-8"?>\n<checker name="instrumented" version="1.0">\n  <function name="starts_one_ends">\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="1" />\n      </arg>\n      <return type="int">\n        <int value="1" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="2" />\n      </arg>\n      <return type="int">\n        <int value="18" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="3" />\n      </arg>\n      <return type="int">\n        <int value="180" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="4" />\n      </arg>\n      <return type="int">\n        <int value="1800" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="5" />\n      </arg>\n      <return type="int">\n        <int value="18000" />\n      </return>\n    </call>\n  </function>\n</checker>\n[/FILE]\n\n[STDERR]\n[TXT]\n[/TXT]\n\n[FILE]\n[TXT]\n<?xml version="1.0" encoding="UTF-8"?>\n<checker name="instrumented" version="1.0">\n  <function name="starts_one_ends">\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="1" />\n      </arg>\n      <return type="int">\n        <int value="1" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="2" />\n      </arg>\n      <return type="int">\n        <int value="18" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="3" />\n      </arg>\n      <return type="int">\n        <int value="180" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="4" />\n      </arg>\n      <return type="int">\n        <int value="1800" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="5" />\n      </arg>\n      <return type="int">\n        <int value="18000" />\n      </return>\n    </call>\n  </function>\n</checker>\n[/FILE]\n\n[STDERR]\n[TXT]\n[/TXT]\n\n[FILE]\n[TXT]\n<?xml version="1.0" encoding="UTF-8"?>\n<checker name="instrumented" version="1.0">\n  <function name="starts_one_ends">\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="1" />\n      </arg>\n      <return type="int">\n        <int value="1" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="2" />\n      </arg>\n      <return type="int">\n        <int value="18" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="3" />\n      </arg>\n      <return type="int">\n        <int value="180" />\n      </return>\n    </call>\n    <call count="1">\n      <arg name="n" count="1" type="int">\n        <int value="4" />\n      </arg>\n      <return type="int">\n        <int value="1
\n\n[SOLUTION]\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring solve(int N) {\n    string str = to_string(N);\n    int sum = 0;\n    for (int i = 0; i < str.length(); i++) {\n        sum += str[i] - '0';\n    }\n    string bi = "";\n    while (sum > 0) {\n        bi = to_string(sum % 2) + bi;\n        sum /= 2;\n    }\n    if (bi.length() == 0) {\n        bi = "0";\n    }\n    return bi;\n}\n\nint main() {\n    string result = solve(1000);\n    if (result != "1") {\n        cout << "Assertion failed for solve(1000)" << endl;\n        return 1;\n    }\n    result = solve(150);\n    if (result != "110") {\n        cout << "Assertion failed for solve(150)" << endl;\n        return 1;\n    }\n    result = solve(147);\n    if (result != "1100") {\n        cout << "Assertion failed for solve(147)" << endl;\n        return 1;\n    }\n    result = solve(333);\n    if (result != "1001") {\n        cout << "Assertion failed for solve(333)" << endl;\n        return 1;\n    }\n    result = solve(963);\n    if (result != "10010") {\n        cout << "Assertion failed for solve(963)" << endl;\n        return 1;\n    }\n    cout << "All tests passed." << endl;\n    return 0;\n}\n[/SOLUTION]\n\n[CHALLENGE]\n/*\n * Challenge #2:\n *\n * Write a function that takes a string and returns the number of\n * vowels in the string.\n *\n * For example:\n *\n *   - "hello" -> 2\n *   - "goodbye" -> 2\n *   - "a" -> 1\n *   - "aeiou" -> 5\n *   - "aeiouaeiou" -> 10\n *   - "aeiouaeiouaeiou" -> 15\n *   - "aeiouaeiouaeiouaeiou" -> 20\n *   - "aeiouaeiouaeiouaeiouaeiou" -> 25\n *   - "aeiouaeiouaeiouaeiouaeiouaeiou" -> 30\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 35\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 40\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 45\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 50\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 55\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 60\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 65\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 70\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 75\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 80\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 85\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 90\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 95\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 100\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 105\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 110\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 115\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 120\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 125\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 130\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 135\n *   - "aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou" -> 140\n *   - "aeiouaeiouaeiouae
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size() / 2; i++) {\n        if (lst[2 * i + 2] % 2 == 0) {\n            sum += lst[2 * i + 2];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test cases\n    lst = {4, 88};\n    result = add(lst);\n    if (result != 88) {\n        std::cout << "Assertion failed: add([4, 88]) == 88" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 5, 6, 7, 2, 122};\n    result = add(lst);\n    if (result != 122) {\n        std::cout << "Assertion failed: add([4, 5, 6, 7, 2, 122]) == 122" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 0, 6, 7};\n    result = add(lst);\n    if (result != 0) {\n        std::cout << "Assertion failed: add([4, 0, 6, 7]) == 0" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 4, 6, 8};\n    result = add(lst);\n    if (result != 12) {\n        std::cout << "Assertion failed: add([4, 4, 6, 8]) == 12" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size() / 2; i++) {\n        if (lst[2 * i + 2] % 2 == 0) {\n            sum += lst[2 * i + 2];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test cases\n    lst = {4, 88};\n    result = add(lst);\n    if (result != 88) {\n        std::cout << "Assertion failed: add([4, 88]) == 88" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 5, 6, 7, 2, 122};\n    result = add(lst);\n    if (result != 122) {\n        std::cout << "Assertion failed: add([4, 5, 6, 7, 2, 122]) == 122" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 0, 6, 7};\n    result = add(lst);\n    if (result != 0) {\n        std::cout << "Assertion failed: add([4, 0, 6, 7]) == 0" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 4, 6, 8};\n    result = add(lst);\n    if (result != 12) {\n        std::cout << "Assertion failed: add([4, 4, 6, 8]) == 12" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size() / 2; i++) {\n        if (lst[2 * i + 2] % 2 == 0) {\n            sum += lst[2 * i + 2];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test cases\n    lst = {4, 88};\n    result = add(lst);\n    if (result != 88) {\n        std::cout << "Assertion failed: add([4, 88]) == 88" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 5, 6, 7, 2, 122};\n    result = add(lst);\n    if (result != 122) {\n        std::cout << "Assertion failed: add([4, 5, 6, 7, 2, 122]) == 122" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 0, 6, 7};\n    result = add(lst);\n    if (result != 0) {\n        std::cout << "Assertion failed: add([4, 0, 6, 7]) == 0" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 4, 6, 8};\n    result = add(lst);\n    if (result != 12) {\n        std::cout << "Assertion failed: add([4, 4, 6, 8]) == 12" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size() / 2; i++) {\n        if (lst[2 * i + 2] % 2 == 0) {\n            sum += lst[2 * i + 2];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test cases\n    lst = {4, 88};\n    result = add(lst);\n    if (result != 88) {\n        std::cout << "Assertion failed: add([4, 88]) == 88" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 5, 6, 7, 2, 122};\n    result = add(lst);\n    if (result != 122) {\n        std::cout << "Assertion failed: add([4, 5, 6, 7, 2, 122]) == 122" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 0, 6, 7};\n    result = add(lst);\n    if (result != 0) {\n        std::cout << "Assertion failed: add([4, 0, 6, 7]) == 0" << std::endl;\n        return 1;\n    }\n\n    lst = {4, 4, 6, 8};\n    result = add(lst);\n    if (result != 12) {\n        std::cout << "Assertion failed: add([4, 4, 6, 8]) == 12" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size() / 2; i++) {\n        if (lst[2 * i + 2] % 2 == 0) {\n            sum += lst[2 * i + 2];\n        }\n    }\n    return sum;\n}\n\n
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    int n = array.size();\n    if (n == 0) {\n        return vector<int>();\n    }\n\n    vector<int> out = array;\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    if (out[0] + out[n - 1] % 2 == 1) {\n        return out;\n    } else {\n        reverse(out.begin(), out.end());\n        return out;\n    }\n}\n\nbool issame(vector<int> a, vector<int> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nvoid test_cases() {\n    assert(issame(sort_array({0}), {0}));\n    assert(issame(sort_array({5}), {5}));\n    assert(issame(sort_array({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5}));\n    assert(issame(sort_array({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0}));\n    assert(issame(sort_array({2, 1}), {1, 2}));\n    assert(issame(sort_array({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87}));\n    assert(issame(sort_array({21, 14, 23, 11}), {23, 21, 14, 11}));\n}\n\nint main() {\n    test_cases();\n}\n[/C++]\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))\n\nvoid assert(bool condition) {\n    if (!condition) {\n        printf("Assertion failed\n");\n        exit(1);\n    }\n}\n\nbool issame(int *a, int *b, int n) {\n    for (int i = 0; i < n; i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint *sort_array(int *array, int n) {\n    int *out = malloc(sizeof(int) * n);\n    memcpy(out, array, sizeof(int) * n);\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    if (out[0] + out[n - 1] % 2 == 1) {\n        return out;\n    } else {\n        for (int i = 0; i < n / 2; i++) {\n            int temp = out[i];\n            out[i] = out[n - i - 1];\n            out[n - i - 1] = temp;\n        }\n        return out;\n    }\n}\n\nvoid test_cases() {\n    assert(issame(sort_array((int[]){0}, 1), (int[]){0}, 1));\n    assert(issame(sort_array((int[]){5}, 1), (int[]){5}, 1));\n    assert(issame(sort_array((int[]){2, 4, 3, 0, 1, 5}, 6), (int[]){0, 1, 2, 3, 4, 5}, 6));\n    assert(issame(sort_array((int[]){2, 4, 3, 0, 1, 5, 6}, 7), (int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    assert(issame(sort_array((int[]){2, 1}, 2), (int[]){1, 2}, 2));\n    assert(issame(sort_array((int[]){15, 42, 87, 32, 11, 0}, 6), (int[]){0, 11, 15, 32, 42, 87}, 6));\n    assert(issame(sort_array((int[]){21, 14, 23, 11}, 4), (int[]){23, 21, 14, 11}, 4));\n}\n\nint main() {\n    test_cases();\n}\n[/C]\n\n[Python]\ndef sort_array(array):\n    n = len(array)\n    if n == 0:\n        return []\n\n    out = array.copy()\n\n    # Bubble sort implementation\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if out[j] > out[j + 1]:\n                out[j], out[j + 1] = out[j + 1], out[j]\n\n    if out[0] + out[n - 1] % 2 == 1:\n        return out\n    else:\n        return out[::-1]\n\ndef issame(a, b):\n    return a == b\n\ndef test_cases():\n    assert issame(sort_array([0]), [0])\n    assert issame(sort_array([5]), [5])\n    assert issame(sort_array([2, 4, 3, 0, 1, 5]), [0, 1, 2, 3, 4, 5])\n    assert issame(sort_array([2, 4, 3, 0, 1, 5, 6]), [6, 5, 4, 3, 2, 1, 0])\n    assert issame(sort_array([2, 1]), [1, 2])\n    assert issame(sort_array([15, 42, 87, 32, 11, 0]), [0, 11, 15, 32, 42, 87])\n    assert issame(sort_array([21, 14, 23, 11]), [23, 21, 14, 11])\n\nif __name__ == "__main__":\n    test_cases()\n[/Python]\n\n[Java]\nimport java.util.Arrays;\n\nclass Main {\n    public static void assert(boolean condition) {\n        if (!condition) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n    }\n\n    public static boolean issame(int[] a, int[] b) {\n        if (a.length != b.length) {\n            return false;\n        }\n\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] != b[
\n\n[CPP]\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() == 0) {\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end());\n\n    int res = -1;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != lst[i-1]) {\n            res = lst[i];\n            break;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    vector<int> lst;\n    int result;\n\n    // Test case 1\n    lst = {1, 2, 3, 4, 5};\n    result = next_smallest(lst);\n    if (result != 2) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    // Test case 2\n    lst = {5, 1, 4, 3, 2};\n    result = next_smallest(lst);\n    if (result != 2) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    // Test case 3\n    lst = {};\n    result = next_smallest(lst);\n    if (result != -1) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    // Test case 4\n    lst = {1, 1};\n    result = next_smallest(lst);\n    if (result != -1) {\n        cout << "Test case 4 failed" << endl;\n        return 1;\n    }\n\n    // Test case 5\n    lst = {1, 1, 1, 1, 0};\n    result = next_smallest(lst);\n    if (result != 1) {\n        cout << "Test case 5 failed" << endl;\n        return 1;\n    }\n\n    // Test case 6\n    lst = {-35, 34, 12, -45};\n    result = next_smallest(lst);\n    if (result != -35) {\n        cout << "Test case 6 failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed" << endl;\n    return 0;\n}\n\n[PY]\ndef next_smallest(lst):\n    if len(lst) == 0:\n        return -1\n\n    lst.sort()\n\n    res = -1\n    for i in range(1, len(lst)):\n        if lst[i] != lst[i-1]:\n            res = lst[i]\n            break\n\n    return res\n\ndef main():\n    lst = [1, 2, 3, 4, 5]\n    result = next_smallest(lst)\n    if result != 2:\n        print("Test case 1 failed")\n        return 1\n\n    lst = [5, 1, 4, 3, 2]\n    result = next_smallest(lst)\n    if result != 2:\n        print("Test case 2 failed")\n        return 1\n\n    lst = []\n    result = next_smallest(lst)\n    if result != -1:\n        print("Test case 3 failed")\n        return 1\n\n    lst = [1, 1]\n    result = next_smallest(lst)\n    if result != -1:\n        print("Test case 4 failed")\n        return 1\n\n    lst = [1, 1, 1, 1, 0]\n    result = next_smallest(lst)\n    if result != 1:\n        print("Test case 5 failed")\n        return 1\n\n    lst = [-35, 34, 12, -45]\n    result = next_smallest(lst)\n    if result != -35:\n        print("Test case 6 failed")\n        return 1\n\n    print("All test cases passed")\n    return 0\n\n[JAVA]\nimport java.util.Arrays;\n\nclass Solution {\n    public static int nextSmallest(int[] lst) {\n        if (lst.length == 0) {\n            return -1;\n        }\n\n        Arrays.sort(lst);\n\n        int res = -1;\n        for (int i = 1; i < lst.length; ++i) {\n            if (lst[i] != lst[i-1]) {\n                res = lst[i];\n                break;\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] lst = {1, 2, 3, 4, 5};\n        int result = nextSmallest(lst);\n        if (result != 2) {\n            System.out.println("Test case 1 failed");\n            System.exit(1);\n        }\n\n        lst = new int[] {5, 1, 4, 3, 2};\n        result = nextSmallest(lst);\n        if (result != 2) {\n            System.out.println("Test case 2 failed");\n            System.exit(1);\n        }\n\n        lst = new int[] {};\n        result = nextSmallest(lst);\n        if (result != -1) {\n            System.out.println("Test case 3 failed");\n            System.exit(1);\n        }\n\n        lst = new int[] {1, 1};\n        result = nextSmallest(lst);\n        if (result != -1) {\n            System.out.println("Test case 4 failed");\n            System.exit(1);\n        }\n\n        lst = new int[] {1, 1, 1, 1, 0};\n        result = nextSmallest(lst);\n        if (result != 1) {\n            System.out.println("Test case 5 failed");\n            System.exit(1);\n        }\n\n        lst = new int[] {-35, 34, 12, -45};\n        result = nextSmallest(lst);\n        if (result != -35) {\n            System.out.println("Test case 6 failed");\n            System.exit(1);\n        }\n\n        System.out.println("All test cases passed");\n    }\n}\n\n[RUBY]\ndef next_smallest(lst)\n    if lst.length == 0\n        return -1\n    end\n\n    lst.sort!\n\n    res = -1\n    for i in 1...lst.length\n        if lst[i] != lst[i-1]\n            res = lst[i]\n            break\n        end\n    end\n\n    return res\nend\n\ndef main\n    lst = [1, 2, 3, 4, 5]\n    result = next_smallest(lst)\n    if result != 2\n        puts "Test case 1 failed"\n        exit 1\n    end\n\n    lst = [5, 1, 4, 3, 2]\n    result = next_smallest(lst)\n    if result != 2\n        puts "Test case 2 failed"\n        exit 1\n    end\n\n    lst = []\n    result = next_smallest(lst)\n    if result != -1\n        puts "Test case 3 failed"\n        exit 1\n    end\n\n    lst = [1, 1]\n    result = next_smallest(lst)\n    if result != -1\n        puts "Test case 4 failed"\n        exit 1\n    end\n\n    lst = [1, 1, 1, 1, 0]\n    result = next_smallest(lst)\n    if result != 1\n        puts "Test case 5 failed"\n        exit 1\n    end\n\n    lst = [-35, 34, 12, -45]\n    result = next_smallest(lst)\n    if result != -35\n        puts "Test case 6 failed"\n        exit 1\n    end\n\n    puts "All test cases passed"\nend\n\n[C#]\nusing System;\nusing System.Linq;\n\nclass Solution {\n    public static int NextSmallest(int[] lst) {\n        if (lst.Length == 0) {\n            return -1;\n        }\n\n
\n\n[EXPECTED]\n[SUCCESS]\n[BACKEND]\n\n[BACKEND]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]\n[TITLE]
\n\n[C++]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nbool any_int(double a, double b, double c) {\n    if (std::floor(a) != a) {\n        return false;\n    }\n    if (std::floor(b) != b) {\n        return false;\n    }\n    if (std::floor(c) != c) {\n        return false;\n    }\n    if (a + b == c || a + c == b || b + c == a) {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    bool result;\n\n    result = any_int(2.0, 3.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 3, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.5, 2.0, 3.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.5, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(1.5, 5.0, 3.5);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(1.5, 5, 3.5) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0, 6.0, 2.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2, 6, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(4.0, 2.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(4, 2, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.2, 2.2, 2.2);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.2, 2.2, 2.2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(-4.0, 6.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(-4, 6, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0, 1.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 1, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.0, 4.0, 7.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(3, 4, 7) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.01, 4.0, 7.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(3.01, 4, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\n[C]\n#include <math.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nbool any_int(double a, double b, double c) {\n    if (floor(a) != a) {\n        return false;\n    }\n    if (floor(b) != b) {\n        return false;\n    }\n    if (floor(c) != c) {\n        return false;\n    }\n    if (a + b == c || a + c == b || b + c == a) {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    bool result;\n\n    result = any_int(2.0, 3.0, 1.0);\n    if (!result) {\n        fprintf(stderr, "Assertion failed: any_int(2, 3, 1) == true\n");\n        exit(1);\n    }\n\n    result = any_int(2.5, 2.0, 3.0);\n    if (result) {\n        fprintf(stderr, "Assertion failed: any_int(2.5, 2, 3) == false\n");\n        exit(1);\n    }\n\n    result = any_int(1.5, 5.0, 3.5);\n    if (result) {\n        fprintf(stderr, "Assertion failed: any_int(1.5, 5, 3.5) == false\n");\n        exit(1);\n    }\n\n    result = any_int(2.0, 6.0, 2.0);\n    if (result) {\n        fprintf(stderr, "Assertion failed: any_int(2, 6, 2) == false\n");\n        exit(1);\n    }\n\n    result = any_int(4.0, 2.0, 2.0);\n    if (!result) {\n        fprintf(stderr, "Assertion failed: any_int(4, 2, 2) == true\n");\n        exit(1);\n    }\n\n    result = any_int(2.2, 2.2, 2.2);\n    if (result) {\n        fprintf(stderr, "Assertion failed: any_int(2.2, 2.2, 2.2) == false\n");\n        exit(1);\n    }\n\n    result = any_int(-4.0, 6.0, 2.0);\n    if (!result) {\n        fprintf(stderr, "Assertion failed: any_int(-4, 6, 2) == true\n");\n        exit(1);\n    }\n\n    result = any_int(2.0, 1.0, 1.0);\n    if (!result) {\n        fprintf(stderr, "Assertion failed: any_int(2, 1, 1) == true\n");\n        exit(1);\n    }\n\n    result = any_int(3.0, 4.0, 7.0);\n    if (!result) {\n        fprintf(stderr, "Assertion failed: any_int(3, 4, 7) == true\n");\n        exit(1);\n    }\n\n    result = any_int(3.01, 4.0, 7.0);\n    if (result) {\n        fprintf(stderr, "Assertion failed: any_int(3.01, 4, 7) == false\n");\n        exit(1);\n    }\n\n    printf("All tests passed.\n");\n    return 0;\n}\n\n[Python]\ndef any_int(a, b, c):\n    if a != int(a):\n        return False\n    if b != int(b):\n        return False\n    if c != int(c):\n        return False\n    return (a + b == c or a + c == b or b + c == a)\n\nif not any_int(2.0, 3.0, 1.0):\n    print("Assertion failed: any_int(2, 3, 1) == true")\n    exit(1)\n\nif any_int(2.5, 2.0, 3.0):\n    print("Assertion failed: any_int(2.5, 2, 3) == false")\n    exit(1)\n\nif any_int(1.5, 5.0, 3.5):\n    print("Assertion failed: any_int(1.5, 5, 3.5) == false
\n\n[CPP]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint skjkasdkd(vector<int> lst) {\n    int largest = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > largest) {\n            bool prime = true;\n            for (int j = 2; j <= sqrt(lst[i]); j++) {\n                if (lst[i] % j == 0) {\n                    prime = false;\n                    break;\n                }\n            }\n            if (prime) largest = lst[i];\n        }\n    }\n\n    int sum = 0;\n    string s = to_string(largest);\n    for (int i = 0; i < s.length(); i++) {\n        sum += s[i] - '0';\n    }\n    return sum;\n}\n\nint main() {\n    vector<int> lst = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    int result = skjkasdkd(lst);\n    if (result != 10) {\n        cout << "Assertion failed: result != 10" << endl;\n        exit(1);\n    }\n\n    lst = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    result = skjkasdkd(lst);\n    if (result != 25) {\n        cout << "Assertion failed: result != 25" << endl;\n        exit(1);\n    }\n\n    lst = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    result = skjkasdkd(lst);\n    if (result != 13) {\n        cout << "Assertion failed: result != 13" << endl;\n        exit(1);\n    }\n\n    lst = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    result = skjkasdkd(lst);\n    if (result != 11) {\n        cout << "Assertion failed: result != 11" << endl;\n        exit(1);\n    }\n\n    lst = {0,81,12,3,1,21};\n    result = skjkasdkd(lst);\n    if (result != 3) {\n        cout << "Assertion failed: result != 3" << endl;\n        exit(1);\n    }\n\n    lst = {0,8,1,2,1,7};\n    result = skjkasdkd(lst);\n    if (result != 7) {\n        cout << "Assertion failed: result != 7" << endl;\n        exit(1);\n    }\n\n    lst = {8191};\n    result = skjkasdkd(lst);\n    if (result != 19) {\n        cout << "Assertion failed: result != 19" << endl;\n        exit(1);\n    }\n\n    lst = {8191, 123456, 127, 7};\n    result = skjkasdkd(lst);\n    if (result != 19) {\n        cout << "Assertion failed: result != 19" << endl;\n        exit(1);\n    }\n\n    lst = {127, 97, 8192};\n    result = skjkasdkd(lst);\n    if (result != 10) {\n        cout << "Assertion failed: result != 10" << endl;\n        exit(1);\n    }\n\n    cout << "All tests passed." << endl;\n    return 0;\n} [/CPP]\n\n[C]\n#include <math.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nint skjkasdkd(int *lst, int lst_len) {\n    int largest = 0;\n    for (int i = 0; i < lst_len; i++) {\n        if (lst[i] > largest) {\n            bool prime = true;\n            for (int j = 2; j <= sqrt(lst[i]); j++) {\n                if (lst[i] % j == 0) {\n                    prime = false;\n                    break;\n                }\n            }\n            if (prime) largest = lst[i];\n        }\n    }\n\n    int sum = 0;\n    char s[20];\n    sprintf(s, "%d", largest);\n    for (int i = 0; i < strlen(s); i++) {\n        sum += s[i] - '0';\n    }\n    return sum;\n}\n\nint main() {\n    int lst[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    int result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 10) {\n        printf("Assertion failed: result != 10\n");\n        exit(1);\n    }\n\n    lst = (int[]){1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 25) {\n        printf("Assertion failed: result != 25\n");\n        exit(1);\n    }\n\n    lst = (int[]){1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 13) {\n        printf("Assertion failed: result != 13\n");\n        exit(1);\n    }\n\n    lst = (int[]){0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 11) {\n        printf("Assertion failed: result != 11\n");\n        exit(1);\n    }\n\n    lst = (int[]){0,81,12,3,1,21};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 3) {\n        printf("Assertion failed: result != 3\n");\n        exit(1);\n    }\n\n    lst = (int[]){0,8,1,2,1,7};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 7) {\n        printf("Assertion failed: result != 7\n");\n        exit(1);\n    }\n\n    lst = (int[]){8191};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 19) {\n        printf("Assertion failed: result != 19\n");\n        exit(1);\n    }\n\n    lst = (int[]){8191, 123456, 127, 7};\n    result = skjkasdkd(lst, sizeof(lst) / sizeof(lst[0]));\n    if (result != 19) {\n        printf("Assertion failed: result !=
\n\n[C++]\n#include <iostream>\n\nint multiply(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}\n\nint main() {\n    int result;\n\n    // Assertions\n    result = multiply(148, 412);\n    if (result != 16) {\n        std::cout << "Assertion failed: multiply(148, 412) == 16" << std::endl;\n        return 1;\n    }\n\n    result = multiply(19, 28);\n    if (result != 72) {\n        std::cout << "Assertion failed: multiply(19, 28) == 72" << std::endl;\n        return 1;\n    }\n\n    result = multiply(2020, 1851);\n    if (result != 0) {\n        std::cout << "Assertion failed: multiply(2020, 1851) == 0" << std::endl;\n        return 1;\n    }\n\n    result = multiply(14, -15);\n    if (result != 20) {\n        std::cout << "Assertion failed: multiply(14, -15) == 20" << std::endl;\n        return 1;\n    }\n\n    result = multiply(76, 67);\n    if (result != 42) {\n        std::cout << "Assertion failed: multiply(76, 67) == 42" << std::endl;\n        return 1;\n    }\n\n    result = multiply(17, 27);\n    if (result != 49) {\n        std::cout << "Assertion failed: multiply(17, 27) == 49" << std::endl;\n        return 1;\n    }\n\n    result = multiply(0, 1);\n    if (result != 0) {\n        std::cout << "Assertion failed: multiply(0, 1) == 0" << std::endl;\n        return 1;\n    }\n\n    result = multiply(0, 0);\n    if (result != 0) {\n        std::cout << "Assertion failed: multiply(0, 0) == 0" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n\nint multiply(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}\n\nint main() {\n    int result;\n\n    // Assertions\n    result = multiply(148, 412);\n    if (result != 16) {\n        printf("Assertion failed: multiply(148, 412) == 16\n");\n        exit(1);\n    }\n\n    result = multiply(19, 28);\n    if (result != 72) {\n        printf("Assertion failed: multiply(19, 28) == 72\n");\n        exit(1);\n    }\n\n    result = multiply(2020, 1851);\n    if (result != 0) {\n        printf("Assertion failed: multiply(2020, 1851) == 0\n");\n        exit(1);\n    }\n\n    result = multiply(14, -15);\n    if (result != 20) {\n        printf("Assertion failed: multiply(14, -15) == 20\n");\n        exit(1);\n    }\n\n    result = multiply(76, 67);\n    if (result != 42) {\n        printf("Assertion failed: multiply(76, 67) == 42\n");\n        exit(1);\n    }\n\n    result = multiply(17, 27);\n    if (result != 49) {\n        printf("Assertion failed: multiply(17, 27) == 49\n");\n        exit(1);\n    }\n\n    result = multiply(0, 1);\n    if (result != 0) {\n        printf("Assertion failed: multiply(0, 1) == 0\n");\n        exit(1);\n    }\n\n    result = multiply(0, 0);\n    if (result != 0) {\n        printf("Assertion failed: multiply(0, 0) == 0\n");\n        exit(1);\n    }\n\n    return 0;\n}\n\n[Python]\ndef multiply(a, b):\n    return abs(a) % 10 * abs(b) % 10\n\n\ndef main():\n    result = multiply(148, 412)\n    if result != 16:\n        print("Assertion failed: multiply(148, 412) == 16")\n        exit(1)\n\n    result = multiply(19, 28)\n    if result != 72:\n        print("Assertion failed: multiply(19, 28) == 72")\n        exit(1)\n\n    result = multiply(2020, 1851)\n    if result != 0:\n        print("Assertion failed: multiply(2020, 1851) == 0")\n        exit(1)\n\n    result = multiply(14, -15)\n    if result != 20:\n        print("Assertion failed: multiply(14, -15) == 20")\n        exit(1)\n\n    result = multiply(76, 67)\n    if result != 42:\n        print("Assertion failed: multiply(76, 67) == 42")\n        exit(1)\n\n    result = multiply(17, 27)\n    if result != 49:\n        print("Assertion failed: multiply(17, 27) == 49")\n        exit(1)\n\n    result = multiply(0, 1)\n    if result != 0:\n        print("Assertion failed: multiply(0, 1) == 0")\n        exit(1)\n\n    result = multiply(0, 0)\n    if result != 0:\n        print("Assertion failed: multiply(0, 0) == 0")\n        exit(1)\n\n\nif __name__ == "__main__":\n    main()\n\n[Java]\npublic class Main {\n    public static void main(String[] args) {\n        int result;\n\n        // Assertions\n        result = multiply(148, 412);\n        if (result != 16) {\n            System.out.println("Assertion failed: multiply(148, 412) == 16");\n            System.exit(1);\n        }\n\n        result = multiply(19, 28);\n        if (result != 72) {\n            System.out.println("Assertion failed: multiply(19, 28) == 72");\n            System.exit(1);\n        }\n\n        result = multiply(2020, 1851);\n        if (result != 0) {\n            System.out.println("Assertion failed: multiply(2020, 1851) == 0");\n            System.exit(1);\n        }\n\n        result = multiply(14, -15);\n        if (result != 20) {\n            System.out.println("Assertion failed: multiply(14, -15) == 20");\n            System.exit(1);\n        }\n\n        result = multiply(76, 67);\n        if (result != 42) {\n            System.out.println("Assertion failed: multiply(76, 67) == 42");\n            System.exit(1);\n        }\n\n        result = multiply(17, 27);\n        if (result != 49) {\n            System.out.println("Assertion failed: multiply(17, 27) == 49");\n            System.exit(1);\n        }\n\n        result = multiply(0, 1);\n        if (result != 0) {\n            System.out.println("Assertion failed: multiply(0, 1)
\n\n[/FOLD]\n\n[FOLD]\n[TAB=Output]\nAll tests passed.\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Code]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count_upper(const char *s);\n\nint main(void)\n{\n    int result;\n\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('aBCdEf') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('abcdefg') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("dBBE");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('dBBE') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("B");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('B') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("U");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('U') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("EEEE");\n    if (result != 2) {\n        printf("Assertion failed: count_upper('EEEE') == 2\n");\n        exit(1);\n    }\n\n    printf("All tests passed.\n");\n    return 0;\n}\n\nint count_upper(const char *s)\n{\n    const char *uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = strlen(s);\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (strchr(uvowel, s[i]) != NULL) {\n            count++;\n        }\n    }\n\n    return count;\n}\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Output]\nAll tests passed.\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Code]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count_upper(const char *s);\n\nint main(void)\n{\n    int result;\n\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('aBCdEf') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('abcdefg') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("dBBE");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('dBBE') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("B");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('B') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("U");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('U') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("EEEE");\n    if (result != 2) {\n        printf("Assertion failed: count_upper('EEEE') == 2\n");\n        exit(1);\n    }\n\n    printf("All tests passed.\n");\n    return 0;\n}\n\nint count_upper(const char *s)\n{\n    const char *uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = strlen(s);\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (strchr(uvowel, s[i]) != NULL) {\n            count++;\n        }\n    }\n\n    return count;\n}\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Output]\nAll tests passed.\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Code]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count_upper(const char *s);\n\nint main(void)\n{\n    int result;\n\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('aBCdEf') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('abcdefg') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("dBBE");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('dBBE') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("B");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('B') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("U");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('U') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("EEEE");\n    if (result != 2) {\n        printf("Assertion failed: count_upper('EEEE') == 2\n");\n        exit(1);\n    }\n\n    printf("All tests passed.\n");\n    return 0;\n}\n\nint count_upper(const char *s)\n{\n    const char *uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = strlen(s);\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (strchr(uvowel, s[i]) != NULL) {\n            count++;\n        }\n    }\n\n    return count;\n}\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Output]\nAll tests passed.\n[/TAB]\n[/FOLD]\n\n[FOLD]\n[TAB=Code]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count_upper(const char *s);\n\nint main(void)\n{\n    int result;\n\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        printf("Assertion failed: count_upper('aBCdEf') == 1\n");\n        exit(1);\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        printf("Assertion failed: count_upper('abcdefg') == 0\n");\n        exit(1);\n    }\n\n    result = count_upper("dBBE");\n    if
\n\n[/C++]\n\n[C++]\n\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n\nint main() {\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n    return 0;\n}\n\nint closest_integer(const char* value) {\n    double w;\n    sscanf(value, "%lf", &w);\n    return (int) round(w);\n}\n\nvoid assert(bool condition, const char* message) {\n    if (!condition) {\n        printf("%s\n", message);\n        exit(1);\n    }\n}\n\n[/C++]\n\n[C#]\n\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n        assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n        assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n        assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n        assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n    }\n\n    static int closest_integer(string value)\n    {\n        double w;\n        double.TryParse(value, out w);\n        return (int)Math.Round(w);\n    }\n\n    static void assert(bool condition, string message)\n    {\n        if (!condition)\n        {\n            Console.WriteLine(message);\n            Environment.Exit(1);\n        }\n    }\n}\n\n[/C#]\n\n[Java]\n\npublic class Main {\n    public static void main(String[] args) {\n        assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n        assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n        assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n        assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n        assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n    }\n\n    static int closest_integer(String value) {\n        double w;\n        try {\n            w = Double.parseDouble(value);\n        } catch (NumberFormatException e) {\n            return 0;\n        }\n        return (int) Math.round(w);\n    }\n\n    static void assert(boolean condition, String message) {\n        if (!condition) {\n            System.out.println(message);\n            System.exit(1);\n        }\n    }\n}\n\n[/Java]\n\n[Python]\n\ndef main():\n    assert closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10"\n    assert closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15"\n    assert closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16"\n    assert closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15"\n    assert closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0"\n\ndef closest_integer(value):\n    return int(round(float(value)))\n\ndef assert(condition, message):\n    if not condition:\n        print(message)\n        exit(1)\n\nif __name__ == "__main__":\n    main()\n\n[/Python]\n\n[PHP]\n\n<?php\n\nfunction main() {\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n}\n\nfunction closest_integer($value) {\n    return (int) round((float) $value);\n}\n\nfunction assert($condition, $message) {\n    if (!$condition) {\n        echo $message . PHP_EOL;\n        exit(1);\n    }\n}\n\nmain();\n\n[/PHP]\n\n[Ruby]\n\ndef main\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10")\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15")\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16")\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15")\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0")\nend\n\ndef closest_integer(value)\n    return value.to_f.round\nend\n\ndef assert(condition, message)\n    if !condition\n        puts message\n        exit(1)\n    end\nend\n\nmain()\n\n[/Ruby]\n\n[Swift]\n\nfunc main() {\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10")\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15")\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16")\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15")\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0")\n}\n\nfunc closest_integer(value: String) -> Int {\n    return Int(round(Double(value)!))\n}\n\nfunc assert(_ condition: Bool, _ message: String) {\n    if !condition {\n        print(message)\n        exit(1)\n    }\n}\n\nmain()\n\n[/Swift]\n\n[Go]\n\npackage main\n\nimport (\n    "fmt"\n    "math"\n    "strconv"\n)\n\nfunc
\n\n[C++]\n#include <vector>\n#include <cstdlib>\n\nvoid make_a_pile(int n, std::vector<int>& out)\n{\n    out.resize(n);\n    out[0] = n;\n    for (int i = 1; i < n; ++i) {\n        out[i] = out[i-1] + 2;\n    }\n}\n\nint main()\n{\n    std::vector<int> pile;\n    make_a_pile(3, pile);\n    if (pile != std::vector<int>({3, 5, 7})) {\n        std::abort();\n    }\n\n    make_a_pile(4, pile);\n    if (pile != std::vector<int>({4, 6, 8, 10})) {\n        std::abort();\n    }\n\n    make_a_pile(5, pile);\n    if (pile != std::vector<int>({5, 7, 9, 11, 13})) {\n        std::abort();\n    }\n\n    make_a_pile(6, pile);\n    if (pile != std::vector<int>({6, 8, 10, 12, 14, 16})) {\n        std::abort();\n    }\n\n    make_a_pile(8, pile);\n    if (pile != std::vector<int>({8, 10, 12, 14, 16, 18, 20, 22})) {\n        std::abort();\n    }\n}\n\n[C]\nvoid make_a_pile(int n, int* out)\n{\n    int i;\n    for (i = 0; i < n; ++i) {\n        out[i] = 2 * i + 1;\n    }\n}\n\nint main()\n{\n    int pile[8];\n    make_a_pile(3, pile);\n    if (pile[0] != 3 || pile[1] != 5 || pile[2] != 7) {\n        abort();\n    }\n\n    make_a_pile(4, pile);\n    if (pile[0] != 4 || pile[1] != 6 || pile[2] != 8 || pile[3] != 10) {\n        abort();\n    }\n\n    make_a_pile(5, pile);\n    if (pile[0] != 5 || pile[1] != 7 || pile[2] != 9 || pile[3] != 11 || pile[4] != 13) {\n        abort();\n    }\n\n    make_a_pile(6, pile);\n    if (pile[0] != 6 || pile[1] != 8 || pile[2] != 10 || pile[3] != 12 || pile[4] != 14 || pile[5] != 16) {\n        abort();\n    }\n\n    make_a_pile(8, pile);\n    if (pile[0] != 8 || pile[1] != 10 || pile[2] != 12 || pile[3] != 14 || pile[4] != 16 || pile[5] != 18 || pile[6] != 20 || pile[7] != 22) {\n        abort();\n    }\n}\n\n[Python]\ndef make_a_pile(n):\n    return [2*i+1 for i in range(n)]\n\nif make_a_pile(3) != [3, 5, 7]:\n    exit(1)\n\nif make_a_pile(4) != [4, 6, 8, 10]:\n    exit(1)\n\nif make_a_pile(5) != [5, 7, 9, 11, 13]:\n    exit(1)\n\nif make_a_pile(6) != [6, 8, 10, 12, 14, 16]:\n    exit(1)\n\nif make_a_pile(8) != [8, 10, 12, 14, 16, 18, 20, 22]:\n    exit(1)\n\n[Rust]\nfn make_a_pile(n: usize) -> Vec<i32> {\n    let mut out = Vec::with_capacity(n);\n    for i in 0..n {\n        out.push(2 * i + 1);\n    }\n    out\n}\n\nfn main() {\n    assert_eq!(make_a_pile(3), vec![3, 5, 7]);\n    assert_eq!(make_a_pile(4), vec![4, 6, 8, 10]);\n    assert_eq!(make_a_pile(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(make_a_pile(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(make_a_pile(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n\n[Go]\nfunc make_a_pile(n int) []int {\n    out := make([]int, n)\n    for i := 0; i < n; i++ {\n        out[i] = 2 * i + 1\n    }\n    return out\n}\n\nfunc main() {\n    if !reflect.DeepEqual(make_a_pile(3), []int{3, 5, 7}) {\n        os.Exit(1)\n    }\n\n    if !reflect.DeepEqual(make_a_pile(4), []int{4, 6, 8, 10}) {\n        os.Exit(1)\n    }\n\n    if !reflect.DeepEqual(make_a_pile(5), []int{5, 7, 9, 11, 13}) {\n        os.Exit(1)\n    }\n\n    if !reflect.DeepEqual(make_a_pile(6), []int{6, 8, 10, 12, 14, 16}) {\n        os.Exit(1)\n    }\n\n    if !reflect.DeepEqual(make_a_pile(8), []int{8, 10, 12, 14, 16, 18, 20, 22}) {\n        os.Exit(1)\n    }\n}\n\n[C#]\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        if (!Enumerable.SequenceEqual(MakeAPile(3), new[] { 3, 5, 7 }))\n        {\n            Environment.Exit(1);\n        }\n\n        if (!Enumerable.SequenceEqual(MakeAPile(4), new[] { 4, 6, 8, 10 }))\n        {\n            Environment.Exit(1);\n        }\n\n        if (!Enumerable.SequenceEqual(MakeAPile(5), new[] { 5, 7, 9, 11, 13 }))\n        {\n            Environment.Exit(1);\n        }\n\n        if (!Enumerable.SequenceEqual(MakeAPile(6), new[] { 6, 8, 10, 12, 14, 16 }))\n        {\n            Environment.Exit(1);\n        }\n\n        if (!Enumerable.SequenceEqual(MakeAPile(8), new[] { 8, 10, 12, 14, 16, 18, 20, 22 }))\n        {\n            Environment.Exit(1);\n        }\n    }\n\n    static int[] MakeAPile(int n)\n    {\n        return Enumerable.Range(0, n).Select(i => 2 * i + 1).ToArray();\n    }\n}\n\n[Java]\nimport java.util.Arrays;\n\npublic
\n\n[C++]\n#include <iostream>\n\nint choose_num(int x, int y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && x % 2 == 1) {\n        return -1;\n    } else if (x % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n\nint main() {\n    int result;\n\n    result = choose_num(12, 15);\n    if (result != 14) {\n        std::cout << "Assertion failed: choose_num(12, 15) == 14" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(13, 12);\n    if (result != -1) {\n        std::cout << "Assertion failed: choose_num(13, 12) == -1" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        std::cout << "Assertion failed: choose_num(33, 12354) == 12354" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(5234, 5233);\n    if (result != -1) {\n        std::cout << "Assertion failed: choose_num(5234, 5233) == -1" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(6, 29);\n    if (result != 28) {\n        std::cout << "Assertion failed: choose_num(6, 29) == 28" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(27, 10);\n    if (result != -1) {\n        std::cout << "Assertion failed: choose_num(27, 10) == -1" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(7, 7);\n    if (result != -1) {\n        std::cout << "Assertion failed: choose_num(7, 7) == -1" << std::endl;\n        return 1;\n    }\n\n    result = choose_num(546, 546);\n    if (result != 546) {\n        std::cout << "Assertion failed: choose_num(546, 546) == 546" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && x % 2 == 1) {\n        return -1;\n    } else if (x % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n\nint main() {\n    int result;\n\n    result = choose_num(12, 15);\n    if (result != 14) {\n        printf("Assertion failed: choose_num(12, 15) == 14\n");\n        return 1;\n    }\n\n    result = choose_num(13, 12);\n    if (result != -1) {\n        printf("Assertion failed: choose_num(13, 12) == -1\n");\n        return 1;\n    }\n\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        printf("Assertion failed: choose_num(33, 12354) == 12354\n");\n        return 1;\n    }\n\n    result = choose_num(5234, 5233);\n    if (result != -1) {\n        printf("Assertion failed: choose_num(5234, 5233) == -1\n");\n        return 1;\n    }\n\n    result = choose_num(6, 29);\n    if (result != 28) {\n        printf("Assertion failed: choose_num(6, 29) == 28\n");\n        return 1;\n    }\n\n    result = choose_num(27, 10);\n    if (result != -1) {\n        printf("Assertion failed: choose_num(27, 10) == -1\n");\n        return 1;\n    }\n\n    result = choose_num(7, 7);\n    if (result != -1) {\n        printf("Assertion failed: choose_num(7, 7) == -1\n");\n        return 1;\n    }\n\n    result = choose_num(546, 546);\n    if (result != 546) {\n        printf("Assertion failed: choose_num(546, 546) == 546\n");\n        return 1;\n    }\n\n    return 0;\n}\n\n[Python]\ndef choose_num(x, y):\n    if y < x:\n        return -1\n    elif y == x and x % 2 == 1:\n        return -1\n    elif x % 2 == 1:\n        return y - 1\n    else:\n        return y\n\n\ndef main():\n    result = choose_num(12, 15)\n    assert result == 14, "Assertion failed: choose_num(12, 15) == 14"\n\n    result = choose_num(13, 12)\n    assert result == -1, "Assertion failed: choose_num(13, 12) == -1"\n\n    result = choose_num(33, 12354)\n    assert result == 12354, "Assertion failed: choose_num(33, 12354) == 12354"\n\n    result = choose_num(5234, 5233)\n    assert result == -1, "Assertion failed: choose_num(5234, 5233) == -1"\n\n    result = choose_num(6, 29)\n    assert result == 28, "Assertion failed: choose_num(6, 29) == 28"\n\n    result = choose_num(27, 10)\n    assert result == -1, "Assertion failed: choose_num(27, 10) == -1"\n\n    result = choose_num(7, 7)\n    assert result == -1, "Assertion failed: choose_num(7, 7) == -1"\n\n    result = choose_num(546, 546)\n    assert result == 546, "Assertion failed: choose_num(546, 546) == 546"\n\n\nif __name__ == "__main__":\n    main()\n\n[JavaScript]\nfunction choose_num(x, y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && x % 2 == 1) {\n        return -1;\n    } else if (x % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n\nfunction main() {\n    let result = choose_num(12, 15);\n    if (result != 14) {\n        console.log("Assertion failed: choose_num(12, 15) == 14");\n        return 1;\n    }\n\n    result = choose_num(13, 12);\n    if (result != -1) {\n        console.log("Assertion failed: choose_num(13, 12) == -1");\n        return 1;\n    }\n\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        console.log
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return "-1";\n    }\n\n    int num = (m + n) / 2;\n    string out = "";\n    while (num > 0) {\n        int remainder = num % 2;\n        string digit = to_string(remainder);\n        out = digit + out;\n        num = num / 2;\n    }\n\n    if (out.length() == 0) {\n        out = "0";\n    }\n\n    return out;\n}\n\nint main() {\n    assert(rounded_avg(1, 5) == "11");\n    assert(rounded_avg(7, 13) == "1010");\n    assert(rounded_avg(964, 977) == "1111001010");\n    assert(rounded_avg(996, 997) == "1111100100");\n    assert(rounded_avg(560, 851) == "1011000001");\n    assert(rounded_avg(185, 546) == "101101101");\n    assert(rounded_avg(362, 496) == "110101101");\n    assert(rounded_avg(350, 902) == "1001110010");\n    assert(rounded_avg(197, 233) == "11010111");\n    assert(rounded_avg(7, 5) == "-1");\n    assert(rounded_avg(5, 1) == "-1");\n    assert(rounded_avg(5, 5) == "101");\n\n    return 0;\n}\n\nvoid assert(string expected, string actual) {\n    if (expected != actual) {\n        cout << "Assertion failed: " << expected << " != " << actual << endl;\n        exit(1);\n    }\n}\n\n[C#]\nusing System;\n\nclass Solution {\n    public static void Main(string[] args) {\n        assert(rounded_avg(1, 5) == "11");\n        assert(rounded_avg(7, 13) == "1010");\n        assert(rounded_avg(964, 977) == "1111001010");\n        assert(rounded_avg(996, 997) == "1111100100");\n        assert(rounded_avg(560, 851) == "1011000001");\n        assert(rounded_avg(185, 546) == "101101101");\n        assert(rounded_avg(362, 496) == "110101101");\n        assert(rounded_avg(350, 902) == "1001110010");\n        assert(rounded_avg(197, 233) == "11010111");\n        assert(rounded_avg(7, 5) == "-1");\n        assert(rounded_avg(5, 1) == "-1");\n        assert(rounded_avg(5, 5) == "101");\n    }\n\n    public static string rounded_avg(int n, int m) {\n        if (n > m) {\n            return "-1";\n        }\n\n        int num = (m + n) / 2;\n        string out = "";\n        while (num > 0) {\n            int remainder = num % 2;\n            string digit = remainder.ToString();\n            out = digit + out;\n            num = num / 2;\n        }\n\n        if (out.Length == 0) {\n            out = "0";\n        }\n\n        return out;\n    }\n\n    public static void assert(string expected, string actual) {\n        if (expected != actual) {\n            Console.WriteLine("Assertion failed: " + expected + " != " + actual);\n            Environment.Exit(1);\n        }\n    }\n}\n\n[Python]\ndef rounded_avg(n, m):\n    if n > m:\n        return "-1"\n\n    num = (m + n) / 2\n    out = ""\n    while num > 0:\n        remainder = num % 2\n        digit = str(remainder)\n        out = digit + out\n        num = num // 2\n\n    if len(out) == 0:\n        out = "0"\n\n    return out\n\ndef assert(expected, actual):\n    if expected != actual:\n        print("Assertion failed: " + expected + " != " + actual)\n        exit(1)\n\nassert(rounded_avg(1, 5) == "11")\nassert(rounded_avg(7, 13) == "1010")\nassert(rounded_avg(964, 977) == "1111001010")\nassert(rounded_avg(996, 997) == "1111100100")\nassert(rounded_avg(560, 851) == "1011000001")\nassert(rounded_avg(185, 546) == "101101101")\nassert(rounded_avg(362, 496) == "110101101")\nassert(rounded_avg(350, 902) == "1001110010")\nassert(rounded_avg(197, 233) == "11010111")\nassert(rounded_avg(7, 5) == "-1")\nassert(rounded_avg(5, 1) == "-1")\nassert(rounded_avg(5, 5) == "101")\n\n[JavaScript]\nfunction rounded_avg(n, m) {\n    if (n > m) {\n        return "-1";\n    }\n\n    let num = (m + n) / 2;\n    let out = "";\n    while (num > 0) {\n        let remainder = num % 2;\n        let digit = remainder.toString();\n        out = digit + out;\n        num = num / 2;\n    }\n\n    if (out.length == 0) {\n        out = "0";\n    }\n\n    return out;\n}\n\nfunction assert(expected, actual) {\n    if (expected != actual) {\n        console.log("Assertion failed: " + expected + " != " + actual);\n        process.exit(1);\n    }\n}\n\nassert(rounded_avg(1, 5) == "11");\nassert(rounded_avg(7, 13) == "1010");\nassert(rounded_avg(964, 977) == "1111001010");\nassert(rounded_avg(996, 997) == "1111100100");\nassert(rounded_avg(560, 851) == "1011000001");\nassert(rounded_avg(185, 546) == "101101101");\nassert(rounded_avg(362, 496) == "110101101");\nassert(rounded_avg(350, 902) == "1001110010");\nassert(rounded_avg(197, 233) == "11010111");\nassert(rounded_avg(7, 5) == "-1");\nassert(rounded_avg(5, 1)
\n\n[CPP]\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct NumTo {\n  int key;\n  string value;\n};\n\nvoid sort_array(vector<int> &arr) {\n  for (int i = 0; i < arr.size() - 1; i++) {\n    for (int j = i + 1; j < arr.size(); j++) {\n      if (arr[i] > arr[j]) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n}\n\nvector<string> by_length(vector<int> &arr) {\n  vector<NumTo> numto = {\n    {0, "Zero"},\n    {1, "One"},\n    {2, "Two"},\n    {3, "Three"},\n    {4, "Four"},\n    {5, "Five"},\n    {6, "Six"},\n    {7, "Seven"},\n    {8, "Eight"},\n    {9, "Nine"}\n  };\n\n  sort_array(arr);\n\n  vector<string> out;\n  for (int i = arr.size() - 1; i >= 0; i--) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      out.push_back(numto[arr[i] + 1].value);\n    }\n  }\n\n  return out;\n}\n\nbool issame(vector<string> a, vector<string> b) {\n  if (a.size() != b.size()) {\n    return false;\n  }\n\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nint main() {\n  vector<int> arr = {2, 1, 1, 4, 5, 8, 2, 3};\n  vector<string> result = by_length(arr);\n  vector<string> expected1 = {"Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"};\n  if (!issame(result, expected1)) {\n    cout << "Test 1: assertion failed" << endl;\n    return 1;\n  }\n\n  arr = {};\n  result = by_length(arr);\n  vector<string> expected2 = {"One"};\n  if (!issame(result, expected2)) {\n    cout << "Test 2: assertion failed" << endl;\n    return 1;\n  }\n\n  arr = {1, -1, 55};\n  result = by_length(arr);\n  if (!issame(result, expected2)) {\n    cout << "Test 3: assertion failed" << endl;\n    return 1;\n  }\n\n  arr = {1, -1, 3, 2};\n  result = by_length(arr);\n  vector<string> expected3 = {"Three", "Two", "One"};\n  if (!issame(result, expected3)) {\n    cout << "Test 4: assertion failed" << endl;\n    return 1;\n  }\n\n  arr = {9, 4, 8};\n  result = by_length(arr);\n  vector<string> expected4 = {"Nine", "Eight", "Four"};\n  if (!issame(result, expected4)) {\n    cout << "Test 5: assertion failed" << endl;\n    return 1;\n  }\n\n  cout << "All tests passed." << endl;\n  return 0;\n} [/CPP]\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  int key;\n  char value[10];\n} NumTo;\n\nvoid sort_array(int *arr, int n) {\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (arr[i] > arr[j]) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n}\n\nchar **by_length(int *arr, int n) {\n  NumTo numto[] = {\n    {0, "Zero"},\n    {1, "One"},\n    {2, "Two"},\n    {3, "Three"},\n    {4, "Four"},\n    {5, "Five"},\n    {6, "Six"},\n    {7, "Seven"},\n    {8, "Eight"},\n    {9, "Nine"}\n  };\n\n  sort_array(arr, n);\n\n  char **out = malloc(sizeof(char *) * n);\n  int count = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      out[count] = malloc(sizeof(char) * 10);\n      strcpy(out[count], numto[arr[i] + 1].value);\n      count++;\n    }\n  }\n\n  return out;\n}\n\nint issame(char **a, char **b, int n, int m) {\n  if (n != m) {\n    return 0;\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (strcmp(a[i], b[i]) != 0) {\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nint main() {\n  int arr[] = {2, 1, 1, 4, 5, 8, 2, 3};\n  char **result = by_length(arr, 8);\n  char *expected1[] = {"Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"};\n  if (!issame(result, expected1, 8, 8)) {\n    printf("Test 1: assertion failed\n");\n    return 1;\n  }\n\n  arr = {};\n  result = by_length(arr, 0);\n  char *expected2[] = {"One"};\n  if (!issame(result, expected2, 0, 1)) {\n    printf("Test 2: assertion failed\n");\n    return 1;\n  }\n\n  arr = {1, -1, 55};\n  result = by_length(arr, 3);\n  if (!issame(result, expected2, 3, 1)) {\n    printf("Test 3: assertion failed\n");\n    return 1;\n  }\n\n  arr = {1, -1, 3, 2};\n  result = by_length(arr, 4);\n  char *expected3[] = {"Three", "Two", "One"};\n  if (!issame(result, expected3, 4, 3)) {\n    printf("Test 4: assertion failed\n");\n    return 1;\n  }\n\n  arr = {9, 4, 8};\n  result = by_length(arr, 3);\n  char *expected4[] = {"Nine", "Eight", "Four"};\n  if (!issame(result, expected4, 3, 3)) {\n    printf("Test 5: assertion failed\n");\n    return 1;\n  }\n\n  printf("All tests passed.\n");\n  return 0;\n} [/C]\n\n[JAVA]\nimport java.util.Arrays;\n\nclass NumTo {\n  int key;\n  String value;\n\n  public NumTo(int key, String value) {\n    this.key = key;\n    this.value = value;\n  }\n}\n\nclass Utils {\n  public static void sortArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      for (int j = i + 1; j < arr.length; j++) {\n        if (arr[i] > arr[j]) {\n          int temp = arr[i];
\n\n[C++]\n#include <cstdlib>\n#include <vector>\n\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0, prod = 1;\n\n    for (int i = 0; i < n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) {\n            out[i] = prod;\n        } else {\n            out[i] = sum;\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> result = f(5);\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for f(5)" << std::endl;\n        exit(1);\n    }\n\n    result = f(7);\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for f(7)" << std::endl;\n        exit(1);\n    }\n\n    result = f(1);\n    std::vector<int> expected3 = {1};\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for f(1)" << std::endl;\n        exit(1);\n    }\n\n    result = f(3);\n    std::vector<int> expected4 = {1, 2, 6};\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for f(3)" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n}\n```\n\n### 1.1.2. 声明\n\n```\n[Fortran]\nmodule utils\n    implicit none\n    contains\n\n    function f(n) result(out)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: out\n        integer :: i, sum, prod\n\n        allocate(out(n))\n        sum = 0\n        prod = 1\n\n        do i = 1, n\n            sum = sum + i\n            prod = prod * i\n            if (mod(i, 2) == 0) then\n                out(i) = prod\n            else\n                out(i) = sum\n            end if\n        end do\n    end function f\n\n    logical function issame(a, b)\n        implicit none\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    integer, dimension(:), allocatable :: result\n    integer, dimension(5) :: expected1 = [1, 2, 6, 24, 15]\n    integer, dimension(7) :: expected2 = [1, 2, 6, 24, 15, 720, 28]\n    integer, dimension(1) :: expected3 = [1]\n    integer, dimension(3) :: expected4 = [1, 2, 6]\n\n    result = f(5)\n    if (.not. issame(result, expected1)) then\n        write(*,*) "Assertion failed for f(5)"\n        call exit(1)\n    end if\n\n    result = f(7)\n    if (.not. issame(result, expected2)) then\n        write(*,*) "Assertion failed for f(7)"\n        call exit(1)\n    end if\n\n    result = f(1)\n    if (.not. issame(result, expected3)) then\n        write(*,*) "Assertion failed for f(1)"\n        call exit(1)\n    end if\n\n    result = f(3)\n    if (.not. issame(result, expected4)) then\n        write(*,*) "Assertion failed for f(3)"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed"\nend program main\n\n[C++]\n#include <cstdlib>\n#include <vector>\n\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0, prod = 1;\n\n    for (int i = 0; i < n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) {\n            out[i] = prod;\n        } else {\n            out[i] = sum;\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> result = f(5);\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for f(5)" << std::endl;\n        exit(1);\n    }\n\n    result = f(7);\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for f(7)" << std::endl;\n        exit(1);\n    }\n\n    result = f(1);\n    std::vector<int> expected3 = {1};\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for f(1)" << std::endl;\n        exit(1);\n    }\n\n    result = f(3);\n    std::vector<int> expected4 = {1, 2, 6};\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for f(3)" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n}\n```\n\n### 1.1.3. 函数\n\n```\n[Fortran]\nmodule utils\n    implicit none\n    contains\n\n    function f(n) result(out)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: out\n        integer :: i, sum, prod\n\n        allocate(out(n))\n        sum = 0\n        prod = 1\n\n        do i = 1, n\n            sum = sum + i\n            prod = prod * i\n            if (mod(i, 2) == 0) then\n                out(i) = prod\n            else\n                out(i) = sum\n            end if\n        end do\n    end function f\n\n    logical function issame(a, b)\n        implicit none\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);\n        string p = w;\n        reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    cout << num2 << " " << num1 << endl;\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; i++) {\n        string w = to_string(i);
\n\n[SOL]\n#include <iostream>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int num = 0;\n    for (int i = 0; i < n.size(); i++) {\n        if (n[i] > 0) {\n            num++;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w /= 10;\n            }\n            sum -= w;\n            if (sum > 0) num++;\n        }\n    }\n    return num;\n}\n\nint main() {\n    vector<int> v;\n    v.push_back(0);\n    if (count_nums(v) != 0) {\n        cout << "Assertion failed: count_nums({0}) == 0" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(-1);\n    v.push_back(-2);\n    v.push_back(0);\n    if (count_nums(v) != 0) {\n        cout << "Assertion failed: count_nums({-1, -2, 0}) == 0" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(-2);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(5);\n    if (count_nums(v) != 6) {\n        cout << "Assertion failed: count_nums({1, 1, 2, -2, 3, 4, 5}) == 6" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    v.push_back(6);\n    v.push_back(9);\n    v.push_back(-6);\n    v.push_back(0);\n    v.push_back(1);\n    v.push_back(5);\n    if (count_nums(v) != 5) {\n        cout << "Assertion failed: count_nums({1, 6, 9, -6, 0, 1, 5}) == 5" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    v.push_back(100);\n    v.push_back(98);\n    v.push_back(-7);\n    v.push_back(1);\n    v.push_back(-1);\n    if (count_nums(v) != 4) {\n        cout << "Assertion failed: count_nums({1, 100, 98, -7, 1, -1}) == 4" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(12);\n    v.push_back(23);\n    v.push_back(34);\n    v.push_back(-45);\n    v.push_back(-56);\n    v.push_back(0);\n    if (count_nums(v) != 5) {\n        cout << "Assertion failed: count_nums({12, 23, 34, -45, -56, 0}) == 5" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(-0);\n    v.push_back(1);\n    if (count_nums(v) != 1) {\n        cout << "Assertion failed: count_nums({-0, 1}) == 1" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    if (count_nums(v) != 1) {\n        cout << "Assertion failed: count_nums({1}) == 1" << endl;\n        exit(1);\n    }\n\n    cout << "All tests passed." << endl;\n    return 0;\n}\n[/SOL]\n\n[M]\n#include <iostream>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int num = 0;\n    for (int i = 0; i < n.size(); i++) {\n        if (n[i] > 0) {\n            num++;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w /= 10;\n            }\n            sum -= w;\n            if (sum > 0) num++;\n        }\n    }\n    return num;\n}\n\nint main() {\n    vector<int> v;\n    v.push_back(0);\n    if (count_nums(v) != 0) {\n        cout << "Assertion failed: count_nums({0}) == 0" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(-1);\n    v.push_back(-2);\n    v.push_back(0);\n    if (count_nums(v) != 0) {\n        cout << "Assertion failed: count_nums({-1, -2, 0}) == 0" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(-2);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(5);\n    if (count_nums(v) != 6) {\n        cout << "Assertion failed: count_nums({1, 1, 2, -2, 3, 4, 5}) == 6" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    v.push_back(6);\n    v.push_back(9);\n    v.push_back(-6);\n    v.push_back(0);\n    v.push_back(1);\n    v.push_back(5);\n    if (count_nums(v) != 5) {\n        cout << "Assertion failed: count_nums({1, 6, 9, -6, 0, 1, 5}) == 5" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(1);\n    v.push_back(100);\n    v.push_back(98);\n    v.push_back(-7);\n    v.push_back(1);\n    v.push_back(-1);\n    if (count_nums(v) != 4) {\n        cout << "Assertion failed: count_nums({1, 100, 98, -7, 1, -1}) == 4" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(12);\n    v.push_back(23);\n    v.push_back(34);\n    v.push_back(-45);\n    v.push_back(-56);\n    v.push_back(0);\n    if (count_nums(v) != 5) {\n        cout << "Assertion failed: count_nums({12, 23, 34, -45, -56, 0}) == 5" << endl;\n        exit(1);\n    }\n\n    v.clear();\n    v.push_back(-0);\n    v.push_back(1);\n    if (count_nums(v) != 1) {\n        cout << "Assertion failed: count_nums({-0, 1}) == 1" << endl;
\n\n[SOLUTION]\n#include <iostream>\n#include <vector>\n\nbool move_one_ball(std::vector<int> &arr) {\n  int num = 0;\n  if (arr.size() == 0) {\n    return true;\n  }\n\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] < arr[i-1]) {\n      num++;\n    }\n  }\n\n  if (arr[0] > arr[arr.size()-1]) {\n    num++;\n  }\n\n  return num < 2;\n}\n\nint main() {\n  std::vector<int> arr;\n  bool result;\n\n  // Test cases\n  arr = {3, 4, 5, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 10, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {4, 3, 1, 2};\n  result = move_one_ball(arr);\n  if (result) {\n    std::cout << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 4, 1, 2};\n  result = move_one_ball(arr);\n  if (result) {\n    std::cout << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {}" << std::endl;\n    return 1;\n  }\n\n  std::cout << "All tests passed." << std::endl;\n  return 0;\n}\n[/SOLUTION]\n\n[SOLUTION]\n#include <iostream>\n#include <vector>\n\nbool move_one_ball(std::vector<int> &arr) {\n  int num = 0;\n  if (arr.size() == 0) {\n    return true;\n  }\n\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] < arr[i-1]) {\n      num++;\n    }\n  }\n\n  if (arr[0] > arr[arr.size()-1]) {\n    num++;\n  }\n\n  return num < 2;\n}\n\nint main() {\n  std::vector<int> arr;\n  bool result;\n\n  // Test cases\n  arr = {3, 4, 5, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 10, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {4, 3, 1, 2};\n  result = move_one_ball(arr);\n  if (result) {\n    std::cout << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 4, 1, 2};\n  result = move_one_ball(arr);\n  if (result) {\n    std::cout << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {}" << std::endl;\n    return 1;\n  }\n\n  std::cout << "All tests passed." << std::endl;\n  return 0;\n}\n[/SOLUTION]\n\n[SOLUTION]\n#include <iostream>\n#include <vector>\n\nbool move_one_ball(std::vector<int> &arr) {\n  int num = 0;\n  if (arr.size() == 0) {\n    return true;\n  }\n\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] < arr[i-1]) {\n      num++;\n    }\n  }\n\n  if (arr[0] > arr[arr.size()-1]) {\n    num++;\n  }\n\n  return num < 2;\n}\n\nint main() {\n  std::vector<int> arr;\n  bool result;\n\n  // Test cases\n  arr = {3, 4, 5, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 10, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {4, 3, 1, 2};\n  result = move_one_ball(arr);\n  if (result) {\n    std::cout << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 4, 1, 2};\n  result = move_one_ball(arr);\n  if (result) {\n    std::cout << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {}" << std::endl;\n    return 1;\n  }\n\n  std::cout << "All tests passed." << std::endl;\n  return 0;\n}\n[/SOLUTION]\n\n[SOLUTION]\n#include <iostream>\n#include <vector>\n\nbool move_one_ball(std::vector<int> &arr) {\n  int num = 0;\n  if (arr.size() == 0) {\n    return true;\n  }\n\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] < arr[i-1]) {\n      num++;\n    }\n  }\n\n  if (arr[0] > arr[arr.size()-1]) {\n    num++;\n  }\n\n  return num < 2;\n}\n\nint main() {\n  std::vector<int> arr;\n  bool result;\n\n  // Test cases\n  arr = {3, 4, 5, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n    return 1;\n  }\n\n  arr = {3, 5, 10, 1, 2};\n  result = move_one_ball(arr);\n  if (!result) {\n    std::cout << "Assertion failed for {3, 5, 10, 1, 2
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int num = 0;\n    for (int i = 0; i < lst1.size(); i++) {\n        if (lst1[i] % 2 == 0) num++;\n    }\n    for (int i = 0; i < lst2.size(); i++) {\n        if (lst2[i] % 2 == 0) num++;\n    }\n\n    if (num >= lst1.size()) {\n        return "YES";\n    } else {\n        return "NO";\n    }\n}\n\nint main() {\n    vector<int> lst1 = {1, 2, 3, 4};\n    vector<int> lst2 = {1, 2, 3, 4};\n    cout << exchange(lst1, lst2) << endl;\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {1, 5, 3, 4};\n    cout << exchange(lst1, lst2) << endl;\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {2, 1, 4, 3};\n    cout << exchange(lst1, lst2) << endl;\n\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 4};\n    cout << exchange(lst1, lst2) << endl;\n\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 3};\n    cout << exchange(lst1, lst2) << endl;\n\n    lst1 = {3, 2, 6, 1, 8, 9};\n    lst2 = {3, 5, 5, 1, 1, 1};\n    cout << exchange(lst1, lst2) << endl;\n\n    lst1 = {100, 200};\n    lst2 = {200, 200};\n    cout << exchange(lst1, lst2) << endl;\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n\nint is_even(int num) {\n    return num % 2 == 0;\n}\n\nint count_even(int *arr, int size) {\n    int i, count = 0;\n    for (i = 0; i < size; i++) {\n        if (is_even(arr[i])) count++;\n    }\n    return count;\n}\n\nint is_possible(int *arr1, int size1, int *arr2, int size2) {\n    int count = count_even(arr1, size1) + count_even(arr2, size2);\n    return count >= size1;\n}\n\nint main() {\n    int arr1[] = {1, 2, 3, 4};\n    int arr2[] = {1, 2, 3, 4};\n    printf("%s\n", is_possible(arr1, 4, arr2, 4) ? "YES" : "NO");\n\n    arr1 = (int[]){1, 2, 3, 4};\n    arr2 = (int[]){1, 5, 3, 4};\n    printf("%s\n", is_possible(arr1, 4, arr2, 4) ? "YES" : "NO");\n\n    arr1 = (int[]){1, 2, 3, 4};\n    arr2 = (int[]){2, 1, 4, 3};\n    printf("%s\n", is_possible(arr1, 4, arr2, 4) ? "YES" : "NO");\n\n    arr1 = (int[]){5, 7, 3};\n    arr2 = (int[]){2, 6, 4};\n    printf("%s\n", is_possible(arr1, 3, arr2, 3) ? "YES" : "NO");\n\n    arr1 = (int[]){5, 7, 3};\n    arr2 = (int[]){2, 6, 3};\n    printf("%s\n", is_possible(arr1, 3, arr2, 3) ? "YES" : "NO");\n\n    arr1 = (int[]){3, 2, 6, 1, 8, 9};\n    arr2 = (int[]){3, 5, 5, 1, 1, 1};\n    printf("%s\n", is_possible(arr1, 6, arr2, 6) ? "YES" : "NO");\n\n    arr1 = (int[]){100, 200};\n    arr2 = (int[]){200, 200};\n    printf("%s\n", is_possible(arr1, 2, arr2, 2) ? "YES" : "NO");\n\n    return 0;\n}\n\n[Python]\ndef is_even(num):\n    return num % 2 == 0\n\ndef count_even(arr):\n    count = 0\n    for num in arr:\n        if is_even(num):\n            count += 1\n    return count\n\ndef is_possible(arr1, arr2):\n    count = count_even(arr1) + count_even(arr2)\n    return count >= len(arr1)\n\nprint(is_possible([1, 2, 3, 4], [1, 2, 3, 4]))\nprint(is_possible([1, 2, 3, 4], [1, 5, 3, 4]))\nprint(is_possible([1, 2, 3, 4], [2, 1, 4, 3]))\nprint(is_possible([5, 7, 3], [2, 6, 4]))\nprint(is_possible([5, 7, 3], [2, 6, 3]))\nprint(is_possible([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\nprint(is_possible([100, 200], [200, 200]))\n\n[Java]\nimport java.util.stream.IntStream;\n\nclass Main {\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3, 4};\n        int[] arr2 = {1, 2, 3, 4};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n\n        arr1 = new int[] {1, 2, 3, 4};\n        arr2 = new int[] {1, 5, 3, 4};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n\n        arr1 = new int[] {1, 2, 3, 4};\n        arr2 = new int[] {2, 1, 4, 3};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n\n        arr1 = new int[] {5, 7, 3};\n        arr2 = new int[] {2, 6, 4};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n\n        arr1 = new int[] {5, 7, 3};\n        arr2 = new int[] {2, 6, 3};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n\n        arr1 = new int[] {3, 2, 6, 1, 8, 9};\n        arr2 = new int[] {3, 5, 5, 1, 1, 1};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n\n        arr1 = new int[] {100, 200};\n        arr2 = new int[] {200, 200};\n        System.out.println(is_possible(arr1, arr2) ? "YES" : "NO");\n    }\n\n
\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid odd_count(vector<string> &input, vector<string> &output) {\n    string s = "the number of odd elements in the string i of the input.";\n    string s2;\n    string temp;\n    int sum;\n    int pos;\n\n    output.clear();\n    for (int i = 0; i < input.size(); i++) {\n        sum = 0;\n        for (int j = 0; j < input[i].size(); j++) {\n            if (input[i][j] >= '0' && input[i][j] <= '9') {\n                if (input[i][j] % 2 == 1) sum++;\n            }\n        }\n\n        s2 = "";\n        pos = 0;\n        for (int j = 0; j < s.size(); j++) {\n            if (s[j] == 'i') {\n                temp = to_string(sum);\n                s2.insert(pos, temp);\n                pos += temp.size();\n            } else {\n                s2.insert(pos, 1, s[j]);\n                pos++;\n            }\n        }\n        output.push_back(s2);\n    }\n}\n\nint main() {\n    vector<string> input;\n    vector<string> output;\n    vector<string> expected;\n\n    // Test case 1\n    input.clear();\n    input.push_back("1234567");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 4 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected);\n\n    // Test case 2\n    input.clear();\n    input.push_back("3");\n    input.push_back("11111111");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 1 of the input.");\n    expected.push_back("the number of odd elements in the string 8 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected);\n\n    // Test case 3\n    input.clear();\n    input.push_back("271");\n    input.push_back("137");\n    input.push_back("314");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 2 of the input.");\n    expected.push_back("the number of odd elements in the string 3 of the input.");\n    expected.push_back("the number of odd elements in the string 2 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected);\n\n    return 0;\n}\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid odd_count(vector<string> &input, vector<string> &output) {\n    string s = "the number of odd elements in the string i of the input.";\n    string s2;\n    string temp;\n    int sum;\n    int pos;\n\n    output.clear();\n    for (int i = 0; i < input.size(); i++) {\n        sum = 0;\n        for (int j = 0; j < input[i].size(); j++) {\n            if (input[i][j] >= '0' && input[i][j] <= '9') {\n                if (input[i][j] % 2 == 1) sum++;\n            }\n        }\n\n        s2 = "";\n        pos = 0;\n        for (int j = 0; j < s.size(); j++) {\n            if (s[j] == 'i') {\n                temp = to_string(sum);\n                s2.insert(pos, temp);\n                pos += temp.size();\n            } else {\n                s2.insert(pos, 1, s[j]);\n                pos++;\n            }\n        }\n        output.push_back(s2);\n    }\n}\n\nint main() {\n    vector<string> input;\n    vector<string> output;\n    vector<string> expected;\n\n    // Test case 1\n    input.clear();\n    input.push_back("1234567");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 4 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected);\n\n    // Test case 2\n    input.clear();\n    input.push_back("3");\n    input.push_back("11111111");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 1 of the input.");\n    expected.push_back("the number of odd elements in the string 8 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected);\n\n    // Test case 3\n    input.clear();\n    input.push_back("271");\n    input.push_back("137");\n    input.push_back("314");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 2 of the input.");\n    expected.push_back("the number of odd elements in the string 3 of the input.");\n    expected.push_back("the number of odd elements in the string 2 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected);\n\n    return 0;\n}\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid odd_count(vector<string> &input, vector<string> &output) {\n    string s = "the number of odd elements in the string i of the input.";\n    string s2;\n    string temp;\n    int sum;\n    int pos;\n\n    output.clear();\n    for (int i = 0; i < input.size(); i++) {\n        sum = 0;\n        for (int j = 0; j < input[i].size(); j++) {\n            if (input[i][j] >= '0' && input[i][j] <= '9') {\n                if (input[i][j] % 2 == 1) sum++;\n            }\n        }\n\n        s2 = "";\n        pos = 0;\n        for (int j = 0; j < s.size(); j++) {\n            if (s[j] == 'i') {\n                temp = to_string(sum);\n                s2.insert(pos, temp);\n                pos += temp.size();\n            } else {\n                s2.insert(pos, 1, s[j]);\n                pos++;\n            }\n        }\n        output.push_back(s2);\n    }\n}\n\nint main() {\n    vector<string> input;\n    vector<string> output;\n    vector<string> expected;\n\n    // Test case 1\n    input.clear();\n    input.push_back("1234567");\n    expected.clear();\n    expected.push_back("the number of odd elements in the string 4 of the input.");\n    odd_count(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << endl;\n    }\n    assert(output == expected
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    vector<int> bin;\n    vector<int> sorted_arr;\n    int i, j, n, b, m;\n\n    sorted_arr = arr;\n\n    for (i = 0; i < arr.size(); i++) {\n        b = 0;\n        n = arr[i];\n        while (n > 0) {\n            b += n % 2;\n            n /= 2;\n        }\n        bin.push_back(b);\n    }\n\n    for (i = 0; i < arr.size(); i++) {\n        for (j = 1; j < arr.size(); j++) {\n            if (bin[j] < bin[j-1] || (bin[j] == bin[j-1] && sorted_arr[j] < sorted_arr[j-1])) {\n                m = sorted_arr[j];\n                sorted_arr[j] = sorted_arr[j-1];\n                sorted_arr[j-1] = m;\n                m = bin[j];\n                bin[j] = bin[j-1];\n                bin[j-1] = m;\n            }\n        }\n    }\n\n    return sorted_arr;\n}\n\nint main() {\n    vector<int> arr = {1, 5, 2, 3, 4};\n    vector<int> expected = {1, 2, 4, 3, 5};\n    vector<int> sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    arr = {-2, -3, -4, -5, -6};\n    expected = {-4, -2, -6, -5, -3};\n    sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    arr = {1, 0, 2, 3, 4};\n    expected = {0, 1, 2, 4, 3};\n    sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    arr = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    expected = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    arr = {3, 6, 44, 12, 32, 5};\n    expected = {32, 3, 5, 6, 12, 44};\n    sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    arr = {2, 4, 8, 16, 32};\n    expected = {2, 4, 8, 16, 32};\n    sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    arr = {2, 4, 8, 16, 32};\n    expected = {2, 4, 8, 16, 32};\n    sorted_arr = sort_array(arr);\n\n    if (sorted_arr != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int *arr;\n    int size;\n} Array;\n\nArray sort_array(Array arr) {\n    Array sorted_arr;\n    int *bin;\n    int i, j, n, b, m;\n\n    sorted_arr.arr = malloc(arr.size * sizeof(int));\n    sorted_arr.size = arr.size;\n    bin = malloc(arr.size * sizeof(int));\n\n    for (i = 0; i < arr.size; i++) {\n        sorted_arr.arr[i] = arr.arr[i];\n    }\n\n    for (i = 0; i < arr.size; i++) {\n        b = 0;\n        n = arr.arr[i];\n        while (n > 0) {\n            b += n % 2;\n            n /= 2;\n        }\n        bin[i] = b;\n    }\n\n    for (i = 0; i < arr.size; i++) {\n        for (j = 1; j < arr.size; j++) {\n            if (bin[j] < bin[j-1] || (bin[j] == bin[j-1] && sorted_arr.arr[j] < sorted_arr.arr[j-1])) {\n                m = sorted_arr.arr[j];\n                sorted_arr.arr[j] = sorted_arr.arr[j-1];\n                sorted_arr.arr[j-1] = m;\n                m = bin[j];\n                bin[j] = bin[j-1];\n                bin[j-1] = m;\n            }\n        }\n    }\n\n    return sorted_arr;\n}\n\nbool is_equal(Array a, Array b) {\n    int i;\n\n    if (a.size != b.size) {\n        return false;\n    }\n\n    for (i = 0; i < a.size; i++) {\n        if (a.arr[i] != b.arr[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_case(Array arr, Array expected) {\n    Array sorted_arr = sort_array(arr);\n\n    if (!is_equal(sorted_arr, expected)) {\n        printf("Assertion failed\n");\n        exit(1);\n    }\n}\n\nint main() {\n    Array arr = {1, 5, 2, 3, 4};\n    Array expected = {1, 2, 4, 3, 5};\n    test_case(arr, expected);\n\n    arr = {-2, -3, -4, -5, -6};\n    expected = {-4, -2, -6, -5, -3};\n    test_case(arr, expected);\n\n    arr = {1, 0, 2, 3, 4};\n    expected = {0, 1, 2, 4, 3};\n    test_case(arr, expected);\n\n    arr = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    expected = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    test_case(arr, expected);\n\n    arr = {3, 6, 44, 12, 32, 5};\n    expected = {32, 3, 5, 6, 12, 44};\n    test_case(arr, expected);\n\n    arr = {2, 4, 8, 16, 32};\n    expected = {2, 4, 8, 16, 32};\n    test_case(arr, expected);\n\n    arr = {2, 4, 8, 16, 32};\n    expected = {2, 4, 8, 16, 32};\n    test_case(arr, expected);\n\n    return 0;\n}\n\n[Python]\ndef sort_array(arr):\n    bin = []\n    sorted_arr =
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring getClosestVowel(string word) {\n    vector<char> vowels = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'};\n    string result = "";\n\n    for (int i = word.length() - 1; i >= 2; i--) {\n        if (find(vowels.begin(), vowels.end(), word[i]) != vowels.end()) {\n            if (find(vowels.begin(), vowels.end(), word[i + 1]) == vowels.end() && find(vowels.begin(), vowels.end(), word[i - 1]) == vowels.end()) {\n                result = word[i];\n                return result;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string word;\n    string result;\n\n    // Test cases\n    word = "yogurt";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "full";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "easy";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "eAsy";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "ali";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "bad";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "most";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "ab";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "ba";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "quick";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "anime";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "Asia";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "Above";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring getClosestVowel(string word) {\n    vector<char> vowels = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'};\n    string result = "";\n\n    for (int i = word.length() - 1; i >= 2; i--) {\n        if (find(vowels.begin(), vowels.end(), word[i]) != vowels.end()) {\n            if (find(vowels.begin(), vowels.end(), word[i + 1]) == vowels.end() && find(vowels.begin(), vowels.end(), word[i - 1]) == vowels.end()) {\n                result = word[i];\n                return result;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string word;\n    string result;\n\n    // Test cases\n    word = "yogurt";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "full";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "easy";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "eAsy";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "ali";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "bad";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "most";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "ab";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "ba";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "quick";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "anime";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "Asia";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    word = "Above";\n    result = getClosestVowel(word);\n    cout << "getClosestVowel(\"" << word << "\") = " << result << endl;\n\n    return 0;\n}\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring getClosestVowel(string word) {\n    vector<char> vowels = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'};\n    string result = "";\n\n    for (int i = word.length() - 1; i >= 2; i--) {\n        if (find(vowels.begin(), vowels.end(), word[i]) != vowels.end()) {\n            if (find(vowels.begin(), vowels.end(), word[i + 1]) == vowels.end() && find(vowels.begin(), vowels.end(), word[i - 1]) == vowels.end()) {\n                result = word[i];\n                return result;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string word;\n    string result;\n\n    // Test cases\n    word = "yogurt";\n    result = getClosestVowel(word);
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid bubble_sort(vector<int> &arr) {\n    int i, j, temp;\n    for (i = 0; i < arr.size() - 1; i++) {\n        for (j = 0; j < arr.size() - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvector<int> maximum(vector<int> arr, int k) {\n    vector<int> sorted_arr = arr;\n    bubble_sort(sorted_arr);\n    vector<int> out(k);\n    for (int i = 0; i < k; i++) {\n        out[i] = sorted_arr[arr.size() - k + i];\n    }\n    return out;\n}\n\nbool issame(vector<int> a, vector<int> b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(issame(maximum({-3, -4, 5}, 3), {-4, -3, 5}));\n    assert(issame(maximum({4, -4, 4}, 2), {4, 4}));\n    assert(issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1), {2}));\n    assert(issame(maximum({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123}));\n    assert(issame(maximum({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20}));\n    assert(issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15}));\n    assert(issame(maximum({-1, 0, 2, 5, 3, -10}, 2), {3, 5}));\n    assert(issame(maximum({1, 0, 5, -7}, 1), {5}));\n    assert(issame(maximum({4, -4}, 2), {-4, 4}));\n    assert(issame(maximum({-10, 10}, 2), {-10, 10}));\n    // Handle the empty array case separately\n    assert(issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0), {}));\n}\n\nint main() {\n    run_tests();\n    return 0;\n} [/C++]\n\n[C#]\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void BubbleSort(List<int> arr)\n    {\n        int i, j, temp;\n        for (i = 0; i < arr.Count - 1; i++)\n        {\n            for (j = 0; j < arr.Count - i - 1; j++)\n            {\n                if (arr[j] > arr[j + 1])\n                {\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    static List<int> Maximum(List<int> arr, int k)\n    {\n        List<int> sorted_arr = arr;\n        BubbleSort(sorted_arr);\n        List<int> out = new List<int>();\n        for (int i = 0; i < k; i++)\n        {\n            out.Add(sorted_arr[arr.Count - k + i]);\n        }\n        return out;\n    }\n\n    static bool IsSame(List<int> a, List<int> b)\n    {\n        if (a.Count != b.Count)\n        {\n            return false;\n        }\n\n        for (int i = 0; i < a.Count; i++)\n        {\n            if (a[i] != b[i])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static void Assert(bool condition)\n    {\n        if (!condition)\n        {\n            Console.WriteLine("Assertion failed");\n            Environment.Exit(1);\n        }\n    }\n\n    static void RunTests()\n    {\n        Assert(IsSame(Maximum(new List<int> { -3, -4, 5 }, 3), new List<int> { -4, -3, 5 }));\n        Assert(IsSame(Maximum(new List<int> { 4, -4, 4 }, 2), new List<int> { 4, 4 }));\n        Assert(IsSame(Maximum(new List<int> { -3, 2, 1, 2, -1, -2, 1 }, 1), new List<int> { 2 }));\n        Assert(IsSame(Maximum(new List<int> { 123, -123, 20, 0, 1, 2, -3 }, 3), new List<int> { 2, 20, 123 }));\n        Assert(IsSame(Maximum(new List<int> { -123, 20, 0, 1, 2, -3 }, 4), new List<int> { 0, 1, 2, 20 }));\n        Assert(IsSame(Maximum(new List<int> { 5, 15, 0, 3, -13, -8, 0 }, 7), new List<int> { -13, -8, 0, 0, 3, 5, 15 }));\n        Assert(IsSame(Maximum(new List<int> { -1, 0, 2, 5, 3, -10 }, 2), new List<int> { 3, 5 }));\n        Assert(IsSame(Maximum(new List<int> { 1, 0, 5, -7 }, 1), new List<int> { 5 }));\n        Assert(IsSame(Maximum(new List<int> { 4, -4 }, 2), new List<int> { -4, 4 }));\n        Assert(IsSame(Maximum(new List<int> { -10, 10 }, 2), new List<int> { -10, 10 }));\n        // Handle the empty array case separately\n        Assert(IsSame(Maximum(new List<int> { 1, 2, 3, -23, 243, -400, 0 }, 0), new List<int>()));\n    }\n\n    static void Main(string[] args)\n    {\n        RunTests();\n    }\n} [/C#]\n\n[Java]\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass Program {\n    static void bubbleSort(List<Integer> arr) {\n        int i, j, temp;\n        for (i = 0; i < arr.size() - 1; i++) {\n            for (j = 0; j < arr.size() - i - 1; j++) {\n                if (arr.get(j) > arr.get(j + 1)) {\n                    temp = arr.get(j);\n                    arr.set(j
\n\n\n[C++]\n#include <iostream>\n#include <vector>\n\nint solutions(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> test_cases[] = {\n        {5, 8, 7, 1},\n        {3, 3, 3, 3, 3},\n        {30, 13, 24, 321},\n        {5, 9},\n        {2, 4, 8},\n        {30, 13, 23, 32},\n        {3, 13, 2, 9}\n    };\n    int results[] = {12, 9, 0, 5, 0, 23, 3};\n    for (int i = 0; i < 7; i++) {\n        if (solutions(test_cases[i]) != results[i]) {\n            std::cout << "Assertion failed: solutions(";\n            for (int j = 0; j < test_cases[i].size(); j++) {\n                std::cout << test_cases[i][j];\n                if (j < test_cases[i].size() - 1) {\n                    std::cout << ", ";\n                }\n            }\n            std::cout << ") == " << results[i] << std::endl;\n            return 1;\n        }\n    }\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n\nint solutions(int *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    int test_cases[][4] = {\n        {5, 8, 7, 1},\n        {3, 3, 3, 3, 3},\n        {30, 13, 24, 321},\n        {5, 9},\n        {2, 4, 8},\n        {30, 13, 23, 32},\n        {3, 13, 2, 9}\n    };\n    int results[] = {12, 9, 0, 5, 0, 23, 3};\n    for (int i = 0; i < 7; i++) {\n        if (solutions(test_cases[i], 4) != results[i]) {\n            printf("Assertion failed: solutions(");\n            for (int j = 0; j < 4; j++) {\n                printf("%d", test_cases[i][j]);\n                if (j < 3) {\n                    printf(", ");\n                }\n            }\n            printf(") == %d\n", results[i]);\n            return 1;\n        }\n    }\n    printf("All tests passed.\n");\n    return 0;\n}\n\n\n[Python]\ndef solutions(lst):\n    sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1:\n            sum += lst[i]\n    return sum\n\n\nif __name__ == '__main__':\n    test_cases = [\n        [5, 8, 7, 1],\n        [3, 3, 3, 3, 3],\n        [30, 13, 24, 321],\n        [5, 9],\n        [2, 4, 8],\n        [30, 13, 23, 32],\n        [3, 13, 2, 9]\n    ]\n    results = [12, 9, 0, 5, 0, 23, 3]\n    for i in range(0, 7):\n        if solutions(test_cases[i]) != results[i]:\n            print("Assertion failed: solutions({}) == {}".format(\n                test_cases[i], results[i]))\n            exit(1)\n    print("All tests passed.")\n\n\n[JavaScript]\nfunction solutions(lst) {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nfunction main() {\n    let test_cases = [\n        [5, 8, 7, 1],\n        [3, 3, 3, 3, 3],\n        [30, 13, 24, 321],\n        [5, 9],\n        [2, 4, 8],\n        [30, 13, 23, 32],\n        [3, 13, 2, 9]\n    ];\n    let results = [12, 9, 0, 5, 0, 23, 3];\n    for (let i = 0; i < 7; i++) {\n        if (solutions(test_cases[i]) != results[i]) {\n            console.log("Assertion failed: solutions({}) == {}".format(\n                test_cases[i], results[i]));\n            process.exit(1);\n        }\n    }\n    console.log("All tests passed.");\n}\n\nmain();\n\n\n[Ruby]\ndef solutions(lst)\n    sum = 0\n    for i in 0...lst.length\n        if lst[i] % 2 == 1\n            sum += lst[i]\n        end\n    end\n    return sum\nend\n\nif __FILE__ == $0\n    test_cases = [\n        [5, 8, 7, 1],\n        [3, 3, 3, 3, 3],\n        [30, 13, 24, 321],\n        [5, 9],\n        [2, 4, 8],\n        [30, 13, 23, 32],\n        [3, 13, 2, 9]\n    ]\n    results = [12, 9, 0, 5, 0, 23, 3]\n    for i in 0...7\n        if solutions(test_cases[i]) != results[i]\n            puts "Assertion failed: solutions({}) == {}".format(\n                test_cases[i], results[i])\n            exit(1)\n        end\n    end\n    puts "All tests passed."\nend\n\n\n[PHP]\nfunction solutions($lst) {\n    $sum = 0;\n    for ($i = 0; $i < count($lst); $i += 2) {\n        if ($lst[$i] % 2 == 1) {\n            $sum += $lst[$i];\n        }\n    }\n    return $sum;\n}\n\nif ($argc != 1) {\n    echo "Usage: php solution.php\n";\n    exit(1);\n}\n\n$test_cases = [\n    [5, 8, 7, 1],\n    [3, 3, 3, 3, 3],\n    [30, 13, 24, 321],\n    [5, 9],\n    [2, 4, 8],\n    [30, 13, 23, 32],\n    [3, 13, 2, 9]\n];\n$results = [12, 9, 0, 5, 0, 23, 3];\nfor ($i = 0; $i < 7; $i++) {\n    if (solutions($test_cases[$i]) != $results[$i]) {\n        echo "Assertion failed: solutions({$test_cases[$i]}) == {$results[$i]}\n";\n
\n\n[CPP]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    int result = add_elements({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3);\n    if (result != -4) {\n        cout << "Assertion failed: result != -4" << endl;\n        return 1;\n    }\n\n    result = add_elements({111, 121, 3, 4000, 5, 6}, 2);\n    if (result != 0) {\n        cout << "Assertion failed: result != 0" << endl;\n        return 1;\n    }\n\n    result = add_elements({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4);\n    if (result != 125) {\n        cout << "Assertion failed: result != 125" << endl;\n        return 1;\n    }\n\n    result = add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4);\n    if (result != 24) {\n        cout << "Assertion failed: result != 24" << endl;\n        return 1;\n    }\n\n    result = add_elements({1}, 1);\n    if (result != 1) {\n        cout << "Assertion failed: result != 1" << endl;\n        return 1;\n    }\n\n    cout << "All tests passed." << endl;\n    return 0;\n} [/CPP]\n\n[PY]\ndef add_elements(arr, k):\n    sum = 0\n    for i in range(k):\n        if arr[i] >= -99 and arr[i] <= 99:\n            sum += arr[i]\n    return sum\n\n\n# Test cases\nassert add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) == -4\nassert add_elements([111, 121, 3, 4000, 5, 6], 2) == 0\nassert add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) == 125\nassert add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) == 24\nassert add_elements([1], 1) == 1\n\nprint("All tests passed.")\n[/PY]\n\n[JAVA]\nimport java.util.Arrays;\n\nclass Solution {\n    public int addElements(int[] arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr[i] >= -99 && arr[i] <= 99) {\n                sum += arr[i];\n            }\n        }\n        return sum;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        assert solution.addElements(new int[]{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3) == -4;\n        assert solution.addElements(new int[]{111, 121, 3, 4000, 5, 6}, 2) == 0;\n        assert solution.addElements(new int[]{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4) == 125;\n        assert solution.addElements(new int[]{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4) == 24;\n        assert solution.addElements(new int[]{1}, 1) == 1;\n\n        System.out.println("All tests passed.");\n    }\n} [/JAVA]\n\n[RUBY]\ndef add_elements(arr, k)\n  sum = 0\n  for i in 0...k\n    sum += arr[i] if arr[i] >= -99 && arr[i] <= 99\n  end\n  sum\nend\n\n# Test cases\nassert add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) == -4\nassert add_elements([111, 121, 3, 4000, 5, 6], 2) == 0\nassert add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) == 125\nassert add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) == 24\nassert add_elements([1], 1) == 1\n\nputs "All tests passed."\n[/RUBY]\n\n[PHP]\nfunction add_elements($arr, $k) {\n    $sum = 0;\n    for ($i = 0; $i < $k; $i++) {\n        if ($arr[$i] >= -99 && $arr[$i] <= 99) {\n            $sum += $arr[$i];\n        }\n    }\n    return $sum;\n}\n\n# Test cases\nassert(add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) == -4);\nassert(add_elements([111, 121, 3, 4000, 5, 6], 2) == 0);\nassert(add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) == 125);\nassert(add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) == 24);\nassert(add_elements([1], 1) == 1);\n\necho "All tests passed.";\n[/PHP]\n\n[GO]\nfunc add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n\n// Test cases\nassert(add_elements([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3) == -4)\nassert(add_elements([]int{111, 121, 3, 4000, 5, 6}, 2) == 0)\nassert(add_elements([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4) == 125)\nassert(add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4) == 24)\nassert(add_elements([]int{1}, 1) == 1)\n\nfmt.Println("All tests passed.")\n[/GO]\n\n[MATLAB]\nfunction sum = add_elements(arr
\n\n[INST] Translate this Fortran code to C++: \nprogram collatz\n  implicit none\n  integer, allocatable :: result(:)\n  integer :: n\n\n  ! Test cases\n  call test_odd_collatz(14, [1, 5, 7, 11, 13, 17])\n  call test_odd_collatz(5, [1, 5])\n  call test_odd_collatz(12, [1, 3, 5])\n  call test_odd_collatz(1, [1])\n\ncontains\n\n  subroutine test_odd_collatz(n, expected)\n    integer, intent(in) :: n\n    integer, dimension(:), intent(in) :: expected\n    integer, allocatable :: result(:)\n    logical :: is_same\n\n    result = get_odd_collatz(n)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n      write(*,*) "Assertion failed for n =", n\n      call exit(1)\n    end if\n  end subroutine test_odd_collatz\n\n  function get_odd_collatz(n) result(out)\n    integer, intent(in) :: n\n    integer, allocatable :: out(:)\n    integer :: temp, i, count\n    integer, allocatable :: temp_array(:)\n\n    allocate(out(1))\n    out(1) = 1\n    temp = n\n    count = 1\n\n    do while (temp /= 1)\n      if (mod(temp, 2) == 1) then\n        count = count + 1\n        if (allocated(temp_array)) deallocate(temp_array)\n        allocate(temp_array(count))\n        temp_array(1:count-1) = out\n        temp_array(count) = temp\n        deallocate(out)\n        out = temp_array\n        temp = temp * 3 + 1\n      else\n        temp = temp / 2\n      end if\n    end do\n\n    call sort(out)\n  end function get_odd_collatz\n\n  function issame(a, b) result(is_equal)\n    integer, dimension(:), intent(in) :: a, b\n    logical :: is_equal\n    integer :: i\n\n    if (size(a) /= size(b)) then\n      is_equal = .false.\n      return\n    end if\n\n    is_equal = .true.\n    do i = 1, size(a)\n      if (a(i) /= b(i)) then\n        is_equal = .false.\n        return\n      end if\n    end do\n  end function issame\n\n  subroutine sort(array)\n    integer, dimension(:), intent(inout) :: array\n    integer :: i, j, temp\n\n    do i = 1, size(array) - 1\n      do j = i + 1, size(array)\n        if (array(i) > array(j)) then\n          temp = array(i)\n          array(i) = array(j)\n          array(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort\n\nend program collatz [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram collatz\n  implicit none\n  integer, allocatable :: result(:)\n  integer :: n\n\n  ! Test cases\n  call test_odd_collatz(14, [1, 5, 7, 11, 13, 17])\n  call test_odd_collatz(5, [1, 5])\n  call test_odd_collatz(12, [1, 3, 5])\n  call test_odd_collatz(1, [1])\n\ncontains\n\n  subroutine test_odd_collatz(n, expected)\n    integer, intent(in) :: n\n    integer, dimension(:), intent(in) :: expected\n    integer, allocatable :: result(:)\n    logical :: is_same\n\n    result = get_odd_collatz(n)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n      write(*,*) "Assertion failed for n =", n\n      call exit(1)\n    end if\n  end subroutine test_odd_collatz\n\n  function get_odd_collatz(n) result(out)\n    integer, intent(in) :: n\n    integer, allocatable :: out(:)\n    integer :: temp, i, count\n    integer, allocatable :: temp_array(:)\n\n    allocate(out(1))\n    out(1) = 1\n    temp = n\n    count = 1\n\n    do while (temp /= 1)\n      if (mod(temp, 2) == 1) then\n        count = count + 1\n        if (allocated(temp_array)) deallocate(temp_array)\n        allocate(temp_array(count))\n        temp_array(1:count-1) = out\n        temp_array(count) = temp\n        deallocate(out)\n        out = temp_array\n        temp = temp * 3 + 1\n      else\n        temp = temp / 2\n      end if\n    end do\n\n    call sort(out)\n  end function get_odd_collatz\n\n  function issame(a, b) result(is_equal)\n    integer, dimension(:), intent(in) :: a, b\n    logical :: is_equal\n    integer :: i\n\n    if (size(a) /= size(b)) then\n      is_equal = .false.\n      return\n    end if\n\n    is_equal = .true.\n    do i = 1, size(a)\n      if (a(i) /= b(i)) then\n        is_equal = .false.\n        return\n      end if\n    end do\n  end function issame\n\n  subroutine sort(array)\n    integer, dimension(:), intent(inout) :: array\n    integer :: i, j, temp\n\n    do i = 1, size(array) - 1\n      do j = i + 1, size(array)\n        if (array(i) > array(j)) then\n          temp = array(i)\n          array(i) = array(j)\n          array(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort\n\nend program collatz [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram collatz\n  implicit none\n  integer, allocatable :: result(:)\n  integer :: n\n\n  ! Test cases\n  call test_odd_collatz(14, [1, 5, 7, 11, 13, 17])\n  call test_odd_collatz(5, [1, 5])\n  call test_odd_collatz(12, [1, 3, 5])\n  call test_odd_collatz(1, [1])\n\ncontains\n\n  subroutine test_odd_collatz(n, expected)\n    integer, intent(in) :: n\n    integer, dimension(:), intent(in) :: expected\n    integer, allocatable :: result(:)\n    logical :: is_same\n\n    result = get_odd_collatz(n)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n      write(*,*) "Assertion failed for n =", n\n      call exit(1)\n    end if\n  end subroutine test_odd_collatz\n\n  function get_odd_collatz(n) result(out)\n    integer, intent(in) :: n\n    integer, allocatable :: out(:)\n    integer :: temp, i, count\n    integer, allocatable :: temp_array(:)\n\n    allocate(out(1))\n    out(1) = 1\n    temp = n\n    count = 1\n\n    do while (temp /= 1)\n      if (mod(temp, 2) == 1) then\n        count = count + 1\n        if (allocated(temp_array)) deallocate(temp_array)\n        allocate(temp_array(count))\n        temp_array(1:count-1) = out\n        temp_array(count) = temp\n        deallocate(out)\n        out = temp_array\n        temp = temp * 3 + 1\n      else\n        temp = temp / 2\n      end
\n\n[C++]\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool valid_date(const string &date)\n{\n    if (date.length() != 10)\n        return false;\n\n    for (int i = 0; i < 10; i++)\n    {\n        if (i == 3 || i == 6)\n        {\n            if (date[i] != '-')\n                return false;\n        }\n        else\n        {\n            if (date[i] < '0' || date[i] > '9')\n                return false;\n        }\n    }\n\n    int mm, dd, yy;\n    sscanf(date.c_str(), "%2d-%2d-%4d", &mm, &dd, &yy);\n\n    if (mm < 1 || mm > 12)\n        return false;\n\n    if (dd < 1 || dd > 31)\n        return false;\n\n    if (dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11 || mm == 2))\n        return false;\n\n    if (dd == 30 && mm == 2)\n        return false;\n\n    return true;\n}\n\nint main()\n{\n    string date;\n\n    // Test cases\n    date = "03-11-2000";\n    if (!valid_date(date))\n    {\n        cerr << "Test case 1 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "15-01-2012";\n    if (valid_date(date))\n    {\n        cerr << "Test case 2 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "04-0-2040";\n    if (valid_date(date))\n    {\n        cerr << "Test case 3 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "06-04-2020";\n    if (!valid_date(date))\n    {\n        cerr << "Test case 4 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "01-01-2007";\n    if (!valid_date(date))\n    {\n        cerr << "Test case 5 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "03-32-2011";\n    if (valid_date(date))\n    {\n        cerr << "Test case 6 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "";\n    if (valid_date(date))\n    {\n        cerr << "Test case 7 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "04-31-3000";\n    if (valid_date(date))\n    {\n        cerr << "Test case 8 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "06-06-2005";\n    if (!valid_date(date))\n    {\n        cerr << "Test case 9 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "21-31-2000";\n    if (valid_date(date))\n    {\n        cerr << "Test case 10 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "04-12-2003";\n    if (!valid_date(date))\n    {\n        cerr << "Test case 11 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "04122003";\n    if (valid_date(date))\n    {\n        cerr << "Test case 12 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "20030412";\n    if (valid_date(date))\n    {\n        cerr << "Test case 13 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "2003-04";\n    if (valid_date(date))\n    {\n        cerr << "Test case 14 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "2003-04-12";\n    if (valid_date(date))\n    {\n        cerr << "Test case 15 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    date = "04-2003";\n    if (valid_date(date))\n    {\n        cerr << "Test case 16 failed" << endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n[C]\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool valid_date(const char *date)\n{\n    if (strlen(date) != 10)\n        return false;\n\n    for (int i = 0; i < 10; i++)\n    {\n        if (i == 3 || i == 6)\n        {\n            if (date[i] != '-')\n                return false;\n        }\n        else\n        {\n            if (date[i] < '0' || date[i] > '9')\n                return false;\n        }\n    }\n\n    int mm, dd, yy;\n    sscanf(date, "%2d-%2d-%4d", &mm, &dd, &yy);\n\n    if (mm < 1 || mm > 12)\n        return false;\n\n    if (dd < 1 || dd > 31)\n        return false;\n\n    if (dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11 || mm == 2))\n        return false;\n\n    if (dd == 30 && mm == 2)\n        return false;\n\n    return true;\n}\n\nint main()\n{\n    char date[11];\n\n    // Test cases\n    strcpy(date, "03-11-2000");\n    if (!valid_date(date))\n    {\n        fprintf(stderr, "Test case 1 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "15-01-2012");\n    if (valid_date(date))\n    {\n        fprintf(stderr, "Test case 2 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "04-0-2040");\n    if (valid_date(date))\n    {\n        fprintf(stderr, "Test case 3 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "06-04-2020");\n    if (!valid_date(date))\n    {\n        fprintf(stderr, "Test case 4 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "01-01-2007");\n    if (!valid_date(date))\n    {\n        fprintf(stderr, "Test case 5 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "03-32-2011");\n    if (valid_date(date))\n    {\n        fprintf(stderr, "Test case 6 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "");\n    if (valid_date(date))\n    {\n        fprintf(stderr, "Test case 7 failed\n");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(date, "04-31-3000");\n   
\n\n[C++]\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_sorted(const vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (int i = 2; i < lst.size(); i++) {\n        if (lst[i] < lst[i-1]) return false;\n        if (i >= 3 && lst[i] == lst[i-1] && lst[i] == lst[i-2]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nint main() {\n    vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is_sorted(lst));\n\n    lst = {1, 3, 2, 4, 5};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5, 6};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5, 6, 7};\n    assert(is_sorted(lst));\n\n    lst = {1, 3, 2, 4, 5, 6, 7};\n    assert(!is_sorted(lst));\n\n    lst = {};\n    assert(is_sorted(lst));\n\n    lst = {1};\n    assert(is_sorted(lst));\n\n    lst = {3, 2, 1};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 2, 2, 3, 4};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 3, 3, 3, 4};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 2, 3, 3, 4};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4};\n    assert(is_sorted(lst));\n\n    return 0;\n}\n\n[C#]\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static bool IsSorted(List<int> lst)\n    {\n        if (lst.Count <= 1) return true;\n\n        for (int i = 2; i < lst.Count; i++)\n        {\n            if (lst[i] < lst[i - 1]) return false;\n            if (i >= 3 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n        }\n        return true;\n    }\n\n    static void Assert(bool condition)\n    {\n        if (!condition)\n        {\n            Console.WriteLine("Assertion failed");\n            Environment.Exit(1);\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        List<int> lst = new List<int> { 5 };\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 3, 4, 5 };\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 1, 3, 2, 4, 5 };\n        Assert(!IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 3, 4, 5, 6 };\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 3, 4, 5, 6, 7 };\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 1, 3, 2, 4, 5, 6, 7 };\n        Assert(!IsSorted(lst));\n\n        lst = new List<int>();\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 1 };\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 3, 2, 1 };\n        Assert(!IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 2, 2, 3, 4 };\n        Assert(!IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 3, 3, 3, 4 };\n        Assert(!IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 2, 3, 3, 4 };\n        Assert(IsSorted(lst));\n\n        lst = new List<int> { 1, 2, 3, 4 };\n        Assert(IsSorted(lst));\n    }\n}\n\n[C++11]\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_sorted(const vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (int i = 2; i < lst.size(); i++) {\n        if (lst[i] < lst[i-1]) return false;\n        if (i >= 3 && lst[i] == lst[i-1] && lst[i] == lst[i-2]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nint main() {\n    vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is_sorted(lst));\n\n    lst = {1, 3, 2, 4, 5};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5, 6};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5, 6, 7};\n    assert(is_sorted(lst));\n\n    lst = {1, 3, 2, 4, 5, 6, 7};\n    assert(!is_sorted(lst));\n\n    lst = {};\n    assert(is_sorted(lst));\n\n    lst = {1};\n    assert(is_sorted(lst));\n\n    lst = {3, 2, 1};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 2, 2, 3, 4};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 3, 3, 3, 4};\n    assert(!is_sorted(lst));\n\n    lst = {1, 2, 2, 3, 3, 4};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4};\n    assert(is_sorted(lst));\n\n    return 0;\n}\n\n[C++14]\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_sorted(const vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (int i = 2; i < lst.size(); i++) {\n        if (lst[i] < lst[i-1]) return false;\n        if (i >= 3 && lst[i] == lst[i-1] && lst[i] == lst[i-2]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nint main() {\n    vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst));\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is
\n\n[C++]\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int inter1 = max(interval1[0], interval2[0]);\n    int inter2 = min(interval1[1], interval2[1]);\n    int l = inter2 - inter1;\n\n    if (l < 2) {\n        return "NO";\n    }\n\n    for (int i = 2; i <= sqrt(l); i++) {\n        if (l % i == 0) {\n            return "NO";\n        }\n    }\n\n    return "YES";\n}\n\nint main() {\n    vector<int> interval1 = {1, 2};\n    vector<int> interval2 = {2, 3};\n    string result = intersection(interval1, interval2);\n    if (result != "NO") {\n        cout << "Assertion failed: intersection([1, 2], [2, 3]) == 'NO'" << endl;\n        return 1;\n    }\n\n    interval1 = {-1, 1};\n    interval2 = {0, 4};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        cout << "Assertion failed: intersection([-1, 1], [0, 4]) == 'NO'" << endl;\n        return 1;\n    }\n\n    interval1 = {-3, -1};\n    interval2 = {-5, 5};\n    result = intersection(interval1, interval2);\n    if (result != "YES") {\n        cout << "Assertion failed: intersection([-3, -1], [-5, 5]) == 'YES'" << endl;\n        return 1;\n    }\n\n    interval1 = {-2, 2};\n    interval2 = {-4, 0};\n    result = intersection(interval1, interval2);\n    if (result != "YES") {\n        cout << "Assertion failed: intersection([-2, 2], [-4, 0]) == 'YES'" << endl;\n        return 1;\n    }\n\n    interval1 = {-11, 2};\n    interval2 = {-1, -1};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        cout << "Assertion failed: intersection([-11, 2], [-1, -1]) == 'NO'" << endl;\n        return 1;\n    }\n\n    interval1 = {1, 2};\n    interval2 = {3, 5};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        cout << "Assertion failed: intersection([1, 2], [3, 5]) == 'NO'" << endl;\n        return 1;\n    }\n\n    interval1 = {1, 2};\n    interval2 = {1, 2};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        cout << "Assertion failed: intersection([1, 2], [1, 2]) == 'NO'" << endl;\n        return 1;\n    }\n\n    interval1 = {-2, -2};\n    interval2 = {-3, -2};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        cout << "Assertion failed: intersection([-2, -2], [-3, -2]) == 'NO'" << endl;\n        return 1;\n    }\n\n    cout << "All tests passed." << endl;\n    return 0;\n}\n\n[C#]\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static string Intersection(int[] interval1, int[] interval2)\n    {\n        int inter1 = Math.Max(interval1[0], interval2[0]);\n        int inter2 = Math.Min(interval1[1], interval2[1]);\n        int l = inter2 - inter1;\n\n        if (l < 2)\n        {\n            return "NO";\n        }\n\n        for (int i = 2; i <= (int)Math.Sqrt(l); i++)\n        {\n            if (l % i == 0)\n            {\n                return "NO";\n            }\n        }\n\n        return "YES";\n    }\n\n    static void Main(string[] args)\n    {\n        int[] interval1 = { 1, 2 };\n        int[] interval2 = { 2, 3 };\n        string result = Intersection(interval1, interval2);\n        if (result != "NO")\n        {\n            Console.WriteLine("Assertion failed: intersection([1, 2], [2, 3]) == 'NO'");\n            return;\n        }\n\n        interval1 = new int[] { -1, 1 };\n        interval2 = new int[] { 0, 4 };\n        result = Intersection(interval1, interval2);\n        if (result != "NO")\n        {\n            Console.WriteLine("Assertion failed: intersection([-1, 1], [0, 4]) == 'NO'");\n            return;\n        }\n\n        interval1 = new int[] { -3, -1 };\n        interval2 = new int[] { -5, 5 };\n        result = Intersection(interval1, interval2);\n        if (result != "YES")\n        {\n            Console.WriteLine("Assertion failed: intersection([-3, -1], [-5, 5]) == 'YES'");\n            return;\n        }\n\n        interval1 = new int[] { -2, 2 };\n        interval2 = new int[] { -4, 0 };\n        result = Intersection(interval1, interval2);\n        if (result != "YES")\n        {\n            Console.WriteLine("Assertion failed: intersection([-2, 2], [-4, 0]) == 'YES'");\n            return;\n        }\n\n        interval1 = new int[] { -11, 2 };\n        interval2 = new int[] { -1, -1 };\n        result = Intersection(interval1, interval2);\n        if (result != "NO")\n        {\n            Console.WriteLine("Assertion failed: intersection([-11, 2], [-1, -1]) == 'NO'");\n            return;\n        }\n\n        interval1 = new int[] { 1, 2 };\n        interval2 = new int[] { 3, 5 };\n        result = Intersection(interval1, interval2);\n        if (result != "NO")\n        {\n            Console.WriteLine("Assertion failed: intersection([1, 2], [3, 5]) == 'NO'");\n            return;\n        }\n\n        interval1 = new int[] { 1, 2 };\n        interval2 = new int[] { 1, 2 };\n        result = Intersection(interval1, interval2);\n        if (result != "NO")\n        {\n            Console.WriteLine("Assertion failed: intersection([1, 2], [1, 2]) == 'NO'");\n            return;\n        }\n\n        interval1 = new int[] { -2, -2 };\n        interval2 = new int[] { -3, -2 };\n        result = Intersection(interval1, interval2);\n        if (result != "NO")\n        {\n            Console.WriteLine("Assertion failed: intersection([-2, -2], [-3, -2]) == 'NO'");\n            return;\n        }\n\n        Console.WriteLine("All tests passed.");\n    }\n}\n\n[Python]\ndef intersection(interval1, interval2):\n    inter1 = max(interval1[0], interval2[0])\n    inter2 = min(interval1[1], interval2[1])\n    l = inter2 - inter1\n\n    if l < 2:\n        return 'NO'\n\n    for i in range(2, int(l ** 0.5) + 1):\n        if l % i == 0:\n            return 'NO'\n\n    return 'YES'\n\n\nif __name__ == '__main__':\n    interval1 = [1, 2]\n    interval2 = [2, 3]\n    result = intersection(interval1, interval2)\n    if result != 'NO':\n        print('Assertion failed: intersection([1, 2], [2, 3]) == \'NO\'
\n\n[CPP]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    int sum = 0;\n    int prods = 1;\n\n    if (arr.size() == 0 || (arr.size() == 1 && arr[0] == 0)) {\n        return -32768;\n    }\n\n    for (int i = 0; i < arr.size(); i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n\n    return sum * prods;\n}\n\nint main() {\n    vector<int> arr1 = {1, 2, 2, -4};\n    int expected1 = -9;\n    int result1 = prod_signs(arr1);\n    cout << "Assertion 1: " << result1 << " == " << expected1 << endl;\n\n    vector<int> arr2 = {0, 1};\n    int expected2 = 0;\n    int result2 = prod_signs(arr2);\n    cout << "Assertion 2: " << result2 << " == " << expected2 << endl;\n\n    vector<int> arr3 = {1, 1, 1, 2, 3, -1, 1};\n    int expected3 = -10;\n    int result3 = prod_signs(arr3);\n    cout << "Assertion 3: " << result3 << " == " << expected3 << endl;\n\n    vector<int> arr4 = {};\n    int expected4 = -32768;\n    int result4 = prod_signs(arr4);\n    cout << "Assertion 4: " << result4 << " == " << expected4 << endl;\n\n    vector<int> arr5 = {2, 4, 1, 2, -1, -1, 9};\n    int expected5 = 20;\n    int result5 = prod_signs(arr5);\n    cout << "Assertion 5: " << result5 << " == " << expected5 << endl;\n\n    vector<int> arr6 = {-1, 1, -1, 1};\n    int expected6 = 4;\n    int result6 = prod_signs(arr6);\n    cout << "Assertion 6: " << result6 << " == " << expected6 << endl;\n\n    vector<int> arr7 = {-1, 1, 1, 1};\n    int expected7 = -4;\n    int result7 = prod_signs(arr7);\n    cout << "Assertion 7: " << result7 << " == " << expected7 << endl;\n\n    vector<int> arr8 = {-1, 1, 1, 0};\n    int expected8 = 0;\n    int result8 = prod_signs(arr8);\n    cout << "Assertion 8: " << result8 << " == " << expected8 << endl;\n\n    cout << "All tests passed." << endl;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint prod_signs(int *arr, int size) {\n    int sum = 0;\n    int prods = 1;\n\n    if (size == 0 || (size == 1 && arr[0] == 0)) {\n        return -32768;\n    }\n\n    for (int i = 0; i < size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n\n    return sum * prods;\n}\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    int expected1 = -9;\n    int result1 = prod_signs(arr1, 4);\n    printf("Assertion 1: %d == %d\n", result1, expected1);\n\n    int arr2[] = {0, 1};\n    int expected2 = 0;\n    int result2 = prod_signs(arr2, 2);\n    printf("Assertion 2: %d == %d\n", result2, expected2);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    int expected3 = -10;\n    int result3 = prod_signs(arr3, 7);\n    printf("Assertion 3: %d == %d\n", result3, expected3);\n\n    int arr4[] = {};\n    int expected4 = -32768;\n    int result4 = prod_signs(arr4, 0);\n    printf("Assertion 4: %d == %d\n", result4, expected4);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    int expected5 = 20;\n    int result5 = prod_signs(arr5, 7);\n    printf("Assertion 5: %d == %d\n", result5, expected5);\n\n    int arr6[] = {-1, 1, -1, 1};\n    int expected6 = 4;\n    int result6 = prod_signs(arr6, 4);\n    printf("Assertion 6: %d == %d\n", result6, expected6);\n\n    int arr7[] = {-1, 1, 1, 1};\n    int expected7 = -4;\n    int result7 = prod_signs(arr7, 4);\n    printf("Assertion 7: %d == %d\n", result7, expected7);\n\n    int arr8[] = {-1, 1, 1, 0};\n    int expected8 = 0;\n    int result8 = prod_signs(arr8, 4);\n    printf("Assertion 8: %d == %d\n", result8, expected8);\n\n    printf("All tests passed.\n");\n}\n\n[PY]\ndef prod_signs(arr):\n    sum = 0\n    prods = 1\n\n    if len(arr) == 0 or (len(arr) == 1 and arr[0] == 0):\n        return -32768\n\n    for i in range(len(arr)):\n        sum += abs(arr[i])\n        if arr[i] == 0:\n            prods = 0\n        if arr[i] < 0:\n            prods = -prods\n\n    return sum * prods\n\n\ndef main():\n    arr1 = [1, 2, 2, -4]\n    expected1 = -9\n    result1 = prod_signs(arr1)\n    print("Assertion 1:", result1, "==", expected1)\n\n    arr2 = [0, 1]\n    expected2 = 0\n    result2 = prod_signs(arr2)\n    print("Assertion 2:", result2, "==", expected2)\n\n    arr3 = [1, 1, 1, 2, 3, -1, 1]\n    expected3 = -10\n    result3 = prod_signs(arr3)\n    print("Assertion 3:", result3, "==", expected3)\n\n    arr4 = []\n    expected4 = -32768\n    result4 = prod_signs(arr4)\n    print("Assertion 4:", result4, "==", expected4)\n\n    arr5 = [2, 4, 1, 2, -1, -1, 9]\n    expected5 = 20\n    result5 = prod_signs(arr5)\n    print("Assertion 5:", result5, "==", expected5)\n\n    arr6 = [-1, 1, -1, 1]\n    expected6 = 4\n    result6 = prod_signs(arr6)\n    print("Assertion 6:", result6, "==", expected6)\n\n    arr7 = [-1, 1, 1, 1]\n    expected7 = -4\n    result7 = prod_signs(arr7)\n    print("Assertion
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    vector<int> grid = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    vector<int> result;\n    int k = 3;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    grid = {5, 9, 3, 4, 1, 6, 7, 8, 2};\n    result.clear();\n    k = 1;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    grid = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n    result.clear();\n    k = 4;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    return 0;\n}\n\nvoid minPath(vector<int> grid, int k, vector<int> &result) {\n    int n = grid.size();\n    int x = -1;\n    int y = -1;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i * n + j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    int min = n * n;\n    if (x > 0 && grid[x * n + y - 1] < min) min = grid[x * n + y - 1];\n    if (x < n - 1 && grid[x * n + y + 1] < min) min = grid[x * n + y + 1];\n    if (y > 0 && grid[(x - 1) * n + y] < min) min = grid[(x - 1) * n + y];\n    if (y < n - 1 && grid[(x + 1) * n + y] < min) min = grid[(x + 1) * n + y];\n\n    result.clear();\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            result.push_back(1);\n        } else {\n            result.push_back(min);\n        }\n    }\n}\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    vector<int> grid = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    vector<int> result;\n    int k = 3;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    grid = {5, 9, 3, 4, 1, 6, 7, 8, 2};\n    result.clear();\n    k = 1;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    grid = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n    result.clear();\n    k = 4;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    return 0;\n}\n\nvoid minPath(vector<int> grid, int k, vector<int> &result) {\n    int n = grid.size();\n    int x = -1;\n    int y = -1;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i * n + j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    int min = n * n;\n    if (x > 0 && grid[x * n + y - 1] < min) min = grid[x * n + y - 1];\n    if (x < n - 1 && grid[x * n + y + 1] < min) min = grid[x * n + y + 1];\n    if (y > 0 && grid[(x - 1) * n + y] < min) min = grid[(x - 1) * n + y];\n    if (y < n - 1 && grid[(x + 1) * n + y] < min) min = grid[(x + 1) * n + y];\n\n    result.clear();\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            result.push_back(1);\n        } else {\n            result.push_back(min);\n        }\n    }\n}\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    vector<int> grid = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    vector<int> result;\n    int k = 3;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    grid = {5, 9, 3, 4, 1, 6, 7, 8, 2};\n    result.clear();\n    k = 1;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    grid = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n    result.clear();\n    k = 4;\n    minPath(grid, k, result);\n    cout << "result: " << endl;\n    for (auto i : result) {\n        cout << i << " ";\n    }\n    cout << endl;\n\n    return 0;\n}\n\nvoid minPath(vector<int> grid, int k, vector<int> &result) {\n    int n = grid.size();\n    int x = -1;\n    int y = -1;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i * n + j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    int min = n * n;\n    if (x > 0 && grid[x * n + y - 1] < min) min = grid[x * n + y - 1];\n    if (x < n - 1 && grid[x * n + y + 1] < min) min = grid[x * n + y + 1];\n    if (y > 0 && grid[(x - 1) * n
\n\n[EXPECTED]\n[TXT]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C]\n[C
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint digits(int n) {\n    string s = to_string(n);\n    int prod = 1;\n    int has = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] % 2 == 1) {\n            has = 1;\n            prod *= s[i] - '0';\n        }\n    }\n\n    if (has == 0) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nint main() {\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n}\n\nint assert(int condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint digits(int n) {\n    char s[20];\n    int prod = 1;\n    int has = 0;\n\n    sprintf(s, "%d", n);\n\n    for (int i = 0; i < strlen(s); i++) {\n        if (s[i] % 2 == 1) {\n            has = 1;\n            prod *= s[i] - '0';\n        }\n    }\n\n    if (has == 0) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nint main() {\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n}\n\nint assert(int condition) {\n    if (!condition) {\n        printf("Assertion failed\n");\n        exit(1);\n    }\n}\n\n[Python]\ndef digits(n):\n    s = str(n)\n    prod = 1\n    has = 0\n\n    for i in range(len(s)):\n        if int(s[i]) % 2 == 1:\n            has = 1\n            prod *= int(s[i])\n\n    if has == 0:\n        return 0\n    else:\n        return prod\n\ndef main():\n    assert(digits(5) == 5)\n    assert(digits(54) == 5)\n    assert(digits(120) == 1)\n    assert(digits(5014) == 5)\n    assert(digits(98765) == 315)\n    assert(digits(5576543) == 2625)\n    assert(digits(2468) == 0)\n\ndef assert(condition):\n    if not condition:\n        print("Assertion failed")\n        exit(1)\n\nif __name__ == "__main__":\n    main()\n\n[Java]\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        assert(digits(5) == 5);\n        assert(digits(54) == 5);\n        assert(digits(120) == 1);\n        assert(digits(5014) == 5);\n        assert(digits(98765) == 315);\n        assert(digits(5576543) == 2625);\n        assert(digits(2468) == 0);\n    }\n\n    public static int digits(int n) {\n        String s = Integer.toString(n);\n        int prod = 1;\n        int has = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) % 2 == 1) {\n                has = 1;\n                prod *= s.charAt(i) - '0';\n            }\n        }\n\n        if (has == 0) {\n            return 0;\n        } else {\n            return prod;\n        }\n    }\n\n    public static void assert(boolean condition) {\n        if (!condition) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n    }\n}\n\n[JavaScript]\nfunction digits(n) {\n    let s = n.toString();\n    let prod = 1;\n    let has = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] % 2 == 1) {\n            has = 1;\n            prod *= s[i] - '0';\n        }\n    }\n\n    if (has == 0) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nfunction main() {\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n}\n\nfunction assert(condition) {\n    if (!condition) {\n        console.log("Assertion failed");\n        process.exit(1);\n    }\n}\n\n[PHP]\nfunction digits($n) {\n    $s = (string) $n;\n    $prod = 1;\n    $has = 0;\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        if ($s[$i] % 2 == 1) {\n            $has = 1;\n            $prod *= $s[$i] - '0';\n        }\n    }\n\n    if ($has == 0) {\n        return 0;\n    } else {\n        return $prod;\n    }\n}\n\nfunction main() {\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n}\n\nfunction assert($condition) {\n    if (!$condition) {\n        echo "Assertion failed\n";\n        exit(1);\n    }\n}\n\n[Ruby]\ndef digits(n)\n    s = n.to_s\n    prod = 1\n    has = 0\n\n    for i in 0...s.length\n        if s[i].ord % 2 == 1\n            has = 1\n            prod *= s[i].ord - '0'.ord\n        end\n    end\n\n    if has == 0\n        return 0\n    else\n        return prod\n    end\nend\n\ndef main()\n    assert(digits(5) == 5)\n    assert(digits(54) == 5)\n    assert(digits(120) == 1)\n    assert(digits(5014) == 5)\n    assert(digits(98765) == 315)\n    assert(digits(55765
\n\n[INST] Translate this Fortran code to C++: \nprogram nested_brackets\n  implicit none\n\n  ! Main program body\n  call run_tests()\n\ncontains\n\n  logical function is_nested(str)\n    character(len=*), intent(in) :: str\n    integer :: count, maxcount, i\n\n    count = 0\n    maxcount = 0\n    do i = 1, len(str)\n      if (str(i:i) == '[') count = count + 1\n      if (str(i:i) == ']') count = count - 1\n      if (count < 0) count = 0\n      if (count > maxcount) maxcount = count\n      if (count <= maxcount - 2) then\n        is_nested = .true.\n        return\n      end if\n    end do\n    is_nested = .false.\n  end function is_nested\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n      call exit(1)\n    end if\n  end subroutine assert\n\n  subroutine run_tests()\n    call assert(is_nested("[[]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]][[[[[]") .eqv. .false.)\n    call assert(is_nested("[][]") .eqv. .false.)\n    call assert(is_nested("[]") .eqv. .false.)\n    call assert(is_nested("[[[[]]]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]]]]]") .eqv. .false.)\n    call assert(is_nested("[][][[]]") .eqv. .true.)\n    call assert(is_nested("[[]") .eqv. .false.)\n    call assert(is_nested("[]]") .eqv. .false.)\n    call assert(is_nested("[[]][[") .eqv. .true.)\n    call assert(is_nested("[[][]]") .eqv. .true.)\n    call assert(is_nested("") .eqv. .false.)\n    call assert(is_nested("[[[[[[[[") .eqv. .false.)\n    call assert(is_nested("]]]]]]]]") .eqv. .false.)\n  end subroutine run_tests\n\nend program nested_brackets [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram nested_brackets\n  implicit none\n\n  ! Main program body\n  call run_tests()\n\ncontains\n\n  logical function is_nested(str)\n    character(len=*), intent(in) :: str\n    integer :: count, maxcount, i\n\n    count = 0\n    maxcount = 0\n    do i = 1, len(str)\n      if (str(i:i) == '[') count = count + 1\n      if (str(i:i) == ']') count = count - 1\n      if (count < 0) count = 0\n      if (count > maxcount) maxcount = count\n      if (count <= maxcount - 2) then\n        is_nested = .true.\n        return\n      end if\n    end do\n    is_nested = .false.\n  end function is_nested\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n      call exit(1)\n    end if\n  end subroutine assert\n\n  subroutine run_tests()\n    call assert(is_nested("[[]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]][[[[[]") .eqv. .false.)\n    call assert(is_nested("[][]") .eqv. .false.)\n    call assert(is_nested("[]") .eqv. .false.)\n    call assert(is_nested("[[[[]]]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]]]]]") .eqv. .false.)\n    call assert(is_nested("[][][[]]") .eqv. .true.)\n    call assert(is_nested("[[]") .eqv. .false.)\n    call assert(is_nested("[]]") .eqv. .false.)\n    call assert(is_nested("[[]][[") .eqv. .true.)\n    call assert(is_nested("[[][]]") .eqv. .true.)\n    call assert(is_nested("") .eqv. .false.)\n    call assert(is_nested("[[[[[[[[") .eqv. .false.)\n    call assert(is_nested("]]]]]]]]") .eqv. .false.)\n  end subroutine run_tests\n\nend program nested_brackets [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram nested_brackets\n  implicit none\n\n  ! Main program body\n  call run_tests()\n\ncontains\n\n  logical function is_nested(str)\n    character(len=*), intent(in) :: str\n    integer :: count, maxcount, i\n\n    count = 0\n    maxcount = 0\n    do i = 1, len(str)\n      if (str(i:i) == '[') count = count + 1\n      if (str(i:i) == ']') count = count - 1\n      if (count < 0) count = 0\n      if (count > maxcount) maxcount = count\n      if (count <= maxcount - 2) then\n        is_nested = .true.\n        return\n      end if\n    end do\n    is_nested = .false.\n  end function is_nested\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n      call exit(1)\n    end if\n  end subroutine assert\n\n  subroutine run_tests()\n    call assert(is_nested("[[]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]][[[[[]") .eqv. .false.)\n    call assert(is_nested("[][]") .eqv. .false.)\n    call assert(is_nested("[]") .eqv. .false.)\n    call assert(is_nested("[[[[]]]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]]]]]") .eqv. .false.)\n    call assert(is_nested("[][][[]]") .eqv. .true.)\n    call assert(is_nested("[[]") .eqv. .false.)\n    call assert(is_nested("[]]") .eqv. .false.)\n    call assert(is_nested("[[]][[") .eqv. .true.)\n    call assert(is_nested("[[][]]") .eqv. .true.)\n    call assert(is_nested("") .eqv. .false.)\n    call assert(is_nested("[[[[[[[[") .eqv. .false.)\n    call assert(is_nested("]]]]]]]]") .eqv. .false.)\n  end subroutine run_tests\n\nend program nested_brackets [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram nested_brackets\n  implicit none\n\n  ! Main program body\n  call run_tests()\n\ncontains\n\n  logical function is_nested(str)\n    character(len=*), intent(in) :: str\n    integer :: count, maxcount, i\n\n    count = 0\n    maxcount = 0\n    do i = 1, len(str)\n      if (str(i:i) == '[') count = count + 1\n      if (str(i:i) == ']') count = count - 1\n      if (count < 0) count = 0\n      if (count > maxcount) maxcount = count\n      if (count <= maxcount - 2) then\n        is_nested = .true.\n        return\n      end if\n    end do\n    is_nested = .false.\n  end function is_nested\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n
\n\n[EXPECTED]\n[SUCCESS]\n[BACKEND]\n\n[SUMMARY]\n[CALLGRAPH]\n[COST]\n[BACKEND_SUMMARY]\n\n[BACKEND_CALLGRAPH]\n[BACKEND_COST]\n\n[BACKEND_BENCHMARK]\n[BACKEND_BENCHMARK_ALL]\n\n[BACKEND_EMIT]\n[BACKEND_EMIT_ALL]\n\n[BACKEND_EMIT_ASM]\n[BACKEND_EMIT_ASM_ALL]\n\n[BACKEND_EMIT_ASM_LINUX]\n[BACKEND_EMIT_ASM_LINUX_ALL]\n\n[BACKEND_EMIT_ASM_WINDOWS]\n[BACKEND_EMIT_ASM_WINDOWS_ALL]\n\n[BACKEND_EMIT_ASM_DARWIN]\n[BACKEND_EMIT_ASM_DARWIN_ALL]\n\n[BACKEND_EMIT_ASM_FREEBSD]\n[BACKEND_EMIT_ASM_FREEBSD_ALL]\n\n[BACKEND_EMIT_ASM_OPENBSD]\n[BACKEND_EMIT_ASM_OPENBSD_ALL]\n\n[BACKEND_EMIT_ASM_ANDROID]\n[BACKEND_EMIT_ASM_ANDROID_ALL]\n\n[BACKEND_EMIT_ASM_WINDOWS_X86_64]\n[BACKEND_EMIT_ASM_WINDOWS_X86_64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_X86_64]\n[BACKEND_EMIT_ASM_LINUX_X86_64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_I386]\n[BACKEND_EMIT_ASM_LINUX_I386_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_ARM]\n[BACKEND_EMIT_ASM_LINUX_ARM_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_AARCH64]\n[BACKEND_EMIT_ASM_LINUX_AARCH64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_PPC]\n[BACKEND_EMIT_ASM_LINUX_PPC_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_PPC64]\n[BACKEND_EMIT_ASM_LINUX_PPC64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPS]\n[BACKEND_EMIT_ASM_LINUX_MIPS_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPSEL]\n[BACKEND_EMIT_ASM_LINUX_MIPSEL_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPS64]\n[BACKEND_EMIT_ASM_LINUX_MIPS64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPSEL64]\n[BACKEND_EMIT_ASM_LINUX_MIPSEL64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_RISCV64]\n[BACKEND_EMIT_ASM_LINUX_RISCV64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_S390X]\n[BACKEND_EMIT_ASM_LINUX_S390X_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_X86_64]\n[BACKEND_EMIT_ASM_LINUX_X86_64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_I386]\n[BACKEND_EMIT_ASM_LINUX_I386_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_ARM]\n[BACKEND_EMIT_ASM_LINUX_ARM_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_AARCH64]\n[BACKEND_EMIT_ASM_LINUX_AARCH64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_PPC]\n[BACKEND_EMIT_ASM_LINUX_PPC_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_PPC64]\n[BACKEND_EMIT_ASM_LINUX_PPC64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPS]\n[BACKEND_EMIT_ASM_LINUX_MIPS_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPSEL]\n[BACKEND_EMIT_ASM_LINUX_MIPSEL_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPS64]\n[BACKEND_EMIT_ASM_LINUX_MIPS64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPSEL64]\n[BACKEND_EMIT_ASM_LINUX_MIPSEL64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_RISCV64]\n[BACKEND_EMIT_ASM_LINUX_RISCV64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_S390X]\n[BACKEND_EMIT_ASM_LINUX_S390X_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_X86_64]\n[BACKEND_EMIT_ASM_LINUX_X86_64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_I386]\n[BACKEND_EMIT_ASM_LINUX_I386_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_ARM]\n[BACKEND_EMIT_ASM_LINUX_ARM_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_AARCH64]\n[BACKEND_EMIT_ASM_LINUX_AARCH64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_PPC]\n[BACKEND_EMIT_ASM_LINUX_PPC_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_PPC64]\n[BACKEND_EMIT_ASM_LINUX_PPC64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPS]\n[BACKEND_EMIT_ASM_LINUX_MIPS_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPSEL]\n[BACKEND_EMIT_ASM_LINUX_MIPSEL_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPS64]\n[BACKEND_EMIT_ASM_LINUX_MIPS64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_MIPSEL64]\n[BACKEND_EMIT_ASM_LINUX_MIPSEL64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_RISCV64]\n[BACKEND_EMIT_ASM_LINUX_RISCV64_ALL]\n\n[BACKEND_EMIT_ASM_LINUX_S390X]\n[BACKEND_EMIT_ASM_LINUX_S390X_ALL
\n\n[SOLUTION]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n	int n = arr.size();\n	int max = -1;\n	for (int i = 0; i < n; i++) {\n		if (arr[i] <= i - 1) {\n			max = i - 1;\n		}\n	}\n	return max;\n}\n\nint can_arrange_empty() {\n	return -1;\n}\n\nint main() {\n	vector<int> arr1 = {1, 2, 4, 3, 5};\n	int result1 = can_arrange(arr1);\n	if (result1 != 3) {\n		cout << "Assertion failed: can_arrange({1,2,4,3,5}) /= 3" << endl;\n		return 1;\n	}\n\n	vector<int> arr2 = {1, 2, 4, 5};\n	int result2 = can_arrange(arr2);\n	if (result2 != -1) {\n		cout << "Assertion failed: can_arrange({1,2,4,5}) /= -1" << endl;\n		return 1;\n	}\n\n	vector<int> arr3 = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n	int result3 = can_arrange(arr3);\n	if (result3 != 2) {\n		cout << "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) /= 2" << endl;\n		return 1;\n	}\n\n	vector<int> arr4 = {4, 8, 5, 7, 3};\n	int result4 = can_arrange(arr4);\n	if (result4 != 4) {\n		cout << "Assertion failed: can_arrange({4,8,5,7,3}) /= 4" << endl;\n		return 1;\n	}\n\n	vector<int> arr5;\n	int result5 = can_arrange_empty();\n	if (result5 != -1) {\n		cout << "Assertion failed: can_arrange({}) /= -1" << endl;\n		return 1;\n	}\n\n	cout << "All tests passed." << endl;\n	return 0;\n}\n[/SOLUTION]\n\n[CHALLENGE]\nWrite a function that takes a list of numbers and returns the maximum number that can be placed at the beginning of the list so that the remaining numbers can be arranged in a strictly increasing order.\n\nFor example, given the list [1, 2, 4, 3, 5], you should return 3, since 3 is the maximum number that can be placed at the beginning of the list so that the remaining numbers can be arranged in a strictly increasing order. Given the list [4, 8, 5, 7, 3], you should return 4, since 4 is the maximum number that can be placed at the beginning of the list so that the remaining numbers can be arranged in a strictly increasing order.\n\nIf the list is empty, return -1.\n\n[/CHALLENGE]\n\n[META]\nentity;\n[/META]\n\n[DESCRIPTION]\n[/DESCRIPTION]\n\n[TAGS]\nfortran, cpp, cpp14, cpp17, c, c89, c99, c11, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y, c++1z, c++14, c++17, c++11, c++1y
\n\n\n[SOLUTION]\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    vector<int> input_array;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int value;\n        cin >> value;\n        input_array.push_back(value);\n    }\n\n    int max_neg = 0;\n    int min_pos = 0;\n    for (int i = 0; i < n; i++) {\n        if (input_array[i] < 0) {\n            if (max_neg == 0 || input_array[i] > max_neg) {\n                max_neg = input_array[i];\n            }\n        } else {\n            if (min_pos == 0 || input_array[i] < min_pos) {\n                min_pos = input_array[i];\n            }\n        }\n    }\n\n    cout << max_neg << " " << min_pos << endl;\n    return 0;\n}\n\n[CHECK]\n\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nvoid run_tests() {\n    vector<int> input_array;\n    int n;\n    int max_neg = 0;\n    int min_pos = 0;\n\n    // Test case #1\n    n = 6;\n    input_array = {2, 4, 1, 3, 5, 7};\n    max_neg = 0;\n    min_pos = 1;\n    printf("Test case #1\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #2\n    n = 7;\n    input_array = {2, 4, 1, 3, 5, 7, 0};\n    max_neg = 0;\n    min_pos = 1;\n    printf("Test case #2\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #3\n    n = 7;\n    input_array = {1, 3, 2, 4, 5, 6, -2};\n    max_neg = -2;\n    min_pos = 1;\n    printf("Test case #3\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #4\n    n = 7;\n    input_array = {4, 5, 3, 6, 2, 7, -7};\n    max_neg = -7;\n    min_pos = 2;\n    printf("Test case #4\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #5\n    n = 8;\n    input_array = {7, 3, 8, 4, 9, 2, 5, -9};\n    max_neg = -9;\n    min_pos = 2;\n    printf("Test case #5\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #6\n    n = 1;\n    input_array = {0};\n    max_neg = 0;\n    min_pos = 0;\n    printf("Test case #6\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #7\n    n = 4;\n    input_array = {-1, -3, -5, -6};\n    max_neg = -1;\n    min_pos = 0;\n    printf("Test case #7\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #8\n    n = 5;\n    input_array = {-1, -3, -5, -6, 0};\n    max_neg = -1;\n    min_pos = 0;\n    printf("Test case #8\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #9\n    n = 5;\n    input_array = {-6, -4, -4, -3, 1};\n    max_neg = -3;\n    min_pos = 1;\n    printf("Test case #9\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #10\n    n = 6;\n    input_array = {-6, -4, -4, -3, -100, 1};\n    max_neg = -3;\n    min_pos = 1;\n    printf("Test case #10\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #11\n    n = 0;\n    input_array = {};\n    max_neg = 0;\n    min_pos = 0;\n    printf("Test case #11\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n}\n\nvoid print_array(vector<int> input_array) {\n    for (int i = 0; i < input_array.size(); i++) {\n        printf("%d ", input_array[i]);\n    }\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n\n[CHECK]\n\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nvoid run_tests() {\n    vector<int> input_array;\n    int n;\n    int max_neg = 0;\n    int min_pos = 0;\n\n    // Test case #1\n    n = 6;\n    input_array = {2, 4, 1, 3, 5, 7};\n    max_neg = 0;\n    min_pos = 1;\n    printf("Test case #1\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #2\n    n = 7;\n    input_array = {2, 4, 1, 3, 5, 7, 0};\n    max_neg = 0;\n    min_pos = 1;\n    printf("Test case #2\n");\n    printf("Expected: %d %d\n", max_neg, min_pos);\n    printf("Got:      ");\n    print_array(input_array);\n    printf("\n");\n\n    // Test case #3\n    n = 7;\n    input_array = {1, 3, 2, 4, 5, 6, -2};\n    max_neg = -2;\n
\n\n[INST] Translate this Fortran code to C++: \nprogram special_factorial_program\n  implicit none\n  integer, parameter :: int64 = selected_int_kind(18)\n  integer(int64) :: result\n\n  ! Test cases\n  result = special_factorial(4)\n  if (result /= 288_int64) then\n    write(*,*) "special_factorial(4) == 288: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(5)\n  if (result /= 34560_int64) then\n    write(*,*) "special_factorial(5) == 34560: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(7)\n  if (result /= 125411328000_int64) then\n    write(*,*) "special_factorial(7) == 125411328000: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(1)\n  if (result /= 1_int64) then\n    write(*,*) "special_factorial(1) == 1: assertion failed"\n    call exit(1)\n  end if\n\ncontains\n\n  function special_factorial(n) result(bfact)\n    implicit none\n    integer, intent(in) :: n\n    integer(int64) :: bfact\n    integer(int64) :: fact\n    integer :: i\n\n    fact = 1\n    bfact = 1\n    do i = 1, n\n      fact = fact * i\n      bfact = bfact * fact\n    end do\n  end function special_factorial\n\nend program special_factorial_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram special_factorial_program\n  implicit none\n  integer, parameter :: int64 = selected_int_kind(18)\n  integer(int64) :: result\n\n  ! Test cases\n  result = special_factorial(4)\n  if (result /= 288_int64) then\n    write(*,*) "special_factorial(4) == 288: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(5)\n  if (result /= 34560_int64) then\n    write(*,*) "special_factorial(5) == 34560: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(7)\n  if (result /= 125411328000_int64) then\n    write(*,*) "special_factorial(7) == 125411328000: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(1)\n  if (result /= 1_int64) then\n    write(*,*) "special_factorial(1) == 1: assertion failed"\n    call exit(1)\n  end if\n\ncontains\n\n  function special_factorial(n) result(bfact)\n    implicit none\n    integer, intent(in) :: n\n    integer(int64) :: bfact\n    integer(int64) :: fact\n    integer :: i\n\n    fact = 1\n    bfact = 1\n    do i = 1, n\n      fact = fact * i\n      bfact = bfact * fact\n    end do\n  end function special_factorial\n\nend program special_factorial_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram special_factorial_program\n  implicit none\n  integer, parameter :: int64 = selected_int_kind(18)\n  integer(int64) :: result\n\n  ! Test cases\n  result = special_factorial(4)\n  if (result /= 288_int64) then\n    write(*,*) "special_factorial(4) == 288: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(5)\n  if (result /= 34560_int64) then\n    write(*,*) "special_factorial(5) == 34560: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(7)\n  if (result /= 125411328000_int64) then\n    write(*,*) "special_factorial(7) == 125411328000: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(1)\n  if (result /= 1_int64) then\n    write(*,*) "special_factorial(1) == 1: assertion failed"\n    call exit(1)\n  end if\n\ncontains\n\n  function special_factorial(n) result(bfact)\n    implicit none\n    integer, intent(in) :: n\n    integer(int64) :: bfact\n    integer(int64) :: fact\n    integer :: i\n\n    fact = 1\n    bfact = 1\n    do i = 1, n\n      fact = fact * i\n      bfact = bfact * fact\n    end do\n  end function special_factorial\n\nend program special_factorial_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram special_factorial_program\n  implicit none\n  integer, parameter :: int64 = selected_int_kind(18)\n  integer(int64) :: result\n\n  ! Test cases\n  result = special_factorial(4)\n  if (result /= 288_int64) then\n    write(*,*) "special_factorial(4) == 288: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(5)\n  if (result /= 34560_int64) then\n    write(*,*) "special_factorial(5) == 34560: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(7)\n  if (result /= 125411328000_int64) then\n    write(*,*) "special_factorial(7) == 125411328000: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(1)\n  if (result /= 1_int64) then\n    write(*,*) "special_factorial(1) == 1: assertion failed"\n    call exit(1)\n  end if\n\ncontains\n\n  function special_factorial(n) result(bfact)\n    implicit none\n    integer, intent(in) :: n\n    integer(int64) :: bfact\n    integer(int64) :: fact\n    integer :: i\n\n    fact = 1\n    bfact = 1\n    do i = 1, n\n      fact = fact * i\n      bfact = bfact * fact\n    end do\n  end function special_factorial\n\nend program special_factorial_program [/INST]\n\n[INST] Translate this Fortran code to C++: \nprogram special_factorial_program\n  implicit none\n  integer, parameter :: int64 = selected_int_kind(18)\n  integer(int64) :: result\n\n  ! Test cases\n  result = special_factorial(4)\n  if (result /= 288_int64) then\n    write(*,*) "special_factorial(4) == 288: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(5)\n  if (result /= 34560_int64) then\n    write(*,*) "special_factorial(5) == 34560: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(7)\n  if (result /= 125411328000
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nbool file_name_check(string file_name) {\n    int numdigit = 0;\n    int numdot = 0;\n    int i;\n    string last;\n    char w;\n\n    if (file_name.length() < 5) return false;\n\n    w = file_name[0];\n    if (isalpha(w) == 0 || (isalpha(w) == 0 && isdigit(w) == 0) || isalpha(w) == 0) return false;\n\n    last = file_name.substr(file_name.length()-4, 4);\n    if (last != ".txt" && last != ".exe" && last != ".dll") return false;\n\n    for (i = 0; i < file_name.length(); i++) {\n        if (isdigit(file_name[i]) != 0) numdigit++;\n        if (file_name[i] == '.') numdot++;\n    }\n\n    if (numdigit > 3 || numdot != 1) return false;\n\n    return true;\n}\n\nint main() {\n    assert(file_name_check("example.txt") == true);\n    assert(file_name_check("1example.dll") == false);\n    assert(file_name_check("s1sdf3.asd") == false);\n    assert(file_name_check("K.dll") == true);\n    assert(file_name_check("MY16FILE3.exe") == true);\n    assert(file_name_check("His12FILE94.exe") == false);\n    assert(file_name_check("_Y.txt") == false);\n    assert(file_name_check("?aREYA.exe") == false);\n    assert(file_name_check("/this_is_valid.dll") == false);\n    assert(file_name_check("this_is_valid.wow") == false);\n    assert(file_name_check("this_is_valid.txt") == true);\n    assert(file_name_check("this_is_valid.txtexe") == false);\n    assert(file_name_check("#this2_i4s_5valid.ten") == false);\n    assert(file_name_check("@this1_is6_valid.exe") == false);\n    assert(file_name_check("this_is_12valid.6exe4.txt") == false);\n    assert(file_name_check("all.exe.txt") == false);\n    assert(file_name_check("I563_No.exe") == true);\n    assert(file_name_check("Is3youfault.txt") == true);\n    assert(file_name_check("no_one#knows.dll") == true);\n    assert(file_name_check("1I563_Yes3.exe") == false);\n    assert(file_name_check("I563_Yes3.txtt") == false);\n    assert(file_name_check("final..txt") == false);\n    assert(file_name_check("final132") == false);\n    assert(file_name_check("_f4indsartal132.") == false);\n    assert(file_name_check(".txt") == false);\n    assert(file_name_check("s.") == false);\n\n    return 0;\n}\n\n[C]\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LENGTH 100\n\nint file_name_check(char *file_name) {\n    int numdigit = 0;\n    int numdot = 0;\n    int i;\n    char last[5];\n    char w;\n\n    if (strlen(file_name) < 5) return 0;\n\n    w = file_name[0];\n    if (isalpha(w) == 0 || (isalpha(w) == 0 && isdigit(w) == 0) || isalpha(w) == 0) return 0;\n\n    strncpy(last, file_name + strlen(file_name) - 4, 4);\n    if (strcmp(last, ".txt") != 0 && strcmp(last, ".exe") != 0 && strcmp(last, ".dll") != 0) return 0;\n\n    for (i = 0; i < strlen(file_name); i++) {\n        if (isdigit(file_name[i]) != 0) numdigit++;\n        if (file_name[i] == '.') numdot++;\n    }\n\n    if (numdigit > 3 || numdot != 1) return 0;\n\n    return 1;\n}\n\nint main() {\n    assert(file_name_check("example.txt") == 1);\n    assert(file_name_check("1example.dll") == 0);\n    assert(file_name_check("s1sdf3.asd") == 0);\n    assert(file_name_check("K.dll") == 1);\n    assert(file_name_check("MY16FILE3.exe") == 1);\n    assert(file_name_check("His12FILE94.exe") == 0);\n    assert(file_name_check("_Y.txt") == 0);\n    assert(file_name_check("?aREYA.exe") == 0);\n    assert(file_name_check("/this_is_valid.dll") == 0);\n    assert(file_name_check("this_is_valid.wow") == 0);\n    assert(file_name_check("this_is_valid.txt") == 1);\n    assert(file_name_check("this_is_valid.txtexe") == 0);\n    assert(file_name_check("#this2_i4s_5valid.ten") == 0);\n    assert(file_name_check("@this1_is6_valid.exe") == 0);\n    assert(file_name_check("this_is_12valid.6exe4.txt") == 0);\n    assert(file_name_check("all.exe.txt") == 0);\n    assert(file_name_check("I563_No.exe") == 1);\n    assert(file_name_check("Is3youfault.txt") == 1);\n    assert(file_name_check("no_one#knows.dll") == 1);\n    assert(file_name_check("1I563_Yes3.exe") == 0);\n    assert(file_name_check("I563_Yes3.txtt") == 0);\n    assert(file_name_check("final..txt") == 0);\n    assert(file_name_check("final132") == 0);\n    assert(file_name_check("_f4indsartal132.") == 0);\n    assert(file_name_check(".txt") == 0);\n    assert(file_name_check("s.") == 0);\n\n    return 0;\n}\n\n[Python]\ndef file_name_check(file_name):\n    numdigit = 0\n    numdot = 0\n    i = 0\n    last = file_name[-4:]\n\n    if len(file_name) < 5:\n        return False\n\n    w = file_name[0]\n    if not (65 <= ord(w) <= 90 or 97 <= ord(w) <= 122):\n        return False\n\n    if last != ".txt" and last != ".exe" and last != ".dll":\n        return False\n\n    for i in range(len(file_name)):\n        if 48 <= ord(file_name[i]) <= 57:\n            numdigit += 1\n        if file_name[i] == ".":\n            numdot += 1\n\n    if numdigit > 3 or numdot != 1:\n        return False\n\n    return True\n\ndef assert(condition):\n    if not condition:\n        print("Assertion failed")\n        exit(1)\n\nif __name__ == "__main__":\n    assert(file_name_check("example.txt") == True)\n    assert(file_name_check("1example.dll") == False)\n
\n```\n\n### Solution\n\n```cpp\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nbool simplify(const std::string& x, const std::string& n) {\n    int a, b, c, d;\n    size_t pos = x.find('/');\n    a = std::stoi(x.substr(0, pos));\n    b = std::stoi(x.substr(pos + 1));\n\n    pos = n.find('/');\n    c = std::stoi(n.substr(0, pos));\n    d = std::stoi(n.substr(pos + 1));\n\n    return (a * c) % (b * d) == 0;\n}\n\nint main() {\n    bool result;\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/6", "2/1");\n    if (result) {\n        std::cout << "Assertion failed: simplify('1/6', '2/1') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/1", "3/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('5/1', '3/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/10", "10/2");\n    if (result) {\n        std::cout << "Assertion failed: simplify('7/10', '10/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/10", "50/10");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('2/10', '50/10') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/2", "4/2");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('7/2', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("11/6", "6/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('11/6', '6/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/3", "5/2");\n    if (result) {\n        std::cout << "Assertion failed: simplify('2/3', '5/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/2", "3/5");\n    if (result) {\n        std::cout << "Assertion failed: simplify('5/2', '3/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "8/4");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('2/4', '8/4') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "4/2");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('2/4', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "1/5");\n    if (result) {\n        std::cout << "Assertion failed: simplify('1/5', '1/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n```\n\n### Solution 2\n\n```cpp\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nbool simplify(const std::string& x, const std::string& n) {\n    int a, b, c, d;\n    size_t pos = x.find('/');\n    a = std::stoi(x.substr(0, pos));\n    b = std::stoi(x.substr(pos + 1));\n\n    pos = n.find('/');\n    c = std::stoi(n.substr(0, pos));\n    d = std::stoi(n.substr(pos + 1));\n\n    return (a * c) % (b * d) == 0;\n}\n\nint main() {\n    bool result;\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/6", "2/1");\n    if (result) {\n        std::cout << "Assertion failed: simplify('1/6', '2/1') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/1", "3/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('5/1', '3/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/10", "10/2");\n    if (result) {\n        std::cout << "Assertion failed: simplify('7/10', '10/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/10", "50/10");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('2/10', '50/10') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/2", "4/2");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('7/2', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("11/6", "6/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('11/6', '6/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/3", "5/2");\n    if (result) {\n        std::cout << "Assertion failed: simplify('2/3', '5/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/2", "3/5");\n    if (result) {\n        std::cout << "Assertion failed: simplify('5/2', '3/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "8/4");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('2/4', '8/4') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "4/2");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('2/4', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cout << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "1/5");\n    if (result) {\n        std::cout << "
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint sum_digits(int n) {\n    string s = to_string(abs(n));\n    int sum = 0;\n    for (int i = 1; i < s.length(); i++) {\n        sum += s[i] - '0';\n    }\n    if (n > 0) {\n        sum += s[0] - '0';\n    } else {\n        sum -= s[0] - '0';\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> sumdigit(nums.size());\n    for (int i = 0; i < nums.size(); i++) {\n        sumdigit[i] = sum_digits(nums[i]);\n    }\n    sort(sumdigit.begin(), sumdigit.end());\n    sort(nums.begin(), nums.end(), [&](int a, int b) {\n        return sumdigit[a] < sumdigit[b];\n    });\n    return nums;\n}\n\nint main() {\n    vector<int> nums = {1, 11, -1, -11, -12};\n    vector<int> result = order_by_points(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << " ";\n    }\n    cout << endl;\n\n    nums = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    result = order_by_points(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << " ";\n    }\n    cout << endl;\n\n    nums = {1, -11, -32, 43, 54, -98, 2, -3};\n    result = order_by_points(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << " ";\n    }\n    cout << endl;\n\n    nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    result = order_by_points(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << " ";\n    }\n    cout << endl;\n\n    nums = {0, 6, 6, -76, -21, 23, 4};\n    result = order_by_points(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << " ";\n    }\n    cout << endl;\n\n    return 0;\n}\n\n[Python]\ndef sum_digits(n):\n    s = str(abs(n))\n    sum = 0\n    for i in range(1, len(s)):\n        sum += int(s[i])\n    if n > 0:\n        sum += int(s[0])\n    else:\n        sum -= int(s[0])\n    return sum\n\ndef order_by_points(nums):\n    sumdigit = [sum_digits(n) for n in nums]\n    sumdigit.sort()\n    nums.sort(key=lambda x: sumdigit[x])\n    return nums\n\nif __name__ == "__main__":\n    nums = [1, 11, -1, -11, -12]\n    result = order_by_points(nums)\n    print(result)\n\n    nums = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\n    result = order_by_points(nums)\n    print(result)\n\n    nums = [1, -11, -32, 43, 54, -98, 2, -3]\n    result = order_by_points(nums)\n    print(result)\n\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    result = order_by_points(nums)\n    print(result)\n\n    nums = [0, 6, 6, -76, -21, 23, 4]\n    result = order_by_points(nums)\n    print(result)\n\n[Java]\nimport java.util.Arrays;\n\nclass Solution {\n    public int sumDigits(int n) {\n        String s = Integer.toString(Math.abs(n));\n        int sum = 0;\n        for (int i = 1; i < s.length(); i++) {\n            sum += s.charAt(i) - '0';\n        }\n        if (n > 0) {\n            sum += s.charAt(0) - '0';\n        } else {\n            sum -= s.charAt(0) - '0';\n        }\n        return sum;\n    }\n\n    public int[] orderByPoints(int[] nums) {\n        int[] sumdigit = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            sumdigit[i] = sumDigits(nums[i]);\n        }\n        Arrays.sort(sumdigit);\n        Arrays.sort(nums, (a, b) -> sumdigit[a] - sumdigit[b]);\n        return nums;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 11, -1, -11, -12};\n        int[] result = new Solution().orderByPoints(nums);\n        for (int i : result) {\n            System.out.print(i + " ");\n        }\n        System.out.println();\n\n        nums = new int[]{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n        result = new Solution().orderByPoints(nums);\n        for (int i : result) {\n            System.out.print(i + " ");\n        }\n        System.out.println();\n\n        nums = new int[]{1, -11, -32, 43, 54, -98, 2, -3};\n        result = new Solution().orderByPoints(nums);\n        for (int i : result) {\n            System.out.print(i + " ");\n        }\n        System.out.println();\n\n        nums = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n        result = new Solution().orderByPoints(nums);\n        for (int i : result) {\n            System.out.print(i + " ");\n        }\n        System.out.println();\n\n        nums = new int[]{0, 6, 6, -76, -21, 23, 4};\n        result = new Solution().orderByPoints(nums);\n        for (int i : result) {\n            System.out.print(i + " ");\n        }\n        System.out.println();\n    }\n}\n\n[JavaScript]\nfunction sumDigits(n) {\n    let s = Math.abs(n).toString();\n    let sum = 0;\n    for (let i = 1; i < s.length; i++) {\n        sum += s[i] - '0';\n    }\n    if (n > 0) {\n        sum +=
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int num = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > 10) {\n            string w = to_string(nums[i]);\n            if (w[0] % 2 == 1 && w[w.length() - 1] % 2 == 1) {\n                num++;\n            }\n        }\n    }\n    return num;\n}\n\nint specialFilterEmpty() {\n    return 0;\n}\n\nint main() {\n    // Test cases\n    int result = specialFilter({5, -2, 1, -5});\n    if (result != 0) {\n        cout << "Test case 1 failed" << endl;\n        return 1;\n    }\n\n    result = specialFilter({15, -73, 14, -15});\n    if (result != 1) {\n        cout << "Test case 2 failed" << endl;\n        return 1;\n    }\n\n    result = specialFilter({33, -2, -3, 45, 21, 109});\n    if (result != 2) {\n        cout << "Test case 3 failed" << endl;\n        return 1;\n    }\n\n    result = specialFilter({43, -12, 93, 125, 121, 109});\n    if (result != 4) {\n        cout << "Test case 4 failed" << endl;\n        return 1;\n    }\n\n    result = specialFilter({71, -2, -33, 75, 21, 19});\n    if (result != 3) {\n        cout << "Test case 5 failed" << endl;\n        return 1;\n    }\n\n    result = specialFilter({1});\n    if (result != 0) {\n        cout << "Test case 6 failed" << endl;\n        return 1;\n    }\n\n    // Handle empty array case separately\n    result = specialFilterEmpty();\n    if (result != 0) {\n        cout << "Test case 7 failed" << endl;\n        return 1;\n    }\n\n    cout << "All test cases passed" << endl;\n    return 0;\n}\n```\n\n### 2.1.2. 整数数组中的最大数字\n\n```\n[INST] Translate this Fortran code to C++:\n\nmodule max_number_module\n    implicit none\n    contains\n\n    function maxNumber(nums) result(num)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: num\n        integer :: i\n\n        num = nums(1)\n        do i = 2, size(nums)\n            if (nums(i) > num) then\n                num = nums(i)\n            end if\n        end do\n    end function maxNumber\n\n    function maxNumberEmpty() result(num)\n        implicit none\n        integer :: num\n        num = 0\n    end function maxNumberEmpty\n\nend module max_number_module\n\nprogram max_number_program\n    use max_number_module\n    implicit none\n    integer :: result\n\n    ! Test cases\n    result = maxNumber([1, 2, 3, 4, 5])\n    if (result /= 5) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n    if (result /= 10) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 4 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 5 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 6 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 7 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 8 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 9 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 10 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 11 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 12 failed"\n        call exit(1)\n    end if\n\n    result = maxNumber([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10])\n    if (result /= 10) then\n        write(*,*) "Test case 13 failed"\n        call exit(1)\n    end if
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint get_matrix_triples(int n) {\n  vector<int> a(n);\n  vector<vector<int>> sum(n+1, vector<int>(3, 0));\n  vector<vector<int>> sum2(n+1, vector<int>(3, 0));\n\n  // Initialize arrays\n  for (int i = 0; i < n; i++) {\n    a[i] = (i*i - i + 1) % 3;\n    sum[i+1][0] = sum[i][0];\n    sum[i+1][a[i]+1] = sum[i+1][a[i]+1] + 1;\n  }\n\n  // Compute sums for times = 1 and 2\n  for (int times = 1; times <= 2; times++) {\n    for (int i = 0; i < n; i++) {\n      sum2[i+1][0] = sum2[i][0];\n      for (int j = 0; j < 3; j++) {\n        sum2[i+1][(a[i] + j) % 3 + 1] = sum2[i+1][(a[i] + j) % 3 + 1] + sum[i][j+1];\n      }\n    }\n    sum = sum2;\n    sum2 = vector<vector<int>>(n+1, vector<int>(3, 0));\n  }\n\n  return sum[n+1][0];\n}\n\nint main() {\n  int n, result;\n\n  // Test cases\n  result = get_matrix_triples(5);\n  if (result != 1) {\n    cout << "Assertion failed: get_matrix_triples(5) == 1" << endl;\n    return 1;\n  }\n\n  result = get_matrix_triples(6);\n  if (result != 4) {\n    cout << "Assertion failed: get_matrix_triples(6) == 4" << endl;\n    return 1;\n  }\n\n  result = get_matrix_triples(10);\n  if (result != 36) {\n    cout << "Assertion failed: get_matrix_triples(10) == 36" << endl;\n    return 1;\n  }\n\n  result = get_matrix_triples(100);\n  if (result != 53361) {\n    cout << "Assertion failed: get_matrix_triples(100) == 53361" << endl;\n    return 1;\n  }\n\n  return 0;\n}\n\n[C#]\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static int GetMatrixTriples(int n)\n    {\n        var a = new int[n];\n        var sum = new int[n + 1, 3];\n        var sum2 = new int[n + 1, 3];\n\n        // Initialize arrays\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = (i * i - i + 1) % 3;\n            sum[i + 1, 0] = sum[i, 0];\n            sum[i + 1, a[i] + 1] = sum[i + 1, a[i] + 1] + 1;\n        }\n\n        // Compute sums for times = 1 and 2\n        for (int times = 1; times <= 2; times++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                sum2[i + 1, 0] = sum2[i, 0];\n                for (int j = 0; j < 3; j++)\n                {\n                    sum2[i + 1, (a[i] + j) % 3 + 1] = sum2[i + 1, (a[i] + j) % 3 + 1] + sum[i, j + 1];\n                }\n            }\n            sum = sum2;\n            sum2 = new int[n + 1, 3];\n        }\n\n        return sum[n + 1, 0];\n    }\n\n    static void Main(string[] args)\n    {\n        int n, result;\n\n        // Test cases\n        result = GetMatrixTriples(5);\n        if (result != 1)\n        {\n            Console.WriteLine("Assertion failed: GetMatrixTriples(5) == 1");\n            return;\n        }\n\n        result = GetMatrixTriples(6);\n        if (result != 4)\n        {\n            Console.WriteLine("Assertion failed: GetMatrixTriples(6) == 4");\n            return;\n        }\n\n        result = GetMatrixTriples(10);\n        if (result != 36)\n        {\n            Console.WriteLine("Assertion failed: GetMatrixTriples(10) == 36");\n            return;\n        }\n\n        result = GetMatrixTriples(100);\n        if (result != 53361)\n        {\n            Console.WriteLine("Assertion failed: GetMatrixTriples(100) == 53361");\n            return;\n        }\n    }\n}\n\n[Java]\nimport java.util.Arrays;\n\nclass Program {\n    static int getMatrixTriples(int n) {\n        int[] a = new int[n];\n        int[][] sum = new int[n + 1][3];\n        int[][] sum2 = new int[n + 1][3];\n\n        // Initialize arrays\n        for (int i = 0; i < n; i++) {\n            a[i] = (i * i - i + 1) % 3;\n            sum[i + 1][0] = sum[i][0];\n            sum[i + 1][a[i] + 1] = sum[i + 1][a[i] + 1] + 1;\n        }\n\n        // Compute sums for times = 1 and 2\n        for (int times = 1; times <= 2; times++) {\n            for (int i = 0; i < n; i++) {\n                sum2[i + 1][0] = sum2[i][0];\n                for (int j = 0; j < 3; j++) {\n                    sum2[i + 1][(a[i] + j) % 3 + 1] = sum2[i + 1][(a[i] + j) % 3 + 1] + sum[i][j + 1];\n                }\n            }\n            sum = sum2;\n            sum2 = new int[n + 1][3];\n        }\n\n        return sum[n + 1][0];\n    }\n\n    public static void main(String[] args) {\n        int n, result;\n\n        // Test cases\n        result = getMatrixTriples(5);\n        if (result != 1) {\n            System.out.println("Assertion failed: getMatrixTriples(5) == 1");\n            return;\n        }\n\n        result = getMatrixTriples(6);\n        if (result != 4) {\n            System.out.println("Assertion failed: getMatrixTriples(6) == 4");\n            return;\n        }\n\n        result = getMatrixTriples(10);\n        if (result != 36) {\n            System.out.println("Assertion failed: getMatrixTriples(10) == 36");\n            return;\n        }\n\n        result = getMatrixTriples(100);\n        if (result != 53361) {\n            System.out.println("Assertion failed: getMatrixTriples(100) == 53361");\n            return;\n        }\n    }\n}\n\n[JavaScript]\nfunction getMatrixTriples(n) {\n    var a = new Array(n);\n    var sum = new Array(n + 1);\n    var sum2 = new Array(n + 1);\n\n    // Initialize arrays\n    for (var i = 0; i < n; i++) {\n        a[i] = (i * i - i + 1) % 3;\n        sum[i + 1] = sum[
\n\n[EXPECTED]\n[SYNTEST]\n[RUNTIME]\n[OUTPUT]\nAll assertions passed.\n[/EXPECTED]\n[/SYNTEST]\n[/RUNTIME]\n[/OUTPUT]\n\n[SYNTEST-PARSE]\n[AST]\n[COMMENT]\n<AST>\n    <Node type="Program">\n        <Node type="Function">\n            <Node type="Name">\n                x_or_y\n            </Node>\n            <Node type="ArgList">\n                <Node type="Name">\n                    n\n                </Node>\n                <Node type="Name">\n                    x\n                </Node>\n                <Node type="Name">\n                    y\n                </Node>\n            </Node>\n            <Node type="Body">\n                <Node type="Block">\n                    <Node type="Decl">\n                        <Node type="Name">\n                            isp\n                        </Node>\n                        <Node type="TypeSpec">\n                            <Node type="Name">\n                                logical\n                            </Node>\n                        </Node>\n                        <Node type="Init">\n                            <Node type="BinaryOp">\n                                <Node type="Name">\n                                    n\n                                </Node>\n                                <Node type="Name">\n                                    < / >\n                                </Node>\n                                <Node type="Number">\n                                    2\n                                </Node>\n                            </Node>\n                        </Node>\n                    </Node>\n                    <Node type="If">\n                        <Node type="BinaryOp">\n                            <Node type="Name">\n                                n\n                            </Node>\n                            <Node type="Name">\n                                < < >\n                            </Node>\n                            <Node type="Number">\n                                2\n                            </Node>\n                        </Node>\n                        <Node type="Block">\n                            <Node type="Assign">\n                                <Node type="Name">\n                                    isp\n                                </Node>\n                                <Node type="Name">\n                                    .false.\n                                </Node>\n                            </Node>\n                        </Node>\n                    </Node>\n                    <Node type="Do">\n                        <Node type="Name">\n                            i\n                        </Node>\n                        <Node type="BinaryOp">\n                            <Node type="Name">\n                                2\n                            </Node>\n                            <Node type="Name">\n                                < < >\n                            </Node>\n                            <Node type="BinaryOp">\n                                <Node type="Name">\n                                    n\n                                </Node>\n                                <Node type="Name">\n                                    < / >\n                                </Node>\n                                <Node type="BinaryOp">\n                                    <Node type="Name">\n                                        i\n                                    </Node>\n                                    <Node type="Name">\n                                        < * >\n                                    </Node>\n                                    <Node type="Number">\n                                        2\n                                    </Node>\n                                </Node>\n                            </Node>\n                        </Node>\n                        <Node type="Block">\n                            <Node type="If">\n                                <Node type="BinaryOp">\n                                    <Node type="Name">\n                                        n\n                                    </Node>\n                                    <Node type="Name">\n                                        < % >\n                                    </Node>\n                                    <Node type="BinaryOp">\n                                        <Node type="Name">\n                                            i\n                                        </Node>\n                                        <Node type="Name">\n                                            < * >\n                                        </Node>\n                                        <Node type="Number">\n                                            2\n                                        </Node>\n                                    </Node>\n                                </Node>\n                                <Node type="Block">\n                                    <Node type="Assign">\n                                        <Node type="Name">\n                                            isp\n                                        </Node>\n                                        <Node type="Name">\n                                            .false.\n                                        </Node>\n                                    </Node>\n                                    <Node type="Exit">\n                                    </Node>\n                                </Node>\n                            </Node>\n                        </Node>\n                    </Node>\n                    <Node type="If">\n                        <Node type="Name">\n                            isp\n                        </Node>\n                        <Node type="Block">\n                            <Node type="Return">\n                                <Node type="Name">\n                                    x\n                                </Node>\n                            </Node>\n                        </Node>\n                        <Node type="Block">\n                            <Node type="Return">\n                                <Node type="Name">\n                                    y\n                                </Node>\n                            </Node>\n                        </Node>\n                    </Node>\n                </Node>\n            </Node>\n        </Node>\n    </Node>\n</AST>\n[/COMMENT]\n[/AST]\n[/SYNTEST-PARSE]\n\n[SYNTEST-EMIT]\n[CODE]\n[COMMENT]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint x_or_y(int n, int x, int y)\n{\n    bool isp = true;\n    if (n < 2) isp = false;\n    for (int i = 2; i <= std::sqrt(n); i++) {\n        if (n % i == 0) {\n            isp = false;\n            break;\n        }\n    }\n\n    if (isp) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nint main()\n{\n    if (x_or_y(7, 34, 12) != 34) {\n        std::cout << "Assertion failed: x_or_y(7, 34, 12) == 34" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(15, 8, 5) != 5) {\n        std::cout << "Assertion failed: x_or_y(15, 8, 5) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3, 33, 5212) != 33) {\n        std::cout << "Assertion failed: x_or_y(3, 33, 5212) == 33" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1259, 3, 52) != 3) {\n        std::cout << "Assertion failed: x_or_y(1259, 3, 52) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(7919, -1, 12) != -1) {\n        std::cout << "Assertion failed: x_or_y(7919, -1, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3609, 1245, 583) != 583) {\n        std::cout << "Assertion failed: x_or_y(3609, 1245, 583) == 583" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(91, 56, 129) != 129) {\n        std::cout << "Assertion failed: x_or_y(91, 56, 129) == 129" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(6, 34, 1234) != 1234) {\n        std::cout << "Assertion failed: x_or_y(6, 34, 1234) == 1234" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1, 2, 0) != 0) {\n        std::cout << "Assertion
\n\n[C++]\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    vector<double> lst;\n    double odd_sum = 0;\n    double result;\n\n    // Test cases\n    assert(double_the_difference({0.0}) == 0);\n    assert(double_the_difference({5.0, 4.0}) == 25);\n    assert(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert(double_the_difference({-1.0, -2.0, 8.0}) == 0);\n    assert(double_the_difference({0.2, 3.0, 5.0}) == 34);\n\n    // Initialize variables\n    lst.resize(100);\n    lst.assign(100, 0.0);\n\n    // Fill the array and calculate odd_sum\n    for (int i = -99; i <= 99; i += 2) {\n        lst[(i+101)/2] = i;\n        if (i > 0 && i % 2 == 1) odd_sum += i*i;\n    }\n\n    // Check the final assertion\n    result = double_the_difference(lst);\n    assert(result == odd_sum);\n\n    return 0;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\ndouble double_the_difference(vector<double> lst) {\n    double sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        double rounded_value = round(lst[i]);\n        if (abs(lst[i] - rounded_value) < 1e-4) {\n            if (lst[i] > 0 && int(rounded_value) % 2 == 1) {\n                sum += int(rounded_value) * int(rounded_value);\n            }\n        }\n    }\n    return sum;\n}\n\n[C]\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_SIZE 100\n\nint main() {\n    double lst[MAX_SIZE];\n    double odd_sum = 0;\n    double result;\n    int i;\n\n    // Test cases\n    assert(double_the_difference({0.0}) == 0);\n    assert(double_the_difference({5.0, 4.0}) == 25);\n    assert(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert(double_the_difference({-1.0, -2.0, 8.0}) == 0);\n    assert(double_the_difference({0.2, 3.0, 5.0}) == 34);\n\n    // Initialize variables\n    for (i = 0; i < MAX_SIZE; i++) {\n        lst[i] = 0.0;\n    }\n\n    // Fill the array and calculate odd_sum\n    for (i = -99; i <= 99; i += 2) {\n        lst[(i+101)/2] = i;\n        if (i > 0 && i % 2 == 1) odd_sum += i*i;\n    }\n\n    // Check the final assertion\n    result = double_the_difference(lst);\n    assert(result == odd_sum);\n\n    return 0;\n}\n\nvoid assert(int condition) {\n    if (!condition) {\n        printf("Assertion failed\n");\n        exit(1);\n    }\n}\n\ndouble double_the_difference(double lst[]) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < MAX_SIZE; i++) {\n        double rounded_value = round(lst[i]);\n        if (abs(lst[i] - rounded_value) < 1e-4) {\n            if (lst[i] > 0 && int(rounded_value) % 2 == 1) {\n                sum += int(rounded_value) * int(rounded_value);\n            }\n        }\n    }\n    return sum;\n}\n\n[Python]\ndef double_the_difference(lst):\n    sum = 0\n    for i in range(len(lst)):\n        rounded_value = round(lst[i])\n        if abs(lst[i] - rounded_value) < 1e-4:\n            if lst[i] > 0 and int(rounded_value) % 2 == 1:\n                sum += int(rounded_value) * int(rounded_value)\n    return sum\n\ndef main():\n    lst = [0.0]\n    odd_sum = 0\n    result = 0\n\n    # Test cases\n    assert(double_the_difference([0.0]) == 0)\n    assert(double_the_difference([5.0, 4.0]) == 25)\n    assert(double_the_difference([0.1, 0.2, 0.3]) == 0)\n    assert(double_the_difference([-10.0, -20.0, -30.0]) == 0)\n    assert(double_the_difference([-1.0, -2.0, 8.0]) == 0)\n    assert(double_the_difference([0.2, 3.0, 5.0]) == 34)\n\n    # Initialize variables\n    lst = [0.0 for i in range(100)]\n\n    # Fill the array and calculate odd_sum\n    for i in range(-99, 99, 2):\n        lst[(i+101)//2] = i\n        if i > 0 and i % 2 == 1:\n            odd_sum += i*i\n\n    # Check the final assertion\n    result = double_the_difference(lst)\n    assert(result == odd_sum)\n\ndef assert(condition):\n    if not condition:\n        print("Assertion failed")\n        exit(1)\n\nif __name__ == "__main__":\n    main()\n\n[Java]\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] lst = {0.0};\n        double odd_sum = 0;\n        double result = 0;\n\n        // Test cases\n        assert(doubleTheDifference(lst) == 0);\n        lst = new double[] {5.0, 4.0};\n        assert(doubleTheDifference(lst) == 25);\n        lst = new double[] {0.1, 0.2, 0.3};\n        assert(doubleTheDifference(lst) == 0);\n        lst = new double[] {-10.0, -20.0, -30.0};\n        assert(doubleTheDifference(lst) == 0);\n        lst = new double[] {-1.0, -2.0, 8.0};\n        assert(doubleTheDifference(lst) == 0);\n        lst = new double[] {0.2, 3.0, 5.0};\n        assert(doubleTheDifference(lst) == 34);\n\n        // Initialize variables\n        lst = new double[100];\n        Arrays.fill(lst, 0.0);\n\n        // Fill the array and calculate odd_sum\n        for (int i = -99; i <= 99; i += 2) {\n            lst[(i+101)/2] = i;\n            if (i > 0 && i % 2 == 1) odd_sum += i*i;\n        }\n\n        // Check the final assertion\n        result = doubleTheDifference(lst);\n        assert(result == odd_sum);\n    }\n\n    public static double doubleTheDifference
\n\n[C++]\n#include <iostream>\n#include <string>\n\nbool cycpattern_check(const std::string& a, const std::string& b)\n{\n    for (int i = 0; i < b.length(); i++) {\n        std::string rotate = b.substr(i+1) + b.substr(0, i);\n        // Debugging print statement\n        // std::cout << "Checking rotation: " << rotate << std::endl;\n        if (a.find(rotate) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    if (!cycpattern_check("xyzw", "xyw")) {\n        std::cout << "Assertion failed: cycpattern_check('xyzw', 'xyw') == false" << std::endl;\n        return 1;\n    }\n    if (!cycpattern_check("yello", "ell")) {\n        std::cout << "Assertion failed: cycpattern_check('yello', 'ell') == true" << std::endl;\n        return 1;\n    }\n    if (!cycpattern_check("whattup", "ptut")) {\n        std::cout << "Assertion failed: cycpattern_check('whattup', 'ptut') == false" << std::endl;\n        return 1;\n    }\n    if (!cycpattern_check("efef", "fee")) {\n        std::cout << "Assertion failed: cycpattern_check('efef', 'fee') == true" << std::endl;\n        return 1;\n    }\n    if (!cycpattern_check("abab", "aabb")) {\n        std::cout << "Assertion failed: cycpattern_check('abab', 'aabb') == false" << std::endl;\n        return 1;\n    }\n    if (!cycpattern_check("winemtt", "tinem")) {\n        std::cout << "Assertion failed: cycpattern_check('winemtt', 'tinem') == true" << std::endl;\n        return 1;\n    }\n    return 0;\n}\n\n[C#]\nusing System;\n\nclass CycPatternCheck\n{\n    static void Main()\n    {\n        if (!cycpattern_check("xyzw", "xyw")) {\n            Console.WriteLine("Assertion failed: cycpattern_check('xyzw', 'xyw') == false");\n            Environment.Exit(1);\n        }\n        if (!cycpattern_check("yello", "ell")) {\n            Console.WriteLine("Assertion failed: cycpattern_check('yello', 'ell') == true");\n            Environment.Exit(1);\n        }\n        if (!cycpattern_check("whattup", "ptut")) {\n            Console.WriteLine("Assertion failed: cycpattern_check('whattup', 'ptut') == false");\n            Environment.Exit(1);\n        }\n        if (!cycpattern_check("efef", "fee")) {\n            Console.WriteLine("Assertion failed: cycpattern_check('efef', 'fee') == true");\n            Environment.Exit(1);\n        }\n        if (!cycpattern_check("abab", "aabb")) {\n            Console.WriteLine("Assertion failed: cycpattern_check('abab', 'aabb') == false");\n            Environment.Exit(1);\n        }\n        if (!cycpattern_check("winemtt", "tinem")) {\n            Console.WriteLine("Assertion failed: cycpattern_check('winemtt', 'tinem') == true");\n            Environment.Exit(1);\n        }\n    }\n\n    static bool cycpattern_check(string a, string b)\n    {\n        for (int i = 0; i < b.Length; i++) {\n            string rotate = b.Substring(i+1) + b.Substring(0, i);\n            // Debugging print statement\n            // Console.WriteLine("Checking rotation: " + rotate);\n            if (a.IndexOf(rotate) != -1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n[Python]\ndef cycpattern_check(a, b):\n    for i in range(len(b)):\n        rotate = b[i+1:] + b[:i]\n        # Debugging print statement\n        # print("Checking rotation: " + rotate)\n        if rotate in a:\n            return True\n    return False\n\ndef main():\n    if not cycpattern_check("xyzw", "xyw"):\n        print("Assertion failed: cycpattern_check('xyzw', 'xyw') == false")\n        exit(1)\n    if not cycpattern_check("yello", "ell"):\n        print("Assertion failed: cycpattern_check('yello', 'ell') == true")\n        exit(1)\n    if not cycpattern_check("whattup", "ptut"):\n        print("Assertion failed: cycpattern_check('whattup', 'ptut') == false")\n        exit(1)\n    if not cycpattern_check("efef", "fee"):\n        print("Assertion failed: cycpattern_check('efef', 'fee') == true")\n        exit(1)\n    if not cycpattern_check("abab", "aabb"):\n        print("Assertion failed: cycpattern_check('abab', 'aabb') == false")\n        exit(1)\n    if not cycpattern_check("winemtt", "tinem"):\n        print("Assertion failed: cycpattern_check('winemtt', 'tinem') == true")\n        exit(1)\n\nif __name__ == "__main__":\n    main()\n\n[Ruby]\ndef cycpattern_check(a, b)\n    b.length.times do |i|\n        rotate = b[i+1..-1] + b[0..i]\n        # Debugging print statement\n        # puts "Checking rotation: #{rotate}"\n        return true if a.include?(rotate)\n    end\n    false\nend\n\ndef main\n    if !cycpattern_check("xyzw", "xyw")\n        puts "Assertion failed: cycpattern_check('xyzw', 'xyw') == false"\n        exit(1)\n    end\n    if !cycpattern_check("yello", "ell")\n        puts "Assertion failed: cycpattern_check('yello', 'ell') == true"\n        exit(1)\n    end\n    if !cycpattern_check("whattup", "ptut")\n        puts "Assertion failed: cycpattern_check('whattup', 'ptut') == false"\n        exit(1)\n    end\n    if !cycpattern_check("efef", "fee")\n        puts "Assertion failed: cycpattern_check('efef', 'fee') == true"\n        exit(1)\n    end\n    if !cycpattern_check("abab", "aabb")\n        puts "Assertion failed: cycpattern_check('abab', 'aabb') == false"\n        exit(1)\n    end\n    if !cycpattern_check("winemtt", "tinem")\n        puts "Assertion failed: cycpattern_check('winemtt', 'tinem') == true"\n        exit(1)\n    end\nend\n\nmain\n\n[JavaScript]\nfunction cycpattern_check(a, b) {\n    for (let i = 0; i < b.length; i++) {\n        let rotate = b.slice(i+1) + b.slice(0, i);\n        // Debugging print statement\n        // console.log("Checking rotation: " + rotate);\n        if (a.includes(rotate)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction main() {\n    if (!cycpattern_check("xyzw", "xyw")) {\n        console.log("Assertion failed: cycpattern_check('xyzw', 'xyw') == false");\n        process.exit(1);\n    }\n    if (!cycpattern_check("yello", "ell")) {\n        console.log("Assertion failed: cycpattern_check('yello', 'ell') == true");\n        process.exit(1);\n    }\n    if (!cycpattern_check("whattup", "ptut")) {\n        console.log("Assertion failed: cycpattern_check('whattup', 'ptut') ==
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    string w = to_string(abs(num));\n    int n1 = 0, n2 = 0;\n\n    for (char c : w) {\n        if (c % 2 == 1) {\n            n1++;\n        } else {\n            n2++;\n        }\n    }\n\n    return {n2, n1};\n}\n\nint main() {\n    vector<int> result, expected;\n\n    // Test cases\n    result = even_odd_count(7);\n    expected = {0, 1};\n    assert(result == expected);\n\n    result = even_odd_count(-78);\n    expected = {1, 1};\n    assert(result == expected);\n\n    result = even_odd_count(3452);\n    expected = {2, 2};\n    assert(result == expected);\n\n    result = even_odd_count(346211);\n    expected = {3, 3};\n    assert(result == expected);\n\n    result = even_odd_count(-345821);\n    expected = {3, 3};\n    assert(result == expected);\n\n    result = even_odd_count(-2);\n    expected = {1, 0};\n    assert(result == expected);\n\n    result = even_odd_count(-45347);\n    expected = {2, 3};\n    assert(result == expected);\n\n    result = even_odd_count(0);\n    expected = {1, 0};\n    assert(result == expected);\n\n    return 0;\n}\n\nvoid assert(vector<int> result, vector<int> expected) {\n    if (result != expected) {\n        cout << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\n[C#]\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        // Test cases\n        Assert(EvenOddCount(7), new int[] { 0, 1 });\n        Assert(EvenOddCount(-78), new int[] { 1, 1 });\n        Assert(EvenOddCount(3452), new int[] { 2, 2 });\n        Assert(EvenOddCount(346211), new int[] { 3, 3 });\n        Assert(EvenOddCount(-345821), new int[] { 3, 3 });\n        Assert(EvenOddCount(-2), new int[] { 1, 0 });\n        Assert(EvenOddCount(-45347), new int[] { 2, 3 });\n        Assert(EvenOddCount(0), new int[] { 1, 0 });\n    }\n\n    static int[] EvenOddCount(int num)\n    {\n        string w = Math.Abs(num).ToString();\n        int n1 = 0, n2 = 0;\n\n        foreach (char c in w)\n        {\n            if (c % 2 == 1)\n            {\n                n1++;\n            }\n            else\n            {\n                n2++;\n            }\n        }\n\n        return new int[] { n2, n1 };\n    }\n\n    static void Assert(int[] result, int[] expected)\n    {\n        if (!result.SequenceEqual(expected))\n        {\n            Console.WriteLine("Assertion failed");\n            Environment.Exit(1);\n        }\n    }\n}\n\n[Python]\ndef even_odd_count(num):\n    w = str(abs(num))\n    n1 = 0\n    n2 = 0\n\n    for c in w:\n        if c % 2 == 1:\n            n1 += 1\n        else:\n            n2 += 1\n\n    return n2, n1\n\ndef main():\n    # Test cases\n    assert even_odd_count(7) == (0, 1)\n    assert even_odd_count(-78) == (1, 1)\n    assert even_odd_count(3452) == (2, 2)\n    assert even_odd_count(346211) == (3, 3)\n    assert even_odd_count(-345821) == (3, 3)\n    assert even_odd_count(-2) == (1, 0)\n    assert even_odd_count(-45347) == (2, 3)\n    assert even_odd_count(0) == (1, 0)\n\ndef assert(result, expected):\n    if result != expected:\n        print("Assertion failed")\n        exit(1)\n\nif __name__ == "__main__":\n    main()\n\n[Java]\nimport java.util.Arrays;\n\nclass Main {\n    public static void main(String[] args) {\n        // Test cases\n        assert(evenOddCount(7), new int[] { 0, 1 });\n        assert(evenOddCount(-78), new int[] { 1, 1 });\n        assert(evenOddCount(3452), new int[] { 2, 2 });\n        assert(evenOddCount(346211), new int[] { 3, 3 });\n        assert(evenOddCount(-345821), new int[] { 3, 3 });\n        assert(evenOddCount(-2), new int[] { 1, 0 });\n        assert(evenOddCount(-45347), new int[] { 2, 3 });\n        assert(evenOddCount(0), new int[] { 1, 0 });\n    }\n\n    public static int[] evenOddCount(int num) {\n        String w = Integer.toString(Math.abs(num));\n        int n1 = 0, n2 = 0;\n\n        for (char c : w.toCharArray()) {\n            if (c % 2 == 1) {\n                n1++;\n            } else {\n                n2++;\n            }\n        }\n\n        return new int[] { n2, n1 };\n    }\n\n    public static void assert(int[] result, int[] expected) {\n        if (!Arrays.equals(result, expected)) {\n            System.out.println("Assertion failed");\n            System.exit(1);\n        }\n    }\n}\n\n[JavaScript]\nfunction evenOddCount(num) {\n    const w = Math.abs(num).toString();\n    let n1 = 0, n2 = 0;\n\n    for (const c of w) {\n        if (c % 2 == 1) {\n            n1++;\n        } else {\n            n2++;\n        }\n    }\n\n    return [n2, n1];\n}\n\nfunction main() {\n    // Test cases\n    assert(evenOddCount(7), [0, 1]);\n    assert(evenOddCount(-78), [1, 1]);\n    assert(evenOddCount(3452), [2, 2]);\n    assert(evenOddCount(346211), [3, 3]);\n    assert(evenOddCount(-345821), [3, 3]);\n    assert(evenOddCount(-2), [1, 0]);\n    assert(evenOddCount(-45347), [2, 3]);\n    assert(evenOddCount(0), [1, 0]);\n}\n\nfunction assert(result, expected) {\n    if (result.length != expected.length) {\n        console.log("Assertion failed");\n        process.exit(1);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] != expected[i]) {\n            console.log("Assertion failed");\n            process.exit(1);\n        }\n    }\n}\n\nif (import.meta.main) {\n    main();\n}\n\n[PHP]\nfunction evenOddCount(int $num): array\n{\n    $w = abs($num);\n    $n1 = 0;\n    $n2 = 0;\n\n    while ($w > 0) {\n        $c = $w % 10;\n        if ($c
\n\n[C++]\n#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nstring int_to_mini_romank(int number) {\n    vector<string> rep = {"m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "};\n    vector<int> num = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    string current = "";\n    int pos = 1;\n    int temp_number = number;\n\n    while (temp_number > 0) {\n        while (temp_number >= num[pos]) {\n            current += rep[pos];\n            temp_number -= num[pos];\n        }\n        if (temp_number > 0) pos++;\n    }\n\n    return current;\n}\n\nint main() {\n    cout << int_to_mini_romank(19) << endl;\n    cout << int_to_mini_romank(152) << endl;\n    cout << int_to_mini_romank(251) << endl;\n    cout << int_to_mini_romank(426) << endl;\n    cout << int_to_mini_romank(500) << endl;\n    cout << int_to_mini_romank(1) << endl;\n    cout << int_to_mini_romank(4) << endl;\n    cout << int_to_mini_romank(43) << endl;\n    cout << int_to_mini_romank(90) << endl;\n    cout << int_to_mini_romank(94) << endl;\n    cout << int_to_mini_romank(532) << endl;\n    cout << int_to_mini_romank(900) << endl;\n    cout << int_to_mini_romank(994) << endl;\n    cout << int_to_mini_romank(1000) << endl;\n}\n\n[C#]\nusing System;\n\npublic static class Program {\n    public static string IntToMiniRoman(int number) {\n        string[] rep = {"m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "};\n        int[] num = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string current = "";\n        int pos = 1;\n        int temp_number = number;\n\n        while (temp_number > 0) {\n            while (temp_number >= num[pos]) {\n                current += rep[pos];\n                temp_number -= num[pos];\n            }\n            if (temp_number > 0) pos++;\n        }\n\n        return current;\n    }\n\n    public static void Main() {\n        Console.WriteLine(IntToMiniRoman(19));\n        Console.WriteLine(IntToMiniRoman(152));\n        Console.WriteLine(IntToMiniRoman(251));\n        Console.WriteLine(IntToMiniRoman(426));\n        Console.WriteLine(IntToMiniRoman(500));\n        Console.WriteLine(IntToMiniRoman(1));\n        Console.WriteLine(IntToMiniRoman(4));\n        Console.WriteLine(IntToMiniRoman(43));\n        Console.WriteLine(IntToMiniRoman(90));\n        Console.WriteLine(IntToMiniRoman(94));\n        Console.WriteLine(IntToMiniRoman(532));\n        Console.WriteLine(IntToMiniRoman(900));\n        Console.WriteLine(IntToMiniRoman(994));\n        Console.WriteLine(IntToMiniRoman(1000));\n    }\n}\n\n[Python]\ndef int_to_mini_romank(number):\n    rep = ["m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "]\n    num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    current = ""\n    pos = 1\n    temp_number = number\n\n    while temp_number > 0:\n        while temp_number >= num[pos]:\n            current += rep[pos]\n            temp_number -= num[pos]\n        if temp_number > 0: pos += 1\n\n    return current\n\nprint(int_to_mini_romank(19))\nprint(int_to_mini_romank(152))\nprint(int_to_mini_romank(251))\nprint(int_to_mini_romank(426))\nprint(int_to_mini_romank(500))\nprint(int_to_mini_romank(1))\nprint(int_to_mini_romank(4))\nprint(int_to_mini_romank(43))\nprint(int_to_mini_romank(90))\nprint(int_to_mini_romank(94))\nprint(int_to_mini_romank(532))\nprint(int_to_mini_romank(900))\nprint(int_to_mini_romank(994))\nprint(int_to_mini_romank(1000))\n\n[JavaScript]\nfunction int_to_mini_romank(number) {\n    var rep = ["m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "];\n    var num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    var current = "";\n    var pos = 1;\n    var temp_number = number;\n\n    while (temp_number > 0) {\n        while (temp_number >= num[pos]) {\n            current += rep[pos];\n            temp_number -= num[pos];\n        }\n        if (temp_number > 0) pos++;\n    }\n\n    return current;\n}\n\nconsole.log(int_to_mini_romank(19));\nconsole.log(int_to_mini_romank(152));\nconsole.log(int_to_mini_romank(251));\nconsole.log(int_to_mini_romank(426));\nconsole.log(int_to_mini_romank(500));\nconsole.log(int_to_mini_romank(1));\nconsole.log(int_to_mini_romank(4));\nconsole.log(int_to_mini_romank(43));\nconsole.log(int_to_mini_romank(90));\nconsole.log(int_to_mini_romank(94));\nconsole.log(int_to_mini_romank(532));\nconsole.log(int_to_mini_romank(900));\nconsole.log(int_to_mini_romank(994));\nconsole.log(int_to_mini_romank(1000));\n\n[PHP]\nfunction int_to_mini_romank($number) {\n    $rep = ["m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "];\n    $num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,
\n\n[SOLUTION]\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nint main() {\n  using namespace std;\n\n  // Function declaration\n  bool right_angle_triangle(double, double, double);\n\n  // Assertions\n  if (!right_angle_triangle(3.0, 4.0, 5.0)) {\n    cout << "Assertion failed: right_angle_triangle(3, 4, 5) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(1.0, 2.0, 3.0)) {\n    cout << "Assertion failed: right_angle_triangle(1, 2, 3) == false" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(10.0, 6.0, 8.0)) {\n    cout << "Assertion failed: right_angle_triangle(10, 6, 8) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(2.0, 2.0, 2.0)) {\n    cout << "Assertion failed: right_angle_triangle(2, 2, 2) == false" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(7.0, 24.0, 25.0)) {\n    cout << "Assertion failed: right_angle_triangle(7, 24, 25) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(10.0, 5.0, 7.0)) {\n    cout << "Assertion failed: right_angle_triangle(10, 5, 7) == false" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(5.0, 12.0, 13.0)) {\n    cout << "Assertion failed: right_angle_triangle(5, 12, 13) == true" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(15.0, 8.0, 17.0)) {\n    cout << "Assertion failed: right_angle_triangle(15, 8, 17) == true" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(48.0, 55.0, 73.0)) {\n    cout << "Assertion failed: right_angle_triangle(48, 55, 73) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(1.0, 1.0, 1.0)) {\n    cout << "Assertion failed: right_angle_triangle(1, 1, 1) == false" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(2.0, 2.0, 10.0)) {\n    cout << "Assertion failed: right_angle_triangle(2, 2, 10) == false" << endl;\n    exit(1);\n  }\n\n  return 0;\n}\n\nbool right_angle_triangle(double a, double b, double c) {\n  double epsilon = 1.0e-4;\n\n  if (abs(a*a + b*b - c*c) < epsilon || abs(a*a + c*c - b*b) < epsilon || abs(b*b + c*c - a*a) < epsilon) {\n    return true;\n  } else {\n    return false;\n  }\n}\n[/SOLUTION]\n\n[CHECK]\n\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  bool right_angle_triangle(double, double, double);\n\n  if (!right_angle_triangle(3.0, 4.0, 5.0)) {\n    cout << "Assertion failed: right_angle_triangle(3, 4, 5) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(1.0, 2.0, 3.0)) {\n    cout << "Assertion failed: right_angle_triangle(1, 2, 3) == false" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(10.0, 6.0, 8.0)) {\n    cout << "Assertion failed: right_angle_triangle(10, 6, 8) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(2.0, 2.0, 2.0)) {\n    cout << "Assertion failed: right_angle_triangle(2, 2, 2) == false" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(7.0, 24.0, 25.0)) {\n    cout << "Assertion failed: right_angle_triangle(7, 24, 25) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(10.0, 5.0, 7.0)) {\n    cout << "Assertion failed: right_angle_triangle(10, 5, 7) == false" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(5.0, 12.0, 13.0)) {\n    cout << "Assertion failed: right_angle_triangle(5, 12, 13) == true" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(15.0, 8.0, 17.0)) {\n    cout << "Assertion failed: right_angle_triangle(15, 8, 17) == true" << endl;\n    exit(1);\n  }\n\n  if (!right_angle_triangle(48.0, 55.0, 73.0)) {\n    cout << "Assertion failed: right_angle_triangle(48, 55, 73) == true" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(1.0, 1.0, 1.0)) {\n    cout << "Assertion failed: right_angle_triangle(1, 1, 1) == false" << endl;\n    exit(1);\n  }\n\n  if (right_angle_triangle(2.0, 2.0, 10.0)) {\n    cout << "Assertion failed: right_angle_triangle(2, 2, 10) == false" << endl;\n    exit(1);\n  }\n\n  return 0;\n}\n\nbool right_angle_triangle(double a, double b, double c) {\n  double epsilon = 1.0e-4;\n\n  if (abs(a*a + b*b - c*c) < epsilon || abs(a*a + c*c - b*b) < epsilon || abs(b*b + c*c - a*a) < epsilon) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n[/CHECK]\n\n[META]\nname = Right Angle Triangle\nfolder = Fortran\nanswer = RightAngleTriangle.cpp\n[/META]\n\n[/QUESTION]\n\n\n[QUESTION]\n\n[TXT]\n\nWrite a function that takes a string and returns a string with all the vowels removed.\n\n[/TXT]\n\n[C]\n\n[C_PROMPT]\n>>> def remove_vowels(s):\n...     vowels = "aeiou"\n...     return "".join(c for c in s if c.lower() not in vowels)\n...\n>>> remove_vowels("Hello, world!")\n'Hll, wrld!'\n>>> remove_vowels("This is a test.")\n'Ths s  tst.'\n>>> remove_vowels("This is a test.")\n'Ths s 
\n\n[CPP]\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word = "";\n    string unique;\n    string word;\n    int maxu = 0;\n    int len_words = words.size();\n\n    for (int i = 0; i < len_words; i++) {\n        word = words[i];\n        unique = "";\n        for (int j = 0; j < word.length(); j++) {\n            if (unique.find(word[j]) == string::npos) {\n                unique += word[j];\n            }\n        }\n        if (unique.length() > maxu || (unique.length() == maxu && word < max_word)) {\n            max_word = word;\n            maxu = unique.length();\n        }\n    }\n    return max_word;\n}\n\nint main() {\n    vector<string> words;\n    string result;\n\n    words = {"name   ", "of     ", "string "};\n    result = find_max(words);\n    if (result != "string") {\n        cerr << "Assertion failed: expected 'string', got " << result << endl;\n        return 1;\n    }\n\n    words = {"name   ", "enam   ", "game   "};\n    result = find_max(words);\n    if (result != "enam") {\n        cerr << "Assertion failed: expected 'enam', got " << result << endl;\n        return 1;\n    }\n\n    words = {"aaaaaaa", "bb     ", "cc     "};\n    result = find_max(words);\n    if (result != "aaaaaaa") {\n        cerr << "Assertion failed: expected 'aaaaaaa', got " << result << endl;\n        return 1;\n    }\n\n    words = {"abc    ", "cba    "};\n    result = find_max(words);\n    if (result != "abc") {\n        cerr << "Assertion failed: expected 'abc', got " << result << endl;\n        return 1;\n    }\n\n    words = {"play    ", "this    ", "game    ", "of      ", "footbott"};\n    result = find_max(words);\n    if (result != "footbott") {\n        cerr << "Assertion failed: expected 'footbott', got " << result << endl;\n        return 1;\n    }\n\n    words = {"we      ", "are     ", "gonna   ", "rock    "};\n    result = find_max(words);\n    if (result != "gonna") {\n        cerr << "Assertion failed: expected 'gonna', got " << result << endl;\n        return 1;\n    }\n\n    words = {"we      ", "are     ", "a       ", "mad     ", "nation  "};\n    result = find_max(words);\n    if (result != "nation") {\n        cerr << "Assertion failed: expected 'nation', got " << result << endl;\n        return 1;\n    }\n\n    words = {"this    ", "is      ", "a       ", "prrk    "};\n    result = find_max(words);\n    if (result != "this") {\n        cerr << "Assertion failed: expected 'this', got " << result << endl;\n        return 1;\n    }\n\n    words = {"b       "};\n    result = find_max(words);\n    if (result != "b") {\n        cerr << "Assertion failed: expected 'b', got " << result << endl;\n        return 1;\n    }\n\n    words = {"play    ", "play    ", "play    "};\n    result = find_max(words);\n    if (result != "play") {\n        cerr << "Assertion failed: expected 'play', got " << result << endl;\n        return 1;\n    }\n\n    cout << "All tests passed." << endl;\n    return 0;\n} [/CPP]\n\n[PY]\ndef find_max(words):\n    max_word = ""\n    unique = ""\n    maxu = 0\n    len_words = len(words)\n\n    for i in range(len_words):\n        word = words[i]\n        unique = ""\n        for j in range(len(word)):\n            if unique.find(word[j]) == -1:\n                unique += word[j]\n        if len(unique) > maxu or (len(unique) == maxu and word < max_word):\n            max_word = word\n            maxu = len(unique)\n    return max_word\n\n\nif __name__ == "__main__":\n    words = ["name   ", "of     ", "string "]\n    result = find_max(words)\n    if result != "string":\n        print("Assertion failed: expected 'string', got", result)\n        exit(1)\n\n    words = ["name   ", "enam   ", "game   "]\n    result = find_max(words)\n    if result != "enam":\n        print("Assertion failed: expected 'enam', got", result)\n        exit(1)\n\n    words = ["aaaaaaa", "bb     ", "cc     "]\n    result = find_max(words)\n    if result != "aaaaaaa":\n        print("Assertion failed: expected 'aaaaaaa', got", result)\n        exit(1)\n\n    words = ["abc    ", "cba    "]\n    result = find_max(words)\n    if result != "abc":\n        print("Assertion failed: expected 'abc', got", result)\n        exit(1)\n\n    words = ["play    ", "this    ", "game    ", "of      ", "footbott"]\n    result = find_max(words)\n    if result != "footbott":\n        print("Assertion failed: expected 'footbott', got", result)\n        exit(1)\n\n    words = ["we      ", "are     ", "gonna   ", "rock    "]\n    result = find_max(words)\n    if result != "gonna":\n        print("Assertion failed: expected 'gonna', got", result)\n        exit(1)\n\n    words = ["we      ", "are     ", "a       ", "mad     ", "nation  "]\n    result = find_max(words)\n    if result != "nation":\n        print("Assertion failed: expected 'nation', got", result)\n        exit(1)\n\n    words = ["this    ", "is      ", "a       ", "prrk    "]\n    result = find_max(words)\n    if result != "this":\n        print("Assertion failed: expected 'this', got", result)\n        exit(1)\n\n    words = ["b       "]\n    result = find_max(words)\n    if result != "b":\n        print("Assertion failed: expected 'b', got", result)\n        exit(1)\n\n    words = ["play    ", "play    ", "play    "]\n    result = find_max(words)\n    if result != "play":\n        print("Assertion failed: expected 'play', got", result)\n        exit(1)\n\n    print("All tests passed.")\n[/PY]\n\n[JAVA]\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FindMax {\n    public static String findMax(List<String> words) {\n        String max_word = "";\n        String unique;\n        String word;\n        int maxu = 0;\n        int len_words = words.size();\n\n        for (int i = 0; i < len_words; i++) {\n            word = words.get(i);\n            unique = "";\n            for (int j = 0; j < word.length(); j++) {\n                if (unique.indexOf(word.charAt(j)) == -1) {\n                    unique += word.charAt(j);\n                }\n            }\n            if (unique.length() > maxu || (unique.length() == maxu && word.compareTo(max_word) < 0)) {\n                max_word = word;\n                maxu = unique.length();\n            }\n        }\n        return max_word;\n    }\n\n    public static void main(String[] args) {\n        List<String> words = new ArrayList<>();\n       
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n  vector<int> res;\n\n  if (need > remaining) {\n    res.push_back(number + remaining);\n    res.push_back(0);\n  } else {\n    res.push_back(number + need);\n    res.push_back(remaining - need);\n  }\n\n  return res;\n}\n\nint main() {\n  vector<int> result;\n  vector<int> expected;\n\n  // Test cases\n  result = eat(5, 6, 10);\n  expected = {11, 4};\n  if (result != expected) {\n    cout << "Assertion failed: eat(5, 6, 10) == {11, 4}" << endl;\n    return 1;\n  }\n\n  result = eat(4, 8, 9);\n  expected = {12, 1};\n  if (result != expected) {\n    cout << "Assertion failed: eat(4, 8, 9) == {12, 1}" << endl;\n    return 1;\n  }\n\n  result = eat(1, 10, 10);\n  expected = {11, 0};\n  if (result != expected) {\n    cout << "Assertion failed: eat(1, 10, 10) == {11, 0}" << endl;\n    return 1;\n  }\n\n  result = eat(2, 11, 5);\n  expected = {7, 0};\n  if (result != expected) {\n    cout << "Assertion failed: eat(2, 11, 5) == {7, 0}" << endl;\n    return 1;\n  }\n\n  result = eat(4, 5, 7);\n  expected = {9, 2};\n  if (result != expected) {\n    cout << "Assertion failed: eat(4, 5, 7) == {9, 2}" << endl;\n    return 1;\n  }\n\n  result = eat(4, 5, 1);\n  expected = {5, 0};\n  if (result != expected) {\n    cout << "Assertion failed: eat(4, 5, 1) == {5, 0}" << endl;\n    return 1;\n  }\n\n  cout << "All tests passed." << endl;\n\n  return 0;\n}\n\n[Python]\ndef eat(number, need, remaining):\n  if need > remaining:\n    return [number + remaining, 0]\n  else:\n    return [number + need, remaining - need]\n\nif __name__ == "__main__":\n  result = eat(5, 6, 10)\n  expected = [11, 4]\n  assert result == expected, "Assertion failed: eat(5, 6, 10) == {11, 4}"\n\n  result = eat(4, 8, 9)\n  expected = [12, 1]\n  assert result == expected, "Assertion failed: eat(4, 8, 9) == {12, 1}"\n\n  result = eat(1, 10, 10)\n  expected = [11, 0]\n  assert result == expected, "Assertion failed: eat(1, 10, 10) == {11, 0}"\n\n  result = eat(2, 11, 5)\n  expected = [7, 0]\n  assert result == expected, "Assertion failed: eat(2, 11, 5) == {7, 0}"\n\n  result = eat(4, 5, 7)\n  expected = [9, 2]\n  assert result == expected, "Assertion failed: eat(4, 5, 7) == {9, 2}"\n\n  result = eat(4, 5, 1)\n  expected = [5, 0]\n  assert result == expected, "Assertion failed: eat(4, 5, 1) == {5, 0}"\n\n  print("All tests passed.")\n\n[Java]\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<Integer> result;\n    List<Integer> expected;\n\n    // Test cases\n    result = eat(5, 6, 10);\n    expected = Arrays.asList(11, 4);\n    if (!result.equals(expected)) {\n      System.out.println("Assertion failed: eat(5, 6, 10) == {11, 4}");\n      System.exit(1);\n    }\n\n    result = eat(4, 8, 9);\n    expected = Arrays.asList(12, 1);\n    if (!result.equals(expected)) {\n      System.out.println("Assertion failed: eat(4, 8, 9) == {12, 1}");\n      System.exit(1);\n    }\n\n    result = eat(1, 10, 10);\n    expected = Arrays.asList(11, 0);\n    if (!result.equals(expected)) {\n      System.out.println("Assertion failed: eat(1, 10, 10) == {11, 0}");\n      System.exit(1);\n    }\n\n    result = eat(2, 11, 5);\n    expected = Arrays.asList(7, 0);\n    if (!result.equals(expected)) {\n      System.out.println("Assertion failed: eat(2, 11, 5) == {7, 0}");\n      System.exit(1);\n    }\n\n    result = eat(4, 5, 7);\n    expected = Arrays.asList(9, 2);\n    if (!result.equals(expected)) {\n      System.out.println("Assertion failed: eat(4, 5, 7) == {9, 2}");\n      System.exit(1);\n    }\n\n    result = eat(4, 5, 1);\n    expected = Arrays.asList(5, 0);\n    if (!result.equals(expected)) {\n      System.out.println("Assertion failed: eat(4, 5, 1) == {5, 0}");\n      System.exit(1);\n    }\n\n    System.out.println("All tests passed.");\n  }\n\n  public static List<Integer> eat(int number, int need, int remaining) {\n    List<Integer> res = new ArrayList<>();\n\n    if (need > remaining) {\n      res.add(number + remaining);\n      res.add(0);\n    } else {\n      res.add(number + need);\n      res.add(remaining - need);\n    }\n\n    return res;\n  }\n}\n\n[JavaScript]\nfunction eat(number, need, remaining) {\n  if (need > remaining) {\n    return [number + remaining, 0];\n  } else {\n    return [number + need, remaining - need];\n  }\n}\n\nif (eat(5, 6, 10)[0] !== 11 || eat(5, 6, 10)[1] !== 4) {\n  console.log("Assertion failed: eat(5, 6, 10) == {11, 4}");\n  process.exit(1);\n}\n\nif (eat(4, 8, 9)[0] !== 12 || eat(4, 8, 9)[1] !== 1) {\n  console.log("Assertion failed: eat(4, 8, 9) == {12, 1}");\n  process.exit(1);\n}\n\nif (eat(1, 10, 10)[0] !== 11 || eat(1, 10, 10)[1] !== 0) {\n  console.log("Assertion failed: eat(1, 10, 10) == {11, 0}");\n  process.exit(1);\n}\n\nif (eat(2, 11, 5)[0] !== 7 || eat(2, 11, 
\n\n[C++]\n#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    string out;\n    int nletter = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        char w = s[i];\n        if (isupper(w)) {\n            w = tolower(w);\n        } else if (islower(w)) {\n            w = toupper(w);\n        } else {\n            nletter++;\n        }\n        out += w;\n    }\n\n    if (nletter == s.length()) {\n        reverse(out.begin(), out.end());\n    }\n\n    return out;\n}\n\nint main() {\n    string s, result;\n\n    // Test cases\n    s = "AsDf";\n    result = solve(s);\n    if (result != "aSdF") {\n        cout << "Assertion failed: solve('AsDf') == 'aSdF'" << endl;\n        return 1;\n    }\n\n    s = "1234";\n    result = solve(s);\n    if (result != "4321") {\n        cout << "Assertion failed: solve('1234') == '4321'" << endl;\n        return 1;\n    }\n\n    s = "ab";\n    result = solve(s);\n    if (result != "AB") {\n        cout << "Assertion failed: solve('ab') == 'AB'" << endl;\n        return 1;\n    }\n\n    s = "#a@C";\n    result = solve(s);\n    if (result != "#A@c") {\n        cout << "Assertion failed: solve('#a@C') == '#A@c'" << endl;\n        return 1;\n    }\n\n    s = "#AsdfW^45";\n    result = solve(s);\n    if (result != "#aSDFw^45") {\n        cout << "Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'" << endl;\n        return 1;\n    }\n\n    s = "#6@2";\n    result = solve(s);\n    if (result != "2@6#") {\n        cout << "Assertion failed: solve('#6@2') == '2@6#'" << endl;\n        return 1;\n    }\n\n    s = "#$a^D";\n    result = solve(s);\n    if (result != "#$A^d") {\n        cout << "Assertion failed: solve('#$a^D') == '#$A^d'" << endl;\n        return 1;\n    }\n\n    s = "#ccc";\n    result = solve(s);\n    if (result != "#CCC") {\n        cout << "Assertion failed: solve('#ccc') == '#CCC'" << endl;\n        return 1;\n    }\n\n    cout << "All tests passed." << endl;\n\n    return 0;\n}\n\n[C#]\nusing System;\n\nclass Solution {\n    public static string solve(string s) {\n        string out = "";\n        int nletter = 0;\n\n        for (int i = 0; i < s.Length; i++) {\n            char w = s[i];\n            if (Char.IsUpper(w)) {\n                w = Char.ToLower(w);\n            } else if (Char.IsLower(w)) {\n                w = Char.ToUpper(w);\n            } else {\n                nletter++;\n            }\n            out += w;\n        }\n\n        if (nletter == s.Length) {\n            out = new string(out.Reverse());\n        }\n\n        return out;\n    }\n\n    static void Main(string[] args) {\n        string s, result;\n\n        // Test cases\n        s = "AsDf";\n        result = solve(s);\n        if (result != "aSdF") {\n            Console.WriteLine("Assertion failed: solve('AsDf') == 'aSdF'");\n            return;\n        }\n\n        s = "1234";\n        result = solve(s);\n        if (result != "4321") {\n            Console.WriteLine("Assertion failed: solve('1234') == '4321'");\n            return;\n        }\n\n        s = "ab";\n        result = solve(s);\n        if (result != "AB") {\n            Console.WriteLine("Assertion failed: solve('ab') == 'AB'");\n            return;\n        }\n\n        s = "#a@C";\n        result = solve(s);\n        if (result != "#A@c") {\n            Console.WriteLine("Assertion failed: solve('#a@C') == '#A@c'");\n            return;\n        }\n\n        s = "#AsdfW^45";\n        result = solve(s);\n        if (result != "#aSDFw^45") {\n            Console.WriteLine("Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'");\n            return;\n        }\n\n        s = "#6@2";\n        result = solve(s);\n        if (result != "2@6#") {\n            Console.WriteLine("Assertion failed: solve('#6@2') == '2@6#'");\n            return;\n        }\n\n        s = "#$a^D";\n        result = solve(s);\n        if (result != "#$A^d") {\n            Console.WriteLine("Assertion failed: solve('#$a^D') == '#$A^d'");\n            return;\n        }\n\n        s = "#ccc";\n        result = solve(s);\n        if (result != "#CCC") {\n            Console.WriteLine("Assertion failed: solve('#ccc') == '#CCC'");\n            return;\n        }\n\n        Console.WriteLine("All tests passed.");\n    }\n}\n\n[Python]\ndef solve(s):\n    out = ""\n    nletter = 0\n\n    for w in s:\n        if w.isupper():\n            w = w.lower()\n        elif w.islower():\n            w = w.upper()\n        else:\n            nletter += 1\n        out += w\n\n    if nletter == len(s):\n        out = out[::-1]\n\n    return out\n\n\nif __name__ == "__main__":\n    s = "AsDf"\n    result = solve(s)\n    if result != "aSdF":\n        print("Assertion failed: solve('AsDf') == 'aSdF'")\n        exit(1)\n\n    s = "1234"\n    result = solve(s)\n    if result != "4321":\n        print("Assertion failed: solve('1234') == '4321'")\n        exit(1)\n\n    s = "ab"\n    result = solve(s)\n    if result != "AB":\n        print("Assertion failed: solve('ab') == 'AB'")\n        exit(1)\n\n    s = "#a@C"\n    result = solve(s)\n    if result != "#A@c":\n        print("Assertion failed: solve('#a@C') == '#A@c'")\n        exit(1)\n\n    s = "#AsdfW^45"\n    result = solve(s)\n    if result != "#aSDFw^45":\n        print("Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'")\n        exit(1)\n\n    s = "#6@2"\n    result = solve(s)\n    if result != "2@6#":\n        print("Assertion failed: solve('#6@2') == '2@6#'")\n        exit(1)\n\n    s = "#$a^D"\n    result = solve(s)\n    if result != "#$A^d":\n        print("Assertion failed: solve('#$a^D') == '#$A^d'")\n        exit(1)\n\n    s = "#ccc"\n    result = solve(s)\n    if result != "#CCC":\n        print("Assertion failed: solve('#ccc') == '#CCC'")\n        exit(1)\n\n    print("All tests passed.")\n\n[Java]\nimport java.util.Scanner;\n\nclass Solution {\n    public static
\n\n[C++]\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b)\n{\n    vector<int> result;\n    int temp_a = a;\n    int temp_b = b;\n\n    if (temp_b < temp_a) {\n        int m = temp_a;\n        temp_a = temp_b;\n        temp_b = m;\n    }\n\n    for (int i = temp_a; i <= temp_b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\nint main()\n{\n    vector<int> result = generate_integers(2, 10);\n    vector<int> expected = {2, 4, 6, 8};\n    if (result != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    result = generate_integers(10, 2);\n    expected = {2, 4, 6, 8};\n    if (result != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    result = generate_integers(132, 2);\n    expected = {2, 4, 6, 8};\n    if (result != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    result = generate_integers(17, 89);\n    expected = {};\n    if (result != expected) {\n        cout << "Assertion failed" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n\n[C]\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nbool is_same(int *a, int *b, int size)\n{\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition)\n{\n    if (!condition) {\n        printf("Assertion failed\n");\n        exit(1);\n    }\n}\n\nint *generate_integers(int a, int b, int *size)\n{\n    int temp_a = a;\n    int temp_b = b;\n\n    if (temp_b < temp_a) {\n        int m = temp_a;\n        temp_a = temp_b;\n        temp_b = m;\n    }\n\n    int count = 0;\n    for (int i = temp_a; i <= temp_b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            count++;\n        }\n    }\n\n    int *result = malloc(count * sizeof(int));\n    int j = 0;\n    for (int i = temp_a; i <= temp_b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            result[j] = i;\n            j++;\n        }\n    }\n\n    *size = count;\n    return result;\n}\n\nint main()\n{\n    int size;\n    int *result = generate_integers(2, 10, &size);\n    int expected[] = {2, 4, 6, 8};\n    assert(is_same(result, expected, 4));\n    free(result);\n\n    result = generate_integers(10, 2, &size);\n    expected = (int[]){2, 4, 6, 8};\n    assert(is_same(result, expected, 4));\n    free(result);\n\n    result = generate_integers(132, 2, &size);\n    expected = (int[]){2, 4, 6, 8};\n    assert(is_same(result, expected, 4));\n    free(result);\n\n    result = generate_integers(17, 89, &size);\n    expected = (int[]){};\n    assert(is_same(result, expected, 0));\n    free(result);\n\n    return 0;\n}\n\n[Python]\ndef generate_integers(a, b):\n    result = []\n    temp_a = a\n    temp_b = b\n\n    if temp_b < temp_a:\n        m = temp_a\n        temp_a = temp_b\n        temp_b = m\n\n    for i in range(temp_a, temp_b + 1):\n        if i < 10 and i % 2 == 0:\n            result.append(i)\n\n    return result\n\ndef assert(condition):\n    if not condition:\n        print("Assertion failed")\n        exit(1)\n\ndef main():\n    result = generate_integers(2, 10)\n    expected = [2, 4, 6, 8]\n    assert(result == expected)\n\n    result = generate_integers(10, 2)\n    expected = [2, 4, 6, 8]\n    assert(result == expected)\n\n    result = generate_integers(132, 2)\n    expected = [2, 4, 6, 8]\n    assert(result == expected)\n\n    result = generate_integers(17, 89)\n    expected = []\n    assert(result == expected)\n\nif __name__ == "__main__":\n    main()\n\n[Rust]\nfn generate_integers(a: i32, b: i32) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut temp_a = a;\n    let mut temp_b = b;\n\n    if temp_b < temp_a {\n        let m = temp_a;\n        temp_a = temp_b;\n        temp_b = m;\n    }\n\n    for i in temp_a..=temp_b {\n        if i < 10 && i % 2 == 0 {\n            result.push(i);\n        }\n    }\n\n    result\n}\n\nfn assert(condition: bool) {\n    if !condition {\n        println!("Assertion failed");\n        std::process::exit(1);\n    }\n}\n\nfn main() {\n    let result = generate_integers(2, 10);\n    let expected = vec![2, 4, 6, 8];\n    assert(result == expected);\n\n    let result = generate_integers(10, 2);\n    let expected = vec![2, 4, 6, 8];\n    assert(result == expected);\n\n    let result = generate_integers(132, 2);\n    let expected = vec![2, 4, 6, 8];\n    assert(result == expected);\n\n    let result = generate_integers(17, 89);\n    let expected = vec![];\n    assert(result == expected);\n}\n\n[Swift]\nfunc generate_integers(_ a: Int, _ b: Int) -> [Int] {\n    var result = [Int]()\n    var temp_a = a\n    var temp_b = b\n\n    if temp_b < temp_a {\n        let m = temp_a\n        temp_a = temp_b\n        temp_b = m\n    }\n\n    for i in temp_a...temp_b {\n        if i < 10 && i % 2 == 0 {\n            result.append(i)\n        }\n    }\n\n    return result\n}\n\nfunc assert(_ condition: Bool) {\n    if !condition {\n        print("Assertion failed")\n        exit(1)\n    }\n}\n\nfunc main() {\n    let result = generate_integers(2, 10)\n    let expected = [2, 4, 6, 8]\n    assert(result == expected)\n\n    let result = generate_integers(10, 2)\n    let expected = [2, 4, 6, 8]\n    assert(result == expected)\n\n    let result = generate_integers(132, 2)\n    let expected = [2, 4, 6, 
