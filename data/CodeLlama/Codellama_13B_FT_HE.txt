Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test case 1\n    std::vector<double> a = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    if (!has_close_elements(a, 0.3)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.05)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    a = {1.0, 2.0, 5.9, 4.0, 5.0};\n    if (!has_close_elements(a, 0.95)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.8)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    a = {1.0, 2.0, 3.0, 4.0, 5.0};\n    if (!has_close_elements(a, 2.0)) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    a = {1.1, 2.2, 3.1, 4.1, 5.1};\n    if (!has_close_elements(a, 1.0)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.5)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses the standard library functions and containers. The `has_close_elements` function is implemented to check if any two elements in the input vector are closer than the specified threshold. The `main` function contains test cases that verify the functionality of `has_close_elements` with different input vectors and threshold values.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `has_close_elements` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\ncontains\n    logical function has_close_elements(numbers, n, threshold)\n        implicit none\n        real, dimension(:), intent(in) :: numbers\n        integer, intent(in) :: n\n        real, intent(in) :: threshold\n        integer :: i, j\n\n        has_close_elements = .false.\n        do i = 1, n\n            do j = i + 1, n\n                if (abs(numbers(i) - numbers(j)) < threshold) then\n                    has_close_elements = .true.\n                    return\n                end if\n            end do\n        end do\n    end function has_close_elements\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    real, dimension(:), allocatable :: a\n    integer :: n\n\n    ! Test case 1\n    a = [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]\n    n = size(a)\n    if (.not. has_close_elements(a, n, 0.3)) then\n        write(*,*) "Test case 1 failed: assertion failed"\n        call exit(1)\n    end if\n    if (has_close_elements(a, n, 0.05)) then\n        write(*,*) "Test case 1 failed: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 2\n    a = [1.0, 2.0, 5.9, 4.0, 5.0]\n    n = size(a)\n    if (.not. has_close_elements(a, n, 0.95)) then\n        write(*,*) "Test case 2 failed: assertion failed"\n        call exit(1)\n    end if\n    if (has_close_elements(a, n, 0.8)) then\n        write(*,*) "Test case 2 failed: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 3\n    a = [1.0, 2.0, 3.0, 4.0, 5.0]\n    n = size(a)\n    if (.not. has_close_elements(a, n, 2.0)) then\n        write(*,*) "Test case 3 failed: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 4\n    a = [1.1, 2.2, 3.1, 4.1, 5.1]\n    n = size(a)\n    if (.not. has_close_elements(a, n, 1.0)) then\n        write(*,*) "Test case 4 failed: assertion failed"\n        call exit(1)\n    end if\n    if (has_close_elements(a, n, 0.5)) then\n        write(*,*) "Test case 4 failed: assertion failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test case 1\n    std::vector<double> a = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    if (!has_close_elements(a, 0.3)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.05)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    a = {1.0, 2.0, 5.9, 4.0, 5.0};\n    if (!has_close_elements(a, 0.95)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.8)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    a = {1.0, 2.0, 3.0, 4.0
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool below_zero(const std::vector<int>& operations) {\n    int num = 0;\n    for (int op : operations) {\n        num += op;\n        if (num < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> operations;\n    bool result;\n\n    // Test case 1: Empty vector\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2: Vector with positive and negative numbers\n    operations = {1, 2, -3, 1, 2, -3};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3: Vector with positive numbers\n    operations = {1, 2, -4, 5, 6};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 4: Vector with positive and negative numbers\n    operations = {1, -1, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 5: Vector with positive and negative numbers\n    operations = {1, -1, 2, -2, 5, -5, 4, -5};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 6: Vector with positive and negative numbers\n    operations = {1, -2, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the `main` function that runs the test cases similar to the Fortran code. The `below_zero` function checks if the sum of the elements in the vector `operations` is less than zero at any point, which is the logic implemented in the Fortran code. The test cases are designed to verify the correctness of the `below_zero` function with different vectors. If any test case fails, the program prints an error message and exits with a non-zero status.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `below_zero` function with various input vectors.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, dimension(:), allocatable :: operations\n    logical :: result\n\n    ! Test case 1: Empty vector\n    allocate(operations(0))\n    result = below_zero(operations)\n    if (result .neqv. .false.) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n    deallocate(operations)\n\n    ! Test case 2: Vector with positive and negative numbers\n    allocate(operations(6))\n    operations = [1, 2, -3, 1, 2, -3]\n    result = below_zero(operations)\n    if (result .neqv. .false.) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n    deallocate(operations)\n\n    ! Test case 3: Vector with positive numbers\n    allocate(operations(5))\n    operations = [1, 2, -4, 5, 6]\n    result = below_zero(operations)\n    if (result .neqv. .true.) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n    deallocate(operations)\n\n    ! Test case 4: Vector with positive and negative numbers\n    allocate(operations(8))\n    operations = [1, -1, 2, -2, 5, -5, 4, -4]\n    result = below_zero(operations)\n    if (result .neqv. .false.) then\n        write(*,*) "Test case 4 failed"\n        call exit(1)\n    end if\n    deallocate(operations)\n\n    ! Test case 5: Vector with positive and negative numbers\n    allocate(operations(8))\n    operations = [1, -1, 2, -2, 5, -5, 4, -5]\n    result = below_zero(operations)\n    if (result .neqv. .true.) then\n        write(*,*) "Test case 5 failed"\n        call exit(1)\n    end if\n    deallocate(operations)\n\n    ! Test case 6: Vector with positive and negative numbers\n    allocate(operations(8))\n    operations = [1, -2, 2, -2, 5, -5, 4, -4]\n    result = below_zero(operations)\n    if (result .neqv. .true.) then\n        write(*,*) "Test case 6 failed"\n        call exit(1)\n    end if\n    deallocate(operations)\n\n    write(*,*) "All test cases passed"\n\ncontains\n\n    logical function below_zero(operations)\n        implicit none\n        integer, dimension(:), intent(in) :: operations\n        integer :: i, num\n\n        num = 0\n        do i = 1, size(operations)\n            num = num + operations(i)\n            if (num < 0) then\n                below_zero = .true.\n                return\n            end if\n        end do\n        below_zero = .false.\n    end function below_zero\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool below_zero(const std::vector<int>& operations) {\n    int num = 0;\n    for (int op : operations) {\n        num += op;\n        if (num < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> operations;\n    bool result;\n\n    // Test case 1: Empty vector\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2: Vector with positive and negative numbers\n    operations = {1, 2, -3, 1, 2, -3};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3: Vector with positive numbers\n    operations = {1, 2, -4, 5, 6};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 4: Vector with positive and negative numbers\n    operations = {1, -1, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        exit
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    int n = numbers.size();\n    float sum = 0.0f;\n    for (int i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    float avg = sum / n;\n\n    float msum = 0.0f;\n    for (int i = 0; i < n; ++i) {\n        msum += std::abs(numbers[i] - avg);\n    }\n    return msum / n;\n}\n\nint main() {\n    // Test cases\n    std::vector<float> test_case_1 = {1.0f, 2.0f, 3.0f};\n    if (std::abs(mean_absolute_deviation(test_case_1) - 2.0f / 3.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<float> test_case_2 = {1.0f, 2.0f, 3.0f, 4.0f};\n    if (std::abs(mean_absolute_deviation(test_case_2) - 1.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    std::vector<float> test_case_3 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    if (std::abs(mean_absolute_deviation(test_case_3) - 6.0f / 5.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a function `mean_absolute_deviation` that computes the mean absolute deviation of a given vector of floats. The `main` function contains test cases that verify the correctness of the `mean_absolute_deviation` function with different input vectors.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `mean_absolute_deviation` function with different input vectors.\n\n### Fortran Unit Tests\n\nTo run the Fortran unit tests, you need to save the Fortran code and the test program in a file, for example, `mad_test.f90`, and then compile and run it using a Fortran compiler like `gfortran`.\n\n```fortran\n! Save this as mad_module.f90\nmodule mad_module\n    implicit none\ncontains\n    function mean_absolute_deviation(numbers) result(mad)\n        implicit none\n        real, dimension(:), intent(in) :: numbers\n        real :: mad\n        real :: sum, avg, msum\n        integer :: i, n\n\n        n = size(numbers)\n        sum = 0.0\n        do i = 1, n\n            sum = sum + numbers(i)\n        end do\n        avg = sum / n\n\n        msum = 0.0\n        do i = 1, n\n            msum = msum + abs(numbers(i) - avg)\n        end do\n        mad = msum / n\n    end function mean_absolute_deviation\nend module mad_module\n\n! Save this as mad_test.f90\nprogram mean_absolute_deviation_program\n    use mad_module\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = mean_absolute_deviation([1.0, 2.0, 3.0])\n    if (abs(result - 2.0/3.0) > 1e-4) then\n        write(*,*) "Assertion failed for test case 1"\n        call exit(1)\n    end if\n\n    result = mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    if (abs(result - 1.0) > 1e-4) then\n        write(*,*) "Assertion failed for test case 2"\n        call exit(1)\n    end if\n\n    result = mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0])\n    if (abs(result - 6.0/5.0) > 1e-4) then\n        write(*,*) "Assertion failed for test case 3"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program mean_absolute_deviation_program\n```\n\nCompile and run the Fortran code:\n\n```sh\ngfortran -o mad_test mad_module.f90 mad_test.f90\n./mad_test\n```\n\n### C++ Unit Tests\n\nTo run the C++ unit tests, you need to save the C++ code in a file, for example, `mad_test.cpp`, and then compile and run it using a C++ compiler like `g++`.\n\n```cpp\n// Save this as mad_test.cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    int n = numbers.size();\n    float sum = 0.0f;\n    for (int i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    float avg = sum / n;\n\n    float msum = 0.0f;\n    for (int i = 0; i < n; ++i) {\n        msum += std::abs(numbers[i] - avg);\n    }\n    return msum / n;\n}\n\nint main() {\n    // Test cases\n    std::vector<float> test_case_1 = {1.0f, 2.0f, 3.0f};\n    if (std::abs(mean_absolute_deviation(test_case_1) - 2.0f / 3.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<float> test_case_2 = {1.0f, 2.0f, 3.0f, 4.0f};\n    if (std::abs(mean_absolute_deviation(test_case_2) - 1.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    std::vector<float> test_case_3 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    if (std::abs(mean_absolute_deviation(test_case_3) - 6.0f / 5.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nCompile and run the C++ code:\n\n```sh\ng++ -o mad_test mad_test.cpp\n./mad_test\n```\n\nThese unit tests will verify the correctness of the `mean_absolute_deviation` function in both Fortran and C++ implementations. If all tests pass, it indicates that the translation is correct.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses standard library features to achieve the same functionality as the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid intersperse(const std::vector<int>& numbers, int delimeter, std::vector<int>& out) {\n    if (numbers.empty()) {\n        out.clear();\n        return;\n    }\n    out.resize(2 * numbers.size() - 1);\n    out[0] = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        out[2 * i - 1] = delimeter;\n        out[2 * i] = numbers[i];\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n    int delimeter;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    intersperse(numbers, 7, result);\n    assert(issame(result, expected));\n\n    // Test case 2\n    numbers = {5, 6, 3, 2};\n    expected = {5, 8, 6, 8, 3, 8, 2};\n    intersperse(numbers, 8, result);\n    assert(issame(result, expected));\n\n    // Test case 3\n    numbers = {2, 2, 2};\n    expected = {2, 2, 2, 2, 2};\n    intersperse(numbers, 2, result);\n    assert(issame(result, expected));\n\n    return 0;\n}\n```\n\nThis C++ code includes the following functionalities:\n\n1. **Interspersing Numbers**: The `intersperse` function takes a vector of numbers and a delimiter, and returns a new vector with the numbers interspersed with the delimiter.\n2. **Comparing Vectors**: The `issame` function compares two vectors to check if they contain the same elements.\n3. **Assertions**: The `assert` function checks a condition and exits the program with an error message if the condition is false.\n\nThe `main` function contains three test cases similar to the Fortran code, verifying the functionality of the `intersperse` and `issame` functions.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: numbers(:), result(:), expected(:)\n    integer :: delimeter\n\n    ! Test case 1\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(0))\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(0))\n    call intersperse(numbers, 7, result)\n    call assert(issame(result, expected))\n\n    ! Test case 2\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(4))\n    numbers = [5, 6, 3, 2]\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(7))\n    expected = [5, 8, 6, 8, 3, 8, 2]\n    call intersperse(numbers, 8, result)\n    call assert(issame(result, expected))\n\n    ! Test case 3\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(3))\n    numbers = [2, 2, 2]\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(5))\n    expected = [2, 2, 2, 2, 2]\n    call intersperse(numbers, 2, result)\n    call assert(issame(result, expected))\n\ncontains\n\n    subroutine intersperse(numbers, delimeter, out)\n        integer, intent(in) :: numbers(:)\n        integer, intent(in) :: delimeter\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i, n\n\n        n = size(numbers)\n        if (n == 0) then\n            allocate(out(0))\n        else\n            allocate(out(2*n-1))\n            out(1) = numbers(1)\n            do i = 2, n\n                out(2*i-2) = delimeter\n                out(2*i-1) = numbers(i)\n            end do\n        end if\n    end subroutine intersperse\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid intersperse(const std::vector<int>& numbers, int delimeter, std::vector<int>& out) {\n    if (numbers.empty()) {\n        out.clear();\n        return;\n    }\n    out.resize(2 * numbers.size() - 1);\n    out[0] = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        out[2 * i - 1] = delimeter;\n        out[2 * i] = numbers[i];\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n    int delimeter;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    intersperse(numbers, 7, result);\n    assert(issame(result, expected));\n\n    // Test case 2\n    numbers = {5, 6, 3, 2};\n    expected = {5, 8, 6, 8, 3, 8, 2};\n    intersperse(numbers, 8, result);\n    assert(issame(result, expected));\n\n    // Test case 3\n    numbers = {2, 2, 2};\n    expected = {2, 2, 2, 2, 2};\n    intersperse(numbers, 2, result);\n    assert(issame(result, expected));\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\n### Explanation\n\n- **Fortran Unit Test Code**: This code defines a main program that includes three test cases for the `intersperse` subroutine and the `issame` function
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code uses the standard library and algorithms to achieve the same functionality.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nvoid parse_nested_parens(const std::string& paren_string, std::vector<int>& all_levels) {\n    int level = 0;\n    int max_level = 0;\n    all_levels.clear();\n\n    for (char chr : paren_string) {\n        if (chr == '(') {\n            level++;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level--;\n            if (level == 0) {\n                all_levels.push_back(max_level);\n                max_level = 0;\n            }\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nint main() {\n    std::string paren_string;\n    std::vector<int> result;\n    std::vector<int> expected1 = {2, 3, 1, 3};\n    std::vector<int> expected2 = {1, 2, 3, 4};\n    std::vector<int> expected3 = {4};\n    bool is_same;\n\n    paren_string = "(()()) ((())) () ((())()())";\n    parse_nested_parens(paren_string, result);\n    is_same = issame(result, expected1);\n    if (!is_same) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    paren_string = "() (()) ((())) (((())))";\n    parse_nested_parens(paren_string, result);\n    is_same = issame(result, expected2);\n    if (!is_same) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    paren_string = "(()(())((())))";\n    parse_nested_parens(paren_string, result);\n    is_same = issame(result, expected3);\n    if (!is_same) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nThis C++ code defines a function `parse_nested_parens` to parse the nested parentheses in a string and another function `issame` to compare two vectors. The `main` function contains the test cases similar to the Fortran program.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `parse_nested_parens` function and the `issame` function.\n\n### Fortran Unit Test Code\n\nHere is the Fortran unit test code that you can compile and run to test the functionality:\n\n```fortran\nprogram test_nested_parens\n    implicit none\n    character(len=100) :: paren_string\n    integer, dimension(:), allocatable :: result\n    integer, dimension(4) :: expected1 = [2, 3, 1, 3]\n    integer, dimension(4) :: expected2 = [1, 2, 3, 4]\n    integer, dimension(1) :: expected3 = [4]\n    logical :: is_same\n\n    ! Test case 1\n    paren_string = '(()()) ((())) () ((())()())'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected1)\n    if (.not. is_same) then\n        write(*,*) "Test case 1 failed"\n    else\n        write(*,*) "Test case 1 passed"\n    end if\n\n    ! Test case 2\n    paren_string = '() (()) ((())) (((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected2)\n    if (.not. is_same) then\n        write(*,*) "Test case 2 failed"\n    else\n        write(*,*) "Test case 2 passed"\n    end if\n\n    ! Test case 3\n    paren_string = '(()(())((())))'\n    call parse_nested_parens(paren_string, result)\n    is_same = issame(result, expected3)\n    if (.not. is_same) then\n        write(*,*) "Test case 3 failed"\n    else\n        write(*,*) "Test case 3 passed"\n    end if\n\ncontains\n\n    subroutine parse_nested_parens(paren_string, all_levels)\n        character(len=*), intent(in) :: paren_string\n        integer, dimension(:), allocatable, intent(out) :: all_levels\n        integer :: level, max_level, i, n\n        character(len=1) :: chr\n        integer, dimension(:), allocatable :: temp_levels\n\n        level = 0\n        max_level = 0\n        n = len_trim(paren_string)\n        allocate(temp_levels(n))\n        temp_levels = 0\n\n        do i = 1, n\n            chr = paren_string(i:i)\n            if (chr == '(') then\n                level = level + 1\n                if (level > max_level) max_level = level\n            else if (chr == ')') then\n                level = level - 1\n                if (level == 0) then\n                    temp_levels(i) = max_level\n                    max_level = 0\n                end if\n            end if\n        end do\n\n        ! Filter out zeros and allocate the result array\n        allocate(all_levels(count(temp_levels /= 0)))\n        all_levels = pack(temp_levels, temp_levels /= 0)\n    end subroutine parse_nested_parens\n\n    logical function issame(a, b)\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend program test_nested_parens\n```\n\n### C++ Unit Test Code\n\nHere is the C++ unit test code that you can compile and run to test the functionality:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nvoid parse_nested_parens(const std::string& paren_string, std::vector<int>& all_levels) {\n    int level = 0;\n    int max_level = 0;\n    all_levels.clear();\n\n    for (char chr : paren_string) {\n        if (chr == '(') {\n            level++;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level--;\n            if (level == 0) {\n                all_levels.push_back(max_level);\n                max_level = 0;\n            }\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid run_test(const std::string& paren_string, const std::vector<int>& expected, const std::string& test_name) {\n    std::vector<int> result;\n    parse_nested_parens(paren_string, result);\n    if (
Certainly! Below is the translated C++ code from the provided Fortran code.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> empty_array;\n    std::vector<int> array1 = {1, 1, 1};\n    std::vector<int> array2 = {100, 0};\n    std::vector<int> array3 = {3, 5, 7};\n    std::vector<int> array4 = {10};\n\n    // Test cases\n    auto result = sum_product(empty_array);\n    if (!issame(result, {0, 1})) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array1);\n    if (!issame(result, {3, 1})) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array2);\n    if (!issame(result, {100, 0})) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array3);\n    if (!issame(result, {3 + 5 + 7, 3 * 5 * 7})) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array4);\n    if (!issame(result, {10, 10})) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the `sum_product` function and the `issame` function, which are analogous to the Fortran module's functions. The `main` function contains test cases that verify the correctness of the `sum_product` function and the `issame` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `sum_product` and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\ncontains\n    function sum_product(numbers) result(res)\n        implicit none\n        integer, dimension(:), intent(in) :: numbers\n        integer, dimension(2) :: res\n        integer :: i, sum, product\n\n        sum = 0\n        product = 1\n\n        do i = 1, size(numbers)\n            sum = sum + numbers(i)\n            product = product * numbers(i)\n        end do\n\n        res = [sum, product]\n    end function sum_product\n\n    logical function issame(a, b)\n        implicit none\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    integer, dimension(:), allocatable :: result\n    integer, dimension(:), allocatable :: empty_array\n    integer, dimension(3) :: array1 = [1, 1, 1]\n    integer, dimension(2) :: array2 = [100, 0]\n    integer, dimension(3) :: array3 = [3, 5, 7]\n    integer, dimension(1) :: array4 = [10]\n\n    ! Allocate empty array with size 0\n    allocate(empty_array(0))\n\n    ! Test cases\n    result = sum_product(empty_array)\n    if (.not. issame(result, [0, 1])) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n\n    result = sum_product(array1)\n    if (.not. issame(result, [3, 1])) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n\n    result = sum_product(array2)\n    if (.not. issame(result, [100, 0])) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n\n    result = sum_product(array3)\n    if (.not. issame(result, [3 + 5 + 7, 3 * 5 * 7])) then\n        write(*,*) "Test case 4 failed"\n        call exit(1)\n    end if\n\n    result = sum_product(array4)\n    if (.not. issame(result, [10, 10])) then\n        write(*,*) "Test case 5 failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> empty_array;\n    std::vector<int> array1 = {1, 1, 1};\n    std::vector<int> array2 = {100, 0};\n    std::vector<int> array3 = {3, 5, 7};\n    std::vector<int> array4 = {10};\n\n    // Test cases\n    auto result = sum_product(empty_array);\n    if (!issame(result, {0, 1})) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array1);\n    if (!issame(result, {3, 1})) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array2);\n    if (!issame(result, {100, 0})) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array3);\n    if (!issame(result, {3 + 5 + 7, 3 * 5 * 7})) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array4);
Translating the provided Fortran code to C++ involves a few steps, including handling dynamic arrays, translating subroutines and functions, and adapting the testing framework. Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\n// Function to find the rolling maximum\nvoid rolling_max(const std::vector<int>& numbers, std::vector<int>& out) {\n    int max = 0;\n    for (int num : numbers) {\n        if (num > max) max = num;\n        out.push_back(max);\n    }\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\n// Assert function to check conditions\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> numbers{};\n    std::vector<int> result;\n    std::vector<int> expected{};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 2\n    numbers = {1, 2, 3, 4};\n    expected = {1, 2, 3, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 3\n    numbers = {4, 3, 2, 1};\n    expected = {4, 4, 4, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 4\n    numbers = {3, 2, 3, 100, 3};\n    expected = {3, 3, 3, 100, 100};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Dynamic Arrays**: In C++, we use `std::vector<int>` to handle dynamic arrays.\n2. **Rolling Maximum**: The `rolling_max` function iterates through the input array and maintains the maximum value seen so far, appending it to the output array.\n3. **Test Cases**: The `main` function contains test cases that verify the correctness of the `rolling_max` function.\n4. **Assertion**: The `assert_condition` function checks if the condition is met. If not, it prints an error message and exits with a non-zero status.\n\nThis C++ code should behave similarly to the original Fortran code, ensuring the same functionality and output.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: numbers(:), result(:), expected(:)\n\n    ! Test case 1\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(0))\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(0))\n    call rolling_max(numbers, result)\n    call assert(issame(result, expected))\n\n    ! Test case 2\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(4))\n    numbers = [1, 2, 3, 4]\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(4))\n    expected = [1, 2, 3, 4]\n    call rolling_max(numbers, result)\n    call assert(issame(result, expected))\n\n    ! Test case 3\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(4))\n    numbers = [4, 3, 2, 1]\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(4))\n    expected = [4, 4, 4, 4]\n    call rolling_max(numbers, result)\n    call assert(issame(result, expected))\n\n    ! Test case 4\n    if (allocated(numbers)) deallocate(numbers)\n    allocate(numbers(5))\n    numbers = [3, 2, 3, 100, 3]\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(5))\n    expected = [3, 3, 3, 100, 100]\n    call rolling_max(numbers, result)\n    call assert(issame(result, expected))\n\ncontains\n\n    subroutine rolling_max(numbers, out)\n        integer, intent(in) :: numbers(:)\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i, max\n\n        if (allocated(out)) deallocate(out)\n        allocate(out(size(numbers)))\n        max = 0\n        do i = 1, size(numbers)\n            if (numbers(i) > max) max = numbers(i)\n            out(i) = max\n        end do\n    end subroutine rolling_max\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\n// Function to find the rolling maximum\nvoid rolling_max(const std::vector<int>& numbers, std::vector<int>& out) {\n    int max = 0;\n    for (int num : numbers) {\n        if (num > max) max = num;\n        out.push_back(max);\n    }\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\n// Assert function to check conditions\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> numbers{};\n    std::vector<int> result;\n    std::vector<int> expected{};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 2\n    numbers = {1, 2, 3, 4};\n    expected = {1, 2, 3, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 3\n    numbers = {4, 3, 2, 1};\n    expected = {4, 4, 4, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result,
Translating the given Fortran code to C++ involves several steps, including adapting the syntax for loops, string handling, and function definitions. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function prototypes\nbool is_palindrome(const std::string& str);\nstd::string make_palindrome(const std::string& str);\nstd::string reverse_string(const std::string& str);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(make_palindrome("") == "");\n    assert(make_palindrome("x") == "x");\n    assert(make_palindrome("xyz") == "xyzyx");\n    assert(make_palindrome("xyx") == "xyx");\n    assert(make_palindrome("jerry") == "jerryrrej");\n\n    return 0;\n}\n\nbool is_palindrome(const std::string& str) {\n    std::string reversed_str = reverse_string(str);\n    return str == reversed_str;\n}\n\nstd::string make_palindrome(const std::string& str) {\n    std::string rstr, nstr, n2str;\n    for (size_t i = 0; i < str.length(); ++i) {\n        rstr = str.substr(i);\n        if (is_palindrome(rstr)) {\n            nstr = str.substr(0, i);\n            n2str = reverse_string(nstr);\n            return str + n2str;\n        }\n    }\n    n2str = reverse_string(str);\n    return str + n2str;\n}\n\nstd::string reverse_string(const std::string& str) {\n    std::string reversed_str = "";\n    for (size_t i = 0; i < str.length(); ++i) {\n        reversed_str += str[str.length() - i - 1];\n    }\n    return reversed_str;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n```\n\n### Key Points in the Translation:\n\n1. **String Handling**: C++ uses `std::string` for string operations, which simplifies handling compared to Fortran's character arrays.\n\n2. **Looping**: The `for` loop in C++ uses zero-based indexing, unlike Fortran's one-based indexing.\n\n3. **Function Definitions**: Functions are defined with their return types explicitly stated. In C++, functions can be overloaded, but here we use different function names for clarity.\n\n4. **Assertions**: The `assert` function in C++ is provided by the `<cstdlib>` header for exiting the program on failure.\n\n5. **Substrings**: C++ handles substrings using the `substr` method of the `std::string` class.\n\n6. **Program Structure**: The `main` function serves as the entry point for C++ programs, similar to the `program` block in Fortran.\n\nThis C++ code should behave similarly to the original Fortran code, providing the same functionality and passing the same test cases.\nLet's write some test to verify if the translation is correct. \nBelow are examples of how you could write unit tests for both the Fortran and C++ versions of the palindrome program. These tests will verify the correctness of the `is_palindrome`, `make_palindrome`, and `reverse_string` functions.\n\n### Fortran Unit Tests\n\nFor Fortran, you can use a simple module for testing. This example assumes you're using a modern Fortran compiler that supports modules.\n\n```fortran\nmodule test_palindrome\n    implicit none\ncontains\n    subroutine test_is_palindrome()\n        implicit none\n        logical :: result\n\n        result = is_palindrome("")\n        call assert(result .eqv. .true.)\n\n        result = is_palindrome("x")\n        call assert(result .eqv. .true.)\n\n        result = is_palindrome("xyz")\n        call assert(result .eqv. .false.)\n\n        result = is_palindrome("xyx")\n        call assert(result .eqv. .true.)\n\n        result = is_palindrome("jerry")\n        call assert(result .eqv. .false.)\n    end subroutine test_is_palindrome\n\n    subroutine test_make_palindrome()\n        implicit none\n        character(len=:), allocatable :: result\n\n        result = make_palindrome("")\n        call assert(result == "")\n\n        result = make_palindrome("x")\n        call assert(result == "x")\n\n        result = make_palindrome("xyz")\n        call assert(result == "xyzyx")\n\n        result = make_palindrome("xyx")\n        call assert(result == "xyx")\n\n        result = make_palindrome("jerry")\n        call assert(result == "jerryrrej")\n    end subroutine test_make_palindrome\n\n    subroutine test_reverse_string()\n        implicit none\n        character(len=:), allocatable :: result\n\n        result = reverse_string("")\n        call assert(result == "")\n\n        result = reverse_string("x")\n        call assert(result == "x")\n\n        result = reverse_string("xyz")\n        call assert(result == "zyx")\n\n        result = reverse_string("jerry")\n        call assert(result == "yrerej")\n    end subroutine test_reverse_string\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\nend module test_palindrome\n\nprogram test\n    use test_palindrome\n    implicit none\n\n    call test_is_palindrome()\n    call test_make_palindrome()\n    call test_reverse_string()\n\n    write(*,*) "All tests passed."\nend program test\n```\n\n### C++ Unit Tests\n\nFor C++, you can use a testing framework like Google Test. Here's how you might write the tests:\n\n```cpp\n#include <gtest/gtest.h>\n#include <string>\n\n// Assume the functions is_palindrome, make_palindrome, and reverse_string are defined in palindrome.h\n#include "palindrome.h"\n\nTEST(PalindromeTest, IsPalindrome) {\n    EXPECT_TRUE(is_palindrome(""));\n    EXPECT_TRUE(is_palindrome("x"));\n    EXPECT_FALSE(is_palindrome("xyz"));\n    EXPECT_TRUE(is_palindrome("xyx"));\n    EXPECT_FALSE(is_palindrome("jerry"));\n}\n\nTEST(PalindromeTest, MakePalindrome) {\n    EXPECT_EQ(make_palindrome(""), "");\n    EXPECT_EQ(make_palindrome("x"), "x");\n    EXPECT_EQ(make_palindrome("xyz"), "xyzyx");\n    EXPECT_EQ(make_palindrome("xyx"), "xyx");\n    EXPECT_EQ(make_palindrome("jerry"), "jerryrrej");\n}\n\nTEST(PalindromeTest, ReverseString) {\n    EXPECT_EQ(reverse_string(""), "");\n    EXPECT_EQ(reverse_string("x"), "x");\n    EXPECT_EQ(reverse_string("xyz"), "zyx");\n    EXPECT_EQ(reverse_string("jerry"), "yrerej");\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\n### Running the Tests\n\n- **Fortran**: Compile the Fortran test program using a Fortran compiler (e.g., `gfortran`) and run the resulting executable. Ensure all functions are accessible, either by including them in the same file or through a module.\n\n- **C++ with Google Test**:\n  1
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses the standard library for string manipulation.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(const std::string& a, const std::string& b) {\n    std::string output;\n    size_t len_a = a.length(), len_b = b.length();\n    size_t min_len = std::min(len_a, len_b);\n\n    for (size_t i = 0; i < min_len; ++i) {\n        if (a[i] == b[i]) {\n            output += '0';\n        } else {\n            output += '1';\n        }\n    }\n\n    if (len_a > len_b) {\n        output += a.substr(min_len);\n    } else if (len_b > len_a) {\n        output += b.substr(min_len);\n    }\n\n    return output;\n}\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_xor("111000", "101010");\n    if (result != "010010") {\n        std::cerr << "Assertion failed: string_xor('111000', '101010') /= '010010'" << std::endl;\n        return 1;\n    }\n\n    result = string_xor("1", "1");\n    if (result != "0") {\n        std::cerr << "Assertion failed: string_xor('1', '1') /= '0'" << std::endl;\n        return 1;\n    }\n\n    result = string_xor("0101", "0000");\n    if (result != "0101") {\n        std::cerr << "Assertion failed: string_xor('0101', '0000') /= '0101'" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nThis C++ code defines a `string_xor` function that performs the same operation as the Fortran function. It compares corresponding characters of the input strings and appends a '0' if they are equal and a '1' if they are different, then concatenates the remaining characters of the longer string. The `main` function contains the test cases similar to the Fortran program.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `string_xor` function in both languages.\n\n### Fortran Unit Test Code\n\nTo compile and run this Fortran code, you might need a Fortran compiler like `gfortran`. Save the code to a file, for example, `test_string_xor.f90`, and then compile and run it using the following commands:\n\n```sh\ngfortran -o test_string_xor test_string_xor.f90\n./test_string_xor\n```\n\n```fortran\nprogram test_string_xor\n    implicit none\n    character(len=:), allocatable :: result\n\n    ! Test cases\n    result = string_xor("111000", "101010")\n    if (result /= "010010") then\n        write(*,*) "Test failed: string_xor('111000', '101010') /= '010010'"\n        call exit(1)\n    end if\n\n    result = string_xor("1", "1")\n    if (result /= "0") then\n        write(*,*) "Test failed: string_xor('1', '1') /= '0'"\n        call exit(1)\n    end if\n\n    result = string_xor("0101", "0000")\n    if (result /= "0101") then\n        write(*,*) "Test failed: string_xor('0101', '0000') /= '0101'"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    function string_xor(a, b) result(output)\n        character(len=*), intent(in) :: a, b\n        character(len=:), allocatable :: output\n        integer :: i, len_a, len_b, min_len\n\n        len_a = len(a)\n        len_b = len(b)\n        min_len = min(len_a, len_b)\n        output = ""\n\n        do i = 1, min_len\n            if (a(i:i) == b(i:i)) then\n                output = output // '0'\n            else\n                output = output // '1'\n            end if\n        end do\n\n        if (len_a > len_b) then\n            output = output // a(min_len+1:len_a)\n        else if (len_b > len_a) then\n            output = output // b(min_len+1:len_b)\n        end if\n    end function string_xor\n\nend program test_string_xor\n```\n\n### C++ Unit Test Code\n\nTo compile and run this C++ code, you might need a C++ compiler like `g++`. Save the code to a file, for example, `test_string_xor.cpp`, and then compile and run it using the following commands:\n\n```sh\ng++ -o test_string_xor test_string_xor.cpp\n./test_string_xor\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(const std::string& a, const std::string& b) {\n    std::string output;\n    size_t len_a = a.length(), len_b = b.length();\n    size_t min_len = std::min(len_a, len_b);\n\n    for (size_t i = 0; i < min_len; ++i) {\n        if (a[i] == b[i]) {\n            output += '0';\n        } else {\n            output += '1';\n        }\n    }\n\n    if (len_a > len_b) {\n        output += a.substr(min_len);\n    } else if (len_b > len_a) {\n        output += b.substr(min_len);\n    }\n\n    return output;\n}\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_xor("111000", "101010");\n    if (result != "010010") {\n        std::cerr << "Test failed: string_xor('111000', '101010') /= '010010'" << std::endl;\n        return 1;\n    }\n\n    result = string_xor("1", "1");\n    if (result != "0") {\n        std::cerr << "Test failed: string_xor('1', '1') /= '0'" << std::endl;\n        return 1;\n    }\n\n    result = string_xor("0101", "0000");\n    if (result != "0101") {\n        std::cerr << "Test failed: string_xor('0101', '0000') /= '0101'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThese unit test codes will verify the correctness of the `string_xor` function in both Fortran and C++ by running the specified test cases. If all tests pass, it will print "All tests passed."
Translating the provided Fortran code to C++ involves a few steps, including adapting the Fortran module and program structure to a C++ class and main function. Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass StringUtils {\npublic:\n    static std::string longest(const std::vector<std::string>& strings) {\n        if (strings.empty()) return "";\n        std::string longestStr = strings[0];\n        for (size_t i = 1; i < strings.size(); ++i) {\n            longestStr = (longestStr.size() > strings[i].size()) ? longestStr : strings[i];\n        }\n        return longestStr;\n    }\n};\n\nint main() {\n    // Test case 1: Empty array\n    std::vector<std::string> strings1 = {};\n    std::string result1 = StringUtils::longest(strings1);\n    if (!result1.empty()) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2: Array with single character strings\n    std::vector<std::string> strings2 = {"x", "y", "z"};\n    std::string result2 = StringUtils::longest(strings2);\n    if (result2 != "x") {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3: Array with varying length strings\n    std::vector<std::string> strings3 = {"x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "};\n    std::string result3 = StringUtils::longest(strings3);\n    if (result3 != "zzzz    ") {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Class Definition**: The Fortran module `string_utils` is translated to a C++ class `StringUtils`. The `longest` function is made static and public so it can be called without instantiating the class.\n\n2. **Function Implementation**: The Fortran function `longest` is translated into a C++ function. It takes a vector of strings as input and returns the longest string.\n\n3. **Main Function**: The `main` function in C++ serves as the entry point for the program. It includes test cases similar to the Fortran program.\n\n4. **Test Cases**: The test cases are implemented using vectors of strings and checking the results against expected outcomes. If a test case fails, an error message is printed, and the program exits with a non-zero status.\n\nThis C++ code should behave similarly to the original Fortran code, providing the same functionality and passing the same test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `longest` function in both implementations.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule string_utils\n    implicit none\n    contains\n\n    function longest(strings) result(out)\n        implicit none\n        character(len=*), dimension(:), intent(in) :: strings\n        character(len=:), allocatable :: out\n        integer :: i\n\n        out = ""\n        do i = 1, size(strings)\n            if (len_trim(strings(i)) > len_trim(out)) then\n                out = strings(i)\n            end if\n        end do\n    end function longest\n\nend module string_utils\n\nprogram main\n    use string_utils\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test case 1: Empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = longest(strings)\n    if (result /= "") then\n        write(*,*) "Test case 1 failed: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 2: Array with single character strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(3))\n    strings = ["x", "y", "z"]\n    result = longest(strings)\n    if (result /= "x") then\n        write(*,*) "Test case 2 failed: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 3: Array with varying length strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(6))\n    strings = ["x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "]\n    result = longest(strings)\n    if (result /= "zzzz    ") then\n        write(*,*) "Test case 3 failed: assertion failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass StringUtils {\npublic:\n    static std::string longest(const std::vector<std::string>& strings) {\n        if (strings.empty()) return "";\n        std::string longestStr = strings[0];\n        for (size_t i = 1; i < strings.size(); ++i) {\n            longestStr = (longestStr.size() > strings[i].size()) ? longestStr : strings[i];\n        }\n        return longestStr;\n    }\n};\n\nint main() {\n    // Test case 1: Empty array\n    std::vector<std::string> strings1 = {};\n    std::string result1 = StringUtils::longest(strings1);\n    if (!result1.empty()) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2: Array with single character strings\n    std::vector<std::string> strings2 = {"x", "y", "z"};\n    std::string result2 = StringUtils::longest(strings2);\n    if (result2 != "x") {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3: Array with varying length strings\n    std::vector<std::string> strings3 = {"x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "};\n    std::string result3 = StringUtils::longest(strings3);\n    if (result3 != "zzzz    ") {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test**:\n   - The Fortran program includes a module `string_utils` with the `longest` function and a main program that tests this function with different inputs.\n   - The test cases include checking for an empty array, an array with single character strings, and an array with strings of varying lengths.\n\n2. **C++ Unit Test**:\n   - The C++ code defines a `StringUtils` class with a static `longest` function and a `main` function that tests this function with the same set of test cases as the Fortran version.\n   - The test cases are designed to ensure that the `longest` function behaves correctly in both C++ and Fortran.\n\nTo compile and run these tests:\n\n- For Fortran, use a Fortran compiler like `gfortran`:\n  ```sh\n  gfortran -o test_fortran test_fortran.f90\n  ./test_fortran\n  ```\n- For C++, use a C++ compiler like `g++`:\n  ```sh\n  g++ -o test_cpp test_cpp.cpp\n  ./test_cpp\n  ```\n\nThese tests should confirm that the `longest
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the `greatest_common_divisor` function and the `assert` function to verify the correctness of the GCD calculation.\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\n// Function to calculate the greatest common divisor\nint greatest_common_divisor(int a, int b) {\n    int temp_a = a, temp_b = b;\n\n    while (true) {\n        if (temp_a < temp_b) {\n            std::swap(temp_a, temp_b);\n        }\n        temp_a = temp_a % temp_b;\n        if (temp_a == 0) {\n            return temp_b;\n        }\n    }\n}\n\n// Assert function to verify the correctness\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(greatest_common_divisor(3, 7) == 1, "Assertion failed: gcd(3, 7) == 1");\n    assert(greatest_common_divisor(10, 15) == 5, "Assertion failed: gcd(10, 15) == 5");\n    assert(greatest_common_divisor(49, 14) == 7, "Assertion failed: gcd(49, 14) == 7");\n    assert(greatest_common_divisor(144, 60) == 12, "Assertion failed: gcd(144, 60) == 12");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines the `greatest_common_divisor` function, which computes the greatest common divisor of two integers using the Euclidean algorithm. The `assert` function is used to verify the correctness of the `greatest_common_divisor` function with various test cases. If any test case fails, the program will print the corresponding message and exit with a non-zero status. If all tests pass, it will print a success message.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `greatest_common_divisor` function with various inputs.\n\n### Fortran Unit Tests\n\nTo compile and run the Fortran code, you can use a Fortran compiler like `gfortran`. Here is the complete Fortran code with the unit tests:\n\n```fortran\nmodule gcd_module\n  implicit none\n\ncontains\n\n  integer function greatest_common_divisor(a, b)\n    implicit none\n    integer, intent(in) :: a, b\n    integer :: m, temp_a, temp_b\n\n    temp_a = a\n    temp_b = b\n\n    do\n      if (temp_a < temp_b) then\n        m = temp_a\n        temp_a = temp_b\n        temp_b = m\n      end if\n      temp_a = mod(temp_a, temp_b)\n      if (temp_a == 0) then\n        greatest_common_divisor = temp_b\n        return\n      end if\n    end do\n  end function greatest_common_divisor\n\n  subroutine assert(condition, message)\n    implicit none\n    logical, intent(in) :: condition\n    character(len=*), intent(in) :: message\n\n    if (.not. condition) then\n      write(*,*) message\n      call exit(1)\n    end if\n  end subroutine assert\n\nend module gcd_module\n\nprogram main\n  use gcd_module\n  implicit none\n\n  call assert(greatest_common_divisor(3, 7) == 1, "Assertion failed: gcd(3, 7) == 1")\n  call assert(greatest_common_divisor(10, 15) == 5, "Assertion failed: gcd(10, 15) == 5")\n  call assert(greatest_common_divisor(49, 14) == 7, "Assertion failed: gcd(49, 14) == 7")\n  call assert(greatest_common_divisor(144, 60) == 12, "Assertion failed: gcd(144, 60) == 12")\n\n  print *, "All tests passed successfully."\nend program main\n```\n\n### C++ Unit Tests\n\nTo compile and run the C++ code, you can use a C++ compiler like `g++`. Here is the complete C++ code with the unit tests:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <string>\n\n// Function to calculate the greatest common divisor\nint greatest_common_divisor(int a, int b) {\n    int temp_a = a, temp_b = b;\n\n    while (true) {\n        if (temp_a < temp_b) {\n            std::swap(temp_a, temp_b);\n        }\n        temp_a = temp_a % temp_b;\n        if (temp_a == 0) {\n            return temp_b;\n        }\n    }\n}\n\n// Assert function to verify the correctness\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(greatest_common_divisor(3, 7) == 1, "Assertion failed: gcd(3, 7) == 1");\n    assert(greatest_common_divisor(10, 15) == 5, "Assertion failed: gcd(10, 15) == 5");\n    assert(greatest_common_divisor(49, 14) == 7, "Assertion failed: gcd(49, 14) == 7");\n    assert(greatest_common_divisor(144, 60) == 12, "Assertion failed: gcd(144, 60) == 12");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n- **For Fortran:**\n  ```sh\n  gfortran -o gcd_test your_fortran_file.f90\n  ./gcd_test\n  ```\n\n- **For C++:**\n  ```sh\n  g++ -o gcd_test your_cpp_file.cpp\n  ./gcd_test\n  ```\n\nThese commands will compile and run the respective programs, executing the unit tests and verifying the correctness of the `greatest_common_divisor` function.
Translating the provided Fortran code to C++ involves a few steps, including adapting the array handling and string manipulation to C++ standards. Here's a C++ version of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid all_prefixes(const std::string& str, std::vector<std::string>& out) {\n    if (str.empty()) {\n        out.push_back("");\n        return;\n    }\n\n    out.clear();\n    std::string current;\n    for (size_t i = 0; i < str.length(); ++i) {\n        current += str[i];\n        out.push_back(current);\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<std::string> prefixes;\n    std::vector<std::string> expected;\n\n    // Test case 1\n    all_prefixes("", prefixes);\n    expected = {""};\n    assert(issame(prefixes, expected));\n\n    // Test case 2\n    all_prefixes("asdfgh", prefixes);\n    expected = {"a", "as", "asd", "asdf", "asdfg", "asdfgh"};\n    assert(issame(prefixes, expected));\n\n    // Test case 3\n    all_prefixes("WWW", prefixes);\n    expected = {"W", "WW", "WWW"};\n    assert(issame(prefixes, expected));\n\n    return 0;\n}\n```\n\nThis C++ code does the following:\n- Uses `std::vector<std::string>` for dynamic arrays of strings, similar to the Fortran allocatable arrays.\n- Implements the `all_prefixes` function to generate all prefixes of a given string, similar to the Fortran subroutine.\n- Implements the `issame` function to compare two vectors of strings, checking if they contain the same strings in the same order.\n- The `assert` function is a simple assertion utility that prints an error message and exits if the condition is false.\n\nThis code should compile with a C++11 or later compiler, as it uses features like `std::vector` and `std::string`.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can create unit tests that cover the specified test cases.\n\n### Fortran Unit Tests\n\nFor the Fortran code, we'll modify the original program to include a testing framework. Fortran doesn't have a built-in unit testing framework like some other languages, so we'll implement a simple test mechanism.\n\n```fortran\nprogram main\n    implicit none\n    character(len=:), allocatable :: str\n    character(len=:), allocatable :: current\n    character(len=:), allocatable, dimension(:) :: prefixes\n    character(len=:), allocatable, dimension(:) :: expected\n    integer :: i\n\n    ! Test cases\n    call test_case("", "a     ", "as    ", "asd   ", "asdf  ", "asdfg ", "asdfgh")\n    call test_case("asdfgh", "a     ", "as    ", "asd   ", "asdf  ", "asdfg ", "asdfgh")\n    call test_case("WWW", "W  ", "WW ", "WWW")\n\ncontains\n\n    subroutine all_prefixes(str, out)\n        character(len=*), intent(in) :: str\n        character(len=:), allocatable, dimension(:), intent(out) :: out\n        character(len=:), allocatable :: current\n        integer :: i\n\n        if (len(str) == 0) then\n            allocate(character(len=1) :: out(1))\n            out(1) = ""\n            return\n        end if\n\n        allocate(character(len=len(str)) :: out(len(str)))\n        current = ""\n        do i = 1, len(str)\n            current = current // str(i:i)\n            out(i) = current\n        end do\n    end subroutine all_prefixes\n\n    logical function issame(a, b)\n        character(len=:), allocatable, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\n    subroutine test_case(str, expected)\n        character(len=*), intent(in) :: str\n        character(len=*), intent(in) :: expected(:)\n        character(len=:), allocatable, dimension(:) :: prefixes\n        call all_prefixes(str, prefixes)\n        call assert(issame(prefixes, expected))\n    end subroutine test_case\n\nend program main\n```\n\n### C++ Unit Tests\n\nFor the C++ code, we can use a testing framework like Google Test for more comprehensive testing. However, for simplicity, we'll implement a basic test mechanism similar to the Fortran version.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid all_prefixes(const std::string& str, std::vector<std::string>& out) {\n    if (str.empty()) {\n        out.push_back("");\n        return;\n    }\n\n    out.clear();\n    std::string current;\n    for (size_t i = 0; i < str.length(); ++i) {\n        current += str[i];\n        out.push_back(current);\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid test_case(const std::string& str, const std::vector<std::string>& expected) {\n    std::vector<std::string> prefixes;\n    all_prefixes(str, prefixes);\n    assert(issame(prefixes, expected));\n}\n\nint main() {\n    // Test case 1\n    test_case("", {""});\n\n    // Test case 2\n    test_case("asdfgh", {"a", "as", "asd", "asdf", "asdfg", "asdfgh"});\n\n    // Test case 3\n    test_case("WWW", {"W", "WW", "WWW"});\n\n    return 0;\n}\n```\n\nThese unit tests cover the specified test cases for both the Fortran and C++ implementations. They check if the `all_prefixes` function correctly generates all prefixes of a given string and compares the result against the expected output.
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code includes the necessary headers and uses standard I/O streams for output.\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    ss << "0";\n    for (int i = 1; i <= n; ++i) {\n        ss << " " << i;\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_sequence(0);\n    if (result != "0") {\n        std::cerr << "Assertion failed: string_sequence(0) == '0'" << std::endl;\n        exit(1);\n    }\n\n    result = string_sequence(3);\n    if (result != "0 1 2 3") {\n        std::cerr << "Assertion failed: string_sequence(3) == '0 1 2 3'" << std::endl;\n        exit(1);\n    }\n\n    result = string_sequence(10);\n    if (result != "0 1 2 3 4 5 6 7 8 9 10") {\n        std::cerr << "Assertion failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a `string_sequence` function that generates a string representation of a sequence of numbers from 0 to `n`, similar to the Fortran version. The `main` function contains test cases that verify the correctness of the `string_sequence` function. If any test fails, the program prints an error message and exits with a non-zero status code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `string_sequence` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_string_sequence\n    implicit none\n    character(len=100) :: result\n\n    ! Test cases\n    result = string_sequence(0)\n    if (trim(result) /= "0") then\n        write(*,*) "Test failed: string_sequence(0) == '0'"\n        call exit(1)\n    end if\n\n    result = string_sequence(3)\n    if (trim(result) /= "0 1 2 3") then\n        write(*,*) "Test failed: string_sequence(3) == '0 1 2 3'"\n        call exit(1)\n    end if\n\n    result = string_sequence(10)\n    if (trim(result) /= "0 1 2 3 4 5 6 7 8 9 10") then\n        write(*,*) "Test failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    function string_sequence(n) result(out)\n        implicit none\n        integer, intent(in) :: n\n        character(len=100) :: out\n        integer :: i\n        character(len=10) :: temp\n\n        out = "0"\n        do i = 1, n\n            write(temp, '(I0)') i\n            out = trim(out) // " " // trim(temp)\n        end do\n    end function string_sequence\n\nend program test_string_sequence\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    ss << "0";\n    for (int i = 1; i <= n; ++i) {\n        ss << " " << i;\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_sequence(0);\n    if (result != "0") {\n        std::cerr << "Test failed: string_sequence(0) == '0'" << std::endl;\n        exit(1);\n    }\n\n    result = string_sequence(3);\n    if (result != "0 1 2 3") {\n        std::cerr << "Test failed: string_sequence(3) == '0 1 2 3'" << std::endl;\n        exit(1);\n    }\n\n    result = string_sequence(10);\n    if (result != "0 1 2 3 4 5 6 7 8 9 10") {\n        std::cerr << "Test failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThese unit test codes are designed to be directly runnable. They will execute the tests for the `string_sequence` function and print a message indicating whether all tests passed or if any test failed. If a test fails, the program will also print the specific failure message.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same functionality as the Fortran code, including the `count_distinct_characters` function and the `to_lower` function.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype> // For std::tolower\n\n// Function to count distinct characters in a string\nint count_distinct_characters(const std::string& str) {\n    std::string lower_str = to_lower(str);\n    std::vector<char> distinct;\n    int count = 0;\n\n    for (char c : lower_str) {\n        if (std::find(distinct.begin(), distinct.end(), c) == distinct.end()) {\n            distinct.push_back(c);\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Function to convert a string to lowercase\nstd::string to_lower(const std::string& str) {\n    std::string lower_str = str;\n    for (char& c : lower_str) {\n        c = std::tolower(static_cast<unsigned char>(c));\n    }\n    return lower_str;\n}\n\nint main() {\n    // Test cases\n    std::string str;\n    int result;\n\n    str = "";\n    result = count_distinct_characters(str);\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_distinct_characters('') == 0" << std::endl;\n        return 1;\n    }\n\n    str = "abcde";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('abcde') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "abcdecadeCADE";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('abcdecadeCADE') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "aaaaAAAAaaaa";\n    result = count_distinct_characters(str);\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_distinct_characters('aaaaAAAAaaaa') == 1" << std::endl;\n        return 1;\n    }\n\n    str = "Jerry jERRY JeRRRY";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('Jerry jERRY JeRRRY') == 5" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses `std::vector<char>` for the distinct characters array, which is a more common and flexible approach in C++ for dynamic arrays compared to raw arrays. The `std::tolower` function from `<cctype>` is used to convert characters to lowercase, and `std::find` from `<algorithm>` is used to check if a character is already in the distinct characters vector. This code should compile and run in any standard C++ environment.
Translating the given Fortran code to C++ involves several steps, including adapting the array handling, string manipulation, and function definitions to C++ syntax and semantics. Here's a C++ version of the code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nstd::vector<int> parse_music(const std::string& music_string) {\n    std::vector<int> out;\n    std::string current;\n    std::string local_music_string = music_string;\n\n    if (!local_music_string.empty()) {\n        local_music_string += ' ';\n    }\n\n    for (size_t i = 0; i < local_music_string.size(); ++i) {\n        if (local_music_string[i] == ' ') {\n            if (current == "o") {\n                out.push_back(4);\n            } else if (current == "o|") {\n                out.push_back(2);\n            } else if (current == ".|") {\n                out.push_back(1);\n            }\n            current.clear();\n        } else {\n            current += local_music_string[i];\n        }\n    }\n\n    return out;\n}\n\nvoid append(std::vector<int>& array, int value) {\n    array.push_back(value);\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(issame(parse_music(""), std::vector<int>{}));\n    assert(issame(parse_music("o o o o"), std::vector<int>{4, 4, 4, 4}));\n    assert(issame(parse_music(".| .| .| .|"), std::vector<int>{1, 1, 1, 1}));\n    assert(issame(parse_music("o| o| .| .| o o o o"), std::vector<int>{2, 2, 1, 1, 4, 4, 4, 4}));\n    assert(issame(parse_music("o| .| o| .| o o| o o|"), std::vector<int>{2, 1, 2, 1, 4, 2, 4, 2}));\n\n    return 0;\n}\n```\n\n### Key Differences and Adaptions:\n\n1. **Array Handling**: C++ uses `std::vector` for dynamic arrays, which is more flexible and safer than raw arrays.\n2. **String Handling**: C++'s `std::string` is used for string manipulation, which simplifies operations like concatenation and clearing.\n3. **Function Definitions**: Functions like `parse_music`, `append`, and `issame` are defined with C++ syntax.\n4. **Assertions**: The `assert` function is implemented to terminate the program if a condition is not met, similar to the Fortran version.\n5. **Test Cases**: The `main` function contains test cases that use the `assert` function to verify the correctness of the `parse_music` function.\n\nThis C++ code should behave similarly to the original Fortran code, parsing music strings and comparing the results against expected outcomes.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `parse_music` function in both languages.\n\n### Fortran Unit Test Code\n\nThis Fortran code includes the `music_parser` program with the `parse_music` function and the `assert` subroutine for testing.\n\n```fortran\nprogram music_parser_test\n    implicit none\n    integer, dimension(:), allocatable :: result\n\n    ! Test cases\n    call assert(issame(parse_music(""), [0]))\n    call assert(issame(parse_music("o o o o"), [4, 4, 4, 4]))\n    call assert(issame(parse_music(".| .| .| .|"), [1, 1, 1, 1]))\n    call assert(issame(parse_music("o| o| .| .| o o o o"), [2, 2, 1, 1, 4, 4, 4, 4]))\n    call assert(issame(parse_music("o| .| o| .| o o| o o|"), [2, 1, 2, 1, 4, 2, 4, 2]))\n\ncontains\n\n    function parse_music(music_string) result(out)\n        character(len=*), intent(in) :: music_string\n        integer, dimension(:), allocatable :: out\n        character(len=100) :: current, local_music_string\n        integer :: i, len_music\n\n        current = ""\n        local_music_string = trim(music_string)\n        len_music = len_trim(local_music_string)\n        if (len_music > 0) then\n            local_music_string = local_music_string // ' '\n        end if\n\n        allocate(out(0))\n        do i = 1, len(local_music_string)\n            if (local_music_string(i:i) == ' ') then\n                if (trim(current) == "o") then\n                    call append(out, 4)\n                else if (trim(current) == "o|") then\n                    call append(out, 2)\n                else if (trim(current) == ".|") then\n                    call append(out, 1)\n                end if\n                current = ""\n            else\n                current = trim(current) // local_music_string(i:i)\n            end if\n        end do\n        print *, "Parsed music string: ", out\n    end function parse_music\n\n    subroutine append(array, value)\n        integer, dimension(:), allocatable, intent(inout) :: array\n        integer, intent(in) :: value\n        integer, dimension(:), allocatable :: temp\n        integer :: n\n\n        n = size(array)\n        allocate(temp(n + 1))\n        if (n > 0) then\n            temp(1:n) = array\n        end if\n        temp(n + 1) = value\n        deallocate(array)\n        allocate(array(n + 1))\n        array = temp\n        deallocate(temp)\n    end subroutine append\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n        print *, "Comparing arrays: ", a, b, " Result: ", is_equal\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program music_parser_test\n```\n\n### C++ Unit Test Code\n\nThis C++ code includes the `parse_music` function, `append` function, `issame` function, and the `assert` function for testing.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nstd::vector<int> parse_music(const std::string& music_string) {\n    std::vector<int> out;\n    std::string current;\n    std::string local_
Certainly! Below is the equivalent C++ code for the provided Fortran code. This C++ code includes the necessary headers and uses the standard library for string manipulation and I/O operations.\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Function to count the number of times a substring occurs in a string\nint how_many_times(const std::string& str, const std::string& substring) {\n    int out = 0;\n    size_t str_len = str.length();\n    size_t sub_len = substring.length();\n\n    if (str_len == 0) {\n        return 0;\n    }\n\n    for (size_t i = 0; i < str_len - sub_len + 1; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            out++;\n        }\n    }\n\n    return out;\n}\n\nint main() {\n    // Test cases\n    if (how_many_times("", "x") != 0) {\n        std::cerr << "Assertion failed: how_many_times('', 'x') == 0" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("xyxyxyx", "x") != 4) {\n        std::cerr << "Assertion failed: how_many_times('xyxyxyx', 'x') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("cacacacac", "cac") != 4) {\n        std::cerr << "Assertion failed: how_many_times('cacacacac', 'cac') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("john doe", "john") != 1) {\n        std::cerr << "Assertion failed: how_many_times('john doe', 'john') == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a function `how_many_times` that takes two strings as input and returns the number of times the second string occurs in the first string. The `main` function contains several test cases to verify the correctness of the `how_many_times` function. If any of the test cases fail, the program will print an error message and return a non-zero exit code. Otherwise, it will print "All tests passed." indicating success.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `how_many_times` function in both languages.\n\n### Fortran Unit Tests\n\nTo compile and run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Here is the complete Fortran code including the module and the test program:\n\n```fortran\nmodule string_utils\n    implicit none\n    contains\n        integer function how_many_times(str, substring)\n            character(len=*), intent(in) :: str, substring\n            integer :: i, out, str_len, sub_len\n\n            out = 0\n            str_len = len(str)\n            sub_len = len(substring)\n\n            if (str_len == 0) then\n                how_many_times = 0\n                return\n            end if\n\n            do i = 1, str_len - sub_len + 1\n                if (str(i:i+sub_len-1) == substring) then\n                    out = out + 1\n                end if\n            end do\n\n            how_many_times = out\n        end function how_many_times\nend module string_utils\n\nprogram main\n    use string_utils\n    implicit none\n    integer :: result\n\n    ! Test cases\n    result = how_many_times("", "x")\n    if (result /= 0) then\n        write(*,*) "Assertion failed: how_many_times('', 'x') == 0"\n        call exit(1)\n    end if\n\n    result = how_many_times("xyxyxyx", "x")\n    if (result /= 4) then\n        write(*,*) "Assertion failed: how_many_times('xyxyxyx', 'x') == 4"\n        call exit(1)\n    end if\n\n    result = how_many_times("cacacacac", "cac")\n    if (result /= 4) then\n        write(*,*) "Assertion failed: how_many_times('cacacacac', 'cac') == 4"\n        call exit(1)\n    end if\n\n    result = how_many_times("john doe", "john")\n    if (result /= 1) then\n        write(*,*) "Assertion failed: how_many_times('john doe', 'john') == 1"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\nend program main\n```\n\nTo compile and run the Fortran code, you can use the following commands in a terminal:\n\n```sh\ngfortran -o string_utils_test string_utils_test.f90\n./string_utils_test\n```\n\n### C++ Unit Tests\n\nHere is the complete C++ code including the `how_many_times` function and the test cases:\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Function to count the number of times a substring occurs in a string\nint how_many_times(const std::string& str, const std::string& substring) {\n    int out = 0;\n    size_t str_len = str.length();\n    size_t sub_len = substring.length();\n\n    if (str_len == 0) {\n        return 0;\n    }\n\n    for (size_t i = 0; i < str_len - sub_len + 1; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            out++;\n        }\n    }\n\n    return out;\n}\n\nint main() {\n    // Test cases\n    if (how_many_times("", "x") != 0) {\n        std::cerr << "Assertion failed: how_many_times('', 'x') == 0" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("xyxyxyx", "x") != 4) {\n        std::cerr << "Assertion failed: how_many_times('xyxyxyx', 'x') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("cacacacac", "cac") != 4) {\n        std::cerr << "Assertion failed: how_many_times('cacacacac', 'cac') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("john doe", "john") != 1) {\n        std::cerr << "Assertion failed: how_many_times('john doe', 'john') == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nTo compile and run the C++ code, you can use the following commands in a terminal:\n\n```sh\ng++ -o string_utils_test string_utils_test.cpp\n./string_utils_test\n```\n\nThese unit tests will verify the correctness of the `how_many_times` function in both Fortran and C++. If any of the tests fail, the program will print an error message and exit with a non-zero status. Otherwise, it will print "All tests passed." indicating success.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(const std::vector<float>& numbers) {\n    std::vector<float> out(2, 0.0f);\n    float min_diff = std::numeric_limits<float>::infinity();\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n                min_diff = diff;\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        std::swap(out[0], out[1]);\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b, float epsilon = 1e-4) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > epsilon) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<float> test1 = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    std::vector<float> test2 = {1.0, 2.0, 5.9, 4.0, 5.0};\n    std::vector<float> test3 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    std::vector<float> test4 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    std::vector<float> test5 = {1.1, 2.2, 3.1, 4.1, 5.1};\n\n    std::vector<float> result;\n\n    result = find_closest_elements(test1);\n    if (!issame(result, {3.9, 4.0})) {\n        std::cerr << "Assertion failed for test1" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test2);\n    if (!issame(result, {5.0, 5.9})) {\n        std::cerr << "Assertion failed for test2" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test3);\n    if (!issame(result, {2.0, 2.2})) {\n        std::cerr << "Assertion failed for test3" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test4);\n    if (!issame(result, {2.0, 2.0})) {\n        std::cerr << "Assertion failed for test4" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test5);\n    if (!issame(result, {2.2, 3.1})) {\n        std::cerr << "Assertion failed for test5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses the standard library features such as `std::vector` for dynamic arrays and `std::abs` for calculating the absolute value. The `find_closest_elements` function and the `issame` function are implemented similarly to the Fortran code, with adjustments for C++ syntax and conventions.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `find_closest_elements` and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\n    contains\n\n    function find_closest_elements(numbers) result(out)\n        implicit none\n        real, dimension(:), intent(in) :: numbers\n        real, dimension(:), allocatable :: out\n        integer :: i, j\n        real :: min_diff\n\n        allocate(out(2))\n        out = [0.0, 0.0]\n        min_diff = huge(1.0)\n\n        do i = 1, size(numbers)\n            do j = i + 1, size(numbers)\n                if (abs(numbers(i) - numbers(j)) < min_diff) then\n                    out = [numbers(i), numbers(j)]\n                    min_diff = abs(numbers(i) - numbers(j))\n                end if\n            end do\n        end do\n\n        if (out(1) > out(2)) then\n            out = [out(2), out(1)]\n        end if\n    end function find_closest_elements\n\n    logical function issame(a, b)\n        implicit none\n        real, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (abs(a(i) - b(i)) > 1e-4) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    real, dimension(:), allocatable :: result\n    real, dimension(6) :: test1 = [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]\n    real, dimension(5) :: test2 = [1.0, 2.0, 5.9, 4.0, 5.0]\n    real, dimension(6) :: test3 = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    real, dimension(6) :: test4 = [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n    real, dimension(5) :: test5 = [1.1, 2.2, 3.1, 4.1, 5.1]\n\n    allocate(result(2))\n    result = find_closest_elements(test1)\n    if (.not. issame(result, [3.9, 4.0])) then\n        write(*,*) "Assertion failed for test1"\n        call exit(1)\n    end if\n\n    result = find_closest_elements(test2)\n    if (.not. issame(result, [5.0, 5.9])) then\n        write(*,*) "Assertion failed for test2"\n        call exit(1)\n    end if\n\n    result = find_closest_elements(test3)\n    if (.not. issame(result, [2.0, 2.2])) then\n        write(*,*) "Assertion failed for test3"\n        call exit(1)\n    end if\n\n    result = find_closest_elements(test4)\n    if (.not. issame(result, [2.0, 2.0])) then\n        write(*,*) "Assertion failed for test4"\n        call exit(1)\n    end if\n\n    result = find_closest_elements(test5)\n    if (.not. issame(result, [2.2, 3.1])) then\n        write(*,*) "Assertion failed for test5"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed"\n    deallocate(result)\nend program main\n```\n\n
Translating the provided Fortran code to C++ involves a few steps, including adapting the array handling, function definitions, and I/O operations to C++ conventions. Here's how the Fortran code could be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> rescale_to_unit(const std::vector<float>& numbers) {\n    std::vector<float> rescaled(numbers.size());\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return rescaled;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<float> numbers;\n    std::vector<float> result;\n    std::vector<float> expected1 = {0.0, 1.0};\n    std::vector<float> expected2 = {1.0, 0.0};\n    std::vector<float> expected3 = {0.0, 0.25, 0.5, 0.75, 1.0};\n    std::vector<float> expected4 = {0.25, 0.0, 1.0, 0.5, 0.75};\n    std::vector<float> expected5 = {0.25, 0.0, 1.0, 0.5, 0.75};\n\n    // Test case 1\n    numbers = {2.0, 49.9};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    numbers = {100.0, 49.9};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    numbers = {1.0, 2.0, 3.0, 4.0, 5.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    numbers = {2.0, 1.0, 5.0, 3.0, 4.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for test case 4" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    numbers = {12.0, 11.0, 15.0, 13.0, 14.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected5)) {\n        std::cerr << "Assertion failed for test case 5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers, uses `std::vector` for dynamic arrays, and defines the `rescale_to_unit` and `issame` functions to perform the same operations as the Fortran code. The `main` function contains the test cases, similar to the Fortran program. Note that C++ uses zero-based indexing, but since the code here is directly translated from Fortran, the indexing starts from 0 as well.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can write unit tests that cover the specified test cases. Below are the unit test codes for both languages.\n\n### Fortran Unit Test Code\n\nTo test the Fortran code, we can create a separate program that calls the `rescale_to_unit` function with different inputs and checks if the outputs match the expected results.\n\n```fortran\nprogram test_rescale_unit\n    implicit none\n    real, allocatable :: numbers(:), result(:)\n    real, dimension(2) :: expected1 = [0.0, 1.0]\n    real, dimension(2) :: expected2 = [1.0, 0.0]\n    real, dimension(5) :: expected3 = [0.0, 0.25, 0.5, 0.75, 1.0]\n    real, dimension(5) :: expected4 = [0.25, 0.0, 1.0, 0.5, 0.75]\n    real, dimension(5) :: expected5 = [0.25, 0.0, 1.0, 0.5, 0.75]\n\n    ! Test case 1\n    allocate(numbers(2))\n    numbers = [2.0, 49.9]\n    result = rescale_to_unit(numbers)\n    if (.not. issame(result, expected1)) then\n        write(*,*) "Test case 1 failed"\n    else\n        write(*,*) "Test case 1 passed"\n    end if\n    deallocate(numbers)\n\n    ! Test case 2\n    allocate(numbers(2))\n    numbers = [100.0, 49.9]\n    result = rescale_to_unit(numbers)\n    if (.not. issame(result, expected2)) then\n        write(*,*) "Test case 2 failed"\n    else\n        write(*,*) "Test case 2 passed"\n    end if\n    deallocate(numbers)\n\n    ! Test case 3\n    allocate(numbers(5))\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    result = rescale_to_unit(numbers)\n    if (.not. issame(result, expected3)) then\n        write(*,*) "Test case 3 failed"\n    else\n        write(*,*) "Test case 3 passed"\n    end if\n    deallocate(numbers)\n\n    ! Test case 4\n    allocate(numbers(5))\n    numbers = [2.0, 1.0, 5.0, 3.0, 4.0]\n    result = rescale_to_unit(numbers)\n    if (.not. issame(result, expected4)) then\n        write(*,*) "Test case 4 failed"\n    else\n        write(*,*) "Test case 4 passed"\n    end if\n    deallocate(numbers)\n\n    ! Test case 5\n    allocate(numbers(5))\n    numbers = [12.0, 11.0, 15.0, 13.0, 14.0]\n    result = rescale_to_unit(numbers)\n    if (.not. issame(result, expected5)) then\n        write(*,*) "Test case 5 failed"\n    else\n        write(*,*) "Test case 5 passed"\n    end if\n    deallocate(numbers)\n\ncontains\n\n    function rescale_to_unit(numbers) result(rescaled)\n        implicit none\n        real, intent(in) :: numbers(:)\n        real, allocatable :: rescaled(:)\n        real :: min_val, max_val\n        integer :: i\n\n        allocate(rescaled(size(numbers)))\n        min_
Certainly! Below is the equivalent C++ code for the provided Fortran code. This C++ code includes the necessary headers and uses standard I/O streams for output.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to get the length of a string\nint strlen(const std::string& str) {\n    return str.length();\n}\n\nvoid run_assertions() {\n    // Assertions\n    if (strlen("") != 0) {\n        std::cerr << "Assertion failed: strlen(\"\") == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen("x") != 1) {\n        std::cerr << "Assertion failed: strlen(\"x\") == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen("asdasnakj") != 9) {\n        std::cerr << "Assertion failed: strlen(\"asdasnakj\") == 9" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nint main() {\n    // Main program logic\n    run_assertions();\n    return 0;\n}\n```\n\n### Explanation:\n1. **Headers and Namespaces:**\n   - `#include <iostream>` for input/output operations.\n   - `#include <string>` for using the `std::string` class.\n   - `#include <cstdlib>` for using the `std::exit()` function.\n\n2. **Function `strlen`:**\n   - This function takes a `const std::string&` as its parameter and returns the length of the string using the `length()` member function of `std::string`.\n\n3. **Subroutine `run_assertions`:**\n   - This function contains the assertions. If any assertion fails, it prints an error message to `std::cerr` and exits the program using `std::exit(1)`.\n\n4. **Main Function:**\n   - The `main` function calls `run_assertions` to run the assertions.\n\nThis C++ code should behave similarly to the provided Fortran code, executing the assertions and printing the results to the console.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `strlen` function and the `run_assertions` subroutine/function.\n\n### Fortran Unit Test Code\n\nTo test the Fortran code, you can create a separate Fortran program that calls the `run_assertions` subroutine and checks the output. Here is an example:\n\n```fortran\nprogram test_main\n    implicit none\n\n    ! Main program logic\n    call run_assertions()\n\ncontains\n\n    ! Function to get the length of a string\n    integer function strlen(str)\n        character(len=*), intent(in) :: str\n        strlen = len_trim(str)\n    end function strlen\n\n    subroutine run_assertions()\n        ! Assertions\n        if (strlen('') /= 0) then\n            write(*,*) 'Assertion failed: strlen("") == 0'\n            call exit(1)\n        end if\n\n        if (strlen('x') /= 1) then\n            write(*,*) 'Assertion failed: strlen("x") == 1'\n            call exit(1)\n        end if\n\n        if (strlen('asdasnakj') /= 9) then\n            write(*,*) 'Assertion failed: strlen("asdasnakj") == 9'\n            call exit(1)\n        end if\n\n        write(*,*) 'All assertions passed.'\n    end subroutine run_assertions\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\nFor the C++ code, you can use a simple main function to call the `run_assertions` function and check the output. Here is an example:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to get the length of a string\nint strlen(const std::string& str) {\n    return str.length();\n}\n\nvoid run_assertions() {\n    // Assertions\n    if (strlen("") != 0) {\n        std::cerr << "Assertion failed: strlen(\"\") == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen("x") != 1) {\n        std::cerr << "Assertion failed: strlen(\"x\") == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen("asdasnakj") != 9) {\n        std::cerr << "Assertion failed: strlen(\"asdasnakj\") == 9" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nint main() {\n    // Main program logic\n    run_assertions();\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test:**\n   - The `test_main` program calls the `run_assertions` subroutine.\n   - The `run_assertions` subroutine contains the assertions. If any assertion fails, it prints an error message and exits the program with a non-zero status.\n   - If all assertions pass, it prints "All assertions passed."\n\n2. **C++ Unit Test:**\n   - The `main` function calls the `run_assertions` function.\n   - The `run_assertions` function contains the assertions. If any assertion fails, it prints an error message to `std::cerr` and exits the program using `std::exit(1)`.\n   - If all assertions pass, it prints "All assertions passed."\n\n### Running the Tests:\n\nTo run the Fortran unit test, you can compile and execute the Fortran code using a Fortran compiler like `gfortran`:\n\n```sh\ngfortran -o test_fortran test_main.f90\n./test_fortran\n```\n\nTo run the C++ unit test, you can compile and execute the C++ code using a C++ compiler like `g++`:\n\n```sh\ng++ -o test_cpp test_main.cpp\n./test_cpp\n```\n\nThese tests will verify that the `strlen` function and the `run_assertions` subroutine/function work correctly in both Fortran and C++.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_divisor(int n) {\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = largest_divisor(3);\n    if (result != 1) {\n        std::cerr << "Assertion failed: largest_divisor(3) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(7);\n    if (result != 1) {\n        std::cerr << "Assertion failed: largest_divisor(7) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(10);\n    if (result != 5) {\n        std::cerr << "Assertion failed: largest_divisor(10) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(100);\n    if (result != 50) {\n        std::cerr << "Assertion failed: largest_divisor(100) == 50" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(49);\n    if (result != 7) {\n        std::cerr << "Assertion failed: largest_divisor(49) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the `largest_divisor` function, which computes the largest divisor of a given integer `n`, and a `main` function that contains several test cases to verify the correctness of the `largest_divisor` function. If any of the test cases fail, the program will print an error message and exit with a status code of 1. Otherwise, it will print "All tests passed."\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `largest_divisor` function in both languages.\n\n### Fortran Unit Test Code\n\nTo compile and run the Fortran code, you can use a Fortran compiler like `gfortran`. Here is the unit test code:\n\n```fortran\nprogram test_largest_divisor\n  implicit none\n\n  integer :: result\n\n  ! Test cases\n  result = largest_divisor(3)\n  if (result /= 1) then\n    write(*,*) "Test failed: largest_divisor(3) == 1"\n    call exit(1)\n  end if\n\n  result = largest_divisor(7)\n  if (result /= 1) then\n    write(*,*) "Test failed: largest_divisor(7) == 1"\n    call exit(1)\n  end if\n\n  result = largest_divisor(10)\n  if (result /= 5) then\n    write(*,*) "Test failed: largest_divisor(10) == 5"\n    call exit(1)\n  end if\n\n  result = largest_divisor(100)\n  if (result /= 50) then\n    write(*,*) "Test failed: largest_divisor(100) == 50"\n    call exit(1)\n  end if\n\n  result = largest_divisor(49)\n  if (result /= 7) then\n    write(*,*) "Test failed: largest_divisor(49) == 7"\n    call exit(1)\n  end if\n\n  write(*,*) "All tests passed."\n\ncontains\n\n  integer function largest_divisor(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: i\n\n    do i = 2, int(sqrt(real(n)))\n      if (mod(n, i) == 0) then\n        largest_divisor = n / i\n        return\n      end if\n    end do\n\n    largest_divisor = 1\n  end function largest_divisor\n\nend program test_largest_divisor\n```\n\n### C++ Unit Test Code\n\nTo compile and run the C++ code, you can use a C++ compiler like `g++`. Here is the unit test code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_divisor(int n) {\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = largest_divisor(3);\n    if (result != 1) {\n        std::cerr << "Test failed: largest_divisor(3) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(7);\n    if (result != 1) {\n        std::cerr << "Test failed: largest_divisor(7) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(10);\n    if (result != 5) {\n        std::cerr << "Test failed: largest_divisor(10) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(100);\n    if (result != 50) {\n        std::cerr << "Test failed: largest_divisor(100) == 50" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(49);\n    if (result != 7) {\n        std::cerr << "Test failed: largest_divisor(49) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n#### Fortran\n\nTo compile and run the Fortran code, use the following commands in your terminal:\n\n```sh\ngfortran -o test_largest_divisor test_largest_divisor.f90\n./test_largest_divisor\n```\n\n#### C++\n\nTo compile and run the C++ code, use the following commands in your terminal:\n\n```sh\ng++ -o test_largest_divisor test_largest_divisor.cpp\n./test_largest_divisor\n```\n\nThese commands will compile the respective unit test codes and execute them, verifying the correctness of the `largest_divisor` function in both Fortran and C++. If all tests pass, the programs will print "All tests passed."
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code includes the necessary headers and uses standard library functions and containers to achieve the same functionality.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nvoid factorize(int n, std::vector<int>& out) {\n    int m = n;\n    int count = 0;\n    out.clear();\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (m <= 1) break;\n        while (m % i == 0) {\n            m /= i;\n            ++count;\n            out.push_back(i);\n        }\n    }\n\n    if (m > 1) {\n        out.push_back(m);\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nint main() {\n    std::vector<int> factors;\n    bool result;\n\n    factorize(2, factors);\n    result = issame(factors, {2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(2)" << std::endl;\n        return 1;\n    }\n\n    factorize(4, factors);\n    result = issame(factors, {2, 2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(4)" << std::endl;\n        return 1;\n    }\n\n    factorize(8, factors);\n    result = issame(factors, {2, 2, 2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(8)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19, factors);\n    result = issame(factors, {3, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19, factors);\n    result = issame(factors, {3, 3, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19 * 3 * 19, factors);\n    result = issame(factors, {3, 3, 3, 19, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 19 * 19, factors);\n    result = issame(factors, {3, 19, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 19 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 2 * 3, factors);\n    result = issame(factors, {2, 3, 3});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 2 * 3)" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nThis C++ code defines the `factorize` function to factorize a number into its prime factors and the `issame` function to compare two vectors of integers. The `main` function then tests the `factorize` function with various inputs and checks the results against expected outcomes.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `factorize` function and the `issame` function.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_factorize\n    implicit none\n    integer, allocatable :: factors(:)\n    logical :: result\n\n    ! Test 1: Factorize 2\n    call factorize(2, factors)\n    result = issame(factors, [2])\n    if (.not. result) then\n        write(*,*) "Test 1 failed for factorize(2)"\n    else\n        write(*,*) "Test 1 passed for factorize(2)"\n    end if\n\n    ! Test 2: Factorize 4\n    call factorize(4, factors)\n    result = issame(factors, [2, 2])\n    if (.not. result) then\n        write(*,*) "Test 2 failed for factorize(4)"\n    else\n        write(*,*) "Test 2 passed for factorize(4)"\n    end if\n\n    ! Test 3: Factorize 8\n    call factorize(8, factors)\n    result = issame(factors, [2, 2, 2])\n    if (.not. result) then\n        write(*,*) "Test 3 failed for factorize(8)"\n    else\n        write(*,*) "Test 3 passed for factorize(8)"\n    end if\n\n    ! Test 4: Factorize 3 * 19\n    call factorize(3 * 19, factors)\n    result = issame(factors, [3, 19])\n    if (.not. result) then\n        write(*,*) "Test 4 failed for factorize(3 * 19)"\n    else\n        write(*,*) "Test 4 passed for factorize(3 * 19)"\n    end if\n\n    ! Test 5: Factorize 3 * 19 * 3 * 19\n    call factorize(3 * 19 * 3 * 19, factors)\n    result = issame(factors, [3, 3, 19, 19])\n    if (.not. result) then\n        write(*,*) "Test 5 failed for factorize(3 * 19 * 3 * 19)"\n    else\n        write(*,*) "Test 5 passed for factorize(3 * 19 * 3 * 19)"\n    end if\n\n    ! Test 6: Factorize 3 * 19 * 3 * 19 * 3 * 19\n    call factorize(3 * 19 * 3 * 19 * 3 * 19, factors)\n    result = issame(factors, [3, 3, 3, 19, 19, 19])\n    if (.not. result) then\n        write(*,*) "Test 6 failed for factorize(3 * 19 * 3 * 19 * 3 * 19)"\n    else\n        write(*,*) "Test 6 passed for factorize(3 * 19 * 3 * 19 * 3 * 19)"\n    end if\n\n    ! Test 7: Factorize 3 * 19 * 19 * 19\n    call factorize(3 * 19 * 19 * 19, factors)\n    result = issame(factors, [3, 19, 19, 19])\n    if (.not. result) then\n        write(*,*) "Test 7 failed for factorize(3 * 19 * 19 * 19)"\n    else\n        write(*,*) "Test 7 passed for factorize(3 * 19 * 19 * 19)"\n    end if\n\n    ! Test 8: Factorize 3 * 2 * 3\n    call factorize(3 * 2 * 3, factors)\n    result = issame(factors, [2, 3, 3])\n    if (.not. result) then\n        write(*,*) "Test 8 failed for factorize(3 * 2 * 3)"\n    else\n        write(*,*)
Translating the provided Fortran code to C++ involves several steps, including converting the array handling and the logic for removing duplicates. Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> remove_duplicates(const std::vector<int>& numbers) {\n    std::vector<int> has1, has2, out;\n\n    if (numbers.empty()) return out;\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int j : has2) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) continue;\n\n        found = false;\n        for (int j : has1) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            has2.push_back(num);\n        } else {\n            has1.push_back(num);\n        }\n    }\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int j : has2) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            out.push_back(num);\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_condition(issame(remove_duplicates({1, 2, 3, 4}), {1, 2, 3, 4}));\n    assert_condition(issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5}));\n    assert_condition(remove_duplicates({}).empty());\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Array Handling**: In C++, we use `std::vector<int>` to handle arrays dynamically.\n2. **Removing Duplicates**: The logic for removing duplicates is preserved, with `has1` and `has2` vectors to track seen numbers.\n3. **Assertion**: The `assert_condition` function checks if the condition is true. If not, it prints an error message and exits the program.\n4. **Test Cases**: The test cases are implemented directly in the `main` function.\n\nThis C++ code should behave similarly to the original Fortran code, ensuring the same functionality and logic for removing duplicates from an array.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram remove_duplicates_program\n    implicit none\n    integer, dimension(:), allocatable :: numbers, result\n    integer :: i\n    integer, dimension(0) :: empty_array\n\n    ! Test cases\n    call assert(issame(remove_duplicates([1, 2, 3, 4]), [1, 2, 3, 4]))\n    call assert(issame(remove_duplicates([1, 2, 3, 2, 4, 3, 5]), [1, 4, 5]))\n    call assert(issame(remove_duplicates(empty_array), empty_array))\n\ncontains\n\n    function remove_duplicates(numbers) result(out)\n        integer, dimension(:), intent(in) :: numbers\n        integer, dimension(:), allocatable :: out\n        integer, dimension(:), allocatable :: has1, has2\n        integer :: i, j, num\n        logical :: found\n\n        allocate(has1(0))\n        allocate(has2(0))\n        allocate(out(0))\n\n        if (size(numbers) == 0) return\n\n        do i = 1, size(numbers)\n            num = numbers(i)\n            found = .false.\n            do j = 1, size(has2)\n                if (has2(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) cycle\n\n            found = .false.\n            do j = 1, size(has1)\n                if (has1(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                call append(has2, num)\n            else\n                call append(has1, num)\n            end if\n        end do\n\n        do i = 1, size(numbers)\n            num = numbers(i)\n            found = .false.\n            do j = 1, size(has2)\n                if (has2(j) == num) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                call append(out, num)\n            end if\n        end do\n    end function remove_duplicates\n\n    subroutine append(array, value)\n        integer, dimension(:), allocatable, intent(inout) :: array\n        integer, intent(in) :: value\n        integer, dimension(:), allocatable :: temp\n\n        allocate(temp(size(array) + 1))\n        temp(1:size(array)) = array\n        temp(size(array) + 1) = value\n        deallocate(array)\n        allocate(array(size(temp)))\n        array = temp\n    end subroutine append\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                exit\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program remove_duplicates_program\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> remove_duplicates(const std::vector<int>& numbers) {\n    std::vector<int> has1, has2, out;\n\n    if (numbers.empty()) return out;\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int j : has2) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) continue;\n\n        found = false;\n        for (int j : has1) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            has2.push_back(num);\n        } else {\n            has1.push_back(num);\n        }\n    }\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int j : has2) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            out.push_back(num);\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string flip_case(const std::string& str) {\n    std::string out;\n    for (size_t i = 0; i < str.length(); ++i) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w = w - 32; // Convert lowercase to uppercase\n        } else if (w >= 'A' && w <= 'Z') {\n            w = w + 32; // Convert uppercase to lowercase\n        }\n        out += w;\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(flip_case("") == "");\n    assert(flip_case("Hello!") == "hELLO!");\n    assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `flip_case`**: This function takes a `std::string` as input and returns a new `std::string` with the case of each character flipped.\n    - It iterates through each character of the input string.\n    - If the character is lowercase, it converts it to uppercase by subtracting 32 from its ASCII value.\n    - If the character is uppercase, it converts it to lowercase by adding 32 to its ASCII value.\n    - The result is appended to the output string.\n\n2. **Subroutine `assert`**: This function checks if the condition is `true`. If not, it prints an error message and exits the program with a non-zero status.\n\n3. **Main function**: The main function contains test cases that call the `flip_case` function with different inputs and uses the `assert` function to verify the correctness of the outputs.\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Tests\n\nTo compile and run the Fortran code, you can use a Fortran compiler like `gfortran`. Here's how you can create a Fortran program with unit tests:\n\n```fortran\nprogram flip_case_program\n    implicit none\n    character(len=100) :: str, result\n\n    ! Test cases\n    call assert(flip_case("") == "")\n    call assert(flip_case("Hello!") == "hELLO!")\n    call assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")\n\ncontains\n\n    function flip_case(str) result(out)\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: out\n        integer :: i\n        character :: w\n\n        out = ""\n        do i = 1, len_trim(str)\n            w = str(i:i)\n            if (iachar(w) >= 97 .and. iachar(w) <= 122) then\n                w = achar(iachar(w) - 32)\n            else if (iachar(w) >= 65 .and. iachar(w) <= 90) then\n                w = achar(iachar(w) + 32)\n            end if\n            out(i:i) = w\n        end do\n    end function flip_case\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program flip_case_program\n```\n\n### C++ Unit Tests\n\nTo compile and run the C++ code, you can use a C++ compiler like `g++`. Here's how you can create a C++ program with unit tests:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string flip_case(const std::string& str) {\n    std::string out;\n    for (size_t i = 0; i < str.length(); ++i) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w = w - 32; // Convert lowercase to uppercase\n        } else if (w >= 'A' && w <= 'Z') {\n            w = w + 32; // Convert uppercase to lowercase\n        }\n        out += w;\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(flip_case("") == "");\n    assert(flip_case("Hello!") == "hELLO!");\n    assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n#### Fortran\n\nTo compile and run the Fortran code, use the following commands in the terminal:\n\n```sh\ngfortran -o flip_case_program flip_case_program.f90\n./flip_case_program\n```\n\n#### C++\n\nTo compile and run the C++ code, use the following commands in the terminal:\n\n```sh\ng++ -o flip_case_program flip_case_program.cpp\n./flip_case_program\n```\n\nBoth programs should output "All tests passed!" if the functions are working correctly. If there is an assertion failure, the programs will exit with an error message.
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code uses the standard library, including `std::vector` for dynamic arrays and `std::string` for handling strings. The `concatenate` function is implemented to mimic the behavior of the Fortran version.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\nint main() {\n    // Test with an empty array\n    std::vector<std::string> strings;\n    std::string result = concatenate(strings);\n    if (result != "") {\n        std::cerr << "Assertion failed: concatenate([]) /= ''" << std::endl;\n        exit(1);\n    }\n\n    // Test with an array of strings\n    strings = {"x", "y", "z"};\n    result = concatenate(strings);\n    if (result != "xyz") {\n        std::cerr << "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'" << std::endl;\n        exit(1);\n    }\n\n    // Test with a larger array of strings\n    strings = {"x", "y", "z", "w", "k"};\n    result = concatenate(strings);\n    if (result != "xyzwk") {\n        std::cerr << "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ program includes the same tests as the Fortran version, checking the functionality of the `concatenate` function with both empty and non-empty input vectors of strings. The `exit(1)` call is used to terminate the program with an error code if any of the assertions fail, similar to the Fortran version.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `concatenate` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_concatenate\n    implicit none\n    character(len=:), allocatable :: result\n    character(len=10), dimension(:), allocatable :: strings\n\n    ! Test with an empty array\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(0))\n    result = concatenate(strings)\n    if (result /= "") then\n        write(*,*) "Test failed: concatenate([]) /= ''"\n        call exit(1)\n    else\n        write(*,*) "Test passed: concatenate([]) /= ''"\n    end if\n\n    ! Test with an array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(3))\n    strings = ["x", "y", "z"]\n    result = concatenate(strings)\n    if (result /= "xyz") then\n        write(*,*) "Test failed: concatenate(['x', 'y', 'z']) /= 'xyz'"\n        call exit(1)\n    else\n        write(*,*) "Test passed: concatenate(['x', 'y', 'z']) /= 'xyz'"\n    end if\n\n    ! Test with a larger array of strings\n    if (allocated(strings)) deallocate(strings)\n    allocate(strings(5))\n    strings = ["x", "y", "z", "w", "k"]\n    result = concatenate(strings)\n    if (result /= "xyzwk") then\n        write(*,*) "Test failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'"\n        call exit(1)\n    else\n        write(*,*) "Test passed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'"\n    end if\n\ncontains\n\n    function concatenate(strings) result(out)\n        character(len=10), dimension(:), intent(in) :: strings\n        character(len=:), allocatable :: out\n        integer :: i\n\n        if (size(strings) == 0) then\n            out = ""\n        else\n            out = ""\n            do i = 1, size(strings)\n                out = out // trim(strings(i))\n            end do\n        end if\n    end function concatenate\n\nend program test_concatenate\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\nvoid test_concatenate() {\n    // Test with an empty array\n    std::vector<std::string> strings;\n    std::string result = concatenate(strings);\n    if (result != "") {\n        std::cerr << "Test failed: concatenate([]) /= ''" << std::endl;\n        exit(1);\n    } else {\n        std::cout << "Test passed: concatenate([]) /= ''" << std::endl;\n    }\n\n    // Test with an array of strings\n    strings = {"x", "y", "z"};\n    result = concatenate(strings);\n    if (result != "xyz") {\n        std::cerr << "Test failed: concatenate(['x', 'y', 'z']) /= 'xyz'" << std::endl;\n        exit(1);\n    } else {\n        std::cout << "Test passed: concatenate(['x', 'y', 'z']) /= 'xyz'" << std::endl;\n    }\n\n    // Test with a larger array of strings\n    strings = {"x", "y", "z", "w", "k"};\n    result = concatenate(strings);\n    if (result != "xyzwk") {\n        std::cerr << "Test failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'" << std::endl;\n        exit(1);\n    } else {\n        std::cout << "Test passed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'" << std::endl;\n    }\n}\n\nint main() {\n    test_concatenate();\n    return 0;\n}\n```\n\nThese unit tests are designed to verify the correctness of the `concatenate` function in both Fortran and C++. Each test checks the function with arrays of strings of different lengths, including an empty array, to ensure the function behaves as expected.
Translating the provided Fortran code to C++ involves several steps, including adapting the array handling and string manipulation to C++ conventions. Here's a C++ version of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> filter_by_prefix(const std::vector<std::string>& strings, const std::string& prefix) {\n    std::vector<std::string> out;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            out.push_back(str);\n        }\n    }\n    return out;\n}\n\nvoid add_to_array(std::vector<std::string>& array, const std::string& element) {\n    array.push_back(element);\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid test_cases() {\n    // Test case 1\n    std::vector<std::string> strings;\n    std::string prefix = "john";\n    auto result = filter_by_prefix(strings, prefix);\n    if (!issame(result, strings)) {\n        std::cerr << "Assertion failed: filter_by_prefix({}, 'john')" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    strings = {"xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "};\n    prefix = "xxx";\n    result = filter_by_prefix(strings, prefix);\n    std::vector<std::string> expected = {"xxx     ", "xxxAAA  ", "xxx     "};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: filter_by_prefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_cases();\n    return 0;\n}\n```\n\n### Key Points:\n\n1. **Array Handling**: C++ uses `std::vector` for dynamic arrays, which is more flexible and safer than raw arrays.\n2. **String Handling**: C++'s `std::string` is used for string manipulation, which simplifies operations like substring comparison.\n3. **Functions**: The `filter_by_prefix` function filters strings based on the given prefix. The `add_to_array` function appends a string to a vector, similar to the Fortran version. The `issame` function checks if two vectors of strings are equal.\n4. **Test Cases**: The `test_cases` function runs the unit tests, comparing the output of `filter_by_prefix` against expected results.\n\nThis C++ code should behave similarly to the original Fortran code, ensuring the same logic and output for the given test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `filter_by_prefix` function and the `add_to_array` subroutine.\n\n### Fortran Unit Test Code\n\nTo compile and run this Fortran code, you might need a Fortran compiler like `gfortran`. Save the following code to a file, say `test_fortran.f90`, and then compile and run it using the command line.\n\n```fortran\nprogram test_main\n    implicit none\n    character(len=8), allocatable :: result(:)\n    character(len=8), allocatable :: expected(:)\n    character(len=8), allocatable :: strings(:)\n    character(len=:), allocatable :: prefix\n\n    ! Test case 1\n    allocate(strings(0))\n    prefix = "john"\n    result = filter_by_prefix(strings, prefix)\n    if (.not. issame(result, strings)) then\n        write(*,*) "Test case 1 failed: filter_by_prefix({}, 'john')"\n        stop\n    end if\n    deallocate(strings)\n    deallocate(result)\n\n    ! Test case 2\n    allocate(strings(6))\n    strings = ["xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "]\n    prefix = "xxx"\n    result = filter_by_prefix(strings, prefix)\n    allocate(expected(3))\n    expected = ["xxx     ", "xxxAAA  ", "xxx     "]\n    if (.not. issame(result, expected)) then\n        write(*,*) "Test case 2 failed: filter_by_prefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')"\n        stop\n    end if\n    deallocate(strings)\n    deallocate(result)\n    deallocate(expected)\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    function filter_by_prefix(strings, prefix) result(out)\n        character(len=8), allocatable, dimension(:) :: strings\n        character(len=:), allocatable :: prefix\n        character(len=8), allocatable, dimension(:) :: out\n        integer :: i, count\n\n        count = 0\n        allocate(out(0))\n        do i = 1, size(strings)\n            if (strings(i)(1:len(prefix)) == prefix) then\n                count = count + 1\n                call add_to_array(out, strings(i))\n            end if\n        end do\n    end function filter_by_prefix\n\n    subroutine add_to_array(array, element)\n        character(len=8), allocatable, dimension(:) :: array\n        character(len=8), intent(in) :: element\n        character(len=8), allocatable, dimension(:) :: temp_array\n        integer :: n\n\n        n = size(array)\n        allocate(temp_array(n + 1), mold=array)\n        if (n > 0) temp_array(1:n) = array\n        temp_array(n + 1) = element\n        deallocate(array)\n        array = temp_array\n    end subroutine add_to_array\n\n    function issame(a, b) result(is_equal)\n        character(len=8), allocatable, dimension(:) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\nTo compile and run this C++ code, you might need a C++ compiler like `g++`. Save the following code to a file, say `test_cpp.cpp`, and then compile and run it using the command line.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> filter_by_prefix(const std::vector<std::string>& strings, const std::string& prefix) {\n    std::vector<std::string> out;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            out.push_back(str);\n        }\n    }\n    return out;\n}\n\nvoid add_to_array(std::vector<std::string>& array, const std::string& element) {\n    array.push_back(element);\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid test
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, function definitions, and control structures. Below is the C++ translation of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to get positive numbers from a vector\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> out;\n    for (float num : l) {\n        if (num > 0.0f) {\n            out.push_back(num);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are equal\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4f) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> input = {-1.0f, -2.0f, 4.0f, 5.0f, 6.0f};\n    std::vector<float> expected = {4.0f, 5.0f, 6.0f};\n    std::vector<float> result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    input = {5.0f, 3.0f, -5.0f, 2.0f, 3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n    expected = {5.0f, 3.0f, 2.0f, 3.0f, 3.0f, 9.0f, 123.0f, 1.0f};\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    input = {-1.0f, -2.0f};\n    expected.clear(); // No positive numbers in input\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    input.clear(); // Empty vector\n    expected.clear(); // Expected to be empty as well\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses `std::vector<float>` for dynamic arrays, which is a common practice in C++ for handling arrays that can vary in size. The `get_positive` function filters the input vector to keep only positive numbers, and the `issame` function compares two vectors for equality within a specified tolerance. The `main` function contains test cases that verify the correctness of these functions.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\n    contains\n\n    function get_positive(l) result(out)\n        real, dimension(:), intent(in) :: l\n        real, dimension(:), allocatable :: out\n        integer :: i, count\n\n        count = 0\n        do i = 1, size(l)\n            if (l(i) > 0.0) count = count + 1\n        end do\n\n        allocate(out(count))\n        count = 0\n        do i = 1, size(l)\n            if (l(i) > 0.0) then\n                count = count + 1\n                out(count) = l(i)\n            end if\n        end do\n    end function get_positive\n\n    function issame(a, b) result(is_equal)\n        real, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (abs(a(i) - b(i)) > 1.0e-4) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    real, dimension(:), allocatable :: input, result, expected\n    logical :: is_same\n\n    ! Test case 1\n    input = [-1.0, -2.0, 4.0, 5.0, 6.0]\n    expected = [4.0, 5.0, 6.0]\n    result = get_positive(input)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Test case 1: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 2\n    input = [5.0, 3.0, -5.0, 2.0, 3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0]\n    expected = [5.0, 3.0, 2.0, 3.0, 3.0, 9.0, 123.0, 1.0]\n    result = get_positive(input)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Test case 2: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 3\n    input = [-1.0, -2.0]\n    if (allocated(expected)) deallocate(expected)\n    allocate(expected(0))\n    result = get_positive(input)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Test case 3: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 4\n    if (allocated(input)) deallocate(input)\n    if (allocated(expected)) deallocate(expected)\n    allocate(input(0))\n    allocate(expected(0))\n    result = get_positive(input)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Test case 4: assertion failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed"\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to get positive numbers from a vector\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> out;\n    for (float num : l) {\n        if (num > 0.0f) {\n            out.push_back(num);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are equal\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the `is_prime` function and a series of assertions to test the function, similar to the Fortran version.\n\n```cpp\n#include <iostream>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false;\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    // Assertions to test the is_prime function\n    if (!is_prime(6)) {\n        std::cerr << "Assertion failed: is_prime(6) == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(101)) {\n        std::cerr << "Assertion failed: is_prime(101) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(11)) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(13441)) {\n        std::cerr << "Assertion failed: is_prime(13441) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(61)) {\n        std::cerr << "Assertion failed: is_prime(61) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(4)) {\n        std::cerr << "Assertion failed: is_prime(4) == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(1)) {\n        std::cerr << "Assertion failed: is_prime(1) == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(5)) {\n        std::cerr << "Assertion failed: is_prime(5) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(11)) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(17)) {\n        std::cerr << "Assertion failed: is_prime(17) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(5 * 17)) {\n        std::cerr << "Assertion failed: is_prime(5 * 17) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(11 * 7)) {\n        std::cerr << "Assertion failed: is_prime(11 * 7) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(13441 * 19)) {\n        std::cerr << "Assertion failed: is_prime(13441 * 19) == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses the `std::sqrt` function to calculate the square root of a number, similar to the Fortran `sqrt` function. The `is_prime` function is implemented to check if a number is prime, and the main function contains assertions to test this function with various inputs. If any assertion fails, the program will print an error message and return a non-zero exit code, indicating a failed test.
Translating the provided Fortran code to C++ involves several steps, including changing the syntax, converting the module to a class or namespace, and handling array indexing differences. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nnamespace polynomial_module {\n    // Define the poly function\n    double poly(const std::vector<double>& xs, int n, double x) {\n        double sum = 0.0;\n        for (int i = 0; i < n; ++i) {\n            sum += xs[i] * std::pow(x, i);\n        }\n        return sum;\n    }\n\n    // Define the find_zero function\n    double find_zero(const std::vector<double>& xs, int n) {\n        double ans = 0.0;\n        double value = poly(xs, n, ans);\n        while (std::abs(value) > 1e-6) {\n            double driv = 0.0;\n            for (int i = 1; i < n; ++i) {\n                driv += xs[i] * (i) * std::pow(ans, i - 1);\n            }\n            ans -= value / driv;\n            value = poly(xs, n, ans);\n        }\n        return ans;\n    }\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i < 100; ++i) {\n        int ncoeff = 2 * (1 + std::rand() % 4);\n        std::vector<double> coeffs(ncoeff);\n\n        for (int j = 0; j < ncoeff; ++j) {\n            coeffs[j] = -10 + std::rand() % 21;\n            if (coeffs[j] == 0) coeffs[j] = 1;\n        }\n\n        double solution = polynomial_module::find_zero(coeffs, ncoeff);\n        if (std::abs(polynomial_module::poly(coeffs, ncoeff, solution)) >= 1e-3) {\n            std::cerr << "Assertion failed: abs(poly(coeffs, solution)) < 1e-3" << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n```\n\n### Key Changes:\n\n1. **Module to Namespace/Class**: Fortran modules are used to group related procedures and data. In C++, a namespace can serve a similar purpose. However, since we're not dealing with global state or encapsulating data, a namespace is more appropriate.\n\n2. **Arrays**: Fortran arrays are 1-based, while C++ arrays (and vectors) are 0-based. This is accounted for in the translation.\n\n3. **Random Number Generation**: The C++ `<cstdlib>` and `<ctime>` headers are used for random number generation, similar to Fortran's `random_seed` and `random_number`.\n\n4. **Function Arguments**: In C++, functions can directly use `std::vector<double>` for the coefficients array, and primitive types for other arguments.\n\n5. **Mathematical Functions**: The `std::pow` function from the `<cmath>` header is used for exponentiation, and `std::abs` for absolute value calculations.\n\n6. **Program Structure**: The `main` function in C++ serves as the entry point for the program, similar to the `program` block in Fortran.\n\nThis translation should provide a functional equivalent of the original Fortran code in C++.\nLet's write some test to verify if the translation is correct. \nBelow are examples of unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `poly` and `find_zero` functions under various conditions.\n\n### Fortran Unit Tests\n\nTo test the Fortran code, we can write a simple test program that uses the `polynomial_module` and checks the functionality of `poly` and `find_zero` functions with predefined inputs.\n\n```fortran\nprogram test_polynomial_module\n    use polynomial_module\n    implicit none\n    real(8) :: test_poly_coeffs(5)\n    real(8) :: test_find_zero_coeffs(3)\n    real(8) :: result\n    integer :: i\n\n    ! Test poly function\n    test_poly_coeffs = [1.0d0, 2.0d0, 3.0d0, 4.0d0, 5.0d0]\n    result = poly(test_poly_coeffs, 5, 2.0d0)\n    print *, "Test poly with x = 2: ", result\n\n    ! Test find_zero function\n    test_find_zero_coeffs = [1.0d0, -2.0d0, 1.0d0]\n    result = find_zero(test_find_zero_coeffs, 3)\n    print *, "Test find_zero with solution x = ", result\n\nend program test_polynomial_module\n```\n\n### C++ Unit Tests\n\nFor C++, we can use a simple testing approach similar to Fortran, or for more comprehensive testing, use a testing framework like Google Test. Here, I'll provide a basic example without a framework for simplicity.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include "polynomial_module.hpp" // Assume the translated code is in this header\n\nvoid test_poly(const std::vector<double>& coeffs, double x, double expected) {\n    double result = polynomial_module::poly(coeffs, coeffs.size(), x);\n    if (std::abs(result - expected) < 1e-6) {\n        std::cout << "Test poly with x = " << x << " passed." << std::endl;\n    } else {\n        std::cerr << "Test poly with x = " << x << " failed." << std::endl;\n    }\n}\n\nvoid test_find_zero(const std::vector<double>& coeffs, double expected) {\n    double result = polynomial_module::find_zero(coeffs, coeffs.size());\n    if (std::abs(result - expected) < 1e-6) {\n        std::cout << "Test find_zero with solution x = " << result << " passed." << std::endl;\n    } else {\n        std::cerr << "Test find_zero with solution x = " << result << " failed." << std::endl;\n    }\n}\n\nint main() {\n    // Test poly function\n    std::vector<double> test_poly_coeffs = {1.0, 2.0, 3.0, 4.0, 5.0};\n    test_poly(test_poly_coeffs, 2.0, 25.0); // Expected result: 25.0\n\n    // Test find_zero function\n    std::vector<double> test_find_zero_coeffs = {1.0, -2.0, 1.0};\n    test_find_zero(test_find_zero_coeffs, 1.0); // Expected result: 1.0\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Tests**:\n   - The `test_poly` function checks if the `poly` function returns the expected result for a predefined set of coefficients and a value of `x`.\n   - The `test_find_zero` function checks if the `find_zero` function correctly finds a zero for a predefined set of coefficients.\n\n2. **C++ Tests**:\n   - The `test_poly` function in C++ performs a similar test to the Fortran version, checking the `poly` function's output.\n   - The `test_find_zero` function checks the output of the `find_zero` function.\n\nThese tests should help verify that the `poly` and `find_zero` functions work as expected in both the Fortran and C++ implementations. Remember to compile and run these tests in their respective environments.
Translating the provided Fortran code to C++ involves several steps, including changing the syntax for array handling, function definitions, and control structures. Here's a C++ version of the code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to sort an array\nvoid sort_array(std::vector<int>& arr) {\n    for (size_t i = 0; i < arr.size() - 1; ++i) {\n        for (size_t j = i + 1; j < arr.size(); ++j) {\n            if (arr[i] > arr[j]) {\n                std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n}\n\n// Function to sort every third element of the input array\nstd::vector<int> sort_third(const std::vector<int>& l) {\n    std::vector<int> third;\n    std::vector<int> out(l.size());\n\n    // Extract every third element\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third.push_back(l[i]);\n    }\n\n    // Sort the third array\n    sort_array(third);\n\n    // Reconstruct the output array\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\n// Function to check if two vectors are equal\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine to assert a condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Subroutine to run tests\nvoid run_tests() {\n    assert(issame(sort_third({1, 2, 3}), sort_third({1, 2, 3})));\n    assert(issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert(issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert(issame(sort_third({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5}));\n    assert(issame(sort_third({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5}));\n    assert(issame(sort_third({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5}));\n    assert(issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Key Changes:\n\n1. **Array Handling**: C++ uses `std::vector` for dynamic arrays, which is more flexible and safer compared to raw arrays.\n2. **Function Definitions**: Functions are defined using `std::vector<int>` for input and output parameters, and `void` for functions that do not return a value.\n3. **Sorting Algorithm**: The sorting algorithm is implemented using nested loops, which is a common approach in C++ for sorting arrays.\n4. **Testing**: The `assert` function checks conditions and prints an error message if the condition is false. The `run_tests` function runs several assertions to verify the correctness of the `sort_third` function.\n\nThis C++ code should provide equivalent functionality to the original Fortran code, ensuring that the sorting logic and the testing framework are correctly translated.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can create unit tests that cover various scenarios. Below are the unit test codes for both languages.\n\n### Fortran Unit Test Code\n\nHere is a Fortran program that includes the `sort_third` function and a series of tests to verify its correctness:\n\n```fortran\nprogram test_sort_third\n    implicit none\n    integer, allocatable :: test_array(:)\n    integer, allocatable :: result_array(:)\n    logical :: test_passed\n\n    ! Test 1\n    allocate(test_array(3))\n    test_array = [1, 2, 3]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [1, 2, 3])\n    call assert(test_passed)\n\n    ! Test 2\n    allocate(test_array(9))\n    test_array = [5, 3, -5, 2, -3, 3, 9, 0, 123]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [5, 3, -5, 2, -3, 3, 9, 0, 123])\n    call assert(test_passed)\n\n    ! Test 3\n    allocate(test_array(7))\n    test_array = [5, 8, -12, 4, 23, 2, 3]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [5, 8, -12, 4, 23, 2, 3])\n    call assert(test_passed)\n\n    ! Test 4\n    allocate(test_array(7))\n    test_array = [5, 6, 3, 4, 8, 9, 2]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [2, 6, 3, 4, 8, 9, 5])\n    call assert(test_passed)\n\n    ! Test 5\n    allocate(test_array(7))\n    test_array = [5, 8, 3, 4, 6, 9, 2]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [2, 8, 3, 4, 6, 9, 5])\n    call assert(test_passed)\n\n    ! Test 6\n    allocate(test_array(7))\n    test_array = [5, 6, 9, 4, 8, 3, 2]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [2, 6, 9, 4, 8, 3, 5])\n    call assert(test_passed)\n\n    ! Test 7\n    allocate(test_array(8))\n    test_array = [5, 6, 3, 4, 8, 9, 2, 1]\n    result_array = sort_third(test_array)\n    test_passed = issame(result_array, [2, 6, 3, 
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid unique(const std::vector<int>& input, std::vector<int>& result) {\n    std::vector<int> temp;\n    std::sort(input.begin(), input.end()); // Sort the input array\n\n    // Remove duplicates\n    for (int num : input) {\n        if (temp.empty() || num != temp.back()) {\n            temp.push_back(num);\n        }\n    }\n\n    result = temp;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    std::vector<int> expected = {0, 2, 3, 5, 9, 123};\n    std::vector<int> result;\n\n    unique(input, result);\n\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: result is not as expected" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **unique Function**: This function removes duplicates from the input vector and stores the unique elements in the result vector. It uses a sorted input vector to efficiently find and remove duplicates.\n2. **issame Function**: This function checks if two vectors are identical.\n3. **main Function**: The main function initializes the input vector, calls the `unique` function to remove duplicates, and then checks if the result matches the expected vector.\n\n### Notes:\n- The `std::sort` function is used to sort the input vector before removing duplicates to ensure that duplicates are adjacent, making it easier to remove them.\n- The `issame` function checks if the sizes of the vectors are the same and then compares each element to ensure they are identical.\n- The `std::vector` is used to handle dynamic arrays, which is a common practice in C++ for similar scenarios to Fortran's allocatable arrays.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_unique\n    implicit none\n    integer, allocatable :: input(:), expected(:), result(:)\n    logical :: is_same\n\n    ! Input array\n    input = [5, 3, 5, 2, 3, 3, 9, 0, 123]\n    ! Expected result\n    expected = [0, 2, 3, 5, 9, 123]\n\n    ! Call the unique function\n    call unique(input, result)\n\n    ! Check if the result is the same as expected\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Assertion failed: result is not as expected"\n        call exit(1)\n    else\n        write(*,*) "Test passed: result is as expected"\n    end if\n\ncontains\n\n    subroutine unique(l, out)\n        integer, intent(in) :: l(:)\n        integer, allocatable, intent(out) :: out(:)\n        integer, allocatable :: temp(:)\n        integer :: i, j, n, count\n\n        ! Allocate temporary array\n        allocate(temp(size(l)))\n        count = 0\n\n        ! Remove duplicates\n        do i = 1, size(l)\n            if (.not. any(temp(1:count) == l(i))) then\n                count = count + 1\n                temp(count) = l(i)\n            end if\n        end do\n\n        ! Allocate output array with the correct size\n        allocate(out(count))\n        out = temp(1:count)\n\n        ! Sort the output array\n        call sort(out)\n    end subroutine unique\n\n    subroutine sort(arr)\n        integer, intent(inout) :: arr(:)\n        integer :: i, j, temp\n\n        ! Simple bubble sort\n        do i = 1, size(arr) - 1\n            do j = 1, size(arr) - i\n                if (arr(j) > arr(j + 1)) then\n                    temp = arr(j)\n                    arr(j) = arr(j + 1)\n                    arr(j + 1) = temp\n                end if\n            end do\n        end do\n    end subroutine sort\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend program test_unique\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid unique(const std::vector<int>& input, std::vector<int>& result) {\n    std::vector<int> temp;\n    std::sort(input.begin(), input.end()); // Sort the input array\n\n    // Remove duplicates\n    for (int num : input) {\n        if (temp.empty() || num != temp.back()) {\n            temp.push_back(num);\n        }\n    }\n\n    result = temp;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    std::vector<int> expected = {0, 2, 3, 5, 9, 123};\n    std::vector<int> result;\n\n    unique(input, result);\n\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: result is not as expected" << std::endl;\n        return 1;\n    } else {\n        std::cout << "Test passed: result is as expected" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n- **Fortran Unit Test**: The Fortran unit test code initializes the input array, calls the `unique` subroutine to remove duplicates, and then checks if the result matches the expected array.\n- **C++ Unit Test**: The C++ unit test code does the same operations and checks if the result matches the expected array.\n\n### Compilation and Execution:\n- **Fortran**: You can compile the Fortran code using a Fortran compiler like `gfortran`:\n  ```sh\n  gfortran -o test_unique test_unique.f90\n  ./test_unique\n  ```\n- **C++**: You can compile the C++ code using a C++ compiler like `g++`:\n  ```sh\n  g++ -o test_unique test_unique.cpp\n  ./test_unique\n  ```\n\nBoth unit tests should output "Test passed: result is as expected" if the implementations are correct.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to find the maximum element in a vector\nfloat max_element(const std::vector<float>& arr) {\n    float max_val = -10000.0f;\n    for (float num : arr) {\n        if (max_val < num) max_val = num;\n    }\n    return max_val;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> arr1 = {1.0f, 2.0f, 3.0f};\n    float result1 = max_element(arr1);\n    if (std::abs(result1 - 3.0f) > 1e-4f) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<float> arr2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 124.0f, 1.0f, -10.0f};\n    float result2 = max_element(arr2);\n    if (std::abs(result2 - 124.0f) > 1e-4f) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function Definition**: The `max_element` function is defined to find the maximum element in a `std::vector<float>`.\n2. **Main Function**: The `main` function contains two test cases to verify the correctness of the `max_element` function.\n3. **Test Cases**:\n   - Test case 1 checks if the maximum element in the array `{1.0, 2.0, 3.0}` is correctly identified.\n   - Test case 2 checks if the maximum element in the array `{5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 124.0, 1.0, -10.0}` is correctly identified.\n4. **Assertions**: The results are compared with the expected values using assertions. If the results do not match the expected values within a tolerance, the program prints an error message and exits with a non-zero status.\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule max_module\n  implicit none\ncontains\n  function max_element(arr) result(max_val)\n    implicit none\n    real, dimension(:), intent(in) :: arr\n    real :: max_val\n    integer :: i\n\n    max_val = -10000.0\n    do i = 1, size(arr)\n      if (max_val < arr(i)) max_val = arr(i)\n    end do\n  end function max_element\nend module max_module\n\nprogram main\n  use max_module\n  implicit none\n  real :: result\n  real, dimension(:), allocatable :: arr\n\n  ! Test case 1\n  if (allocated(arr)) deallocate(arr)\n  allocate(arr(3))\n  arr = [1.0, 2.0, 3.0]\n  result = max_element(arr)\n  if (abs(result - 3.0) > 1e-4) then\n    write(*,*) "Test case 1: assertion failed"\n    call exit(1)\n  end if\n\n  ! Test case 2\n  if (allocated(arr)) deallocate(arr)\n  allocate(arr(11))\n  arr = [5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 124.0, 1.0, -10.0]\n  result = max_element(arr)\n  if (abs(result - 124.0) > 1e-4) then\n    write(*,*) "Test case 2: assertion failed"\n    call exit(1)\n  end if\n\n  write(*,*) "All tests passed"\n  if (allocated(arr)) deallocate(arr)\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to find the maximum element in a vector\nfloat max_element(const std::vector<float>& arr) {\n    float max_val = -10000.0f;\n    for (float num : arr) {\n        if (max_val < num) max_val = num;\n    }\n    return max_val;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> arr1 = {1.0f, 2.0f, 3.0f};\n    float result1 = max_element(arr1);\n    if (std::abs(result1 - 3.0f) > 1e-4f) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<float> arr2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 124.0f, 1.0f, -10.0f};\n    float result2 = max_element(arr2);\n    if (std::abs(result2 - 124.0f) > 1e-4f) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test**:\n   - The Fortran code defines a module `max_module` containing the `max_element` function.\n   - The `main` program includes two test cases to verify the correctness of the `max_element` function.\n   - It uses an allocatable array to test the function with different input arrays.\n   - The results are compared with the expected values using assertions.\n\n2. **C++ Unit Test**:\n   - The C++ code defines a function `max_element` to find the maximum element in a vector.\n   - The `main` function includes two test cases to verify the correctness of the `max_element` function.\n   - It uses `std::vector<float>` to test the function with different input arrays.\n   - The results are compared with the expected values using assertions.\n\nThese unit tests will help verify the correctness of both the original Fortran code and the translated C++ code.
Translating the given Fortran code to C++ involves several steps, including changing the syntax, converting the loop structures, and adjusting the function and subroutine calls to match C++ conventions. Here's how the Fortran code can be translated to C++:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint fizz_buzz(int n);\nvoid assert(bool condition, const std::string& message);\n\nint main() {\n    int result;\n\n    // Main program logic\n    result = fizz_buzz(50);\n    assert(result == 0, "fizz_buzz(50) == 0: assertion failed");\n\n    result = fizz_buzz(78);\n    assert(result == 2, "fizz_buzz(78) == 2: assertion failed");\n\n    result = fizz_buzz(79);\n    assert(result == 3, "fizz_buzz(79) == 3: assertion failed");\n\n    result = fizz_buzz(100);\n    assert(result == 3, "fizz_buzz(100) == 3: assertion failed");\n\n    result = fizz_buzz(200);\n    assert(result == 6, "fizz_buzz(200) == 6: assertion failed");\n\n    result = fizz_buzz(4000);\n    assert(result == 192, "fizz_buzz(4000) == 192: assertion failed");\n\n    result = fizz_buzz(10000);\n    assert(result == 639, "fizz_buzz(10000) == 639: assertion failed");\n\n    result = fizz_buzz(100000);\n    assert(result == 8026, "fizz_buzz(100000) == 8026: assertion failed");\n\n    return 0;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) {\n                    ++count;\n                }\n                q /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n```\n\n### Key Changes:\n\n1. **Function and Subroutine Definitions:** Fortran's `function` and `subroutine` are replaced with C++ functions. The `assert` subroutine is converted to a C++ function that takes a condition and a message.\n\n2. **Loop Syntax:** Fortran's `do` loop is replaced with C++'s `for` loop. The loop variable `i` starts from 0 and goes up to `n-1` to match Fortran's 1-based indexing.\n\n3. **Modulus Operator:** The Fortran modulus operator `.mod.` is replaced with C++'s `%` operator.\n\n4. **Program Logic:** The main program logic remains largely unchanged, but the syntax is adapted to C++.\n\n5. **Assertion:** The `assert` function checks the condition and prints an error message if the condition is false, then exits the program with a non-zero status.\n\n6. **Standard Library Includes:** `<iostream>` is included for input/output operations, and `<cstdlib>` is included for the `exit` function.\n\nThis C++ code should behave similarly to the original Fortran code, performing the same calculations and checks.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can write unit tests. For Fortran, we'll use a simple approach to test the function, as Fortran doesn't have a built-in unit testing framework like some other languages. For C++, we can use the Google Test framework, which is widely used and supports a variety of testing features.\n\n### Fortran Unit Tests\n\nSince Fortran doesn't have a built-in unit testing framework, we'll write a simple test procedure within the program. This is not as robust or scalable as using a dedicated testing framework but serves for demonstration purposes.\n\n```fortran\nprogram test_fizz_buzz\n    implicit none\n\n    call test_fizz_buzz_function()\n\ncontains\n\n    subroutine test_fizz_buzz_function()\n        integer :: expected, result\n\n        ! Test case 1\n        expected = 0\n        result = fizz_buzz(50)\n        call assert(result == expected, "Test case 1 failed: fizz_buzz(50) != 0")\n\n        ! Test case 2\n        expected = 2\n        result = fizz_buzz(78)\n        call assert(result == expected, "Test case 2 failed: fizz_buzz(78) != 2")\n\n        ! Test case 3\n        expected = 3\n        result = fizz_buzz(79)\n        call assert(result == expected, "Test case 3 failed: fizz_buzz(79) != 3")\n\n        ! Add more test cases as needed\n\n        print *, "All tests passed."\n    end subroutine test_fizz_buzz_function\n\n    ! Include the fizz_buzz function and assert subroutine here\n\nend program test_fizz_buzz\n```\n\n### C++ Unit Tests with Google Test\n\nFirst, ensure you have Google Test installed and set up in your project. The following example assumes you have Google Test set up.\n\n```cpp\n#include <gtest/gtest.h>\n\n// Include or directly paste the fizz_buzz function here\n\nTEST(FizzBuzzTest, TestCases) {\n    EXPECT_EQ(fizz_buzz(50), 0);\n    EXPECT_EQ(fizz_buzz(78), 2);\n    EXPECT_EQ(fizz_buzz(79), 3);\n    // Add more test cases as needed\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\n### Running the Tests\n\n- **For Fortran:** Compile and run the Fortran program as you would normally. If all assertions pass, it will print "All tests passed."\n\n- **For C++ with Google Test:**\n  1. Ensure Google Test is properly set up in your project.\n  2. Compile the test file along with the Google Test library. This typically involves linking against the Google Test library and including the Google Test headers.\n  3. Run the compiled test executable. Google Test will automatically run all tests and report the results.\n\nThese unit tests will help ensure that both the Fortran and C++ implementations of the Fizz Buzz function behave as expected across a range of inputs.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses the standard library for array operations and sorting.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> sort_even(const std::vector<float>& l) {\n    std::vector<float> out(l.size());\n    std::vector<float> even(l.size() / 2 + l.size() % 2);\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < even.size(); ++i) {\n        even[i] = l[i * 2];\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even.begin(), even.end());\n\n    // Merge sorted even-indexed elements back into the output array\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\nvoid sort_array(std::vector<float>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid run_tests() {\n    // Test case 1\n    std::vector<float> l = {1.0, 2.0, 3.0};\n    std::vector<float> expected = {1.0, 2.0, 3.0};\n    std::vector<float> result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    expected = {-10.0, 3.0, -5.0, 2.0, -3.0, 3.0, 5.0, 0.0, 9.0, 1.0, 123.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {5.0, 8.0, -12.0, 4.0, 23.0, 2.0, 3.0, 11.0, 12.0, -10.0};\n    expected = {-12.0, 8.0, 3.0, 4.0, 5.0, 2.0, 12.0, 11.0, 23.0, -10.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\nThis C++ code defines the `sort_even` function, which sorts the elements of an array based on their even indices, and the `sort_array` subroutine, which sorts an array using the standard library's `std::sort` function. The `issame` function checks if two vectors are approximately equal, and the `run_tests` function runs several test cases to verify the correctness of the `sort_even` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `sort_even` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_sort_even\n    implicit none\n    real, dimension(:), allocatable :: l, result, expected\n\n    ! Test case 1\n    allocate(l(3))\n    l = [1.0, 2.0, 3.0]\n    allocate(expected(3))\n    expected = [1.0, 2.0, 3.0]\n    result = sort_even(l)\n    if (.not. issame(result, expected)) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n    deallocate(l, result, expected)\n\n    ! Test case 2\n    allocate(l(11))\n    l = [5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0]\n    allocate(expected(11))\n    expected = [-10.0, 3.0, -5.0, 2.0, -3.0, 3.0, 5.0, 0.0, 9.0, 1.0, 123.0]\n    result = sort_even(l)\n    if (.not. issame(result, expected)) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n    deallocate(l, result, expected)\n\n    ! Test case 3\n    allocate(l(10))\n    l = [5.0, 8.0, -12.0, 4.0, 23.0, 2.0, 3.0, 11.0, 12.0, -10.0]\n    allocate(expected(10))\n    expected = [-12.0, 8.0, 3.0, 4.0, 5.0, 2.0, 12.0, 11.0, 23.0, -10.0]\n    result = sort_even(l)\n    if (.not. issame(result, expected)) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n    deallocate(l, result, expected)\n\n    write(*,*) "All test cases passed"\n\ncontains\n\n    function sort_even(l) result(out)\n        real, dimension(:), intent(in) :: l\n        real, dimension(:), allocatable :: out, even\n        integer :: i, n\n\n        n = size(l)\n        allocate(out(n))\n        allocate(even((n+1)/2))\n\n        ! Extract even-indexed elements\n        do i = 1, (n+1)/2\n            even(i) = l(2*i - 1)\n        end do\n\n        ! Sort the even-indexed elements\n        call sort_array(even)\n\n        ! Merge sorted even-indexed elements back into the output array\n        do i = 1, n\n            if (mod(i, 2) == 1) then\n                out(i) = even((i+1)/2)\n            else\n                out(i) = l(i)\n            end if\n        end do\n    end function sort_even\n\n    subroutine sort_array(arr)\n        real, dimension(:), intent(inout) :: arr\n        integer :: i, j\n        real :: temp\n        integer :: n\n\n        n = size(arr)\n        do i = 1, n-1\n            do j = i+1, n\n                if (arr(i) > arr(j)) then\n                    temp = arr(i)\n                    arr(i) =
Certainly! Here's the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint car_race_collision(int n);\n\nint main() {\n    // Assertions\n    if (car_race_collision(2) != 4) {\n        std::cerr << "Assertion failed: car_race_collision(2) == 4" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(3) != 9) {\n        std::cerr << "Assertion failed: car_race_collision(3) == 9" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(4) != 16) {\n        std::cerr << "Assertion failed: car_race_collision(4) == 16" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(8) != 64) {\n        std::cerr << "Assertion failed: car_race_collision(8) == 64" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(10) != 100) {\n        std::cerr << "Assertion failed: car_race_collision(10) == 100" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint car_race_collision(int n) {\n    return n * n;\n}\n```\n\nThis C++ code includes the necessary headers and uses `std::cerr` for error output, similar to the `write(*,*)` statement in Fortran. The `std::exit(1)` call is used to exit the program with an error code, similar to the `call exit(1)` statement in Fortran. The function `car_race_collision` is defined similarly to the Fortran version, taking an integer input and returning its square.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `car_race_collision` function.\n\n### Fortran Unit Test Code\n\nTo test the Fortran code, you can create a separate program that calls the `car_race_collision` function with different inputs and checks the results. Here's how you can do it:\n\n```fortran\nprogram test_car_race\n  implicit none\n\n  integer :: result\n\n  ! Test case 1\n  result = car_race_collision(2)\n  if (result /= 4) then\n    write(*,*) "Test case 1 failed: Expected 4, got ", result\n    call exit(1)\n  end if\n\n  ! Test case 2\n  result = car_race_collision(3)\n  if (result /= 9) then\n    write(*,*) "Test case 2 failed: Expected 9, got ", result\n    call exit(1)\n  end if\n\n  ! Test case 3\n  result = car_race_collision(4)\n  if (result /= 16) then\n    write(*,*) "Test case 3 failed: Expected 16, got ", result\n    call exit(1)\n  end if\n\n  ! Test case 4\n  result = car_race_collision(8)\n  if (result /= 64) then\n    write(*,*) "Test case 4 failed: Expected 64, got ", result\n    call exit(1)\n  end if\n\n  ! Test case 5\n  result = car_race_collision(10)\n  if (result /= 100) then\n    write(*,*) "Test case 5 failed: Expected 100, got ", result\n    call exit(1)\n  end if\n\n  write(*,*) "All tests passed."\n\ncontains\n\n  integer function car_race_collision(n)\n    integer, intent(in) :: n\n    car_race_collision = n * n\n  end function car_race_collision\n\nend program test_car_race\n```\n\n### C++ Unit Test Code\n\nFor the C++ code, you can use a simple main function to test the `car_race_collision` function:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\nint car_race_collision(int n);\n\nint main() {\n    // Test case 1\n    if (car_race_collision(2) != 4) {\n        std::cerr << "Test case 1 failed: Expected 4" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    if (car_race_collision(3) != 9) {\n        std::cerr << "Test case 2 failed: Expected 9" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    if (car_race_collision(4) != 16) {\n        std::cerr << "Test case 3 failed: Expected 16" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4\n    if (car_race_collision(8) != 64) {\n        std::cerr << "Test case 4 failed: Expected 64" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5\n    if (car_race_collision(10) != 100) {\n        std::cerr << "Test case 5 failed: Expected 100" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nint car_race_collision(int n) {\n    return n * n;\n}\n```\n\nThese unit tests will verify that the `car_race_collision` function works correctly for the given inputs. If any test case fails, the program will exit with an error code, indicating a failure in the function's logic. If all tests pass, it will print "All tests passed."
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses modern C++ standards for better code readability and maintainability.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::vector<int> incr_list(const std::vector<int>& l) {\n    std::vector<int> res(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        res[i] = l[i] + 1;\n    }\n    return res;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> l, result, expected;\n    bool condition;\n\n    // Test case 1\n    l = {0};\n    expected = {0};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2\n    l = {3, 2, 1};\n    expected = {4, 3, 2};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3\n    l = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    expected = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines the `incr_list` function, which increments each element of the input vector by 1, and the `issame` function, which compares two vectors to check if they are equal. The `main` function contains several test cases to verify the correctness of the `incr_list` function. If any test case fails, it prints an error message and exits with a non-zero status. Otherwise, it prints "All tests passed" indicating success.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `incr_list` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: l(:), result(:), expected(:)\n    logical :: condition\n\n    ! Test case 1\n    allocate(l(0))\n    allocate(expected(0))\n    result = incr_list(l)\n    condition = issame(result, expected)\n    if (.not. condition) then\n        write(*,*) "Test case 1: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 2\n    allocate(l(3))\n    l = [3, 2, 1]\n    allocate(expected(3))\n    expected = [4, 3, 2]\n    result = incr_list(l)\n    condition = issame(result, expected)\n    if (.not. condition) then\n        write(*,*) "Test case 2: assertion failed"\n        call exit(1)\n    end if\n\n    ! Test case 3\n    allocate(l(9))\n    l = [5, 2, 5, 2, 3, 3, 9, 0, 123]\n    allocate(expected(9))\n    expected = [6, 3, 6, 3, 4, 4, 10, 1, 124]\n    result = incr_list(l)\n    condition = issame(result, expected)\n    if (.not. condition) then\n        write(*,*) "Test case 3: assertion failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed"\n    call exit(0)\ncontains\n\n    function incr_list(l) result(res)\n        integer, intent(in) :: l(:)\n        integer, allocatable :: res(:)\n        integer :: i\n\n        allocate(res(size(l)))\n        res = l + 1\n    end function incr_list\n\n    function issame(a, b) result(is_equal)\n        integer, intent(in) :: a(:), b(:)\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::vector<int> incr_list(const std::vector<int>& l) {\n    std::vector<int> res(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        res[i] = l[i] + 1;\n    }\n    return res;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> l, result, expected;\n    bool condition;\n\n    // Test case 1\n    l = {0};\n    expected = {0};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2\n    l = {3, 2, 1};\n    expected = {4, 3, 2};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3\n    l = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    expected = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\nThese unit test codes are designed to verify the correctness of the `incr_list` function in both Fortran and C++. If any test case fails, the program will print an error message and exit with a non-zero status. If all tests pass, it will print "All tests passed" indicating success.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses the standard library, particularly the vector from the Standard Template Library (STL) for dynamic array allocation, which is a common practice in C++ for similar scenarios.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> l;\n    bool result;\n\n    // Test case 1\n    l = {1, 3, 5, 0};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {1, 3, -2, 1};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {1, 2, 3, 7};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4\n    l = {2, 4, -5, 3, 5, 7};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5\n    l = {1};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 6\n    l = {-3, 9, -1, 3, 2, 30};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 7\n    l = {-3, 9, -1, 3, 2, 31};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 8\n    l = {-3, 9, -1, 4, 2, 30};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 8 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 9\n    l = {-3, 9, -1, 4, 2, 31};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 9 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the `pairs_sum_to_zero` function, which performs the same logic as the Fortran function. It iterates through the vector `l` and checks for pairs of elements that sum to zero. The `main` function contains test cases similar to the Fortran program, using the `std::vector<int>` for dynamic array allocation and initialization. If any test case fails, it prints an error message and exits with a non-zero status, using `std::cerr` for error output and `std::exit(1)` for exiting the program with an error state.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary functions to perform the base conversion and integer to string conversion, similar to the Fortran version.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to change base\nstd::string change_base(int x, int base) {\n    std::string out;\n    int temp_x = x;\n    while (temp_x > 0) {\n        int remainder = temp_x % base;\n        out = std::to_string(remainder) + out;\n        temp_x = temp_x / base;\n    }\n    return out;\n}\n\n// Integer to string conversion function\nstd::string itoa(int num) {\n    return std::to_string(num);\n}\n\nint main() {\n    // Assertions\n    if (change_base(8, 3) != "22") {\n        std::cerr << "Assertion failed: change_base(8, 3) == '22'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(9, 3) != "100") {\n        std::cerr << "Assertion failed: change_base(9, 3) == '100'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(234, 2) != "11101010") {\n        std::cerr << "Assertion failed: change_base(234, 2) == '11101010'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(16, 2) != "10000") {\n        std::cerr << "Assertion failed: change_base(16, 2) == '10000'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(8, 2) != "1000") {\n        std::cerr << "Assertion failed: change_base(8, 2) == '1000'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(7, 2) != "111") {\n        std::cerr << "Assertion failed: change_base(7, 2) == '111'" << std::endl;\n        std::exit(1);\n    }\n\n    for (int x = 2; x <= 7; ++x) {\n        if (change_base(x, x + 1) != itoa(x)) {\n            std::cerr << "Assertion failed: change_base(" << x << ", " << x + 1 << ") == " << x << std::endl;\n            std::exit(1);\n        }\n    }\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary functions to perform the base conversion and integer to string conversion, similar to the Fortran version. The `change_base` function converts an integer `x` from its current base to a new base `base`, and `itoa` converts an integer to a string. The main function contains assertions to verify the correctness of the `change_base` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These unit tests will verify the correctness of the `change_base` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram change_base_test\n    implicit none\n    character(len=100) :: result\n    integer :: x\n\n    ! Test cases\n    if (trim(change_base(8, 3)) /= "22") then\n        write(*,*) "Test failed: change_base(8, 3) == '22'"\n    else\n        write(*,*) "Test passed: change_base(8, 3) == '22'"\n    end if\n\n    if (trim(change_base(9, 3)) /= "100") then\n        write(*,*) "Test failed: change_base(9, 3) == '100'"\n    else\n        write(*,*) "Test passed: change_base(9, 3) == '100'"\n    end if\n\n    if (trim(change_base(234, 2)) /= "11101010") then\n        write(*,*) "Test failed: change_base(234, 2) == '11101010'"\n    else\n        write(*,*) "Test passed: change_base(234, 2) == '11101010'"\n    end if\n\n    if (trim(change_base(16, 2)) /= "10000") then\n        write(*,*) "Test failed: change_base(16, 2) == '10000'"\n    else\n        write(*,*) "Test passed: change_base(16, 2) == '10000'"\n    end if\n\n    if (trim(change_base(8, 2)) /= "1000") then\n        write(*,*) "Test failed: change_base(8, 2) == '1000'"\n    else\n        write(*,*) "Test passed: change_base(8, 2) == '1000'"\n    end if\n\n    if (trim(change_base(7, 2)) /= "111") then\n        write(*,*) "Test failed: change_base(7, 2) == '111'"\n    else\n        write(*,*) "Test passed: change_base(7, 2) == '111'"\n    end if\n\ncontains\n    ! Function to change base\n    character(len=100) function change_base(x, base)\n        implicit none\n        integer, intent(in) :: x, base\n        integer :: temp_x, remainder\n        character(len=100) :: out, temp_str\n        out = ""\n        temp_x = x\n        do while (temp_x > 0)\n            remainder = mod(temp_x, base)\n            write(temp_str, '(I0)') remainder\n            out = trim(adjustl(temp_str)) // out\n            temp_x = temp_x / base\n        end do\n        change_base = out\n    end function change_base\n\nend program change_base_test\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to change base\nstd::string change_base(int x, int base) {\n    std::string out;\n    int temp_x = x;\n    while (temp_x > 0) {\n        int remainder = temp_x % base;\n        out = std::to_string(remainder) + out;\n        temp_x = temp_x / base;\n    }\n    return out;\n}\n\n// Integer to string conversion function\nstd::string itoa(int num) {\n    return std::to_string(num);\n}\n\nvoid test_change_base(int x, int base, const std::string& expected) {\n    std::string result = change_base(x, base);\n    if (result == expected) {\n        std::cout << "Test passed: change_base(" << x << ", " << base << ") == " << expected << std::endl;\n    } else {\n        std::cerr << "Test failed: change_base(" << x << ", " << base << ") == " << expected << " (Got " << result << ")" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_change_base(8, 3, "22");\n    test_change_base(9, 3, "100");\n    test_change_base(234, 2, "11101010");\n    test_change_base(16, 2, "10000");\n    test_change_base(8, 2, "1000");\n    test_change_base(7, 2, "111");\n\n    return 0;\n}\n
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\ndouble triangle_area(double a, double h);\n\nint main() {\n    double result;\n\n    // Test cases\n    result = triangle_area(5.0, 3.0);\n    if (std::abs(result - 7.5) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(5, 3) should be 7.5" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(2.0, 2.0);\n    if (std::abs(result - 2.0) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(2, 2) should be 2.0" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(10.0, 8.0);\n    if (std::abs(result - 40.0) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(10, 8) should be 40.0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n\n// Function definition\ndouble triangle_area(double a, double h) {\n    return (a * h) * 0.5;\n}\n```\n\nThis C++ code includes the main function and the `triangle_area` function, which calculates the area of a triangle given the base and height. The main function contains several test cases to verify the correctness of the `triangle_area` function. If any test case fails, it prints an error message and exits with a non-zero status. If all tests pass, it prints a success message.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `triangle_area` function in both languages.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_triangle_area.f90`:\n\n```fortran\nprogram test_triangle_area\n    implicit none\n    real :: result\n\n    ! Test cases\n    result = triangle_area(5.0, 3.0)\n    if (abs(result - 7.5) > 1e-4) then\n        write(*,*) "Test failed: triangle_area(5, 3) should be 7.5"\n        call exit(1)\n    end if\n\n    result = triangle_area(2.0, 2.0)\n    if (abs(result - 2.0) > 1e-4) then\n        write(*,*) "Test failed: triangle_area(2, 2) should be 2.0"\n        call exit(1)\n    end if\n\n    result = triangle_area(10.0, 8.0)\n    if (abs(result - 40.0) > 1e-4) then\n        write(*,*) "Test failed: triangle_area(10, 8) should be 40.0"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function triangle_area(a, h) result(area)\n        real, intent(in) :: a, h\n        real :: area\n        area = (a * h) * 0.5\n    end function triangle_area\n\nend program test_triangle_area\n```\n\nTo compile and run the Fortran code, use the following commands:\n\n```sh\ngfortran -o test_triangle_area test_triangle_area.f90\n./test_triangle_area\n```\n\n### C++ Unit Test Code\n\nSave the following C++ code in a file named `test_triangle_area.cpp`:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\ndouble triangle_area(double a, double h);\n\nint main() {\n    double result;\n\n    // Test cases\n    result = triangle_area(5.0, 3.0);\n    if (std::abs(result - 7.5) > 1e-4) {\n        std::cerr << "Test failed: triangle_area(5, 3) should be 7.5" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(2.0, 2.0);\n    if (std::abs(result - 2.0) > 1e-4) {\n        std::cerr << "Test failed: triangle_area(2, 2) should be 2.0" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(10.0, 8.0);\n    if (std::abs(result - 40.0) > 1e-4) {\n        std::cerr << "Test failed: triangle_area(10, 8) should be 40.0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n\n// Function definition\ndouble triangle_area(double a, double h) {\n    return (a * h) * 0.5;\n}\n```\n\nTo compile and run the C++ code, use the following commands:\n\n```sh\ng++ -o test_triangle_area test_triangle_area.cpp\n./test_triangle_area\n```\n\nThese unit tests will verify that the `triangle_area` function works correctly in both Fortran and C++ by comparing the computed results with the expected values. If all tests pass, it indicates that the function behaves as expected in both languages.
Certainly! Below is the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint fib4(int n);\n\nint main() {\n    // Assertions\n    if (fib4(5) != 4) {\n        std::cerr << "fib4(5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fib4(8) != 28) {\n        std::cerr << "fib4(8) == 28: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fib4(10) != 104) {\n        std::cerr << "fib4(10) == 104: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fib4(12) != 386) {\n        std::cerr << "fib4(12) == 386: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint fib4(int n) {\n    static int f[100]; // Static array to store the sequence\n    if (n < 4) {\n        // Initialize the first four elements\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n    }\n\n    // Compute the sequence if not already computed\n    if (f[n] == 0) {\n        f[n] = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4);\n    }\n\n    return f[n];\n}\n```\n\n### Explanation:\n1. **Function Declaration and Definition**: The `fib4` function is defined similarly to the Fortran version, using a static array to store the computed values.\n2. **Main Function**: The main function contains assertions similar to the Fortran code. If any assertion fails, it prints an error message and exits with a non-zero status.\n3. **Static Array**: The static array `f` is used to store the computed values of the Fibonacci sequence to avoid recomputing the same values.\n4. **Initialization**: The first four elements are initialized directly within the function, similar to the Fortran version.\n5. **Recursion**: The function uses recursion to compute the Fibonacci sequence.\n\nThis C++ code should behave similarly to the provided Fortran code, ensuring the same correctness and performance.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Tests\n\nTo create unit tests for the Fortran code, you can use a simple testing approach by adding test cases directly in the program. Here is an example:\n\n```fortran\nprogram fib4_program\n    implicit none\n\n    ! Test cases\n    call test_fib4()\n\ncontains\n\n    ! Function definition\n    integer function fib4(n)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(0:99) :: f\n        integer :: i\n\n        ! Initialize the first four elements\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\n        ! Compute the sequence\n        do i = 4, n\n            f(i) = f(i-1) + f(i-2) + f(i-3) + f(i-4)\n        end do\n\n        fib4 = f(n)\n    end function fib4\n\n    ! Test function\n    subroutine test_fib4()\n        implicit none\n        integer :: i\n        integer, parameter :: expected(4) = [4, 28, 104, 386]\n        integer, parameter :: n(4) = [5, 8, 10, 12]\n\n        do i = 1, 4\n            if (fib4(n(i)) /= expected(i)) then\n                write(*,*) "Test failed for fib4(", n(i), "): expected ", expected(i), ", got ", fib4(n(i))\n                call exit(1)\n            end if\n        end do\n\n        write(*,*) "All tests passed."\n    end subroutine test_fib4\n\nend program fib4_program\n```\n\n### C++ Unit Tests\n\nFor the C++ code, you can use a simple testing approach by adding test cases directly in the `main` function. Here is an example:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint fib4(int n);\n\nvoid test_fib4() {\n    int expected[4] = {4, 28, 104, 386};\n    int n[4] = {5, 8, 10, 12};\n\n    for (int i = 0; i < 4; ++i) {\n        if (fib4(n[i]) != expected[i]) {\n            std::cerr << "Test failed for fib4(" << n[i] << "): expected " << expected[i] << ", got " << fib4(n[i]) << std::endl;\n            std::exit(1);\n        }\n    }\n\n    std::cout << "All tests passed." << std::endl;\n}\n\nint main() {\n    // Assertions (optional, if you want to use the same approach as in the original code)\n    // ...\n\n    // Test cases\n    test_fib4();\n\n    return 0;\n}\n\n// Function definition\nint fib4(int n) {\n    static int f[100]; // Static array to store the sequence\n    if (n < 4) {\n        // Initialize the first four elements\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n    }\n\n    // Compute the sequence if not already computed\n    if (f[n] == 0) {\n        f[n] = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4);\n    }\n\n    return f[n];\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Tests**:\n   - The `test_fib4` subroutine contains test cases for the `fib4` function.\n   - It checks if the output of `fib4` matches the expected values.\n   - If any test fails, it prints an error message and exits with a non-zero status.\n   - If all tests pass, it prints "All tests passed."\n\n2. **C++ Unit Tests**:\n   - The `test_fib4` function contains test cases for the `fib4` function.\n   - It checks if the output of `fib4` matches the expected values.\n   - If any test fails, it prints an error message and exits with a non-zero status.\n   - If all tests pass, it prints "All tests passed."\n\nThese unit tests will help verify that the translated C++ code behaves correctly and matches the output of the original Fortran code.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the `sort` and `median` functions within a namespace `utilities` similar to the Fortran module. The `median_test` function demonstrates how to use these functions and includes a few test cases to verify their correctness.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nnamespace utilities {\n    void sort(std::vector<float>& arr) {\n        int n = arr.size();\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (arr[i] > arr[j]) {\n                    std::swap(arr[i], arr[j]);\n                }\n            }\n        }\n    }\n\n    float median(const std::vector<float>& arr) {\n        std::vector<float> sorted_arr = arr;\n        sort(sorted_arr);\n        int n = sorted_arr.size();\n        if (n % 2 == 1) {\n            return sorted_arr[n / 2];\n        } else {\n            return (sorted_arr[n / 2 - 1] + sorted_arr[n / 2]) / 2.0f;\n        }\n    }\n}\n\nvoid median_test() {\n    using namespace utilities;\n\n    // Test cases\n    float result = median({3.0f, 1.0f, 2.0f, 4.0f, 5.0f});\n    if (std::abs(result - 3.0f) > 1e-4) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({-10.0f, 4.0f, 6.0f, 1000.0f, 10.0f, 20.0f});\n    if (std::abs(result - 8.0f) > 1e-4) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({5.0f});\n    if (std::abs(result - 5.0f) > 1e-4) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({6.0f, 5.0f});\n    if (std::abs(result - 5.5f) > 1e-4) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({8.0f, 1.0f, 3.0f, 9.0f, 9.0f, 2.0f, 7.0f});\n    if (std::abs(result - 7.0f) > 1e-4) {\n        std::cerr << "Test case 5 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All test cases passed." << std::endl;\n}\n\nint main() {\n    median_test();\n    return 0;\n}\n```\n\nThis C++ code defines the `sort` and `median` functions within the `utilities` namespace, similar to the Fortran module. The `median_test` function demonstrates how to use these functions and includes a few test cases to verify their correctness. The test cases compare the computed median against expected values and print an error message if any test case fails.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const std::string& text) {\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return (reversed_text == text);\n}\n\nint main() {\n    // Main program\n    if (!is_palindrome("")) {\n        std::cerr << "Assertion failed: is_palindrome('') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aba")) {\n        std::cerr << "Assertion failed: is_palindrome('aba') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        std::cerr << "Assertion failed: is_palindrome('aaaaa') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("zbcd")) {\n        std::cerr << "Assertion failed: is_palindrome('zbcd') == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyx') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywyz")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyz') == false" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywzx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywzx') == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a function `is_palindrome` that checks if a given string is a palindrome, and then tests this function with various inputs in the `main` function. The tests are similar to the Fortran program, ensuring that the function behaves as expected.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `is_palindrome` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule palindrome_module\n    implicit none\ncontains\n    logical function is_palindrome(text)\n        character(len=*), intent(in) :: text\n        character(len=:), allocatable :: reversed_text\n        integer :: i, n\n\n        n = len_trim(text)\n        allocate(character(len=n) :: reversed_text)\n        do i = 1, n\n            reversed_text(i:i) = text(n-i+1:n-i+1)\n        end do\n\n        is_palindrome = (trim(reversed_text) == trim(text))\n        deallocate(reversed_text)\n    end function is_palindrome\nend module palindrome_module\n\nprogram palindrome_check\n    use palindrome_module\n    implicit none\n\n    ! Main program\n    if (.not. is_palindrome("")) then\n        write(*,*) "Assertion failed: is_palindrome('') == true"\n        call exit(1)\n    end if\n\n    if (.not. is_palindrome("aba")) then\n        write(*,*) "Assertion failed: is_palindrome('aba') == true"\n        call exit(1)\n    end if\n\n    if (.not. is_palindrome("aaaaa")) then\n        write(*,*) "Assertion failed: is_palindrome('aaaaa') == true"\n        call exit(1)\n    end if\n\n    if (is_palindrome("zbcd")) then\n        write(*,*) "Assertion failed: is_palindrome('zbcd') == false"\n        call exit(1)\n    end if\n\n    if (.not. is_palindrome("xywyx")) then\n        write(*,*) "Assertion failed: is_palindrome('xywyx') == true"\n        call exit(1)\n    end if\n\n    if (is_palindrome("xywyz")) then\n        write(*,*) "Assertion failed: is_palindrome('xywyz') == false"\n        call exit(1)\n    end if\n\n    if (is_palindrome("xywzx")) then\n        write(*,*) "Assertion failed: is_palindrome('xywzx') == false"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\nend program palindrome_check\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const std::string& text) {\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return (reversed_text == text);\n}\n\nint main() {\n    // Main program\n    if (!is_palindrome("")) {\n        std::cerr << "Assertion failed: is_palindrome('') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aba")) {\n        std::cerr << "Assertion failed: is_palindrome('aba') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        std::cerr << "Assertion failed: is_palindrome('aaaaa') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("zbcd")) {\n        std::cerr << "Assertion failed: is_palindrome('zbcd') == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyx') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywyz")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyz') == false" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywzx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywzx') == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThese unit tests are designed to verify the correctness of the `is_palindrome` function in both Fortran and C++. They cover various cases, including empty strings, strings with odd and even lengths, and strings that are palindromes and not palindromes. If any test fails, the program will print an error message and exit with a non-zero status.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint modp(int n, int p);\n\nint main() {\n    // Variable declaration\n    int result;\n\n    // Assertions\n    result = modp(3, 5);\n    if (result != 3) {\n        std::cerr << "modp(3, 5) == 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(1101, 101);\n    if (result != 2) {\n        std::cerr << "modp(1101, 101) == 2: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(0, 101);\n    if (result != 1) {\n        std::cerr << "modp(0, 101) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(3, 11);\n    if (result != 8) {\n        std::cerr << "modp(3, 11) == 8: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(100, 101);\n    if (result != 1) {\n        std::cerr << "modp(100, 101) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(30, 5);\n    if (result != 4) {\n        std::cerr << "modp(30, 5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(31, 5);\n    if (result != 3) {\n        std::cerr << "modp(31, 5) == 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint modp(int n, int p) {\n    int result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\n```\n\nThis C++ code includes the necessary headers and uses the `std::cerr` for error output and `std::exit(1)` for exiting the program with an error code if any of the assertions fail. The `modp` function is defined similarly to the Fortran version, using a for-loop to iterate through the bits of `n` and multiplying the result by 2, modulo `p`, for each bit.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `modp` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_modp\n    implicit none\n\n    ! Test cases\n    call test_case(3, 5, 3)\n    call test_case(1101, 101, 2)\n    call test_case(0, 101, 1)\n    call test_case(3, 11, 8)\n    call test_case(100, 101, 1)\n    call test_case(30, 5, 4)\n    call test_case(31, 5, 3)\n\ncontains\n\n    ! Function definition\n    integer function modp(n, p)\n        integer, intent(in) :: n, p\n        integer :: i\n        modp = 1\n        do i = 1, n\n            modp = mod(modp * 2, p)\n        end do\n    end function modp\n\n    ! Test case subroutine\n    subroutine test_case(n, p, expected)\n        integer, intent(in) :: n, p, expected\n        integer :: result\n        result = modp(n, p)\n        if (result /= expected) then\n            write(*,*) "Test failed: modp(", n, ",", p, ") == ", expected, ", got ", result\n            call exit(1)\n        else\n            write(*,*) "Test passed: modp(", n, ",", p, ") == ", expected\n        end if\n    end subroutine test_case\n\nend program test_modp\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint modp(int n, int p);\n\n// Test case function\nvoid test_case(int n, int p, int expected) {\n    int result = modp(n, p);\n    if (result != expected) {\n        std::cerr << "Test failed: modp(" << n << ", " << p << ") == " << expected << ", got " << result << std::endl;\n        std::exit(1);\n    } else {\n        std::cout << "Test passed: modp(" << n << ", " << p << ") == " << expected << std::endl;\n    }\n}\n\nint main() {\n    // Test cases\n    test_case(3, 5, 3);\n    test_case(1101, 101, 2);\n    test_case(0, 101, 1);\n    test_case(3, 11, 8);\n    test_case(100, 101, 1);\n    test_case(30, 5, 4);\n    test_case(31, 5, 3);\n\n    return 0;\n}\n\n// Function definition\nint modp(int n, int p) {\n    int result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\n```\n\n### Explanation\n\n- **Fortran Unit Test Code**:\n  - The `modp` function is defined as before.\n  - The `test_case` subroutine is used to test the `modp` function with different inputs and expected outputs.\n  - If the result does not match the expected output, it prints an error message and exits with a non-zero status.\n  - If the test passes, it prints a success message.\n\n- **C++ Unit Test Code**:\n  - The `modp` function is defined as before.\n  - The `test_case` function is used to test the `modp` function with different inputs and expected outputs.\n  - If the result does not match the expected output, it prints an error message and exits with a non-zero status.\n  - If the test passes, it prints a success message.\n\nThese unit tests will help ensure that the `modp` function behaves correctly in both Fortran and C++.
To translate the given Fortran code to C++, we need to adapt the Fortran-specific features to their C++ equivalents. Here's how the Fortran code can be translated to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n\nstd::string encode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = (s[i] + 5 - 'a') % 26 + 'a';\n        out[i] = static_cast<char>(w);\n    }\n    return out;\n}\n\nstd::string decode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = (s[i] + 21 - 'a') % 26 + 'a';\n        out[i] = static_cast<char>(w);\n    }\n    return out;\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i < 100; ++i) {\n        int l = 10 + std::rand() % 11;\n        std::string str = "";\n        for (int j = 0; j < l; ++j) {\n            int chr = 'a' + std::rand() % 26;\n            str += static_cast<char>(chr);\n        }\n\n        std::string encoded_str = encode_shift(str);\n        std::string decoded_str = decode_shift(encoded_str);\n\n        if (str != decoded_str) {\n            std::cerr << "Assertion failed: decoded string does not match original" << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Random Number Generation**:\n   - In Fortran, `call random_seed()` and `call random_number(rand_val)` are used to generate random numbers.\n   - In C++, `std::srand(std::time(nullptr));` initializes the random number generator and `std::rand()` generates random numbers.\n\n2. **String Handling**:\n   - Fortran's `character(len=21) :: str, encoded_str, decoded_str` is translated to `std::string` in C++.\n\n3. **Character Encoding and Decoding**:\n   - The `encode_shift` and `decode_shift` functions in Fortran are translated to C++ functions that return `std::string`.\n   - The character encoding and decoding logic remains the same, using modular arithmetic to shift characters.\n\n4. **Loop Constructs**:\n   - Fortran's `do` loops are translated to `for` loops in C++.\n\n5. **Assertion**:\n   - The Fortran `if` statement and `write` statement are replaced with an `if` statement and `std::cerr` for error output in C++.\n\nThis C++ code should behave similarly to the original Fortran code, performing the same operations and checks.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can create unit tests. These tests will run a series of checks to ensure that the encoding and decoding functions work as expected.\n\n### Fortran Unit Test\n\nFor the Fortran code, we can create a simple test program that calls the `encode_shift` and `decode_shift` functions with predefined inputs and checks the results.\n\n```fortran\nprogram test_encode_decode_shift\n    implicit none\n    character(len=21) :: test_str, encoded_str, decoded_str\n\n    ! Test 1\n    test_str = "hello"\n    encoded_str = encode_shift(test_str)\n    decoded_str = decode_shift(encoded_str)\n    if (trim(decoded_str) /= trim(test_str)) then\n        write(*,*) "Test 1 failed: ", trim(test_str), " != ", trim(decoded_str)\n    else\n        write(*,*) "Test 1 passed"\n    end if\n\n    ! Test 2\n    test_str = "world"\n    encoded_str = encode_shift(test_str)\n    decoded_str = decode_shift(encoded_str)\n    if (trim(decoded_str) /= trim(test_str)) then\n        write(*,*) "Test 2 failed: ", trim(test_str), " != ", trim(decoded_str)\n    else\n        write(*,*) "Test 2 passed"\n    end if\n\ncontains\n    function encode_shift(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 5 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function encode_shift\n\n    function decode_shift(s) result(out)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: out\n        integer :: i, w\n\n        out = s\n        do i = 1, len(s)\n            w = mod(iachar(s(i:i)) + 21 - iachar('a'), 26) + iachar('a')\n            out(i:i) = char(w)\n        end do\n    end function decode_shift\nend program test_encode_decode_shift\n```\n\n### C++ Unit Test\n\nFor the C++ code, we can use a simple test framework like Google Test or just write a basic test function. Here, I'll show a basic approach without an external framework:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string encode_shift(const std::string& s);\nstd::string decode_shift(const std::string& s);\n\nvoid test_encode_decode_shift() {\n    // Test 1\n    std::string test_str = "hello";\n    std::string encoded_str = encode_shift(test_str);\n    std::string decoded_str = decode_shift(encoded_str);\n    assert(test_str == decoded_str && "Test 1 failed");\n    std::cout << "Test 1 passed" << std::endl;\n\n    // Test 2\n    test_str = "world";\n    encoded_str = encode_shift(test_str);\n    decoded_str = decode_shift(encoded_str);\n    assert(test_str == decoded_str && "Test 2 failed");\n    std::cout << "Test 2 passed" << std::endl;\n}\n\nint main() {\n    test_encode_decode_shift();\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test**:\n   - The program defines two tests, "hello" and "world", and checks if the decoded string matches the original.\n   - The `encode_shift` and `decode_shift` functions are included within the program for completeness.\n\n2. **C++ Unit Test**:\n   - The `test_encode_decode_shift` function defines two tests similar to the Fortran version.\n   - The `assert` function is used to check if the decoded string matches the original. If the assertion fails, it will terminate the program and print an error message.\n   - The `main` function calls `test_encode_decode_shift` to run the tests.\n\nThese unit tests will help verify that the encoding and decoding functions work as expected in both the Fortran and C++ implementations.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses standard I/O streams for output.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_vowels(const std::string& text) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\nvoid assert_test(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_test(remove_vowels("") == "");\n    assert_test(remove_vowels("abcdef//nghijklm") == "bcdf//nghjklm");\n    assert_test(remove_vowels("fedcba") == "fdcb");\n    assert_test(remove_vowels("eeeee") == "");\n    assert_test(remove_vowels("acBAA") == "cB");\n    assert_test(remove_vowels("EcBOO") == "cB");\n    assert_test(remove_vowels("ybcd") == "ybcd");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `remove_vowels`**: This function takes a `std::string` as input and returns a new string with all vowels removed. It uses a `std::string` for the vowels and iterates through the input string, copying non-vowel characters to the result string.\n\n2. **`assert_test`**: This function is a simple assertion utility that checks the condition and prints an error message if the condition is false, then exits the program with a non-zero status. It's a direct translation of the Fortran `assert` subroutine.\n\n3. **`main` function**: This is the entry point of the C++ program. It contains the test cases that call `assert_test` with the expected outcomes. If all tests pass, it prints a success message.\n\nThis code should compile with a standard C++ compiler and run the tests as expected.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `remove_vowels` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram remove_vowels_program\n    implicit none\n    character(len=100) :: text, result\n    character(len=100) :: empty_string\n    character(len=100) :: vowels\n    integer :: i\n\n    ! Test cases\n    empty_string = ""\n    call assert(remove_vowels(empty_string) == "")\n    call assert(remove_vowels("abcdef//nghijklm") == "bcdf//nghjklm")\n    call assert(remove_vowels("fedcba") == "fdcb")\n    call assert(remove_vowels("eeeee") == "")\n    call assert(remove_vowels("acBAA") == "cB")\n    call assert(remove_vowels("EcBOO") == "cB")\n    call assert(remove_vowels("ybcd") == "ybcd")\n\ncontains\n\n    function remove_vowels(text) result(out)\n        character(len=*), intent(in) :: text\n        character(len=100) :: out\n        character(len=100) :: vowels\n        integer :: i, j, len_text, len_vowels\n        logical :: is_vowel\n\n        out = ""\n        vowels = "AEIOUaeiou"\n        len_text = len_trim(text)\n        len_vowels = len_trim(vowels)\n\n        do i = 1, len_text\n            is_vowel = .false.\n            do j = 1, len_vowels\n                if (text(i:i) == vowels(j:j)) then\n                    is_vowel = .true.\n                    exit\n                end if\n            end do\n            if (.not. is_vowel) then\n                out = trim(out) // text(i:i)\n            end if\n        end do\n    end function remove_vowels\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program remove_vowels_program\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_vowels(const std::string& text) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\nvoid assert_test(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_test(remove_vowels("") == "");\n    assert_test(remove_vowels("abcdef//nghijklm") == "bcdf//nghjklm");\n    assert_test(remove_vowels("fedcba") == "fdcb");\n    assert_test(remove_vowels("eeeee") == "");\n    assert_test(remove_vowels("acBAA") == "cB");\n    assert_test(remove_vowels("EcBOO") == "cB");\n    assert_test(remove_vowels("ybcd") == "ybcd");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code**: This program includes the `remove_vowels` function and a simple `assert` subroutine to check the correctness of the function. It tests various strings with and without vowels to ensure the function works as expected.\n\n2. **C++ Unit Test Code**: This program mirrors the Fortran unit test code, using C++ syntax and constructs. It includes the `remove_vowels` function and an `assert_test` function to validate the correctness of the function.\n\nTo compile and run these tests, you would use a Fortran compiler for the Fortran code and a C++ compiler for the C++ code. For example, for Fortran, you might use `gfortran`, and for C++, `g++` or `clang++`.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses standard I/O for output. The function `below_threshold` is implemented to match the Fortran version's logic.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> l;\n    int t;\n\n    // Test cases\n    l = {1, 2, 4, 10};\n    t = 100;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 20, 4, 10};\n    t = 5;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 20, 4, 10};\n    t = 21;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 20, 4, 10};\n    t = 22;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 8, 4, 10};\n    t = 11;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 8, 4, 10};\n    t = 10;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ code defines a function `below_threshold` that takes a vector of integers and an integer threshold as arguments. It iterates through the vector elements and checks if any of them is greater than or equal to the threshold. If any element meets the condition, it returns `false`, indicating that the threshold is not met; otherwise, it returns `true`, indicating that the threshold is met. The `main` function contains several test cases that verify the correctness of the `below_threshold` function. If any test fails, it prints an error message and exits with a non-zero status.
Certainly! Below is the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n#include <ctime> // For srand() and rand()\n\n// Function declaration\nint add(int x, int y);\n\nint main() {\n    // Assertions\n    if (add(0, 1) != 1) {\n        std::cerr << "Assertion failed: add(0, 1) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (add(1, 0) != 1) {\n        std::cerr << "Assertion failed: add(1, 0) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (add(2, 3) != 5) {\n        std::cerr << "Assertion failed: add(2, 3) == 5" << std::endl;\n        exit(1);\n    }\n\n    if (add(5, 7) != 12) {\n        std::cerr << "Assertion failed: add(5, 7) == 12" << std::endl;\n        exit(1);\n    }\n\n    if (add(7, 5) != 12) {\n        std::cerr << "Assertion failed: add(7, 5) == 12" << std::endl;\n        exit(1);\n    }\n\n    // Seed the random number generator\n    srand(static_cast<unsigned int>(time(nullptr)));\n\n    // Loop with random number generation and assertions\n    for (int i = 1; i <= 100; ++i) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        if (add(x, y) != x + y) {\n            std::cerr << "Assertion failed: add(" << x << ", " << y << ") == " << (x + y) << std::endl;\n            exit(1);\n        }\n    }\n\n    return 0;\n}\n\n// Function definition\nint add(int x, int y) {\n    return x + y;\n}\n```\n\n### Explanation:\n1. **Header Files**:\n   - `#include <iostream>` for input and output operations.\n   - `#include <cstdlib>` for the `exit()` function.\n   - `#include <ctime>` for random number generation.\n\n2. **Function Declaration**:\n   - The `add` function is declared before `main` to ensure it is recognized when called.\n\n3. **Assertions**:\n   - The assertions are directly translated from Fortran to C++ with the same logic.\n\n4. **Random Number Generation**:\n   - The `srand` function is used to seed the random number generator.\n   - The `rand()` function is used to generate random numbers.\n\n5. **Loop with Assertions**:\n   - The loop generates random numbers and checks the result of `add` against the expected value.\n\n6. **Error Handling**:\n   - If an assertion fails, an error message is printed to `std::cerr` and the program exits with a status code of `1`.\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\nTo create a unit test for the Fortran code, you can use a simple Fortran program that calls the `add` function with various inputs and checks the results.\n\n```fortran\nprogram test_add\n    implicit none\n    integer :: errors\n    errors = 0\n\n    ! Test cases\n    if (add(0, 1) /= 1) then\n        write(*,*) "Test failed: add(0, 1) == 1"\n        errors = errors + 1\n    end if\n\n    if (add(1, 0) /= 1) then\n        write(*,*) "Test failed: add(1, 0) == 1"\n        errors = errors + 1\n    end if\n\n    if (add(2, 3) /= 5) then\n        write(*,*) "Test failed: add(2, 3) == 5"\n        errors = errors + 1\n    end if\n\n    if (add(5, 7) /= 12) then\n        write(*,*) "Test failed: add(5, 7) == 12"\n        errors = errors + 1\n    end if\n\n    if (add(7, 5) /= 12) then\n        write(*,*) "Test failed: add(7, 5) == 12"\n        errors = errors + 1\n    end if\n\n    ! Final report\n    if (errors == 0) then\n        write(*,*) "All tests passed successfully."\n    else\n        write(*,*) errors, " tests failed."\n    end if\n\ncontains\n\n    integer function add(x, y)\n        integer, intent(in) :: x, y\n        add = x + y\n    end function add\n\nend program test_add\n```\n\n### C++ Unit Test Code\n\nTo create a unit test for the C++ code, you can use a simple C++ program that calls the `add` function with various inputs and checks the results.\n\n```cpp\n#include <iostream>\n#include <cassert> // For assert()\n\n// Function declaration\nint add(int x, int y);\n\nint main() {\n    // Test cases\n    assert(add(0, 1) == 1);\n    assert(add(1, 0) == 1);\n    assert(add(2, 3) == 5);\n    assert(add(5, 7) == 12);\n    assert(add(7, 5) == 12);\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint add(int x, int y) {\n    return x + y;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code**:\n   - The `test_add` program contains a series of assertions to test the `add` function.\n   - If any test fails, it prints an error message and increments the `errors` variable.\n   - At the end, it reports the number of failed tests.\n\n2. **C++ Unit Test Code**:\n   - The `main` function contains a series of `assert` statements to test the `add` function.\n   - If any test fails, the program will terminate and indicate the failed assertion.\n   - If all tests pass, it prints a success message.\n\nThese unit tests will help ensure that the `add` function behaves correctly in both the Fortran and C++ implementations.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the `same_chars` function and the main function to run the assertions.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool same_chars(const std::string& s0, const std::string& s1) {\n    for (size_t i = 0; i < s0.size(); ++i) {\n        if (s1.find(s0[i]) == std::string::npos) {\n            return false;\n        }\n    }\n\n    for (size_t i = 0; i < s1.size(); ++i) {\n        if (s0.find(s1[i]) == std::string::npos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    bool result;\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddeddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("abcd", "dddddddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabc') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("dddddddabc", "abcd");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('dddddddabc', 'abcd') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("eabcd", "dddddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcd', 'dddddddabc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("abcd", "dddddddabcf");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabcf') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("aabb", "aaccc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('aabb', 'aaccc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines the `same_chars` function, which takes two strings as input and returns `true` if all characters in the first string are present in the second string and vice versa, and `false` otherwise. The `main` function contains assertions similar to the Fortran code, checking the correctness of the `same_chars` function with various inputs. If any assertion fails, it prints an error message and exits with a non-zero status.
Certainly! Below is the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\nint fib(int n) {\n    int f[1000];\n    f[1] = 0;\n    f[2] = 1;\n    for (int i = 3; i <= n + 1; ++i) {\n        f[i] = f[i-1] + f[i-2];\n    }\n    return f[n+1];\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = fib(10);\n    if (result != 55) {\n        std::cerr << "fib(10) == 55: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(1);\n    if (result != 1) {\n        std::cerr << "fib(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(8);\n    if (result != 21) {\n        std::cerr << "fib(8) == 21: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(11);\n    if (result != 89) {\n        std::cerr << "fib(11) == 89: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(12);\n    if (result != 144) {\n        std::cerr << "fib(12) == 144: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a `fib` function to calculate the nth Fibonacci number and includes a main function with test cases to verify the correctness of the `fib` function. The test cases are similar to those in the Fortran code and will exit the program with an error code if any of the assertions fail.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the Fortran and C++ versions of the Fibonacci code. These tests will verify the correctness of the `fib` function for a range of inputs.\n\n### Fortran Unit Tests\n\nTo run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Save the following code in a file named `fibonacci_tests.f90`:\n\n```fortran\nprogram fibonacci_tests\n  implicit none\n  integer :: result\n  integer :: i\n\n  ! Test cases\n  do i = 1, 12\n     result = fib(i)\n     if (result /= expected_fib(i)) then\n        write(*,*) "fib(", i, ") == ", expected_fib(i), ": assertion failed"\n        call exit(1)\n     end if\n  end do\n\n  write(*,*) "All tests passed successfully."\n\ncontains\n\n  integer function fib(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: f(1000)\n    integer :: i\n\n    f(1) = 0\n    f(2) = 1\n    do i = 3, n + 1\n      f(i) = f(i-1) + f(i-2)\n    end do\n    fib = f(n+1)\n  end function fib\n\n  integer function expected_fib(n)\n    implicit none\n    integer, intent(in) :: n\n    select case(n)\n    case(1)\n      expected_fib = 1\n    case(2)\n      expected_fib = 1\n    case(3)\n      expected_fib = 2\n    case(4)\n      expected_fib = 3\n    case(5)\n      expected_fib = 5\n    case(6)\n      expected_fib = 8\n    case(7)\n      expected_fib = 13\n    case(8)\n      expected_fib = 21\n    case(9)\n      expected_fib = 34\n    case(10)\n      expected_fib = 55\n    case(11)\n      expected_fib = 89\n    case(12)\n      expected_fib = 144\n    case default\n      expected_fib = -1\n    end select\n  end function expected_fib\n\nend program fibonacci_tests\n```\n\n### C++ Unit Tests\n\nTo run the C++ unit tests, you can use a C++ compiler like `g++`. Save the following code in a file named `fibonacci_tests.cpp`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\nint fib(int n) {\n    int f[1000];\n    f[1] = 0;\n    f[2] = 1;\n    for (int i = 3; i <= n + 1; ++i) {\n        f[i] = f[i-1] + f[i-2];\n    }\n    return f[n+1];\n}\n\nint expected_fib(int n) {\n    switch (n) {\n        case 1: return 1;\n        case 2: return 1;\n        case 3: return 2;\n        case 4: return 3;\n        case 5: return 5;\n        case 6: return 8;\n        case 7: return 13;\n        case 8: return 21;\n        case 9: return 34;\n        case 10: return 55;\n        case 11: return 89;\n        case 12: return 144;\n        default: return -1;\n    }\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    for (int i = 1; i <= 12; ++i) {\n        result = fib(i);\n        if (result != expected_fib(i)) {\n            std::cerr << "fib(" << i << ") == " << expected_fib(i) << ": assertion failed" << std::endl;\n            std::exit(1);\n        }\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Running the Tests\n\n#### Fortran\n\nTo compile and run the Fortran tests, use the following commands:\n\n```sh\ngfortran -o fibonacci_tests fibonacci_tests.f90\n./fibonacci_tests\n```\n\n#### C++\n\nTo compile and run the C++ tests, use the following commands:\n\n```sh\ng++ -o fibonacci_tests fibonacci_tests.cpp\n./fibonacci_tests\n```\n\nThese tests will verify the correctness of the `fib` function for inputs from 1 to 12 and will exit the program with an error code if any of the assertions fail. If all tests pass, it will print "All tests passed successfully."
Certainly! Below is the translated C++ code for the given Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n// Function to check if the array is monotonic\nbool is_monotonic(const std::vector<float>& l) {\n    bool incr = false;\n    bool decr = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) incr = true;\n        if (l[i] < l[i - 1]) decr = true;\n    }\n\n    return !(incr && decr);\n}\n\nint main() {\n    // Test cases\n    std::vector<float> l;\n\n    l = {1.0, 2.0, 4.0, 10.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 4, 10} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 2.0, 4.0, 20.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 4, 20} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 20.0, 4.0, 10.0};\n    if (is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 20, 4, 10} should not be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {4.0, 1.0, 0.0, -10.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {4, 1, 0, -10} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {4.0, 1.0, 1.0, 0.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {4, 1, 1, 0} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 2.0, 3.0, 2.0, 5.0, 60.0};\n    if (is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 3, 2, 5, 60} should not be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 2.0, 3.0, 4.0, 5.0, 60.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 3, 4, 5, 60} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {9.0, 9.0, 9.0, 9.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {9, 9, 9, 9} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses the `std::vector<float>` for the array representation, which is a common practice in C++ for dynamic arrays. The `is_monotonic` function checks if the array is monotonic, and the `main` function contains the test cases similar to the Fortran program. The `std::cerr` is used for error output, and `std::exit(1)` is used to exit the program with an error code if any of the assertions fail.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `is_monotonic` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule monotonic_module\n  implicit none\ncontains\n  ! Function to check if the array is monotonic\n  logical function is_monotonic(l)\n    real, dimension(:), intent(in) :: l\n    integer :: i\n    logical :: incr, decr\n\n    incr = .false.\n    decr = .false.\n\n    do i = 2, size(l)\n      if (l(i) > l(i-1)) incr = .true.\n      if (l(i) < l(i-1)) decr = .true.\n    end do\n\n    if (incr .and. decr) then\n      is_monotonic = .false.\n    else\n      is_monotonic = .true.\n    end if\n  end function is_monotonic\nend module monotonic_module\n\nprogram monotonic_check\n  use monotonic_module\n  implicit none\n  real, dimension(:), allocatable :: l\n\n  ! Test cases\n  allocate(l(4))\n  l = [1.0, 2.0, 4.0, 10.0]\n  if (.not. is_monotonic(l)) then\n    write(*,*) "Assertion failed: {1, 2, 4, 10} should be monotonic"\n    call exit(1)\n  end if\n\n  l = [1.0, 2.0, 4.0, 20.0]\n  if (.not. is_monotonic(l)) then\n    write(*,*) "Assertion failed: {1, 2, 4, 20} should be monotonic"\n    call exit(1)\n  end if\n\n  l = [1.0, 20.0, 4.0, 10.0]\n  if (is_monotonic(l)) then\n    write(*,*) "Assertion failed: {1, 20, 4, 10} should not be monotonic"\n    call exit(1)\n  end if\n\n  l = [4.0, 1.0, 0.0, -10.0]\n  if (.not. is_monotonic(l)) then\n    write(*,*) "Assertion failed: {4, 1, 0, -10} should be monotonic"\n    call exit(1)\n  end if\n\n  l = [4.0, 1.0, 1.0, 0.0]\n  if (.not. is_monotonic(l)) then\n    write(*,*) "Assertion failed: {4, 1, 1, 0} should be monotonic"\n    call exit(1)\n  end if\n\n  l = [1.0, 2.0, 3.0, 2.0, 5.0, 60.0]\n  if (is_monotonic(l)) then\n    write(*,*) "Assertion failed: {1, 2, 3, 2, 5, 60} should not be monotonic"\n    call exit(1)\n  end if\n\n  l = [1.0, 2.0, 3.0, 4.0, 5.0, 60.0]\n  if (.not. is_monotonic(l)) then\n    write(*,*) "Assertion failed: {1, 2, 3, 4, 5, 60} should be monotonic"\n    call exit(1)\n  end if\n\n  l = [9.0, 9.0, 9.0, 9.0]\n  if (.not. is_monotonic(l)) then\n    write(*,*) "Assertion failed: {9, 9, 9, 9} should be monotonic"\n    call exit(1)\n  end if\n\n  write(*,*) "All tests passed successfully."\n\nend program
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, sorting, and checking for equality between arrays. Below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to sort an array\nvoid sort(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to check if two arrays are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to find the common elements between two arrays\nvoid common(const std::vector<int>& l1, const std::vector<int>& l2, std::vector<int>& out) {\n    std::vector<int> temp(l1.size());\n    size_t n = 0;\n\n    for (size_t i = 0; i < l1.size(); ++i) {\n        bool found = false;\n        for (size_t j = 0; j < n; ++j) {\n            if (temp[j] == l1[i]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (std::any_of(l2.begin(), l2.end(), [&l1, i](int val) { return val == l1[i]; })) {\n                temp[n] = l1[i];\n                ++n;\n            }\n        }\n    }\n\n    if (n > 0) {\n        sort(temp);\n        out = std::vector<int>(temp.begin(), temp.begin() + n);\n    } else {\n        out.clear();\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> l1 = {1, 4, 3, 34, 653, 2, 5};\n    std::vector<int> l2 = {5, 7, 1, 5, 9, 653, 121};\n    std::vector<int> expected = {1, 5, 653};\n    std::vector<int> result;\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    l1 = {5, 3, 2, 8};\n    l2 = {3, 2};\n    expected = {2, 3};\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    l1 = {4, 3, 2, 8};\n    l2 = {3, 2, 4};\n    expected = {2, 3, 4};\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    l1 = {4, 3, 2, 8};\n    l2.clear();\n    expected.clear();\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code includes the necessary functions to perform the same operations as the Fortran code. It uses `std::vector` for dynamic arrays and `std::sort` for sorting. The `issame` function checks if two vectors are equal, and the `common` function finds the common elements between two arrays, similar to the Fortran version. The `main` function contains test cases to verify the correctness of the translation.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `common` and `sort` functions, as well as the `issame` function.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule common_module\n    implicit none\n    contains\n\n    subroutine common(l1, l2, out)\n        implicit none\n        integer, intent(in) :: l1(:), l2(:)\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i, j, n\n        logical :: found\n        integer, allocatable :: temp(:)\n\n        allocate(temp(size(l1)))\n        n = 0\n\n        do i = 1, size(l1)\n            found = .false.\n            do j = 1, n\n                if (temp(j) == l1(i)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                if (any(l2 == l1(i))) then\n                    n = n + 1\n                    temp(n) = l1(i)\n                end if\n            end if\n        end do\n\n        if (n > 0) then\n            call sort(temp(1:n))\n            allocate(out(n))\n            out = temp(1:n)\n        else\n            allocate(out(0))\n        end if\n\n        deallocate(temp)\n    end subroutine common\n\n    subroutine sort(arr)\n        implicit none\n        integer, intent(inout) :: arr(:)\n        integer :: i, j, temp\n\n        do i = 1, size(arr) - 1\n            do j = i + 1, size(arr)\n                if (arr(i) > arr(j)) then\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort\n\n    logical function issame(a, b)\n        implicit none\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend module common_module\n\nprogram test_common\n    use common_module\n    implicit none\n    integer, allocatable :: l1(:), l2(:), result(:), expected(:)\n    logical :: is_same\n\n    ! Test case 1\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    expected = [1, 5, 653]\n    call common(l1, l2, result)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n\n    ! Test case 2\n    l1 = [5, 3, 2, 8]\n    l2 = [3, 2]\n    expected = [2, 3]\n    call common(l1, l2, result)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n\n    ! Test case 3\n    l1 = [4, 3, 2, 8]\n    l2 = [3, 2, 4]\n    expected
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same functionality and assertions as the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_prime_factor(int n) {\n    int num = n;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        while (num % i == 0 && num > i) {\n            num /= i;\n        }\n    }\n    return num;\n}\n\nint main() {\n    // Assertions\n    if (largest_prime_factor(15) != 5) {\n        std::cerr << "Assertion failed: largest_prime_factor(15) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(27) != 3) {\n        std::cerr << "Assertion failed: largest_prime_factor(27) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(63) != 7) {\n        std::cerr << "Assertion failed: largest_prime_factor(63) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(330) != 11) {\n        std::cerr << "Assertion failed: largest_prime_factor(330) == 11" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(13195) != 29) {\n        std::cerr << "Assertion failed: largest_prime_factor(13195) == 29" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ code defines a function `largest_prime_factor` which computes the largest prime factor of a given number, similar to the Fortran version. The `main` function contains assertions to verify the correctness of the `largest_prime_factor` function with specific test cases. If any assertion fails, it prints an error message and exits with a status code of 1, similar to the Fortran version.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `largest_prime_factor` function with a set of predefined test cases.\n\n### Fortran Unit Test Code\n\nTo compile and run this Fortran code, you might need a Fortran compiler like `gfortran`. Save the code in a file named `test_main.f90` and compile it using a command like `gfortran -o test_main test_main.f90`.\n\n```fortran\nprogram test_main\n  implicit none\n\n  ! Test cases\n  call test_case(15, 5)\n  call test_case(27, 3)\n  call test_case(63, 7)\n  call test_case(330, 11)\n  call test_case(13195, 29)\n\ncontains\n\n  subroutine test_case(n, expected)\n    implicit none\n    integer, intent(in) :: n, expected\n    integer :: result\n\n    result = largest_prime_factor(n)\n    if (result /= expected) then\n      write(*,*) "Test failed: largest_prime_factor(", n, ") == ", expected, ", got ", result\n      call exit(1)\n    else\n      write(*,*) "Test passed: largest_prime_factor(", n, ") == ", expected\n    end if\n  end subroutine test_case\n\n  integer function largest_prime_factor(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: i, num\n\n    num = n\n    do i = 2, int(sqrt(real(n)))\n      do while (mod(num, i) == 0 .and. num > i)\n        num = num / i\n      end do\n    end do\n    largest_prime_factor = num\n  end function largest_prime_factor\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\nTo compile and run this C++ code, you might need a C++ compiler like `g++`. Save the code in a file named `test_main.cpp` and compile it using a command like `g++ -o test_main test_main.cpp`.\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_prime_factor(int n) {\n    int num = n;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        while (num % i == 0 && num > i) {\n            num /= i;\n        }\n    }\n    return num;\n}\n\nvoid test_case(int n, int expected) {\n    int result = largest_prime_factor(n);\n    if (result != expected) {\n        std::cerr << "Test failed: largest_prime_factor(" << n << ") == " << expected << ", got " << result << std::endl;\n        std::exit(1);\n    } else {\n        std::cout << "Test passed: largest_prime_factor(" << n << ") == " << expected << std::endl;\n    }\n}\n\nint main() {\n    // Test cases\n    test_case(15, 5);\n    test_case(27, 3);\n    test_case(63, 7);\n    test_case(330, 11);\n    test_case(13195, 29);\n\n    return 0;\n}\n```\n\nThese unit test codes for both Fortran and C++ will verify the correctness of the `largest_prime_factor` function with predefined test cases. If any test fails, it will print an error message and exit with a status code of 1. If all tests pass, it will print a success message for each test case.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint sum_to_n(int n);\n\nint main() {\n    // Assertions\n    if (sum_to_n(1) != 1) {\n        std::cerr << "sum_to_n(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(6) != 21) {\n        std::cerr << "sum_to_n(6) == 21: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(11) != 66) {\n        std::cerr << "sum_to_n(11) == 66: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(30) != 465) {\n        std::cerr << "sum_to_n(30) == 465: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(100) != 5050) {\n        std::cerr << "sum_to_n(100) == 5050: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n```\n\nThis C++ code includes the necessary headers and uses `std::cerr` for error output and `std::exit(1)` to exit the program with an error code if any of the assertions fail, similar to the Fortran code. The `sum_to_n` function is defined with the same logic as in the Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `sum_to_n` function.\n\n### Fortran Unit Tests\n\nTo add unit tests directly in the Fortran program, you can modify the program to include test cases directly. Here's how you can do it:\n\n```fortran\nprogram main\n  implicit none\n\n  ! Test cases\n  call test_sum_to_n()\n\ncontains\n\n  ! Function definition\n  integer function sum_to_n(n)\n    integer, intent(in) :: n\n    sum_to_n = n * (n + 1) / 2\n  end function sum_to_n\n\n  ! Test function\n  subroutine test_sum_to_n()\n    implicit none\n    integer :: result\n\n    ! Test case 1\n    result = sum_to_n(1)\n    if (result /= 1) then\n      write(*,*) "Test case 1 failed: sum_to_n(1) should be 1"\n      stop 1\n    end if\n\n    ! Test case 2\n    result = sum_to_n(6)\n    if (result /= 21) then\n      write(*,*) "Test case 2 failed: sum_to_n(6) should be 21"\n      stop 1\n    end if\n\n    ! Test case 3\n    result = sum_to_n(11)\n    if (result /= 66) then\n      write(*,*) "Test case 3 failed: sum_to_n(11) should be 66"\n      stop 1\n    end if\n\n    ! Test case 4\n    result = sum_to_n(30)\n    if (result /= 465) then\n      write(*,*) "Test case 4 failed: sum_to_n(30) should be 465"\n      stop 1\n    end if\n\n    ! Test case 5\n    result = sum_to_n(100)\n    if (result /= 5050) then\n      write(*,*) "Test case 5 failed: sum_to_n(100) should be 5050"\n      stop 1\n    end if\n\n    write(*,*) "All tests passed successfully."\n  end subroutine test_sum_to_n\n\nend program main\n```\n\n### C++ Unit Tests\n\nFor C++, you can use a simple testing approach similar to the Fortran example above. However, for more comprehensive testing, you might consider using a testing framework like Google Test. Here's a basic example without a framework:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint sum_to_n(int n);\n\n// Test function declaration\nvoid test_sum_to_n();\n\nint main() {\n    // Run tests\n    test_sum_to_n();\n\n    return 0;\n}\n\n// Function definition\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n\n// Test function definition\nvoid test_sum_to_n() {\n    if (sum_to_n(1) != 1) {\n        std::cerr << "Test case 1 failed: sum_to_n(1) should be 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(6) != 21) {\n        std::cerr << "Test case 2 failed: sum_to_n(6) should be 21" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(11) != 66) {\n        std::cerr << "Test case 3 failed: sum_to_n(11) should be 66" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(30) != 465) {\n        std::cerr << "Test case 4 failed: sum_to_n(30) should be 465" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(100) != 5050) {\n        std::cerr << "Test case 5 failed: sum_to_n(100) should be 5050" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n}\n```\n\nThese unit tests will verify the correctness of the `sum_to_n` function in both the Fortran and C++ implementations.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same logic and test cases as the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    int level = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            level++;\n        } else if (c == ')') {\n            level--;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nint main() {\n    // Test cases\n    if (!correct_bracketing("()")) {\n        std::cerr << "Assertion failed: ()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("(()())")) {\n        std::cerr << "Assertion failed: (()())" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()(()())()")) {\n        std::cerr << "Assertion failed: ()()(()())()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()((()()())())(()()(()))")) {\n        std::cerr << "Assertion failed: ()()((()()())())(()()(()))" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("((()())))")) {\n        std::cerr << "Assertion failed: ((()())))" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing(")()(")) {\n        std::cerr << "Assertion failed: )(()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("(")) {\n        std::cerr << "Assertion failed: (" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("((((")) {\n        std::cerr << "Assertion failed: ((((" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing(")")) {\n        std::cerr << "Assertion failed: )" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("(()")) {\n        std::cerr << "Assertion failed: (()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("()()(()())())(()")) {\n        std::cerr << "Assertion failed: ()()(()())())(()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("()()(()())()))()")) {\n        std::cerr << "Assertion failed: ()()(()())()))()" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a function `correct_bracketing` that takes a string of brackets and checks if the bracketing is correct. The main function contains a series of test cases that verify the correctness of the `correct_bracketing` function. If any test case fails, it prints an error message and returns a non-zero exit code. If all tests pass, it prints "All tests passed."\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `correct_bracketing` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram correct_bracketing_test\n    implicit none\n    character(len=100) :: brackets\n    logical :: result\n\n    ! Test cases\n    result = correct_bracketing("()")\n    if (.not. result) then\n        write(*,*) "Assertion failed: ()"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("(()())")\n    if (.not. result) then\n        write(*,*) "Assertion failed: (()())"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("()()(()())()")\n    if (.not. result) then\n        write(*,*) "Assertion failed: ()()(()())()"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("()()((()()())())(()()(()))")\n    if (.not. result) then\n        write(*,*) "Assertion failed: ()()((()()())())(()()(()))"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("((()())))")\n    if (result) then\n        write(*,*) "Assertion failed: ((()())))"\n        call exit(1)\n    end if\n\n    result = correct_bracketing(")(()")\n    if (result) then\n        write(*,*) "Assertion failed: )(()"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("(")\n    if (result) then\n        write(*,*) "Assertion failed: ("\n        call exit(1)\n    end if\n\n    result = correct_bracketing("((((")\n    if (result) then\n        write(*,*) "Assertion failed: (((("\n        call exit(1)\n    end if\n\n    result = correct_bracketing(")")\n    if (result) then\n        write(*,*) "Assertion failed: )"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("(()")\n    if (result) then\n        write(*,*) "Assertion failed: (()"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("()()(()())())(()")\n    if (result) then\n        write(*,*) "Assertion failed: ()()(()())())(()"\n        call exit(1)\n    end if\n\n    result = correct_bracketing("()()(()())()))()")\n    if (result) then\n        write(*,*) "Assertion failed: ()()(()())()))()"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    logical function correct_bracketing(brackets)\n        character(len=*), intent(in) :: brackets\n        integer :: i, level\n\n        level = 0\n        do i = 1, len_trim(brackets)\n            if (brackets(i:i) == '(') then\n                level = level + 1\n            else if (brackets(i:i) == ')') then\n                level = level - 1\n            end if\n            if (level < 0) then\n                correct_bracketing = .false.\n                return\n            end if\n        end do\n\n        if (level /= 0) then\n            correct_bracketing = .false.\n        else\n            correct_bracketing = .true.\n        end if\n    end function correct_bracketing\n\nend program correct_bracketing_test\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    int level = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            level++;\n        } else if (c == ')') {\n            level--;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nint main() {\n    // Test cases\n    if (!correct_bracketing("()")) {\n        std::cerr << "Assertion failed: ()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("(()())")) {\n        std::cerr << "Assertion failed: (()())" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()(()())()")) {\n        std::cerr << "Assertion failed: ()()(()())()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()((()()
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint fibfib(int n);\n\nint main() {\n    // Assertions\n    if (fibfib(2) != 1) {\n        std::cerr << "fibfib(2) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(1) != 0) {\n        std::cerr << "fibfib(1) == 0: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(5) != 4) {\n        std::cerr << "fibfib(5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(8) != 24) {\n        std::cerr << "fibfib(8) == 24: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(10) != 81) {\n        std::cerr << "fibfib(10) == 81: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(12) != 274) {\n        std::cerr << "fibfib(12) == 274: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(14) != 927) {\n        std::cerr << "fibfib(14) == 927: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint fibfib(int n) {\n    int ff[n+1]; // Dynamic array, size is n+1\n\n    // Initial values\n    ff[0] = 0;\n    ff[1] = 0;\n    ff[2] = 1;\n\n    // Compute the sequence\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i-1] + ff[i-2] + ff[i-3];\n    }\n\n    return ff[n];\n}\n```\n\nThis C++ code performs the same operations as the Fortran code. It defines a `fibfib` function that computes the Fibonacci sequence and then uses assertions to verify the correctness of the function for specific inputs. If any assertion fails, it prints an error message and exits with a non-zero status.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `fibfib` function for a range of inputs.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram fibfib_test\n  implicit none\n\n  integer :: i, errors\n  integer, parameter :: test_values(14) = [0, 1, 2, 3, 5, 8, 10, 12, 14, 16, 18, 20, 22]\n  integer, parameter :: expected_values(14) = [0, 1, 1, 2, 4, 24, 81, 274, 927, 144, 234, 407, 746]\n\n  errors = 0\n\n  do i = 1, 14\n    if (fibfib(test_values(i)) /= expected_values(i)) then\n      write(*,*) "Test failed for n =", test_values(i), "Expected:", expected_values(i), "Got:", fibfib(test_values(i))\n      errors = errors + 1\n    end if\n  end do\n\n  if (errors == 0) then\n    write(*,*) "All tests passed successfully."\n  else\n    write(*,*) "Number of failed tests:", errors\n  end if\n\ncontains\n\n  integer function fibfib(n)\n    implicit none\n    integer, intent(in) :: n\n    integer, dimension(0:n) :: ff\n    integer :: i\n\n    ! Initial values\n    ff(0) = 0\n    ff(1) = 0\n    ff(2) = 1\n\n    ! Compute the sequence\n    do i = 3, n\n      ff(i) = ff(i-1) + ff(i-2) + ff(i-3)\n    end do\n\n    fibfib = ff(n)\n  end function fibfib\n\nend program fibfib_test\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint fibfib(int n);\n\nint main() {\n    int errors = 0;\n    const int test_values[14] = {0, 1, 2, 3, 5, 8, 10, 12, 14, 16, 18, 20, 22};\n    const int expected_values[14] = {0, 1, 1, 2, 4, 24, 81, 274, 927, 144, 234, 407, 746};\n\n    for (int i = 0; i < 14; ++i) {\n        if (fibfib(test_values[i]) != expected_values[i]) {\n            std::cerr << "Test failed for n = " << test_values[i] << ". Expected: " << expected_values[i] << ", Got: " << fibfib(test_values[i]) << std::endl;\n            errors++;\n        }\n    }\n\n    if (errors == 0) {\n        std::cout << "All tests passed successfully." << std::endl;\n    } else {\n        std::cout << "Number of failed tests: " << errors << std::endl;\n    }\n\n    return 0;\n}\n\n// Function definition\nint fibfib(int n) {\n    int ff[n+1]; // Dynamic array, size is n+1\n\n    // Initial values\n    ff[0] = 0;\n    ff[1] = 0;\n    ff[2] = 1;\n\n    // Compute the sequence\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i-1] + ff[i-2] + ff[i-3];\n    }\n\n    return ff[n];\n}\n```\n\nThese unit test codes for both Fortran and C++ check the correctness of the `fibfib` function for a range of input values. If any test fails, it prints an error message and increments the error count. At the end, it reports the total number of failed tests.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses the standard library functions and idioms.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to count vowels in a string\nint vowels_count(const std::string& s) {\n    int count = 0;\n    const std::string vowels = "aeiouAEIOU";\n\n    for (char c : s) {\n        if (vowels.find(c) != std::string::npos) {\n            count++;\n        }\n    }\n\n    // Special handling for 'y' at the end of the string\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n\nint main() {\n    std::string s;\n    int count;\n\n    // Test cases\n    s = "abcde";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cerr << "Assertion failed for 'abcde'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "Alone";\n    count = vowels_count(s);\n    if (count != 3) {\n        std::cerr << "Assertion failed for 'Alone'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "key";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cerr << "Assertion failed for 'key'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "bye";\n    count = vowels_count(s);\n    if (count != 1) {\n        std::cerr << "Assertion failed for 'bye'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "keY";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cerr << "Assertion failed for 'keY'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "bYe";\n    count = vowels_count(s);\n    if (count != 1) {\n        std::cerr << "Assertion failed for 'bYe'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "ACEDY";\n    count = vowels_count(s);\n    if (count != 3) {\n        std::cerr << "Assertion failed for 'ACEDY'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers for input/output operations and program exit, and it uses the `std::string` class for handling strings, which is a common and powerful feature of C++. The `vowels_count` function iterates through each character of the input string and checks if it is a vowel, counting the vowels as it goes. The special handling for the 'y' at the end of the string is also included, as in the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `vowels_count` function in both languages.\n\n### Fortran Unit Test Code\n\nTo compile and run this Fortran code, you might need a Fortran compiler like `gfortran`. Save the following code in a file named `test_fortran.f90`:\n\n```fortran\nprogram test_vowels_count\n    implicit none\n    integer :: count\n\n    ! Test cases\n    count = vowels_count("abcde")\n    if (count /= 2) then\n        write(*,*) "Test failed for 'abcde'"\n        stop 1\n    end if\n\n    count = vowels_count("Alone")\n    if (count /= 3) then\n        write(*,*) "Test failed for 'Alone'"\n        stop 1\n    end if\n\n    count = vowels_count("key")\n    if (count /= 2) then\n        write(*,*) "Test failed for 'key'"\n        stop 1\n    end if\n\n    count = vowels_count("bye")\n    if (count /= 1) then\n        write(*,*) "Test failed for 'bye'"\n        stop 1\n    end if\n\n    count = vowels_count("keY")\n    if (count /= 2) then\n        write(*,*) "Test failed for 'keY'"\n        stop 1\n    end if\n\n    count = vowels_count("bYe")\n    if (count /= 1) then\n        write(*,*) "Test failed for 'bYe'"\n        stop 1\n    end if\n\n    count = vowels_count("ACEDY")\n    if (count /= 3) then\n        write(*,*) "Test failed for 'ACEDY'"\n        stop 1\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function vowels_count(s) result(count)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: count\n        character(len=10) :: vowels\n        integer :: i\n\n        vowels = "aeiouAEIOU"\n        count = 0\n\n        do i = 1, len(s)\n            if (index(vowels, s(i:i)) > 0) then\n                count = count + 1\n            end if\n        end do\n\n        if (s(len(s):len(s)) == 'y' .or. s(len(s):len(s)) == 'Y') then\n            count = count + 1\n        end if\n    end function vowels_count\n\nend program test_vowels_count\n```\n\n### C++ Unit Test Code\n\nTo compile and run this C++ code, you might need a C++ compiler like `g++`. Save the following code in a file named `test_cpp.cpp`:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to count vowels in a string\nint vowels_count(const std::string& s) {\n    int count = 0;\n    const std::string vowels = "aeiouAEIOU";\n\n    for (char c : s) {\n        if (vowels.find(c) != std::string::npos) {\n            count++;\n        }\n    }\n\n    // Special handling for 'y' at the end of the string\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n\nvoid test_vowels_count(const std::string& test_case, int expected) {\n    int result = vowels_count(test_case);\n    if (result != expected) {\n        std::cerr << "Test failed for '" << test_case << "'. Expected " << expected << ", got " << result << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_vowels_count("abcde", 2);\n    test_vowels_count("Alone", 3);\n    test_vowels_count("key", 2);\n    test_vowels_count("bye", 1);\n    test_vowels_count("keY", 2);\n    test_vowels_count("bYe", 1);\n    test_vowels_count("ACEDY", 3);\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n#### Fortran\n\nTo compile and run the Fortran code, use the following commands in your terminal:\n\n```sh\ngfortran -o test_fortran test_fortran.f90\n./test_fortran\n
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string circular_shift(int x, int shift) {\n    std::string xs = std::to_string(x);\n    int len_xs = xs.length();\n    if (len_xs < shift) {\n        std::string reversed = reverse_string(xs);\n        return reversed.substr(0, shift % len_xs) + reversed.substr(0, len_xs - (shift % len_xs));\n    } else {\n        int actual_shift = shift % len_xs;\n        return xs.substr(len_xs - actual_shift, actual_shift) + xs.substr(0, len_xs - actual_shift);\n    }\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string reversed;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        reversed += s[i];\n    }\n    return reversed;\n}\n\nint main() {\n    std::string result;\n\n    result = circular_shift(100, 2);\n    if (result != "001") {\n        std::cerr << "Assertion failed: circular_shift(100, 2) == '001'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 2);\n    if (result != "12") {\n        std::cerr << "Assertion failed: circular_shift(12, 2) == '12'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(97, 8);\n    if (result != "79") {\n        std::cerr << "Assertion failed: circular_shift(97, 8) == '79'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 1);\n    if (result != "21") {\n        std::cerr << "Assertion failed: circular_shift(12, 1) == '21'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(11, 101);\n    if (result != "11") {\n        std::cerr << "Assertion failed: circular_shift(11, 101) == '11'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Circular Shift Function:**\n   - The `circular_shift` function takes an integer `x` and a shift value `shift`.\n   - It converts `x` to a string `xs`.\n   - If the length of `xs` is less than `shift`, it reverses the string and returns a substring of the reversed string.\n   - Otherwise, it computes the actual shift and returns a substring of `xs`.\n\n2. **Reverse String Function:**\n   - The `reverse_string` function takes a string `s` and returns its reversed string.\n\n3. **Main Function:**\n   - The `main` function runs several tests to verify the correctness of the `circular_shift` function.\n   - If any test fails, it prints an error message and exits with a non-zero status.\n   - If all tests pass, it prints "All tests passed."\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram circular_shift_test\n    implicit none\n    character(len=100) :: result\n\n    result = circular_shift(100, 2)\n    if (trim(result) /= "001") then\n        write(*,*) "Assertion failed: circular_shift(100, 2) == '001'"\n        call exit(1)\n    end if\n\n    result = circular_shift(12, 2)\n    if (trim(result) /= "12") then\n        write(*,*) "Assertion failed: circular_shift(12, 2) == '12'"\n        call exit(1)\n    end if\n\n    result = circular_shift(97, 8)\n    if (trim(result) /= "79") then\n        write(*,*) "Assertion failed: circular_shift(97, 8) == '79'"\n        call exit(1)\n    end if\n\n    result = circular_shift(12, 1)\n    if (trim(result) /= "21") then\n        write(*,*) "Assertion failed: circular_shift(12, 1) == '21'"\n        call exit(1)\n    end if\n\n    result = circular_shift(11, 101)\n    if (trim(result) /= "11") then\n        write(*,*) "Assertion failed: circular_shift(11, 101) == '11'"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    function circular_shift(x, shift) result(shifted)\n        implicit none\n        integer, intent(in) :: x, shift\n        character(len=100) :: shifted\n        character(len=100) :: xs\n        integer :: len_xs, actual_shift\n\n        write(xs, '(I0)') x\n        len_xs = len(trim(xs))\n\n        if (len_xs < shift) then\n            shifted = reverse_string(trim(xs))\n        else\n            actual_shift = mod(shift, len_xs)\n            shifted = trim(xs(len_xs-actual_shift+1:len_xs)) // trim(xs(1:len_xs-actual_shift))\n        end if\n    end function circular_shift\n\n    function reverse_string(s) result(reversed)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: reversed\n        integer :: i, len_s\n\n        len_s = len(trim(s))\n        do i = 1, len_s\n            reversed(i:i) = s(len_s-i+1:len_s-i+1)\n        end do\n    end function reverse_string\n\nend program circular_shift_test\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string circular_shift(int x, int shift) {\n    std::string xs = std::to_string(x);\n    int len_xs = xs.length();\n    if (len_xs < shift) {\n        std::string reversed = reverse_string(xs);\n        return reversed.substr(0, shift % len_xs) + reversed.substr(0, len_xs - (shift % len_xs));\n    } else {\n        int actual_shift = shift % len_xs;\n        return xs.substr(len_xs - actual_shift, actual_shift) + xs.substr(0, len_xs - actual_shift);\n    }\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string reversed;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        reversed += s[i];\n    }\n    return reversed;\n}\n\nint main() {\n    std::string result;\n\n    result = circular_shift(100, 2);\n    if (result != "001") {\n        std::cerr << "Assertion failed: circular_shift(100, 2) == '001'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 2);\n    if (result != "12") {\n        std::cerr << "Assertion failed: circular_shift(12, 2) == '12'" << std::endl;
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code includes the necessary headers and uses standard I/O streams for output.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to calculate the sum of the ASCII values of the uppercase letters in a string\nint digitSum(const std::string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Assertions\n    if (digitSum("") != 0) {\n        std::cerr << "Assertion failed: digitSum('') == 0" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("abAB") != 131) {\n        std::cerr << "Assertion failed: digitSum('abAB') == 131" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("abcCd") != 67) {\n        std::cerr << "Assertion failed: digitSum('abcCd') == 67" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("helloE") != 69) {\n        std::cerr << "Assertion failed: digitSum('helloE') == 69" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("woArBld") != 131) {\n        std::cerr << "Assertion failed: digitSum('woArBld') == 131" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("aAaaaXa") != 153) {\n        std::cerr << "Assertion failed: digitSum('aAaaaXa') == 153" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum(" How are yOu?") != 151) {\n        std::cerr << "Assertion failed: digitSum(' How are yOu?') == 151" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("You arE Very Smart") != 327) {\n        std::cerr << "Assertion failed: digitSum('You arE Very Smart') == 327" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a `digitSum` function that calculates the sum of the ASCII values of the uppercase letters in a given string, similar to the Fortran version. The `main` function contains assertions that verify the correctness of the `digitSum` function with various test cases. If any assertion fails, the program prints an error message and exits with a non-zero status, indicating a failure. If all assertions pass, it prints a success message.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\nFor the Fortran code, we'll use a simple approach to test the `digitSum` function with different inputs and print the results. Fortran doesn't have a built-in unit testing framework like some other languages, so we'll manually check the results and print the outcomes.\n\n```fortran\nprogram test_digit_sum\n    implicit none\n\n    ! Test cases\n    call test_case('', 0)\n    call test_case('abAB', 131)\n    call test_case('abcCd', 67)\n    call test_case('helloE', 69)\n    call test_case('woArBld', 131)\n    call test_case('aAaaaXa', 153)\n    call test_case(' How are yOu?', 151)\n    call test_case('You arE Very Smart', 327)\n\ncontains\n\n    subroutine test_case(s, expected)\n        character(len=*), intent(in) :: s\n        integer, intent(in) :: expected\n        integer :: result\n\n        result = digitSum(s)\n        if (result == expected) then\n            write(*,*) "Test passed for input: ", s\n        else\n            write(*,*) "Test failed for input: ", s, " Expected: ", expected, " Got: ", result\n        end if\n    end subroutine test_case\n\n    integer function digitSum(s)\n        character(len=*), intent(in) :: s\n        integer :: i\n        digitSum = 0\n        do i = 1, len_trim(s)\n            if (iachar(s(i:i)) >= 65 .and. iachar(s(i:i)) <= 90) then\n                digitSum = digitSum + iachar(s(i:i))\n            end if\n        end do\n    end function digitSum\n\nend program test_digit_sum\n```\n\n### C++ Unit Test Code\n\nFor the C++ code, we'll use a simple approach similar to the Fortran code. C++ doesn't have a built-in unit testing framework, but for simplicity, we'll manually check the results and print the outcomes.\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Function to calculate the sum of the ASCII values of the uppercase letters in a string\nint digitSum(const std::string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nvoid test_case(const std::string& s, int expected) {\n    int result = digitSum(s);\n    if (result == expected) {\n        std::cout << "Test passed for input: " << s << std::endl;\n    } else {\n        std::cout << "Test failed for input: " << s << ". Expected: " << expected << ", Got: " << result << std::endl;\n    }\n}\n\nint main() {\n    // Test cases\n    test_case("", 0);\n    test_case("abAB", 131);\n    test_case("abcCd", 67);\n    test_case("helloE", 69);\n    test_case("woArBld", 131);\n    test_case("aAaaaXa", 153);\n    test_case(" How are yOu?", 151);\n    test_case("You arE Very Smart", 327);\n\n    return 0;\n}\n```\n\n### Running the Tests\n\nTo run the Fortran tests, you'll need a Fortran compiler like `gfortran`. Compile and run the Fortran code as follows:\n\n```sh\ngfortran -o test_digit_sum test_digit_sum.f90\n./test_digit_sum\n```\n\nTo run the C++ tests, you'll need a C++ compiler like `g++`. Compile and run the C++ code as follows:\n\n```sh\ng++ -o test_digit_sum test_digit_sum.cpp\n./test_digit_sum\n```\n\nThese tests will verify the correctness of the `digitSum` function in both the Fortran and C++ implementations by comparing the computed results with the expected values for each test case.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function declaration\nint fruit_distribution(const std::string& s, int n);\n\nint main() {\n    std::string s;\n    int n;\n\n    // Test cases\n    s = "5 apples and 6 oranges";\n    n = 19;\n    if (fruit_distribution(s, n) != 8) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "5 apples and 6 oranges";\n    n = 21;\n    if (fruit_distribution(s, n) != 10) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "0 apples and 1 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "1 apples and 0 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 100;\n    if (fruit_distribution(s, n) != 95) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 5;\n    if (fruit_distribution(s, n) != 0) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "1 apples and 100 oranges";\n    n = 120;\n    if (fruit_distribution(s, n) != 19) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n\nint fruit_distribution(const std::string& s, int n) {\n    std::string num1, num2;\n    int is12 = 0;\n    int num1_val = 0, num2_val = 0;\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1 += s[i];\n            } else if (is12 == 1) {\n                num2 += s[i];\n            }\n        } else if (is12 == 0 && !num1.empty()) {\n            is12 = 1;\n        }\n    }\n\n    if (!num1.empty()) {\n        num1_val = std::stoi(num1);\n    }\n    if (!num2.empty()) {\n        num2_val = std::stoi(num2);\n    }\n\n    return n - num1_val - num2_val;\n}\n```\n\nThis C++ code includes the `fruit_distribution` function, which is equivalent to the Fortran function `fruit_distribution`. The main function contains several test cases to verify the correctness of the `fruit_distribution` function. If any test case fails, it prints an error message and exits with a non-zero status. If all test cases pass, it prints "All test cases passed".\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `fruit_distribution` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram fruit_distribution_program\n    implicit none\n    character(len=100) :: s\n    integer :: n\n\n    ! Function declaration\n    integer :: fruit_distribution\n\n    ! Test cases\n    s = "5 apples and 6 oranges"\n    n = 19\n    if (fruit_distribution(trim(s), n) /= 8) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n\n    s = "5 apples and 6 oranges"\n    n = 21\n    if (fruit_distribution(trim(s), n) /= 10) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n\n    s = "0 apples and 1 oranges"\n    n = 3\n    if (fruit_distribution(trim(s), n) /= 2) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n\n    s = "1 apples and 0 oranges"\n    n = 3\n    if (fruit_distribution(trim(s), n) /= 2) then\n        write(*,*) "Test case 4 failed"\n        call exit(1)\n    end if\n\n    s = "2 apples and 3 oranges"\n    n = 100\n    if (fruit_distribution(trim(s), n) /= 95) then\n        write(*,*) "Test case 5 failed"\n        call exit(1)\n    end if\n\n    s = "2 apples and 3 oranges"\n    n = 5\n    if (fruit_distribution(trim(s), n) /= 0) then\n        write(*,*) "Test case 6 failed"\n        call exit(1)\n    end if\n\n    s = "1 apples and 100 oranges"\n    n = 120\n    if (fruit_distribution(trim(s), n) /= 19) then\n        write(*,*) "Test case 7 failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program fruit_distribution_program\n\nfunction fruit_distribution(s, n) result(res)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer, intent(in) :: n\n    integer :: res\n    character(len=100) :: num1, num2\n    integer :: i, is12, num1_val, num2_val\n\n    num1 = ""\n    num2 = ""\n    is12 = 0\n\n    do i = 1, len(s)\n        if (iachar(s(i:i)) >= 48 .and. iachar(s(i:i)) <= 57) then\n            if (is12 == 0) then\n                num1 = trim(num1) // s(i:i)\n            else if (is12 == 1) then\n                num2 = trim(num2) // s(i:i)\n            end if\n        else if (is12 == 0 .and. len(trim(num1)) > 0) then\n            is12 = 1\n        end if\n    end do\n\n    read(num1, *) num1_val\n    read(num2, *) num2_val\n\n    res = n - num1_val - num2_val\nend function fruit_distribution\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function declaration\nint fruit_distribution(const std::string& s, int n);\n\nint main() {\n    std::string s;\n    int n;\n\n    // Test cases\n    s = "5 apples and 6 oranges";\n    n = 19;\n    if (fruit_distribution(s, n) != 8) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "5 apples and 6 oranges";\n    n = 21;\n    if (f
Translating the given Fortran code to C++ involves several steps, including handling dynamic arrays, subroutine calls, and logical operations. Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid pluck(const std::vector<int>& arr, std::vector<int>& out) {\n    out.clear();\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (out.empty() || arr[i] < out[0])) {\n            out.clear();\n            out.push_back(arr[i]);\n            out.push_back(i);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> arr, result, empty;\n\n    // Test cases\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {4, 2, 3};\n    pluck(arr, result);\n    assert_condition(issame(result, {2, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {1, 2, 3};\n    pluck(arr, result);\n    assert_condition(issame(result, {2, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {};\n    pluck(arr, result);\n    assert_condition(issame(result, empty));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {5, 0, 3, 0, 4, 2};\n    pluck(arr, result);\n    assert_condition(issame(result, {0, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {1, 2, 3, 0, 5, 3};\n    pluck(arr, result);\n    assert_condition(issame(result, {0, 3}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {5, 4, 8, 4, 8};\n    pluck(arr, result);\n    assert_condition(issame(result, {4, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {7, 6, 7, 1};\n    pluck(arr, result);\n    assert_condition(issame(result, {6, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {7, 9, 7, 1};\n    pluck(arr, result);\n    assert_condition(issame(result, empty));\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Dynamic Arrays**: In C++, we use `std::vector<int>` to handle dynamic arrays.\n2. **Subroutine Calls**: The `pluck` and `issame` functions are translated as regular functions in C++.\n3. **Logical Operations**: The logical operations are directly translated using C++ syntax.\n4. **Assertions**: The `assert` subroutine is translated to a function `assert_condition` that uses `std::cerr` and `std::exit` for error handling.\n\nThis C++ code should behave similarly to the original Fortran code, ensuring the same logic and output for the given test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `pluck` function and the `issame` function.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: arr(:), result(:)\n    integer, allocatable :: empty(:)\n    integer :: i\n\n    ! Allocate an empty array\n    allocate(empty(0))\n\n    ! Test cases\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(3))\n    arr = [4, 2, 3]\n    call pluck(arr, result)\n    call assert(issame(result, [2, 1]))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(3))\n    arr = [1, 2, 3]\n    call pluck(arr, result)\n    call assert(issame(result, [2, 1]))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(0))\n    call pluck(arr, result)\n    call assert(issame(result, empty))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(6))\n    arr = [5, 0, 3, 0, 4, 2]\n    call pluck(arr, result)\n    call assert(issame(result, [0, 1]))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(6))\n    arr = [1, 2, 3, 0, 5, 3]\n    call pluck(arr, result)\n    call assert(issame(result, [0, 3]))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(5))\n    arr = [5, 4, 8, 4, 8]\n    call pluck(arr, result)\n    call assert(issame(result, [4, 1]))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(4))\n    arr = [7, 6, 7, 1]\n    call pluck(arr, result)\n    call assert(issame(result, [6, 1]))\n\n    if (allocated(arr)) then\n        deallocate(arr)\n    end if\n    allocate(arr(4))\n    arr = [7, 9, 7, 1]\n    call pluck(arr, result)\n    call assert(issame(result, empty))\n\ncontains\n\n    subroutine pluck(arr, out)\n        integer, intent(in) :: arr(:)\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i\n\n        if (allocated(out)) then\n            deallocate(out)\n        end if\n        allocate(out(0))\n\n        do i = 1, size(arr)\n            if (mod(arr(i), 2) == 0 .and. (size(out) == 0 .or. arr(i) < out(1))) then\n                if (allocated(out)) then\n                    deallocate(out)\n                end if\n                allocate(out(2))\n                out = [arr(i), i-1]\n            end if\n        end do\n    end subroutine pluck\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\n    subroutine assert(condition)\n        logical
Translating the given Fortran code to C++ involves several steps, including handling dynamic arrays, searching, and module functionalities. Below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n// Utility functions\nvoid extend_array(std::vector<std::vector<int>>& array, int new_size) {\n    std::vector<std::vector<int>> temp(array.size(), std::vector<int>(new_size));\n    for (size_t i = 0; i < array.size(); ++i) {\n        for (size_t j = 0; j < array[i].size(); ++j) {\n            temp[i][j] = array[i][j];\n        }\n    }\n    array = temp;\n}\n\nint search(const std::vector<int>& lst) {\n    std::vector<std::vector<int>> freq(2, std::vector<int>(0));\n    int max = -1;\n    bool has;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        has = false;\n        for (size_t j = 0; j < freq[1].size(); ++j) {\n            if (lst[i] == freq[0][j]) {\n                freq[1][j] += 1;\n                has = true;\n                if (freq[1][j] >= freq[0][j] && freq[0][j] > max) {\n                    max = freq[0][j];\n                }\n            }\n        }\n        if (!has) {\n            freq[0].push_back(lst[i]);\n            freq[1].push_back(1);\n            if (max == -1 && lst[i] == 1) {\n                max = 1;\n            }\n        }\n    }\n    return max;\n}\n\nint main() {\n    std::vector<int> test_case1 = {5, 5, 5, 5, 1};\n    if (search(test_case1) != 1) {\n        std::cerr << "Assertion failed: search([5, 5, 5, 5, 1]) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case2 = {4, 1, 4, 1, 4, 4};\n    if (search(test_case2) != 4) {\n        std::cerr << "Assertion failed: search([4, 1, 4, 1, 4, 4]) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case3 = {3, 3};\n    if (search(test_case3) != -1) {\n        std::cerr << "Assertion failed: search([3, 3]) == -1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case4 = {8, 8, 8, 8, 8, 8, 8, 8};\n    if (search(test_case4) != 8) {\n        std::cerr << "Assertion failed: search([8, 8, 8, 8, 8, 8, 8, 8]) == 8" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case5 = {2, 3, 3, 2, 2};\n    if (search(test_case5) != 2) {\n        std::cerr << "Assertion failed: search([2, 3, 3, 2, 2]) == 2" << std::endl;\n        return 1;\n    }\n\n    // Add more test cases as needed...\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Dynamic Arrays**: In C++, `std::vector` is used to handle dynamic arrays. The `extend_array` function extends the 2D vector by adding a new column.\n\n2. **Search Function**: The `search` function iterates through the input array and updates the frequency map. It returns the maximum element that occurs more than once.\n\n3. **Main Function**: The `main` function contains several test cases to verify the correctness of the `search` function.\n\nThis C++ code should provide the same functionality as the original Fortran code. You can add more test cases to further verify the correctness of the translation.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\ncontains\n    subroutine extend_array(array, new_size)\n        implicit none\n        integer, dimension(:,:), allocatable, intent(inout) :: array\n        integer, intent(in) :: new_size\n        integer, dimension(:,:), allocatable :: temp\n\n        allocate(temp(size(array, 1), new_size))\n        temp(:, 1:size(array, 2)) = array\n        array = temp\n    end subroutine extend_array\n\n    function search(lst) result(max)\n        implicit none\n        integer, dimension(:), intent(in) :: lst\n        integer :: max\n        integer, dimension(:,:), allocatable :: freq\n        integer :: i, j, n, freq_size\n        logical :: has\n\n        max = -1\n        freq_size = 0\n        allocate(freq(2, 0))\n\n        do i = 1, size(lst)\n            has = .false.\n            do j = 1, freq_size\n                if (lst(i) == freq(1, j)) then\n                    freq(2, j) = freq(2, j) + 1\n                    has = .true.\n                    if (freq(2, j) >= freq(1, j) .and. freq(1, j) > max) max = freq(1, j)\n                end if\n            end do\n            if (.not. has) then\n                freq_size = freq_size + 1\n                call extend_array(freq, freq_size)\n                freq(1, freq_size) = lst(i)\n                freq(2, freq_size) = 1\n                if (max == -1 .and. lst(i) == 1) max = 1\n            end if\n        end do\n    end function search\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    integer :: result\n\n    result = search([5, 5, 5, 5, 1])\n    if (result /= 1) then\n        write(*,*) "Assertion failed: search([5, 5, 5, 5, 1]) == 1"\n        call exit(1)\n    end if\n\n    result = search([4, 1, 4, 1, 4, 4])\n    if (result /= 4) then\n        write(*,*) "Assertion failed: search([4, 1, 4, 1, 4, 4]) == 4"\n        call exit(1)\n    end if\n\n    result = search([3, 3])\n    if (result /= -1) then\n        write(*,*) "Assertion failed: search([3, 3]) == -1"\n        call exit(1)\n    end if\n\n    result = search([8, 8, 8, 8, 8, 8, 8, 8])\n    if (result /= 8) then\n        write(*,*) "Assertion failed: search([8, 8, 8, 8, 8, 8, 8, 8]) == 8"\n        call exit(1)\n    end if\n\n    result = search([2, 3, 3, 2, 2])\n    if (result /= 2) then\n        write(*,*) "Assertion failed: search([2, 3, 3, 2, 2]) == 2"\n        call exit(1)\n    end if\n\n    ! Add more assertions as needed...\n\n    write(*,*) "All
Translating the provided Fortran code to C++ involves several steps, including adapting the array handling, the sorting algorithm, and the testing framework. Below is a C++ translation of the Fortran code, including unit tests using the Google Test framework.\n\nFirst, ensure you have Google Test set up in your project. The following C++ code is a direct translation of the Fortran code, including the sorting logic and the unit tests.\n\n```cpp\n#include <gtest/gtest.h>\n#include <vector>\n#include <algorithm>\n\n// Function to sort the list in the strange order\nvoid strange_sort_list(const std::vector<int>& lst, std::vector<int>& out) {\n    int n = lst.size();\n    if (n == 0) {\n        out.clear();\n        return;\n    }\n\n    std::vector<int> sorted_lst = lst;\n    // Bubble sort\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (sorted_lst[j] > sorted_lst[j + 1]) {\n                std::swap(sorted_lst[j], sorted_lst[j + 1]);\n            }\n        }\n    }\n\n    out.resize(n);\n    int l = 0, r = n - 1;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = sorted_lst[l];\n            ++l;\n        } else {\n            out[i] = sorted_lst[r];\n            --r;\n        }\n    }\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Unit tests\nTEST(StrangeSortTest, HandlesEmptyArray) {\n    std::vector<int> out;\n    strange_sort_list(std::vector<int>(), out);\n    EXPECT_TRUE(out.empty());\n}\n\nTEST(StrangeSortTest, HandlesOddSizeArray) {\n    std::vector<int> out;\n    std::vector<int> lst = {1, 2, 3, 4, 5};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {1, 5, 2, 4, 3};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesEvenSizeArray) {\n    std::vector<int> out;\n    std::vector<int> lst = {5, 6, 7, 8, 9, 1};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {1, 9, 5, 8, 6, 7};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesRepeatedElements) {\n    std::vector<int> out;\n    std::vector<int> lst = {5, 5, 5, 5};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {5, 5, 5, 5};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesSingleElement) {\n    std::vector<int> out;\n    std::vector<int> lst = {111111};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {111111};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesMixedElements) {\n    std::vector<int> out;\n    std::vector<int> lst = {0, 2, 2, 2, 5, 5, -5, -5};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {-5, 5, -5, 5, 0, 2, 2, 2};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\nThis C++ code includes the `strange_sort_list` function, which sorts the input array in a peculiar way, and a series of unit tests to verify the correctness of this sorting function. The unit tests cover various scenarios, including empty arrays, arrays of odd and even lengths, arrays with repeated elements, and arrays with a single element.\n\nTo compile and run this code, you'll need to link against the Google Test library. The exact command depends on your setup, but it might look something like this:\n\n```sh\ng++ -std=c++11 -o test_strange_sort test_strange_sort.cpp -lgtest -lgtest_main -pthread\n./test_strange_sort\n```\n\nThis command compiles the C++ code into an executable named `test_strange_sort`, linking against the Google Test libraries, and then runs the executable. The output will show the results of the unit tests.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\ndouble triangle_area(double a, double b, double c);\nvoid check_assertion(bool condition, const std::string& message);\n\nint main() {\n    // Main program body\n    check_assertion(std::abs(triangle_area(3.0, 4.0, 5.0) - 6.0) < 0.01, "Assertion failed: triangle_area(3, 4, 5)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 10)");\n    check_assertion(std::abs(triangle_area(4.0, 8.0, 5.0) - 8.18) < 0.01, "Assertion failed: triangle_area(4, 8, 5)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 2.0) - 1.73) < 0.01, "Assertion failed: triangle_area(2, 2, 2)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 3)");\n    check_assertion(std::abs(triangle_area(10.0, 5.0, 7.0) - 16.25) < 0.01, "Assertion failed: triangle_area(10, 5, 7)");\n    check_assertion(std::abs(triangle_area(2.0, 6.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 6, 3)");\n    check_assertion(std::abs(triangle_area(1.0, 1.0, 1.0) - 0.43) < 0.01, "Assertion failed: triangle_area(1, 1, 1)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 2, 10)");\n\n    return 0;\n}\n\ndouble triangle_area(double a, double b, double c) {\n    double h, area;\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        area = -1.0;\n    } else {\n        h = (a + b + c) / 2.0;\n        area = std::sqrt(h * (h - a) * (h - b) * (h - c));\n    }\n    return area;\n}\n\nvoid check_assertion(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cout << message << std::endl;\n        std::exit(1);\n    }\n}\n```\n\nThis C++ code includes the necessary headers for input/output operations, mathematical functions, and program termination. The `triangle_area` function calculates the area of a triangle given its three sides, and the `check_assertion` function checks if the condition is met, printing a message and terminating the program if the condition is not met.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `triangle_area` function and the `check_assertion` subroutine/function.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    real :: a, b, c, area\n\n    ! Test cases for triangle_area function\n    a = 3.0\n    b = 4.0\n    c = 5.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area - 6.0) < 0.01, "Test failed: triangle_area(3, 4, 5)")\n\n    a = 1.0\n    b = 2.0\n    c = 10.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area + 1.0) < 0.01, "Test failed: triangle_area(1, 2, 10)")\n\n    a = 4.0\n    b = 8.0\n    c = 5.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area - 8.18) < 0.01, "Test failed: triangle_area(4, 8, 5)")\n\n    a = 2.0\n    b = 2.0\n    c = 2.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area - 1.73) < 0.01, "Test failed: triangle_area(2, 2, 2)")\n\n    a = 1.0\n    b = 2.0\n    c = 3.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area + 1.0) < 0.01, "Test failed: triangle_area(1, 2, 3)")\n\n    a = 10.0\n    b = 5.0\n    c = 7.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area - 16.25) < 0.01, "Test failed: triangle_area(10, 5, 7)")\n\n    a = 2.0\n    b = 6.0\n    c = 3.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area + 1.0) < 0.01, "Test failed: triangle_area(2, 6, 3)")\n\n    a = 1.0\n    b = 1.0\n    c = 1.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area - 0.43) < 0.01, "Test failed: triangle_area(1, 1, 1)")\n\n    a = 2.0\n    b = 2.0\n    c = 10.0\n    area = triangle_area(a, b, c)\n    call check_assertion(abs(area + 1.0) < 0.01, "Test failed: triangle_area(2, 2, 10)")\n\ncontains\n\n    function triangle_area(a, b, c) result(area)\n        real :: a, b, c, area, h\n        if (a + b <= c .or. a + c <= b .or. b + c <= a) then\n            area = -1.0\n        else\n            h = (a + b + c) / 2.0\n            area = sqrt(h * (h - a) * (h - b) * (h - c))\n        end if\n    end function triangle_area\n\n    subroutine check_assertion(condition, message)\n        logical :: condition\n        character(len=*) :: message\n        if (.not. condition) then\n            write(*,*) message\n            call exit(1)\n        end if\n    end subroutine check_assertion\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n\ndouble triangle_area(double a, double b, double c);\nvoid check_assertion(bool condition, const std::string& message);\n\nint main() {\n    // Test cases for triangle_area function\n    check_assertion(std::abs(triangle_area(3.0, 4.0, 5.0) - 6
Translating the provided Fortran code to C++ involves a few steps, including adapting the module and function structure to a class and method structure, handling array allocation and deallocation, and converting the Fortran logical type to C++ bool type. Here's how the Fortran code can be translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nclass FlightModule {\npublic:\n    static bool will_it_fly(const std::vector<int>& q, int w) {\n        int sum = 0;\n        int n = q.size();\n        bool result = true;\n\n        for (int i = 0; i < n; ++i) {\n            if (q[i] != q[n - 1 - i]) {\n                result = false;\n                return result;\n            }\n            sum += q[i];\n        }\n\n        if (sum > w) {\n            result = false;\n        }\n        return result;\n    }\n};\n\nint main() {\n    std::vector<int> q;\n    int w;\n\n    // Test cases\n    q = {3, 2, 3};\n    w = 9;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2};\n    w = 5;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3};\n    w = 5;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3, 2, 3};\n    w = 1;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2, 3};\n    w = 6;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    q = {5};\n    w = 5;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nKey Points in the Translation:\n- The Fortran module `flight_module` is translated to a C++ class `FlightModule`.\n- The Fortran function `will_it_fly` is translated to a static member function of the `FlightModule` class.\n- Fortran's `integer, dimension(:), intent(in) :: q` is translated to a `const std::vector<int>& q` in C++, which allows for dynamic array handling.\n- Fortran's `logical` type is translated to C++'s `bool` type.\n- Array allocation and deallocation in Fortran are handled automatically by the language, but in C++ we use `std::vector` which manages memory automatically.\n- The `main` program in Fortran is translated to the `main` function in C++.\n- The `write` and `exit` statements in Fortran are replaced with `std::cout` for output and `return 1;` for exiting with an error code, respectively, in C++.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `will_it_fly` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule flight_module\n    implicit none\ncontains\n\n    logical function will_it_fly(q, w)\n        implicit none\n        integer, dimension(:), intent(in) :: q\n        integer, intent(in) :: w\n        integer :: sum, i, n\n\n        sum = 0\n        n = size(q)\n        will_it_fly = .true.\n\n        do i = 1, n\n            if (q(i) /= q(n + 1 - i)) then\n                will_it_fly = .false.\n                return\n            end if\n            sum = sum + q(i)\n        end do\n\n        if (sum > w) then\n            will_it_fly = .false.\n        end if\n    end function will_it_fly\nend module flight_module\n\nprogram main\n    use flight_module\n    implicit none\n    integer, dimension(:), allocatable :: q\n    integer :: w\n\n    ! Test cases\n    if (allocated(q)) deallocate(q)\n    allocate(q(3))\n    q = [3, 2, 3]\n    w = 9\n    if (.not. will_it_fly(q, w)) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n\n    if (allocated(q)) deallocate(q)\n    allocate(q(2))\n    q = [1, 2]\n    w = 5\n    if (will_it_fly(q, w)) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n\n    if (allocated(q)) deallocate(q)\n    allocate(q(1))\n    q = [3]\n    w = 5\n    if (.not. will_it_fly(q, w)) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n\n    if (allocated(q)) deallocate(q)\n    allocate(q(3))\n    q = [3, 2, 3]\n    w = 1\n    if (will_it_fly(q, w)) then\n        write(*,*) "Test case 4 failed"\n        call exit(1)\n    end if\n\n    if (allocated(q)) deallocate(q)\n    allocate(q(3))\n    q = [1, 2, 3]\n    w = 6\n    if (will_it_fly(q, w)) then\n        write(*,*) "Test case 5 failed"\n        call exit(1)\n    end if\n\n    if (allocated(q)) deallocate(q)\n    allocate(q(1))\n    q = [5]\n    w = 5\n    if (.not. will_it_fly(q, w)) then\n        write(*,*) "Test case 6 failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n\nclass FlightModule {\npublic:\n    static bool will_it_fly(const std::vector<int>& q, int w) {\n        int sum = 0;\n        int n = q.size();\n        bool result = true;\n\n        for (int i = 0; i < n; ++i) {\n            if (q[i] != q[n - 1 - i]) {\n                result = false;\n                return result;\n            }\n            sum += q[i];\n        }\n\n        if (sum > w) {\n            result = false;\n        }\n        return result;\n    }\n};\n\nint main() {\n    std::vector<int> q;\n    int w;\n\n    // Test cases\n    q = {3, 2, 3};\n    w = 9;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2};\n    w = 5;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3};\n    w = 5;\n
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint smallest_change(const std::vector<int>& arr) {\n    int out = 0;\n    int n = arr.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++out;\n        }\n    }\n    return out;\n}\n\nint main() {\n    std::vector<int> test_case_1 = {1, 2, 3, 5, 4, 7, 9, 6};\n    if (smallest_change(test_case_1) != 4) {\n        std::cerr << "Assertion failed: smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_2 = {1, 2, 3, 4, 3, 2, 2};\n    if (smallest_change(test_case_2) != 1) {\n        std::cerr << "Assertion failed: smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_3 = {1, 4, 2};\n    if (smallest_change(test_case_3) != 1) {\n        std::cerr << "Assertion failed: smallest_change([1, 4, 2]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_4 = {1, 4, 4, 2};\n    if (smallest_change(test_case_4) != 1) {\n        std::cerr << "Assertion failed: smallest_change([1, 4, 4, 2]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_5 = {1, 2, 3, 2, 1};\n    if (smallest_change(test_case_5) != 0) {\n        std::cerr << "Assertion failed: smallest_change([1, 2, 3, 2, 1]) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_6 = {3, 1, 1, 3};\n    if (smallest_change(test_case_6) != 0) {\n        std::cerr << "Assertion failed: smallest_change([3, 1, 1, 3]) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_7 = {1};\n    if (smallest_change(test_case_7) != 0) {\n        std::cerr << "Assertion failed: smallest_change([1]) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_8 = {0, 1};\n    if (smallest_change(test_case_8) != 1) {\n        std::cerr << "Assertion failed: smallest_change([0, 1]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code includes the `smallest_change` function, which computes the smallest number of changes needed to make the array palindrome, and a `main` function that runs several test cases to verify the correctness of the `smallest_change` function. The test cases are similar to those in the Fortran code, and the output is checked against the expected results. If any test case fails, an error message is printed, and the program exits with a non-zero status.
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, string manipulation, and the logic of the program. Below is a C++ version of the Fortran code, using modern C++ features.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::string> total_match(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    int num1 = 0, num2 = 0;\n    for (const auto& str : lst1) {\n        num1 += str.size();\n    }\n    for (const auto& str : lst2) {\n        num2 += str.size();\n    }\n\n    if (num1 > num2) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "condition: assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nstd::string pad(const std::string& str, size_t len) {\n    std::string padded_str = str;\n    padded_str.resize(len, ' ');\n    return padded_str;\n}\n\nint main() {\n    // Test cases\n    assert_condition(issame({"hi", "admin"}, {"hi", "hi"}));\n    assert_condition(issame({"hi", "admin"}, {"hi", "hi", "admin", "project"}));\n    assert_condition(issame({"4"}, {"1", "2", "3", "4", "5"}));\n    assert_condition(issame({"hi", "admin"}, {"hI", "Hi"}));\n    assert_condition(issame({"hi", "admin"}, {"hI", "hi", "hi"}));\n    assert_condition(issame({"hi", "admin"}, {"hI", "hi", "hii"}));\n    assert_condition(issame({}, {"this"}));\n    assert_condition(issame({"this"}, {}));\n\n    // Demonstrating the use of total_match\n    std::vector<std::string> lst1 = {"hi", "admin"};\n    std::vector<std::string> lst2 = {"hI", "Hi", "hi", "hii"};\n    std::vector<std::string> result = total_match(lst1, lst2);\n    std::cout << "total_match result: ";\n    for (const auto& str : result) {\n        std::cout << '"' << str << "\" ";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n\n### Key Points:\n\n1. **Dynamic Arrays**: C++ uses `std::vector` for dynamic arrays, which is more flexible and safer than raw pointers.\n2. **String Handling**: The `std::string` class is used for string manipulation, which simplifies operations such as resizing and appending spaces.\n3. **Functions and Logic**: The logic of the program is translated directly, with functions such as `total_match` and `issame` implemented similarly to the Fortran version.\n4. **Assertions**: The `assert_condition` function is used to check conditions, similar to the Fortran `assert` subroutine. If the condition is false, it prints an error message and exits the program.\n5. **Test Cases**: The test cases are directly translated and executed in the `main` function.\n\nThis C++ code should provide equivalent functionality to the original Fortran code, ensuring the same logic and output for the given test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `total_match` and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    character(len=100), dimension(:), allocatable :: lst1, lst2, result\n    logical :: is_same\n\n    ! Test cases\n    call assert(issame(total_match([pad("hi", 100), pad("admin", 100)], &\n                                   [pad("hi", 100), pad("hi", 100)]), &\n                                   [pad("hi", 100), pad("hi", 100)]))\n    call assert(issame(total_match([pad("hi", 100), pad("admin", 100)], &\n                                   [pad("hi", 100), pad("hi", 100), &\n                                    pad("admin", 100), pad("project", 100)]), &\n                                   [pad("hi", 100), pad("admin", 100)]))\n    call assert(issame(total_match([pad("4", 100)], &\n                                   [pad("1", 100), pad("2", 100), &\n                                    pad("3", 100), pad("4", 100), pad("5", 100)]), &\n                                   [pad("4", 100)]))\n    call assert(issame(total_match([pad("hi", 100), pad("admin", 100)], &\n                                   [pad("hI", 100), pad("Hi", 100)]), &\n                                   [pad("hI", 100), pad("Hi", 100)]))\n    call assert(issame(total_match([pad("hi", 100), pad("admin", 100)], &\n                                   [pad("hI", 100), pad("hi", 100), pad("hi", 100)]), &\n                                   [pad("hI", 100), pad("hi", 100), pad("hi", 100)]))\n    call assert(issame(total_match([pad("hi", 100), pad("admin", 100)], &\n                                   [pad("hI", 100), pad("hi", 100), pad("hii", 100)]), &\n                                   [pad("hi", 100), pad("admin", 100)]))\n\ncontains\n\n    function total_match(lst1, lst2) result(res)\n        character(len=100), dimension(:), intent(in) :: lst1, lst2\n        character(len=100), dimension(:), allocatable :: res\n        integer :: num1, num2, i\n\n        num1 = 0\n        num2 = 0\n\n        do i = 1, size(lst1)\n            num1 = num1 + len_trim(lst1(i))\n        end do\n\n        do i = 1, size(lst2)\n            num2 = num2 + len_trim(lst2(i))\n        end do\n\n        if (num1 > num2) then\n            allocate(res(size(lst2)))\n            res = lst2\n        else\n            allocate(res(size(lst1)))\n            res = lst1\n        end if\n    end function total_match\n\n    function issame(a, b) result(is_equal)\n        character(len=100), dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (trim(a(i)) /= trim(b(i))) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\n    subrout
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    int p = 1;\n    int count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) {\n            return true;\n        }\n        p *= n;\n        ++count;\n    }\n    return false;\n}\n\nint main() {\n    // Test cases\n    if (!is_simple_power(1, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 4) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(2, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(2, 2) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(8, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(8, 2) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(3, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(3, 2) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(3, 1)) {\n        std::cerr << "Assertion failed: is_simple_power(3, 1) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(5, 3)) {\n        std::cerr << "Assertion failed: is_simple_power(5, 3) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(16, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(16, 2) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(143214, 16)) {\n        std::cerr << "Assertion failed: is_simple_power(143214, 16) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(4, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(4, 2) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(9, 3)) {\n        std::cerr << "Assertion failed: is_simple_power(9, 3) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(16, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(16, 4) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(24, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(24, 2) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(128, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(128, 4) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(12, 6)) {\n        std::cerr << "Assertion failed: is_simple_power(12, 6) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(1, 1)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 1) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(1, 12)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 12) == true" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nThis C++ code includes the `is_simple_power` function, which checks if a number `x` is a simple power of another number `n`. The `main` function contains a series of assertions to verify the correctness of the `is_simple_power` function. If any assertion fails, it prints an error message and returns 1, indicating a failure. Otherwise, it returns 0, indicating success.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the Fortran and C++ versions of the `is_simple_power` function. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_simple_power\n  implicit none\n\n  ! Test cases\n  call assert_true(is_simple_power(1, 4))\n  call assert_true(is_simple_power(2, 2))\n  call assert_true(is_simple_power(8, 2))\n  call assert_false(is_simple_power(3, 2))\n  call assert_false(is_simple_power(3, 1))\n  call assert_false(is_simple_power(5, 3))\n  call assert_true(is_simple_power(16, 2))\n  call assert_false(is_simple_power(143214, 16))\n  call assert_true(is_simple_power(4, 2))\n  call assert_true(is_simple_power(9, 3))\n  call assert_true(is_simple_power(16, 4))\n  call assert_false(is_simple_power(24, 2))\n  call assert_false(is_simple_power(128, 4))\n  call assert_false(is_simple_power(12, 6))\n  call assert_true(is_simple_power(1, 1))\n  call assert_true(is_simple_power(1, 12))\n\ncontains\n\n  logical function is_simple_power(x, n)\n    implicit none\n    integer, intent(in) :: x, n\n    integer :: p, count\n\n    p = 1\n    count = 0\n    do while (p <= x .and. count < 100)\n      if (p == x) then\n        is_simple_power = .true.\n        return\n      end if\n      p = p * n\n      count = count + 1\n    end do\n    is_simple_power = .false.\n  end function is_simple_power\n\n  subroutine assert_true(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed: expected true"\n      call exit(1)\n    end if\n  end subroutine assert_true\n\n  subroutine assert_false(condition)\n    logical, intent(in) :: condition\n    if (condition) then\n      write(*,*) "Assertion failed: expected false"\n      call exit(1)\n    end if\n  end subroutine assert_false\n\nend program test_simple_power\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cassert>\n\nbool is_simple_power(int x, int n) {\n    int p = 1;\n    int count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) {\n            return true;\n        }\n        p *= n;\n        ++count;\n    }\n    return false;\n}\n\nvoid assert_true(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed: expected true" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid assert_false(bool condition) {\n    if (condition) {\n        std::cerr << "Assertion failed: expected false" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool iscuber(int a) {\n    bool result = false;\n    for (int i = 0; i <= static_cast<int>(std::pow(std::abs(a), 1.0 / 3.0)); ++i) {\n        if (i * i * i == std::abs(a)) {\n            result = true;\n            return result;\n        }\n    }\n    return result;\n}\n\nint main() {\n    // Assertions\n    if (!iscuber(1)) {\n        std::cerr << "iscuber(1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(2)) {\n        std::cerr << "iscuber(2): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(-1)) {\n        std::cerr << "iscuber(-1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(64)) {\n        std::cerr << "iscuber(64): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(180)) {\n        std::cerr << "iscuber(180): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(1000)) {\n        std::cerr << "iscuber(1000): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(0)) {\n        std::cerr << "iscuber(0): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(1729)) {\n        std::cerr << "iscuber(1729): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a function `iscuber` that checks if a given integer `a` is a cube number. It uses a loop to iterate through possible cube roots of `a` (rounded down to the nearest integer) and checks if any of these cube roots squared equals `a`. The `main` function contains assertions to verify the correctness of the `iscuber` function with various test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_cube_module.f90`:\n\n```fortran\nmodule cube_module\n  implicit none\ncontains\n  logical function iscuber(a)\n    integer, intent(in) :: a\n    integer :: i\n\n    iscuber = .false.\n    do i = 0, int(abs(a)**(1.0/3.0))\n      if (i**3 == abs(a)) then\n        iscuber = .true.\n        return\n      end if\n    end do\n  end function iscuber\nend module cube_module\n\nprogram test_cube_module\n  use cube_module\n  implicit none\n\n  ! Test cases\n  if (.not. iscuber(1)) then\n    write(*,*) "iscuber(1): test failed"\n  else\n    write(*,*) "iscuber(1): test passed"\n  end if\n\n  if (iscuber(2)) then\n    write(*,*) "iscuber(2): test failed"\n  else\n    write(*,*) "iscuber(2): test passed"\n  end if\n\n  if (.not. iscuber(-1)) then\n    write(*,*) "iscuber(-1): test failed"\n  else\n    write(*,*) "iscuber(-1): test passed"\n  end if\n\n  if (.not. iscuber(64)) then\n    write(*,*) "iscuber(64): test failed"\n  else\n    write(*,*) "iscuber(64): test passed"\n  end if\n\n  if (iscuber(180)) then\n    write(*,*) "iscuber(180): test failed"\n  else\n    write(*,*) "iscuber(180): test passed"\n  end if\n\n  if (.not. iscuber(1000)) then\n    write(*,*) "iscuber(1000): test failed"\n  else\n    write(*,*) "iscuber(1000): test passed"\n  end if\n\n  if (.not. iscuber(0)) then\n    write(*,*) "iscuber(0): test failed"\n  else\n    write(*,*) "iscuber(0): test passed"\n  end if\n\n  if (iscuber(1729)) then\n    write(*,*) "iscuber(1729): test failed"\n  else\n    write(*,*) "iscuber(1729): test passed"\n  end if\n\nend program test_cube_module\n```\n\n### C++ Unit Test Code\n\nSave the following C++ code in a file named `test_cube_module.cpp`:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool iscuber(int a) {\n    bool result = false;\n    for (int i = 0; i <= static_cast<int>(std::pow(std::abs(a), 1.0 / 3.0)); ++i) {\n        if (i * i * i == std::abs(a)) {\n            result = true;\n            return result;\n        }\n    }\n    return result;\n}\n\nvoid test_iscuber(int a, bool expected) {\n    bool result = iscuber(a);\n    if (result == expected) {\n        std::cout << "iscuber(" << a << "): test passed" << std::endl;\n    } else {\n        std::cerr << "iscuber(" << a << "): test failed" << std::endl;\n    }\n}\n\nint main() {\n    // Test cases\n    test_iscuber(1, true);\n    test_iscuber(2, false);\n    test_iscuber(-1, true);\n    test_iscuber(64, true);\n    test_iscuber(180, false);\n    test_iscuber(1000, true);\n    test_iscuber(0, true);\n    test_iscuber(1729, false);\n\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n#### Fortran\n\nTo compile and run the Fortran code, use the following commands in a terminal:\n\n```sh\ngfortran -o test_cube_module test_cube_module.f90\n./test_cube_module\n```\n\n#### C++\n\nTo compile and run the C++ code, use the following commands in a terminal:\n\n```sh\ng++ -o test_cube_module test_cube_module.cpp\n./test_cube_module\n```\n\nBoth the Fortran and C++ unit test codes will output the results of the tests to the console. If the translations are correct, both sets of tests should pass, indicating that the logic in both implementations is equivalent.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nconst std::string key = "2357BD";\n\nint hex_key(const std::string& num) {\n    int out = 0;\n    for (size_t i = 0; i < num.length(); ++i) {\n        if (key.find(num[i]) != std::string::npos) {\n            out += 1;\n        }\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assert(hex_key("AB") == 1);\n    assert(hex_key("1077E") == 2);\n    assert(hex_key("ABED1A33") == 4);\n    assert(hex_key("2020") == 2);\n    assert(hex_key("123456789ABCDEF0") == 6);\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert(hex_key("") == 0);\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Key Definition**: The `key` string is defined similarly to the Fortran code.\n2. **`hex_key` Function**: This function takes a string `num` as input and returns the number of characters in `num` that are present in the `key` string.\n3. **`assert` Function**: This function checks if the condition is `true`. If not, it prints an error message and exits the program with a status code of `1`.\n4. **`main` Function**: The `main` function contains assertions similar to the Fortran program. If any assertion fails, the program will exit with an error message.\n\nThis C++ code should behave similarly to the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `hex_key_test.f90`:\n\n```fortran\nprogram hex_key_test\n    implicit none\n    character(len=*), parameter :: key = "2357BD"\n    integer :: result\n\n    ! Main program body\n    call assert(hex_key("AB") == 1)\n    call assert(hex_key("1077E") == 2)\n    call assert(hex_key("ABED1A33") == 4)\n    call assert(hex_key("2020") == 2)\n    call assert(hex_key("123456789ABCDEF0") == 6)\n    call assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12)\n    call assert(hex_key("") == 0)\n\ncontains\n\n    function hex_key(num) result(out)\n        character(len=*), intent(in) :: num\n        integer :: out\n        integer :: i\n        character(len=1) :: char\n\n        out = 0\n        do i = 1, len_trim(num)\n            char = num(i:i)\n            if (index(key, char) /= 0) then\n                out = out + 1\n            end if\n        end do\n    end function hex_key\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program hex_key_test\n```\n\n### C++ Unit Test Code\n\nSave the following C++ code in a file named `hex_key_test.cpp`:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nconst std::string key = "2357BD";\n\nint hex_key(const std::string& num) {\n    int out = 0;\n    for (size_t i = 0; i < num.length(); ++i) {\n        if (key.find(num[i]) != std::string::npos) {\n            out += 1;\n        }\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assert(hex_key("AB") == 1);\n    assert(hex_key("1077E") == 2);\n    assert(hex_key("ABED1A33") == 4);\n    assert(hex_key("2020") == 2);\n    assert(hex_key("123456789ABCDEF0") == 6);\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert(hex_key("") == 0);\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n#### Fortran\n\nTo compile and run the Fortran code, use the following commands:\n\n```sh\ngfortran -o hex_key_test hex_key_test.f90\n./hex_key_test\n```\n\n#### C++\n\nTo compile and run the C++ code, use the following commands:\n\n```sh\ng++ -o hex_key_test hex_key_test.cpp\n./hex_key_test\n```\n\nBoth programs should output "All tests passed successfully." if all assertions are correct. If any assertion fails, the programs will exit with an error message.
Certainly! Here's the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <string>\n\nstd::string decimal_to_binary(int decimal) {\n    std::string out;\n    if (decimal == 0) {\n        return "db0db";\n    }\n\n    int temp = decimal;\n    while (temp > 0) {\n        out += (temp % 2 == 0) ? '0' : '1';\n        temp /= 2;\n    }\n\n    return "db" + out + "db";\n}\n\nvoid test_decimal_to_binary() {\n    std::string result;\n\n    result = decimal_to_binary(0);\n    if (result != "db0db") {\n        std::cerr << "Assertion failed: decimal_to_binary(0) == 'db0db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(32);\n    if (result != "db100000db") {\n        std::cerr << "Assertion failed: decimal_to_binary(32) == 'db100000db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(103);\n    if (result != "db1100111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(103) == 'db1100111db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(15);\n    if (result != "db1111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(15) == 'db1111db'" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_decimal_to_binary();\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a function `decimal_to_binary` that converts a decimal number to a binary string representation, and a function `test_decimal_to_binary` that performs unit tests on the `decimal_to_binary` function. The `main` function calls `test_decimal_to_binary` to run the tests and then prints a message indicating that all assertions passed.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `decimal_to_binary` function.\n\n### Fortran Unit Test Code\n\nTo compile and run this Fortran code, you might need a Fortran compiler like `gfortran`. Save the following code to a file named `test_decimal_to_binary.f90`:\n\n```fortran\nprogram test_decimal_to_binary\n    implicit none\n    character(len=100) :: result\n\n    result = decimal_to_binary(0)\n    if (trim(result) /= "db0db") then\n        write(*,*) "Assertion failed: decimal_to_binary(0) == 'db0db'"\n        call exit(1)\n    end if\n\n    result = decimal_to_binary(32)\n    if (trim(result) /= "db100000db") then\n        write(*,*) "Assertion failed: decimal_to_binary(32) == 'db100000db'"\n        call exit(1)\n    end if\n\n    result = decimal_to_binary(103)\n    if (trim(result) /= "db1100111db") then\n        write(*,*) "Assertion failed: decimal_to_binary(103) == 'db1100111db'"\n        call exit(1)\n    end if\n\n    result = decimal_to_binary(15)\n    if (trim(result) /= "db1111db") then\n        write(*,*) "Assertion failed: decimal_to_binary(15) == 'db1111db'"\n        call exit(1)\n    end if\n\n    write(*,*) "All assertions passed."\n\ncontains\n\n    character(len=100) function decimal_to_binary(decimal)\n        implicit none\n        integer, intent(in) :: decimal\n        integer :: temp\n        character(len=100) :: out\n        character(len=1) :: digit\n\n        out = ""\n        if (decimal == 0) then\n            decimal_to_binary = "db0db"\n            return\n        end if\n\n        temp = decimal\n        do while (temp > 0)\n            write(digit, '(I1)') mod(temp, 2)\n            out = trim(digit) // out\n            temp = temp / 2\n        end do\n\n        decimal_to_binary = "db" // trim(out) // "db"\n    end function decimal_to_binary\n\nend program test_decimal_to_binary\n```\n\n### C++ Unit Test Code\n\nTo compile and run this C++ code, you might need a C++ compiler like `g++`. Save the following code to a file named `test_decimal_to_binary.cpp`:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For std::exit\n\nstd::string decimal_to_binary(int decimal) {\n    std::string out;\n    if (decimal == 0) {\n        return "db0db";\n    }\n\n    int temp = decimal;\n    while (temp > 0) {\n        out += (temp % 2 == 0) ? '0' : '1';\n        temp /= 2;\n    }\n\n    return "db" + out + "db";\n}\n\nvoid test_decimal_to_binary() {\n    std::string result;\n\n    result = decimal_to_binary(0);\n    if (result != "db0db") {\n        std::cerr << "Assertion failed: decimal_to_binary(0) == 'db0db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(32);\n    if (result != "db100000db") {\n        std::cerr << "Assertion failed: decimal_to_binary(32) == 'db100000db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(103);\n    if (result != "db1100111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(103) == 'db1100111db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(15);\n    if (result != "db1111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(15) == 'db1111db'" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_decimal_to_binary();\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n- For Fortran:\n  ```sh\n  gfortran -o test_decimal_to_binary test_decimal_to_binary.f90\n  ./test_decimal_to_binary\n  ```\n\n- For C++:\n  ```sh\n  g++ -o test_decimal_to_binary test_decimal_to_binary.cpp\n  ./test_decimal_to_binary\n  ```\n\nThese unit tests will verify the correctness of the `decimal_to_binary` function in both the Fortran and C++ implementations. If all assertions pass, the programs will print "All assertions passed."
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_happy(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (size_t i = 3; i <= s.length(); ++i) {\n        if (s[i - 1] == s[i - 2] || s[i - 1] == s[i - 3]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    // Test cases\n    if (!is_happy("a")) {\n        std::cout << "Test 1 passed" << std::endl;\n    } else {\n        std::cout << "Test 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("aa")) {\n        std::cout << "Test 2 passed" << std::endl;\n    } else {\n        std::cout << "Test 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (is_happy("abcd")) {\n        std::cout << "Test 3 passed" << std::endl;\n    } else {\n        std::cout << "Test 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("aabb")) {\n        std::cout << "Test 4 passed" << std::endl;\n    } else {\n        std::cout << "Test 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (is_happy("adb")) {\n        std::cout << "Test 5 passed" << std::endl;\n    } else {\n        std::cout << "Test 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("xyy")) {\n        std::cout << "Test 6 passed" << std::endl;\n    } else {\n        std::cout << "Test 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (is_happy("iopaxpoi")) {\n        std::cout << "Test 7 passed" << std::endl;\n    } else {\n        std::cout << "Test 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("iopaxioi")) {\n        std::cout << "Test 8 passed" << std::endl;\n    } else {\n        std::cout << "Test 8 failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ code includes the `is_happy` function to check if a given string is happy, and a `main` function that runs several test cases to verify the correctness of the `is_happy` function. The tests are designed to match the Fortran tests, ensuring the same logic and outcomes are tested.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `is_happy` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_is_happy\n    implicit none\n\n    ! Test cases\n    call test_case("a", .false.)\n    call test_case("aa", .false.)\n    call test_case("abcd", .true.)\n    call test_case("aabb", .false.)\n    call test_case("adb", .true.)\n    call test_case("xyy", .false.)\n    call test_case("iopaxpoi", .true.)\n    call test_case("iopaxioi", .false.)\n\ncontains\n\n    subroutine test_case(s, expected)\n        character(len=*), intent(in) :: s\n        logical, intent(in) :: expected\n        logical :: result\n\n        result = is_happy(s)\n        if (result .eqv. expected) then\n            write(*,*) "Test passed for: ", s\n        else\n            write(*,*) "Test failed for: ", s\n            call exit(1)\n        end if\n    end subroutine test_case\n\n    logical function is_happy(s)\n        character(len=*), intent(in) :: s\n        integer :: i\n\n        if (len(s) < 3) then\n            is_happy = .false.\n            return\n        end if\n\n        do i = 3, len(s)\n            if (s(i:i) == s(i-1:i-1) .or. s(i:i) == s(i-2:i-2)) then\n                is_happy = .false.\n                return\n            end if\n        end do\n\n        is_happy = .true.\n    end function is_happy\n\nend program test_is_happy\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_happy(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (size_t i = 3; i <= s.length(); ++i) {\n        if (s[i - 1] == s[i - 2] || s[i - 1] == s[i - 3]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_case(const std::string& s, bool expected) {\n    bool result = is_happy(s);\n    if (result == expected) {\n        std::cout << "Test passed for: " << s << std::endl;\n    } else {\n        std::cout << "Test failed for: " << s << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_case("a", false);\n    test_case("aa", false);\n    test_case("abcd", true);\n    test_case("aabb", false);\n    test_case("adb", true);\n    test_case("xyy", false);\n    test_case("iopaxpoi", true);\n    test_case("iopaxioi", false);\n\n    return 0;\n}\n```\n\n### Explanation\n\n- **Fortran Unit Test Code**: This code defines a `test_case` subroutine that takes a string `s` and an expected result `expected`. It then checks if the `is_happy` function returns the expected result for the given string. If the result matches the expected result, it prints "Test passed"; otherwise, it prints "Test failed" and exits with an error code.\n\n- **C++ Unit Test Code**: This code defines a `test_case` function that takes a string `s` and an expected result `expected`. It then checks if the `is_happy` function returns the expected result for the given string. If the result matches the expected result, it prints "Test passed"; otherwise, it prints "Test failed" and exits with an error code.\n\nBoth unit test codes are designed to ensure that the `is_happy` function behaves correctly across a range of inputs, matching the original Fortran logic and outcomes.
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, string comparisons, and conditional logic. Below is the C++ translation of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nvoid numerical_letter_grade(const std::vector<float>& grades, std::vector<std::string>& out) {\n    out.resize(grades.size());\n\n    for (size_t i = 0; i < grades.size(); ++i) {\n        if (grades[i] >= 3.9999) {\n            out[i] = "A+";\n        } else if (grades[i] > 3.7001 && grades[i] < 3.9999) {\n            out[i] = "A ";\n        } else if (grades[i] > 3.3001 && grades[i] <= 3.7001) {\n            out[i] = "A-";\n        } else if (grades[i] > 3.0001 && grades[i] <= 3.3001) {\n            out[i] = "B+";\n        } else if (grades[i] > 2.7001 && grades[i] <= 3.0001) {\n            out[i] = "B ";\n        } else if (grades[i] > 2.3001 && grades[i] <= 2.7001) {\n            out[i] = "B-";\n        } else if (grades[i] > 2.0001 && grades[i] <= 2.3001) {\n            out[i] = "C+";\n        } else if (grades[i] > 1.7001 && grades[i] <= 2.0001) {\n            out[i] = "C ";\n        } else if (grades[i] > 1.3001 && grades[i] <= 1.7001) {\n            out[i] = "C-";\n        } else if (grades[i] > 1.0001 && grades[i] <= 1.3001) {\n            out[i] = "D+";\n        } else if (grades[i] > 0.7001 && grades[i] <= 1.0001) {\n            out[i] = "D ";\n        } else if (grades[i] > 0.0001 && grades[i] <= 0.7001) {\n            out[i] = "D-";\n        } else {\n            out[i] = "E ";\n        }\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::string> result;\n    std::vector<std::string> expected1 = {"A+", "B ", "C-", "C ", "A-"};\n    std::vector<std::string> expected2 = {"D+"};\n    std::vector<std::string> expected3 = {"D-"};\n    std::vector<std::string> expected4 = {"E "};\n    std::vector<std::string> expected5 = {"D ", "D-", "C-", "B ", "B+"};\n    std::vector<std::string> expected6 = {"E ", "D-"};\n\n    numerical_letter_grade({4.0, 3.0, 1.7, 2.0, 3.5}, result);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({1.2}, result);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({0.5}, result);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({0.0}, result);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for test case 4" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({1.0, 0.3, 1.5, 2.8, 3.3}, result);\n    if (!issame(result, expected5)) {\n        std::cerr << "Assertion failed for test case 5" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({0.0, 0.7}, result);\n    if (!issame(result, expected6)) {\n        std::cerr << "Assertion failed for test case 6" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\n### Key Points:\n\n1. **Dynamic Arrays**: In C++, `std::vector` is used to handle dynamic arrays. This is more flexible and safer compared to raw pointers or arrays.\n\n2. **String Comparison**: The `issame` function compares two vectors of strings to check if they are equal.\n\n3. **Numerical Letter Grade**: The `numerical_letter_grade` function translates numerical grades to letter grades and stores them in a vector of strings.\n\n4. **Conditional Logic**: The conditional logic inside the `numerical_letter_grade` function closely mirrors the original Fortran code's logic.\n\n5. **Error Handling**: Instead of `write(*,*) "Assertion failed for test case 1"` and `call exit(1)`, C++ uses `std::cerr` for error messages and returns `1` from `main` to indicate an error.\n\nThis C++ code should behave similarly to the original Fortran code, ensuring the same logic and output for the given test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `numerical_letter_grade` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_numerical_letter_grade\n    implicit none\n    character(len=2), dimension(:), allocatable :: result\n    character(len=2), dimension(5) :: expected1 = (/"A+", "B ", "C-", "C ", "A-"/)\n    character(len=2), dimension(1) :: expected2 = (/"D+"/)\n    character(len=2), dimension(1) :: expected3 = (/"D-"/)\n    character(len=2), dimension(1) :: expected4 = (/"E "/)\n    character(len=2), dimension(5) :: expected5 = (/"D ", "D-", "C-", "B ", "B+"/)\n    character(len=2), dimension(2) :: expected6 = (/"E ", "D-"/)\n\n    call test_case_1()\n    call test_case_2()\n    call test_case_3()\n    call test_case_4()\n    call test_case_5()\n    call test_case_6()\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    subroutine numerical_letter_grade(grades, out)\n        real, dimension(:), intent(in) :: grades\n        character(len=2), dimension(:), allocatable, intent(out) :: out\n        integer :: i\n\n        allocate(out(size(grades)))\n\n        do i = 1, size(grades)\n            if (grades(i) >= 3
Certainly! Below is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\nbool is_prime_length(const std::string& s) {\n    int l = s.length();\n    if (l < 2) {\n        return false;\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(l)); ++i) {\n        if (l % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid run_tests() {\n    struct Test {\n        std::string str;\n        bool expected;\n    };\n\n    Test tests[] = {\n        {"Hello", true},\n        {"abcdcba", true},\n        {"kittens", true},\n        {"orange", false},\n        {"wow", true},\n        {"world", true},\n        {"MadaM", true},\n        {"Wow", true},\n        {"", false},\n        {"HI", true},\n        {"go", true},\n        {"gogo", false},\n        {"aaaaaaaaaaaaaaa", false},\n        {"Madam", true},\n        {"M", false},\n        {"0", false}\n    };\n\n    bool all_tests_passed = true;\n    for (const auto& test : tests) {\n        bool result = is_prime_length(test.str);\n        if (result != test.expected) {\n            std::cerr << "is_prime_length('" << test.str << "') == "\n                      << std::boolalpha << test.expected << ": assertion failed" << std::endl;\n            all_tests_passed = false;\n        }\n    }\n\n    if (all_tests_passed) {\n        std::cout << "All tests passed successfully." << std::endl;\n    }\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `is_prime_length`**:\n   - This function checks if the length of the given string `s` is a prime number.\n   - It uses a loop to check if the length of the string is divisible by any number between 2 and the square root of the length.\n\n2. **Function `run_tests`**:\n   - This function contains an array of test cases where each test case is a pair of a string and a boolean value indicating whether the string's length is a prime number.\n   - It iterates through the array, calls `is_prime_length` with each string, and checks if the result matches the expected outcome.\n   - If all tests pass, it prints "All tests passed successfully."\n\n3. **Main Function**:\n   - Calls the `run_tests` function to execute the tests.\n\nThis C++ code should behave similarly to the provided Fortran code. The tests have been adapted to use a struct array for test cases and to use `std::boolalpha` for printing boolean values as true/false instead of 1/0.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram prime_length_check\n  implicit none\n\n  call run_tests()\n\ncontains\n\n  logical function is_prime_length(s)\n    character(len=*), intent(in) :: s\n    integer :: l, i\n\n    l = len_trim(s)\n    if (l < 2) then\n      is_prime_length = .false.\n      return\n    end if\n\n    do i = 2, int(sqrt(real(l)))\n      if (mod(l, i) == 0) then\n        is_prime_length = .false.\n        return\n      end if\n    end do\n\n    is_prime_length = .true.\n  end function is_prime_length\n\n  subroutine run_tests()\n    character(len=:), allocatable :: str\n    logical :: result\n\n    str = "Hello"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('Hello') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "abcdcba"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('abcdcba') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "kittens"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('kittens') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "orange"\n    result = is_prime_length(str)\n    if (result) then\n      write(*,*) "is_prime_length('orange') == false: assertion failed"\n      call exit(1)\n    end if\n\n    str = "wow"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('wow') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "world"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('world') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "MadaM"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('MadaM') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "Wow"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('Wow') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = ""\n    result = is_prime_length(str)\n    if (result) then\n      write(*,*) "is_prime_length('') == false: assertion failed"\n      call exit(1)\n    end if\n\n    str = "HI"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('HI') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "go"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('go') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "gogo"\n    result = is_prime_length(str)\n    if (result) then\n      write(*,*) "is_prime_length('gogo') == false: assertion failed"\n      call exit(1)\n    end if\n\n    str = "aaaaaaaaaaaaaaa"\n    result = is_prime_length(str)\n    if (result) then\n      write(*,*) "is_prime_length('aaaaaaaaaaaaaaa') == false: assertion failed"\n      call exit(1)\n    end if\n\n    str = "Madam"\n    result = is_prime_length(str)\n    if (.not. result) then\n      write(*,*) "is_prime_length('Madam') == true: assertion failed"\n      call exit(1)\n    end if\n\n    str = "M"\n    result = is_prime_length(str)\n    if (result) then\n      write(*,*) "is_prime_length('M') == false: assertion failed"\n      call exit(1)\n    end if\n\n    str = "0"\n    result = is_prime_length(str)\n    if (result) then\n      write(*,*) "is_prime_length('0') == false: assertion failed"\n      call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n  end subroutine run_tests\n\nend program prime_length_check\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <string
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code includes the necessary assertions and the function `starts_one_ends` as a part of the main program.\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint starts_one_ends(int n);\n\nint main() {\n    // Assertions\n    if (starts_one_ends(1) != 1) {\n        std::cerr << "Assertion failed: starts_one_ends(1) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(2) != 18) {\n        std::cerr << "Assertion failed: starts_one_ends(2) == 18" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(3) != 180) {\n        std::cerr << "Assertion failed: starts_one_ends(3) == 180" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(4) != 1800) {\n        std::cerr << "Assertion failed: starts_one_ends(4) == 1800" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(5) != 18000) {\n        std::cerr << "Assertion failed: starts_one_ends(5) == 18000" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint starts_one_ends(int n) {\n    if (n < 1) {\n        return 0;\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    int out = 18;\n    for (int i = 2; i <= n - 1; ++i) {\n        out *= 10;\n    }\n\n    return out;\n}\n```\n\nThis C++ code includes the necessary headers and uses `std::cerr` for error output and `std::exit(1)` to exit the program with an error code if an assertion fails. The `starts_one_ends` function is defined similarly to the Fortran version, with adjustments for C++ syntax.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `starts_one_ends` function for various inputs.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_starts_one_ends\n    implicit none\n\n    integer :: i\n    integer, parameter :: test_values(5) = [1, 2, 3, 4, 5]\n    integer, parameter :: expected_results(5) = [1, 18, 180, 1800, 18000]\n\n    do i = 1, size(test_values)\n        if (starts_one_ends(test_values(i)) /= expected_results(i)) then\n            write(*,*) "Test failed for n =", test_values(i)\n            write(*,*) "Expected:", expected_results(i), "Got:", starts_one_ends(test_values(i))\n            call exit(1)\n        end if\n    end do\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    integer function starts_one_ends(n)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i, out\n\n        if (n < 1) then\n            starts_one_ends = 0\n            return\n        end if\n\n        if (n == 1) then\n            starts_one_ends = 1\n            return\n        end if\n\n        out = 18\n        do i = 2, n - 1\n            out = out * 10\n        end do\n\n        starts_one_ends = out\n    end function starts_one_ends\n\nend program test_starts_one_ends\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint starts_one_ends(int n);\n\nint main() {\n    // Test cases\n    struct TestCase {\n        int input;\n        int expected;\n    };\n\n    TestCase testCases[] = {\n        {1, 1},\n        {2, 18},\n        {3, 180},\n        {4, 1800},\n        {5, 18000}\n    };\n\n    bool allTestsPassed = true;\n    for (const auto& testCase : testCases) {\n        int result = starts_one_ends(testCase.input);\n        if (result != testCase.expected) {\n            std::cerr << "Test failed for n = " << testCase.input << std::endl;\n            std::cerr << "Expected: " << testCase.expected << " Got: " << result << std::endl;\n            allTestsPassed = false;\n        }\n    }\n\n    if (allTestsPassed) {\n        std::cout << "All tests passed." << std::endl;\n    }\n\n    return 0;\n}\n\n// Function definition\nint starts_one_ends(int n) {\n    if (n < 1) {\n        return 0;\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    int out = 18;\n    for (int i = 2; i <= n - 1; ++i) {\n        out *= 10;\n    }\n\n    return out;\n}\n```\n\nThese unit test codes for both Fortran and C++ will verify the correctness of the `starts_one_ends` function for inputs from 1 to 5. If any test fails, the program will output the expected and actual results for the failed test case and exit with an error code. If all tests pass, it will print a success message.
To translate the given Fortran code to C++, we need to consider several differences between the two languages, such as variable declaration, function definition, and string handling. Here's a C++ version of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function prototype\nstd::string solve(int N);\n\nint main() {\n    std::string result;\n\n    result = solve(1000);\n    if (result != "1") {\n        std::cerr << "Assertion failed for solve(1000)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(150);\n    if (result != "110") {\n        std::cerr << "Assertion failed for solve(150)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(147);\n    if (result != "1100") {\n        std::cerr << "Assertion failed for solve(147)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(333);\n    if (result != "1001") {\n        std::cerr << "Assertion failed for solve(333)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(963);\n    if (result != "10010") {\n        std::cerr << "Assertion failed for solve(963)" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nstd::string solve(int N) {\n    std::string str = std::to_string(N); // Convert integer N to string\n    int sum = 0;\n\n    // Calculate the sum of digits\n    for (char c : str) {\n        sum += c - '0'; // Subtract '0' to get the digit value\n    }\n\n    std::string bi = "";\n\n    // Convert sum to binary\n    while (sum > 0) {\n        bi = static_cast<char>(sum % 2) + bi; // Append digit to the beginning\n        sum /= 2;\n    }\n\n    // Handle the case when sum is 0\n    if (bi.empty()) {\n        bi = "0";\n    }\n\n    return bi;\n}\n```\n\nKey Points in the Translation:\n\n1. **Function Definition**: The `solve` function is defined with the return type `std::string` to handle the string output.\n2. **String Handling**: C++'s `std::string` class is used for string operations, which simplifies operations like concatenation and conversion compared to Fortran's character handling.\n3. **Variable Declaration**: Variables are declared with their types, using `std::string` for strings and `int` for integers.\n4. **Looping Through Strings**: The Fortran code uses a loop to iterate over each character in a string. In C++, we can use a range-based for loop to achieve the same effect.\n5. **Character Conversion**: The Fortran code manually converts characters to integers and back. In C++, we use the `- '0'` trick to convert characters to their digit values, and `static_cast<char>()` to convert integer values back to characters.\n6. **Program Termination**: The `exit(1)` call is used to terminate the program with an error code, similar to Fortran's `call exit(1)`.\n\nThis C++ code should behave similarly to the original Fortran code, performing the same calculations and checks.\nLet's write some test to verify if the translation is correct. \nBelow are examples of how you could write unit tests for both the Fortran and C++ versions of the code. These tests will verify the correctness of the `solve` function with various inputs.\n\n### Fortran Unit Tests\n\nFor the Fortran code, we'll use a simple approach to test the `solve` function by calling it with known inputs and comparing the results against expected outputs. Fortran doesn't have a built-in unit testing framework like some other languages, so we'll do this in a straightforward manner.\n\n```fortran\nprogram test_solve\n    implicit none\n    character(len=10) :: result\n    integer :: errors\n\n    errors = 0\n\n    ! Test 1\n    result = solve(1000)\n    if (trim(result) /= "1") then\n        write(*,*) "Test 1 failed: Expected 1, got ", trim(result)\n        errors = errors + 1\n    end if\n\n    ! Test 2\n    result = solve(150)\n    if (trim(result) /= "110") then\n        write(*,*) "Test 2 failed: Expected 110, got ", trim(result)\n        errors = errors + 1\n    end if\n\n    ! Add more tests as needed...\n\n    if (errors == 0) then\n        write(*,*) "All tests passed."\n    else\n        write(*,*) errors, " tests failed."\n    end if\nend program test_solve\n\n! Include or link the solve function here\n```\n\n### C++ Unit Tests\n\nFor C++, we can use the Google Test framework for unit testing, which provides a rich set of assertions and is widely used. First, you'll need to set up Google Test in your project. Instructions for setting up Google Test can be found in its [GitHub repository](https://github.com/google/googletest).\n\nHere's how you might write the tests in C++:\n\n```cpp\n#include <gtest/gtest.h>\n#include "solve.h" // Assume the solve function is declared in solve.h\n\nTEST(SolveTest, HandlesZeroInput) {\n    EXPECT_EQ(solve(0), "0");\n}\n\nTEST(SolveTest, HandlesOneInput) {\n    EXPECT_EQ(solve(1), "1");\n}\n\nTEST(SolveTest, HandlesMultipleDigitsInput) {\n    EXPECT_EQ(solve(100), "1100100");\n    EXPECT_EQ(solve(150), "110");\n    EXPECT_EQ(solve(147), "1100");\n    EXPECT_EQ(solve(333), "1001");\n    EXPECT_EQ(solve(963), "10010");\n}\n\n// Add more tests as needed...\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\nThis C++ code uses Google Test to define three test cases:\n\n1. **HandlesZeroInput**: Tests the `solve` function with an input of `0`, expecting the output to be `"0"`.\n2. **HandlesOneInput**: Tests the `solve` function with an input of `1`, expecting the output to be `"1"`.\n3. **HandlesMultipleDigitsInput**: Tests the `solve` function with various inputs (100, 150, 147, 333, 963), comparing the outputs against expected binary strings.\n\nTo run these tests, you'll need to compile the test file along with the Google Test library and your `solve` function implementation, then execute the resulting binary. The specifics of compiling and running will depend on your development environment and how you've set up Google Test.\n\nThese tests should help ensure that the `solve` function behaves correctly across both the Fortran and C++ implementations.
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same test cases and functionality as the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nint add(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size() / 2; ++i) {\n        if (lst[2 * i + 1] % 2 == 0) {\n            sum += lst[2 * i + 1];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    if (add({4, 88}) != 88) {\n        std::cerr << "Assertion failed: add({4, 88}) == 88" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 5, 6, 7, 2, 122}) != 122) {\n        std::cerr << "Assertion failed: add({4, 5, 6, 7, 2, 122}) == 122" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 0, 6, 7}) != 0) {\n        std::cerr << "Assertion failed: add({4, 0, 6, 7}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 4, 6, 8}) != 12) {\n        std::cerr << "Assertion failed: add({4, 4, 6, 8}) == 12" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `add`**: This function takes a vector of integers as input and returns the sum of even-valued elements in the vector, considering the original Fortran code's logic.\n2. **Main function**: This contains the test cases that verify the correctness of the `add` function. If any test case fails, it prints an error message and exits with a non-zero status.\n\n### Notes:\n- The original Fortran code uses 1-based indexing for arrays, while C++ uses 0-based indexing. Therefore, the translation adjusts the indexing accordingly.\n- The `std::vector<int>` is used to represent the array of integers, and its size is dynamically managed, similar to how arrays are handled in Fortran.\n- The `std::cerr` is used for error output, and `std::exit(1)` is used to exit the program with a failure status, similar to the `call exit(1)` in Fortran.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `add` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_add_function\n    implicit none\n    integer :: result\n\n    ! Test cases\n    result = add([4, 88])\n    if (result /= 88) then\n        write(*,*) "Test failed: add([4, 88]) == 88"\n        call exit(1)\n    end if\n\n    result = add([4, 5, 6, 7, 2, 122])\n    if (result /= 122) then\n        write(*,*) "Test failed: add([4, 5, 6, 7, 2, 122]) == 122"\n        call exit(1)\n    end if\n\n    result = add([4, 0, 6, 7])\n    if (result /= 0) then\n        write(*,*) "Test failed: add([4, 0, 6, 7]) == 0"\n        call exit(1)\n    end if\n\n    result = add([4, 4, 6, 8])\n    if (result /= 12) then\n        write(*,*) "Test failed: add([4, 4, 6, 8]) == 12"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed successfully."\n\ncontains\n\n    function add(lst) result(sum)\n        integer, dimension(:), intent(in) :: lst\n        integer :: sum\n        integer :: i\n\n        sum = 0\n        do i = 0, (size(lst) - 1) / 2\n            if (mod(lst(2 * i + 2), 2) == 0) then\n                sum = sum + lst(2 * i + 2)\n            end if\n        end do\n    end function add\n\nend program test_add_function\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nint add(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size() / 2; ++i) {\n        if (lst[2 * i + 1] % 2 == 0) {\n            sum += lst[2 * i + 1];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    if (add({4, 88}) != 88) {\n        std::cerr << "Test failed: add({4, 88}) == 88" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 5, 6, 7, 2, 122}) != 122) {\n        std::cerr << "Test failed: add({4, 5, 6, 7, 2, 122}) == 122" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 0, 6, 7}) != 0) {\n        std::cerr << "Test failed: add({4, 0, 6, 7}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 4, 6, 8}) != 12) {\n        std::cerr << "Test failed: add({4, 4, 6, 8}) == 12" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n- **Fortran Unit Test Code**: This program defines a `test_add_function` program that includes the `add` function and several test cases to verify its correctness. If any test fails, it prints an error message and exits with a non-zero status.\n- **C++ Unit Test Code**: This program defines a `main` function that includes the `add` function and several test cases to verify its correctness. If any test fails, it prints an error message and exits with a non-zero status.\n\n### Compilation and Execution:\n- **Fortran**: You can compile the Fortran code using a Fortran compiler like `gfortran`:\n  ```sh\n  gfortran -o test_add_function test_add_function.f90\n  ./test_add_function\n  ```\n- **C++**: You can compile the C++ code using a C++ compiler like `g++`:\n  ```sh\n  g++ -o test_add_function test_add_function.cpp\n  ./test_add_function\n  ```\n\nThese unit tests will help ensure that the `add` function behaves as expected in both the Fortran and C++ implementations.
Translating the provided Fortran code to C++ involves several steps, including adapting the syntax, changing array handling, and implementing the logic for sorting and testing. Here's a C++ version of the code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> sort_array(const std::vector<int>& array) {\n    std::vector<int> out = array;\n    int n = out.size();\n\n    if (n == 0) {\n        return out;\n    }\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (out[j] > out[j + 1]) {\n                std::swap(out[j], out[j + 1]);\n            }\n        }\n    }\n\n    if (out[0] + out[n - 1] % 2 == 1) {\n        return out;\n    } else {\n        std::reverse(out.begin(), out.end());\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid test_cases() {\n    assert(issame(sort_array({0}), {0}));\n    assert(issame(sort_array({5}), {5}));\n    assert(issame(sort_array({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5}));\n    assert(issame(sort_array({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0}));\n    assert(issame(sort_array({2, 1}), {1, 2}));\n    assert(issame(sort_array({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87}));\n    assert(issame(sort_array({21, 14, 23, 11}), {23, 21, 14, 11}));\n}\n\nint main() {\n    test_cases();\n    return 0;\n}\n```\n\n### Key Points:\n\n1. **Array Handling**: C++ uses `std::vector<int>` for dynamic arrays, which is more flexible and safer compared to raw arrays.\n\n2. **Sorting Algorithm**: The bubble sort algorithm is implemented directly in the `sort_array` function.\n\n3. **Logic for Odd-Even Sort**: The logic for the odd-even sort is preserved, but note that C++ uses zero-based indexing.\n\n4. **Assertion and Testing**: The `assert` function and `test_cases` subroutine are implemented similarly to the Fortran version, but in C++.\n\n5. **Main Function**: The `main` function in C++ is used to call the `test_cases` function, similar to the Fortran program structure.\n\nThis C++ code should provide the same functionality as the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the sorting and comparison functionalities.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, dimension(:), allocatable :: array, sorted_array, expected_array\n    integer :: i\n    logical :: result\n\n    call test_cases()\n\ncontains\n\n    function sort_array(array) result(out)\n        integer, dimension(:), intent(in) :: array\n        integer, dimension(:), allocatable :: out\n        integer :: n, i, j, temp\n\n        n = size(array)\n        if (n == 0) then\n            allocate(out(0))\n            return\n        end if\n\n        allocate(out(n))\n        out = array\n\n        ! Bubble sort implementation\n        do i = 1, n-1\n            do j = 1, n-i\n                if (out(j) > out(j+1)) then\n                    temp = out(j)\n                    out(j) = out(j+1)\n                    out(j+1) = temp\n                end if\n            end do\n        end do\n\n        if (mod(out(1) + out(n), 2) == 1) then\n            return\n        else\n            out = out(n:1:-1)\n        end if\n    end function sort_array\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\n    subroutine test_cases\n        call assert(issame(sort_array([0]), [0]))\n        call assert(issame(sort_array([5]), [5]))\n        call assert(issame(sort_array([2, 4, 3, 0, 1, 5]), [0, 1, 2, 3, 4, 5]))\n        call assert(issame(sort_array([2, 4, 3, 0, 1, 5, 6]), [6, 5, 4, 3, 2, 1, 0]))\n        call assert(issame(sort_array([2, 1]), [1, 2]))\n        call assert(issame(sort_array([15, 42, 87, 32, 11, 0]), [0, 11, 15, 32, 42, 87]))\n        call assert(issame(sort_array([21, 14, 23, 11]), [23, 21, 14, 11]))\n    end subroutine test_cases\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> sort_array(const std::vector<int>& array) {\n    std::vector<int> out = array;\n    int n = out.size();\n\n    if (n == 0) {\n        return out;\n    }\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (out[j] > out[j + 1]) {\n                std::swap(out[j], out[j + 1]);\n            }\n        }\n    }\n\n    if (out[0] + out[n - 1] % 2 == 1) {\n        return out;\n    } else {\n        std::reverse(out.begin(), out.end());\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector
Translating the provided Fortran code to C++ involves converting the module and subroutine into a class with member functions, and handling dynamic arrays with vectors or list containers from the Standard Template Library (STL). Here's how the translation might look:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Utilities {\npublic:\n    static int next_smallest(const std::vector<int>& lst) {\n        if (lst.empty()) {\n            return -1;\n        }\n\n        std::vector<int> sorted_lst = lst;\n        std::sort(sorted_lst.begin(), sorted_lst.end());\n\n        int res = -1;\n        for (size_t i = 1; i < sorted_lst.size(); ++i) {\n            if (sorted_lst[i] != sorted_lst[i - 1]) {\n                res = sorted_lst[i];\n                break;\n            }\n        }\n        return res;\n    }\n\n    static void sort(std::vector<int>& arr) {\n        std::sort(arr.begin(), arr.end());\n    }\n};\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test case 1\n    lst = {1, 2, 3, 4, 5};\n    result = Utilities::next_smallest(lst);\n    if (result != 2) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    lst = {5, 1, 4, 3, 2};\n    result = Utilities::next_smallest(lst);\n    if (result != 2) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    lst = {};\n    result = Utilities::next_smallest(lst);\n    if (result != -1) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    lst = {1, 1};\n    result = Utilities::next_smallest(lst);\n    if (result != -1) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    lst = {1, 1, 1, 1, 0};\n    result = Utilities::next_smallest(lst);\n    if (result != 1) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 6\n    lst = {-35, 34, 12, -45};\n    result = Utilities::next_smallest(lst);\n    if (result != -35) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a `Utilities` class with static member functions `next_smallest` and `sort`, which correspond to the Fortran module's functions. The `main` function contains test cases similar to the Fortran program, ensuring that the translated code behaves as expected. Note that in C++, vectors are used to handle dynamic arrays, which provides more flexibility and safety compared to raw arrays.\nLet's write some test to verify if the translation is correct. \nBelow are examples of how you might write unit tests for both the Fortran and C++ versions of the code. These tests will verify the correctness of the `next_smallest` function under various conditions.\n\n### Fortran Unit Tests\n\nFor Fortran, you can use a simple testing approach by adding test cases directly in the program. Fortran lacks a built-in unit testing framework, so we'll manually check the results and print out messages accordingly.\n\n```fortran\nprogram test_utilities\n    use utilities\n    implicit none\n    integer, dimension(:), allocatable :: lst\n    integer :: result\n\n    ! Test case 1\n    lst = [1, 2, 3, 4, 5]\n    result = next_smallest(lst)\n    if (result == 2) then\n        write(*,*) "Test case 1 passed"\n    else\n        write(*,*) "Test case 1 failed"\n    end if\n\n    ! Test case 2\n    lst = [5, 1, 4, 3, 2]\n    result = next_smallest(lst)\n    if (result == 2) then\n        write(*,*) "Test case 2 passed"\n    else\n        write(*,*) "Test case 2 failed"\n    end if\n\n    ! Add more test cases as needed...\n\nend program test_utilities\n```\n\n### C++ Unit Tests\n\nFor C++, you can use a unit testing framework like Google Test for more comprehensive testing. Here's how you might set up a basic test suite using Google Test.\n\nFirst, you need to install Google Test. The setup might vary depending on your system and IDE.\n\nThen, you can write the test cases as follows:\n\n```cpp\n#include <gtest/gtest.h>\n#include "Utilities.h" // Assume the Utilities class is defined in this header\n\nTEST(UtilitiesTest, NextSmallest) {\n    std::vector<int> lst = {1, 2, 3, 4, 5};\n    EXPECT_EQ(Utilities::next_smallest(lst), 2);\n\n    lst = {5, 1, 4, 3, 2};\n    EXPECT_EQ(Utilities::next_smallest(lst), 2);\n\n    lst = {}; // Empty vector\n    EXPECT_EQ(Utilities::next_smallest(lst), -1);\n\n    lst = {1, 1};\n    EXPECT_EQ(Utilities::next_smallest(lst), -1);\n\n    lst = {1, 1, 1, 1, 0};\n    EXPECT_EQ(Utilities::next_smallest(lst), 1);\n\n    lst = {-35, 34, 12, -45};\n    EXPECT_EQ(Utilities::next_smallest(lst), -35);\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\nThis C++ code uses Google Test to define a test case for each scenario you want to test. Each `EXPECT_EQ` macro checks if the `next_smallest` function returns the expected value for a given input.\n\nTo run these tests, you'll need to compile the C++ test file with Google Test libraries linked, and then execute the resulting binary. The exact compilation command depends on your setup, but it might look something like this:\n\n```bash\ng++ -std=c++11 -isystem /path/to/gtest/include -pthread path/to/your_test_file.cpp path/to/your_utilities_file.cpp /path/to/gtest_main.a -o your_test_executable\n./your_test_executable\n```\n\nReplace `/path/to/...` with the actual paths to your files and libraries.\n\nThese tests will help ensure that both the Fortran and C++ implementations of the `next_smallest` function behave as expected under various conditions.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint is_bored(const std::string& S) {\n    int sum = 0;\n    bool isstart = true;\n    bool isi = false;\n    int lenS = S.length();\n\n    for (int i = 0; i < lenS; ++i) {\n        if (S[i] == ' ' && isi) {\n            isi = false;\n            sum++;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = true;\n        } else {\n            isi = false;\n        }\n        if (S[i] != ' ') {\n            isstart = false;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = true;\n        }\n    }\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(is_bored("Hello world") == 0);\n    assert(is_bored("Is the sky blue?") == 0);\n    assert(is_bored("I love It !") == 1);\n    assert(is_bored("bIt") == 0);\n    assert(is_bored("I feel good today. I will be productive. will kill It") == 2);\n    assert(is_bored("You and I are going for a walk") == 0);\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `is_bored`**: This function takes a `std::string` as input and returns an integer. It calculates the number of times the word "I" is followed by a space in the given string.\n2. **Variable `sum`**: This variable is used to count the number of times the word "I" is followed by a space.\n3. **Variables `isstart`, `isi`, `lenS`**: These variables are used to keep track of the state of the string and the position of the character being processed.\n4. **Loop**: The loop iterates through each character of the input string. It checks for the conditions to increment the `sum` variable.\n5. **`assert` function**: This function checks if the condition is `false` and prints an error message if so. If the condition is `false`, the program exits with a status code of `1`.\n6. **Main function**: The `main` function contains the test cases that call the `assert` function with the results of the `is_bored` function.\n\nThis C++ code should behave the same way as the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram is_bored_program\n    implicit none\n    character(len=100) :: S\n    integer :: result\n\n    ! Test cases\n    call assert(is_bored("Hello world") == 0)\n    call assert(is_bored("Is the sky blue?") == 0)\n    call assert(is_bored("I love It !") == 1)\n    call assert(is_bored("bIt") == 0)\n    call assert(is_bored("I feel good today. I will be productive. will kill It") == 2)\n    call assert(is_bored("You and I are going for a walk") == 0)\n\ncontains\n\n    function is_bored(S) result(sum)\n        implicit none\n        character(len=*), intent(in) :: S\n        integer :: sum\n        logical :: isstart, isi\n        integer :: i, lenS\n\n        isstart = .true.\n        isi = .false.\n        sum = 0\n        lenS = len_trim(S)\n\n        do i = 1, lenS\n            if (S(i:i) == ' ' .and. isi) then\n                isi = .false.\n                sum = sum + 1\n            end if\n            if (S(i:i) == 'I' .and. isstart) then\n                isi = .true.\n            else\n                isi = .false.\n            end if\n            if (S(i:i) /= ' ') then\n                isstart = .false.\n            end if\n            if (S(i:i) == '.' .or. S(i:i) == '?' .or. S(i:i) == '!') then\n                isstart = .true.\n            end if\n        end do\n    end function is_bored\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program is_bored_program\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint is_bored(const std::string& S) {\n    int sum = 0;\n    bool isstart = true;\n    bool isi = false;\n    int lenS = S.length();\n\n    for (int i = 0; i < lenS; ++i) {\n        if (S[i] == ' ' && isi) {\n            isi = false;\n            sum++;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = true;\n        } else {\n            isi = false;\n        }\n        if (S[i] != ' ') {\n            isstart = false;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = true;\n        }\n    }\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(is_bored("Hello world") == 0);\n    assert(is_bored("Is the sky blue?") == 0);\n    assert(is_bored("I love It !") == 1);\n    assert(is_bored("bIt") == 0);\n    assert(is_bored("I feel good today. I will be productive. will kill It") == 2);\n    assert(is_bored("You and I are going for a walk") == 0);\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Fortran Unit Test Code**: This code includes the `is_bored` function and a `assert` subroutine to check the correctness of the function. It contains test cases that call the `assert` subroutine with the results of the `is_bored` function.\n2. **C++ Unit Test Code**: This code includes the `is_bored` function and a `assert` function to check the correctness of the function. It contains test cases that call the `assert` function with the results of the `is_bored` function.\n\nTo compile and run the Fortran code, you can use a Fortran compiler like `gfortran`:\n```sh\ngfortran -o is_bored_test is_bored_program.f90\n./is_bored_test\n```\n\nTo compile and run the C++ code, you can use a C++ compiler like `g++`:\n```sh\ng++ -o is_bored_test is_bored_program.cpp\n./is_bored_test\n```\n\nThese unit tests will verify that the translation from Fortran to C++ is correct by ensuring that both implementations produce the same results for the given test cases.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool any_int(double a, double b, double c) {\n    if (std::round(a) != a || std::round(b) != b || std::round(c) != c) {\n        return false;\n    }\n    if (a + b == c || a + c == b || b + c == a) {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    bool result;\n\n    result = any_int(2.0, 3.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 3, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.5, 2.0, 3.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.5, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(1.5, 5.0, 3.5);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(1.5, 5, 3.5) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0, 6.0, 2.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2, 6, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(4.0, 2.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(4, 2, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.2, 2.2, 2.2);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.2, 2.2, 2.2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(-4.0, 6.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(-4, 6, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0, 1.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 1, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.0, 4.0, 7.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(3, 4, 7) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.01, 4.0, 7.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(3.01, 4, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the same logic and tests as the original Fortran code. It defines a function `any_int` that takes three double-precision floating-point numbers as arguments and returns a boolean value indicating whether the function's conditions are met. The `main` function contains assertions similar to the Fortran program, checking the function's output against expected results and printing error messages if the assertions fail.
Translating the given Fortran code to C++ involves several steps, including changing the syntax for loops, arrays, and functions. Here's how the Fortran code could be translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint largestPrime(const std::vector<int>& lst) {\n    int largest = 0;\n    for (int i : lst) {\n        if (i > largest && isPrime(i)) {\n            largest = i;\n        }\n    }\n    return largest;\n}\n\nint sumDigits(int n) {\n    std::string s = std::to_string(n);\n    int sum = 0;\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nint skjkasdkd(const std::vector<int>& lst) {\n    int largest = largestPrime(lst);\n    return sumDigits(largest);\n}\n\nint main() {\n    std::vector<int> testCases[] = {\n        {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3},\n        {1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1},\n        {1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3},\n        {0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6},\n        {0, 81, 12, 3, 1, 21},\n        {0, 8, 1, 2, 1, 7},\n        {8191},\n        {8191, 123456, 127, 7},\n        {127, 97, 8192}\n    };\n\n    bool allTestsPassed = true;\n    for (const auto& testCase : testCases) {\n        int result = skjkasdkd(testCase);\n        if (result != 10) {\n            std::cerr << "Assertion failed: result /= 10" << std::endl;\n            allTestsPassed = false;\n        }\n    }\n\n    if (allTestsPassed) {\n        std::cout << "All tests passed." << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function Definitions:**\n   - `isPrime` checks if a number is prime.\n   - `largestPrime` finds the largest prime number in a list.\n   - `sumDigits` sums the digits of an integer.\n   - `skjkasdkd` is the main function that uses the above functions to find the sum of the digits of the largest prime number in a list.\n\n2. **Main Function:**\n   - The `main` function contains several test cases that call `skjkasdkd` with different lists of integers.\n   - It checks if the returned result matches the expected values and prints an error message if any test fails.\n\nThis C++ code should perform the same operations as the original Fortran code and pass the same set of tests.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule skjkasdkd_module\n    implicit none\ncontains\n    function skjkasdkd(lst) result(sum)\n        implicit none\n        integer, dimension(:), intent(in) :: lst\n        integer :: sum\n        integer :: largest, i, j\n        logical :: prime\n        character(len=20) :: s\n        integer :: digit\n\n        largest = 0\n        do i = 1, size(lst)\n            if (lst(i) > largest) then\n                prime = .true.\n                do j = 2, int(sqrt(real(lst(i))))\n                    if (mod(lst(i), j) == 0) then\n                        prime = .false.\n                        exit\n                    end if\n                end do\n                if (prime) largest = lst(i)\n            end if\n        end do\n\n        sum = 0\n        write(s, '(I0)') largest\n        do i = 1, len_trim(s)\n            read(s(i:i), '(I1)') digit\n            sum = sum + digit\n        end do\n    end function skjkasdkd\nend module skjkasdkd_module\n\nprogram main\n    use skjkasdkd_module\n    implicit none\n    integer :: result\n\n    result = skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3])\n    if (result /= 10) then\n        write(*,*) "Assertion failed: result /= 10"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1])\n    if (result /= 25) then\n        write(*,*) "Assertion failed: result /= 25"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3])\n    if (result /= 13) then\n        write(*,*) "Assertion failed: result /= 13"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6])\n    if (result /= 11) then\n        write(*,*) "Assertion failed: result /= 11"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([0,81,12,3,1,21])\n    if (result /= 3) then\n        write(*,*) "Assertion failed: result /= 3"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([0,8,1,2,1,7])\n    if (result /= 7) then\n        write(*,*) "Assertion failed: result /= 7"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([8191])\n    if (result /= 19) then\n        write(*,*) "Assertion failed: result /= 19"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([8191, 123456, 127, 7])\n    if (result /= 19) then\n        write(*,*) "Assertion failed: result /= 19"\n        call exit(1)\n    end if\n\n    result = skjkasdkd([127, 97, 8192])\n    if (result
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same assertions and functionality as the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint multiply(int a, int b);\n\nint main() {\n    int result;\n\n    // Assertions\n    result = multiply(148, 412);\n    if (result != 16) {\n        std::cerr << "Assertion failed: multiply(148, 412) == 16" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(19, 28);\n    if (result != 72) {\n        std::cerr << "Assertion failed: multiply(19, 28) == 72" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(2020, 1851);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(2020, 1851) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(14, -15);\n    if (result != 20) {\n        std::cerr << "Assertion failed: multiply(14, -15) == 20" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(76, 67);\n    if (result != 42) {\n        std::cerr << "Assertion failed: multiply(76, 67) == 42" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(17, 27);\n    if (result != 49) {\n        std::cerr << "Assertion failed: multiply(17, 27) == 49" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(0, 1);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(0, 1) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(0, 0);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(0, 0) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint multiply(int a, int b) {\n    return (a % 10) * (b % 10);\n}\n```\n\nThis C++ code includes the same assertions as the original Fortran code and uses the `std::cerr` for error output and `std::exit(1)` to terminate the program if an assertion fails, similar to the `write(*,*)` and `call exit(1)` in Fortran. The `multiply` function is defined similarly in both languages, ensuring the same logic is applied to the multiplication operation.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These unit tests will verify the correctness of the `multiply` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_multiply\n    implicit none\n\n    integer :: result\n\n    ! Test cases for the multiply function\n    result = multiply(148, 412)\n    if (result /= 16) then\n        write(*,*) "Test failed: multiply(148, 412) == 16"\n    else\n        write(*,*) "Test passed: multiply(148, 412) == 16"\n    end if\n\n    result = multiply(19, 28)\n    if (result /= 72) then\n        write(*,*) "Test failed: multiply(19, 28) == 72"\n    else\n        write(*,*) "Test passed: multiply(19, 28) == 72"\n    end if\n\n    result = multiply(2020, 1851)\n    if (result /= 0) then\n        write(*,*) "Test failed: multiply(2020, 1851) == 0"\n    else\n        write(*,*) "Test passed: multiply(2020, 1851) == 0"\n    end if\n\n    result = multiply(14, -15)\n    if (result /= 20) then\n        write(*,*) "Test failed: multiply(14, -15) == 20"\n    else\n        write(*,*) "Test passed: multiply(14, -15) == 20"\n    end if\n\n    result = multiply(76, 67)\n    if (result /= 42) then\n        write(*,*) "Test failed: multiply(76, 67) == 42"\n    else\n        write(*,*) "Test passed: multiply(76, 67) == 42"\n    end if\n\n    result = multiply(17, 27)\n    if (result /= 49) then\n        write(*,*) "Test failed: multiply(17, 27) == 49"\n    else\n        write(*,*) "Test passed: multiply(17, 27) == 49"\n    end if\n\n    result = multiply(0, 1)\n    if (result /= 0) then\n        write(*,*) "Test failed: multiply(0, 1) == 0"\n    else\n        write(*,*) "Test passed: multiply(0, 1) == 0"\n    end if\n\n    result = multiply(0, 0)\n    if (result /= 0) then\n        write(*,*) "Test failed: multiply(0, 0) == 0"\n    else\n        write(*,*) "Test passed: multiply(0, 0) == 0"\n    end if\n\ncontains\n\n    integer function multiply(a, b)\n        integer, intent(in) :: a, b\n        multiply = mod(abs(a), 10) * mod(abs(b), 10)\n    end function multiply\n\nend program test_multiply\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint multiply(int a, int b);\n\nint main() {\n    int result;\n\n    // Test cases for the multiply function\n    result = multiply(148, 412);\n    if (result != 16) {\n        std::cerr << "Test failed: multiply(148, 412) == 16" << std::endl;\n    } else {\n        std::cout << "Test passed: multiply(148, 412) == 16" << std::endl;\n    }\n\n    result = multiply(19, 28);\n    if (result != 72) {\n        std::cerr << "Test failed: multiply(19, 28) == 72" << std::endl;\n    } else {\n        std::cout << "Test passed: multiply(19, 28) == 72" << std::endl;\n    }\n\n    result = multiply(2020, 1851);\n    if (result != 0) {\n        std::cerr << "Test failed: multiply(2020, 1851) == 0" << std::endl;\n    } else {\n        std::cout << "Test passed: multiply(2020, 1851) == 0" << std::endl;\n    }\n\n    result = multiply(14, -15);\n    if (result != 20) {\n        std::cerr << "Test failed: multiply(14, -15) == 20" << std::endl;\n    } else {\n        std::cout << "Test passed: multiply(14, -15) == 20" << std::endl;\n    }\n\n    result = multiply(76, 67);\n    if (result != 42) {\n        std::cerr
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function prototype\nint count_upper(const std::string& s);\n\nint main() {\n    int result;\n\n    // Test cases\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_upper('aBCdEf') == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('abcdefg') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("dBBE");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('dBBE') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("B");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('B') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("U");\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_upper('U') == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("EEEE");\n    if (result != 2) {\n        std::cerr << "Assertion failed: count_upper('EEEE') == 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nint count_upper(const std::string& s) {\n    const std::string uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = s.length();\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (uvowel.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n\nThis C++ code includes the `count_upper` function, which is equivalent to the Fortran function, and a `main` function that tests this function with various inputs, similar to the Fortran program. The `std::string` class is used to handle strings, and the `std::cerr` and `std::exit` functions are used for error handling and exiting the program, respectively, similar to the Fortran `write` and `exit` statements.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `count_upper` function in both languages.\n\n### Fortran Unit Test Code\n\nTo compile and run the Fortran code, you can use a Fortran compiler like `gfortran`. Here is the unit test code:\n\n```fortran\nprogram test_count_upper\n    implicit none\n    integer :: result\n\n    ! Test cases\n    result = count_upper("aBCdEf")\n    if (result /= 1) then\n        write(*,*) "Test failed: count_upper('aBCdEf') == 1"\n    else\n        write(*,*) "Test passed: count_upper('aBCdEf') == 1"\n    end if\n\n    result = count_upper("abcdefg")\n    if (result /= 0) then\n        write(*,*) "Test failed: count_upper('abcdefg') == 0"\n    else\n        write(*,*) "Test passed: count_upper('abcdefg') == 0"\n    end if\n\n    result = count_upper("dBBE")\n    if (result /= 0) then\n        write(*,*) "Test failed: count_upper('dBBE') == 0"\n    else\n        write(*,*) "Test passed: count_upper('dBBE') == 0"\n    end if\n\n    result = count_upper("B")\n    if (result /= 0) then\n        write(*,*) "Test failed: count_upper('B') == 0"\n    else\n        write(*,*) "Test passed: count_upper('B') == 0"\n    end if\n\n    result = count_upper("U")\n    if (result /= 1) then\n        write(*,*) "Test failed: count_upper('U') == 1"\n    else\n        write(*,*) "Test passed: count_upper('U') == 1"\n    end if\n\n    result = count_upper("")\n    if (result /= 0) then\n        write(*,*) "Test failed: count_upper('') == 0"\n    else\n        write(*,*) "Test passed: count_upper('') == 0"\n    end if\n\n    result = count_upper("EEEE")\n    if (result /= 2) then\n        write(*,*) "Test failed: count_upper('EEEE') == 2"\n    else\n        write(*,*) "Test passed: count_upper('EEEE') == 2"\n    end if\n\ncontains\n\n    function count_upper(s) result(count)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: count\n        character(len=5) :: uvowel\n        integer :: i, len_s\n\n        uvowel = "AEIOU"\n        count = 0\n        len_s = len_trim(s)\n\n        do i = 1, len_s, 2\n            if (index(uvowel, s(i:i)) > 0) then\n                count = count + 1\n            end if\n        end do\n    end function count_upper\n\nend program test_count_upper\n```\n\n### C++ Unit Test Code\n\nTo compile and run the C++ code, you can use a C++ compiler like `g++`. Here is the unit test code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\n// Function prototype\nint count_upper(const std::string& s);\n\nint main() {\n    // Test cases\n    assert(count_upper("aBCdEf") == 1);\n    std::cout << "Test passed: count_upper('aBCdEf') == 1" << std::endl;\n\n    assert(count_upper("abcdefg") == 0);\n    std::cout << "Test passed: count_upper('abcdefg') == 0" << std::endl;\n\n    assert(count_upper("dBBE") == 0);\n    std::cout << "Test passed: count_upper('dBBE') == 0" << std::endl;\n\n    assert(count_upper("B") == 0);\n    std::cout << "Test passed: count_upper('B') == 0" << std::endl;\n\n    assert(count_upper("U") == 1);\n    std::cout << "Test passed: count_upper('U') == 1" << std::endl;\n\n    assert(count_upper("") == 0);\n    std::cout << "Test passed: count_upper('') == 0" << std::endl;\n\n    assert(count_upper("EEEE") == 2);\n    std::cout << "Test passed: count_upper('EEEE') == 2" << std::endl;\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nint count_upper(const std::string& s) {\n    const std::string uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = s.length();\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (uvowel.find(s[i]) != std::string::npos)
Certainly! Here's the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n#include <cmath> // For round()\n#include <string>\n\n// Function to find the closest integer to a given floating-point number\nint closest_integer(const std::string& value) {\n    double w;\n    // Assuming the value is a floating-point number represented as a string\n    std::stringstream(value) >> w;\n    return std::round(w);\n}\n\n// Subroutine to assert conditions\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Main program body\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `closest_integer`:**\n   - Takes a `std::string` as input.\n   - Uses a `std::stringstream` to convert the string to a `double`.\n   - Returns the closest integer to the given floating-point number using `std::round`.\n\n2. **Subroutine `assert`:**\n   - Takes a boolean condition and a message string.\n   - Prints the message if the condition is false, then exits the program with an error code using `std::exit(1)`.\n\n3. **Main function:**\n   - Contains assertions similar to the Fortran version.\n   - Calls the `assert` function with the expected conditions and messages.\n\nThis C++ code should behave similarly to the Fortran code, performing the same checks and exiting with an error if any assertion fails.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n\n    ! Main program body\n    call assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10")\n    call assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15")\n    call assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16")\n    call assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15")\n    call assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0")\n\ncontains\n\n    integer function closest_integer(value)\n        character(len=*), intent(in) :: value\n        real :: w\n        read(value, *) w\n        closest_integer = nint(w)\n    end function closest_integer\n\n    subroutine assert(condition, message)\n        logical, intent(in) :: condition\n        character(len=*), intent(in) :: message\n        if (.not. condition) then\n            write(*,*) message\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n#include <cmath> // For round()\n#include <string>\n#include <sstream> // For string conversion\n\n// Function to find the closest integer to a given floating-point number\nint closest_integer(const std::string& value) {\n    double w;\n    // Assuming the value is a floating-point number represented as a string\n    std::stringstream(value) >> w;\n    return std::round(w);\n}\n\n// Subroutine to assert conditions\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Main program body\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code:**\n   - The main program `test_main` contains assertions similar to the original Fortran code.\n   - The `closest_integer` function and `assert` subroutine are defined within the same program.\n\n2. **C++ Unit Test Code:**\n   - The main function contains assertions similar to the translated C++ code.\n   - The `closest_integer` function and `assert` function are defined in the same file.\n\n### Running the Tests:\n\nTo run the Fortran unit test, you can use a Fortran compiler like `gfortran`:\n\n```sh\ngfortran -o test_fortran test_main.f90\n./test_fortran\n```\n\nTo run the C++ unit test, you can use a C++ compiler like `g++`:\n\n```sh\ng++ -o test_cpp test_main.cpp\n./test_cpp\n```\n\nBoth programs should pass the assertions without any errors if the translation is correct.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid make_a_pile(int n, std::vector<int>& out) {\n    out.resize(n);\n    out[0] = n;\n    for (int i = 1; i < n; ++i) {\n        out[i] = out[i - 1] + 2;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> pile;\n    int n;\n\n    make_a_pile(3, pile);\n    assert(issame(pile, {3, 5, 7}));\n\n    make_a_pile(4, pile);\n    assert(issame(pile, {4, 6, 8, 10}));\n\n    make_a_pile(5, pile);\n    assert(issame(pile, {5, 7, 9, 11, 13}));\n\n    make_a_pile(6, pile);\n    assert(issame(pile, {6, 8, 10, 12, 14, 16}));\n\n    make_a_pile(8, pile);\n    assert(issame(pile, {8, 10, 12, 14, 16, 18, 20, 22}));\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Functions and Variables**:\n   - The `make_a_pile` function creates a pile of numbers based on the input `n`.\n   - The `issame` function checks if two vectors are equal.\n   - The `assert` function is used to assert the condition.\n\n2. **Main Function**:\n   - The `main` function calls `make_a_pile` with different values of `n` and uses `assert` to verify the correctness.\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: pile(:)\n    integer :: n\n\n    ! Test case 1\n    call make_a_pile(3, pile)\n    call assert(issame(pile, [3, 5, 7]))\n\n    ! Test case 2\n    call make_a_pile(4, pile)\n    call assert(issame(pile, [4, 6, 8, 10]))\n\n    ! Test case 3\n    call make_a_pile(5, pile)\n    call assert(issame(pile, [5, 7, 9, 11, 13]))\n\n    ! Test case 4\n    call make_a_pile(6, pile)\n    call assert(issame(pile, [6, 8, 10, 12, 14, 16]))\n\n    ! Test case 5\n    call make_a_pile(8, pile)\n    call assert(issame(pile, [8, 10, 12, 14, 16, 18, 20, 22]))\n\ncontains\n\n    subroutine make_a_pile(n, out)\n        integer, intent(in) :: n\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i\n\n        allocate(out(n))\n        out(1) = n\n        do i = 2, n\n            out(i) = out(i-1) + 2\n        end do\n    end subroutine make_a_pile\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid make_a_pile(int n, std::vector<int>& out) {\n    out.resize(n);\n    out[0] = n;\n    for (int i = 1; i < n; ++i) {\n        out[i] = out[i - 1] + 2;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> pile;\n    int n;\n\n    // Test case 1\n    make_a_pile(3, pile);\n    assert(issame(pile, {3, 5, 7}));\n\n    // Test case 2\n    make_a_pile(4, pile);\n    assert(issame(pile, {4, 6, 8, 10}));\n\n    // Test case 3\n    make_a_pile(5, pile);\n    assert(issame(pile, {5, 7, 9, 11, 13}));\n\n    // Test case 4\n    make_a_pile(6, pile);\n    assert(issame(pile, {6, 8, 10, 12, 14, 16}));\n\n    // Test case 5\n    make_a_pile(8, pile);\n    assert(issame(pile, {8, 10, 12, 14, 16, 18, 20, 22}));\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code**:\n   - The `test_main` program calls the `make_a_pile` subroutine with different values of `n` and checks the output using the `assert` subroutine.\n   - The `make_a_pile` subroutine creates a pile of numbers based on the input `n`.\n   - The `issame` function checks if two arrays are equal.\n   - The `assert` subroutine is used to assert the condition.\n\n2. **C++ Unit Test Code**:\n   - The `main` function calls the `make_a_pile` function with different values of `n` and checks the output using the `assert` function.\n   - The `make_a_pile` function creates a pile of numbers based on the input `n
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint choose_num(int x, int y);\n\nint main() {\n    int result;\n\n    result = choose_num(12, 15);\n    if (result != 14) {\n        std::cerr << "Assertion failed: choose_num(12, 15) == 14" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(13, 12);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(13, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        std::cerr << "Assertion failed: choose_num(33, 12354) == 12354" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(5234, 5233);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(5234, 5233) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(6, 29);\n    if (result != 28) {\n        std::cerr << "Assertion failed: choose_num(6, 29) == 28" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(27, 10);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(27, 10) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(7, 7);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(7, 7) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(546, 546);\n    if (result != 546) {\n        std::cerr << "Assertion failed: choose_num(546, 546) == 546" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nint choose_num(int x, int y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && x % 2 == 1) {\n        return -1;\n    } else if (x % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n```\n\nThis C++ code includes the main function and the `choose_num` function, which mimics the functionality of the Fortran code. The `main` function contains assertions to verify the correctness of the `choose_num` function with various inputs. If any assertion fails, it prints an error message and exits with a status code of 1.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `choose_num` function with various inputs.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_choose_num\n    implicit none\n\n    integer :: result\n\n    ! Test 1\n    result = choose_num(12, 15)\n    if (result /= 14) then\n        write(*,*) "Test 1 failed: choose_num(12, 15) == 14"\n    else\n        write(*,*) "Test 1 passed"\n    end if\n\n    ! Test 2\n    result = choose_num(13, 12)\n    if (result /= -1) then\n        write(*,*) "Test 2 failed: choose_num(13, 12) == -1"\n    else\n        write(*,*) "Test 2 passed"\n    end if\n\n    ! Test 3\n    result = choose_num(33, 12354)\n    if (result /= 12354) then\n        write(*,*) "Test 3 failed: choose_num(33, 12354) == 12354"\n    else\n        write(*,*) "Test 3 passed"\n    end if\n\n    ! Test 4\n    result = choose_num(5234, 5233)\n    if (result /= -1) then\n        write(*,*) "Test 4 failed: choose_num(5234, 5233) == -1"\n    else\n        write(*,*) "Test 4 passed"\n    end if\n\n    ! Test 5\n    result = choose_num(6, 29)\n    if (result /= 28) then\n        write(*,*) "Test 5 failed: choose_num(6, 29) == 28"\n    else\n        write(*,*) "Test 5 passed"\n    end if\n\n    ! Test 6\n    result = choose_num(27, 10)\n    if (result /= -1) then\n        write(*,*) "Test 6 failed: choose_num(27, 10) == -1"\n    else\n        write(*,*) "Test 6 passed"\n    end if\n\n    ! Test 7\n    result = choose_num(7, 7)\n    if (result /= -1) then\n        write(*,*) "Test 7 failed: choose_num(7, 7) == -1"\n    else\n        write(*,*) "Test 7 passed"\n    end if\n\n    ! Test 8\n    result = choose_num(546, 546)\n    if (result /= 546) then\n        write(*,*) "Test 8 failed: choose_num(546, 546) == 546"\n    else\n        write(*,*) "Test 8 passed"\n    end if\n\ncontains\n\n    integer function choose_num(x, y)\n        implicit none\n        integer, intent(in) :: x, y\n\n        if (y < x) then\n            choose_num = -1\n        else if (y == x .and. mod(y, 2) == 1) then\n            choose_num = -1\n        else if (mod(y, 2) == 1) then\n            choose_num = y - 1\n        else\n            choose_num = y\n        end if\n    end function choose_num\n\nend program test_choose_num\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint choose_num(int x, int y);\n\nint main() {\n    int result;\n\n    // Test 1\n    result = choose_num(12, 15);\n    if (result != 14) {\n        std::cerr << "Test 1 failed: choose_num(12, 15) == 14" << std::endl;\n    } else {\n        std::cout << "Test 1 passed" << std::endl;\n    }\n\n    // Test 2\n    result = choose_num(13, 12);\n    if (result != -1) {\n        std::cerr << "Test 2 failed: choose_num(13, 12) == -1" << std::endl;\n    } else {\n        std::cout << "Test 2 passed" << std::endl;\n    }\n\n    // Test 3\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        std::cerr << "Test 3 failed: choose_num(33, 12354) == 12354" << std::endl;\n    } else {\n        std::cout << "
Translating the provided Fortran code to C++ involves several steps, including adapting the module and subroutine structure to a class and methods structure, converting Fortran intrinsic functions and I/O operations to their C++ equivalents, and handling dynamic memory allocation for the output string. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nclass Utils {\npublic:\n    static std::string rounded_avg(int n, int m) {\n        if (n > m) {\n            return "-1";\n        }\n\n        int num = (m + n) / 2;\n        std::string temp_out = "";\n        while (num > 0) {\n            int remainder = num % 2;\n            temp_out = std::string(1, static_cast<char>(remainder + '0')) + temp_out;\n            num = num / 2;\n        }\n\n        if (temp_out.empty()) {\n            temp_out = "0";\n        }\n\n        return temp_out;\n    }\n\n    static void assert(bool condition, const std::string& message) {\n        if (!condition) {\n            std::cerr << message << std::endl;\n            exit(1);\n        }\n    }\n};\n\nint main() {\n    // Main program\n    Utils::assert(Utils::rounded_avg(1, 5) == "11", "Assertion failed: rounded_avg(1, 5) == '11'");\n    Utils::assert(Utils::rounded_avg(7, 13) == "1010", "Assertion failed: rounded_avg(7, 13) == '1010'");\n    Utils::assert(Utils::rounded_avg(964, 977) == "1111001010", "Assertion failed: rounded_avg(964, 977) == '1111001010'");\n    Utils::assert(Utils::rounded_avg(996, 997) == "1111100100", "Assertion failed: rounded_avg(996, 997) == '1111100100'");\n    Utils::assert(Utils::rounded_avg(560, 851) == "1011000001", "Assertion failed: rounded_avg(560, 851) == '1011000001'");\n    Utils::assert(Utils::rounded_avg(185, 546) == "101101101", "Assertion failed: rounded_avg(185, 546) == '101101101'");\n    Utils::assert(Utils::rounded_avg(362, 496) == "110101101", "Assertion failed: rounded_avg(362, 496) == '110101101'");\n    Utils::assert(Utils::rounded_avg(350, 902) == "1001110010", "Assertion failed: rounded_avg(350, 902) == '1001110010'");\n    Utils::assert(Utils::rounded_avg(197, 233) == "11010111", "Assertion failed: rounded_avg(197, 233) == '11010111'");\n    Utils::assert(Utils::rounded_avg(7, 5) == "-1", "Assertion failed: rounded_avg(7, 5) == '-1'");\n    Utils::assert(Utils::rounded_avg(5, 1) == "-1", "Assertion failed: rounded_avg(5, 1) == '-1'");\n    Utils::assert(Utils::rounded_avg(5, 5) == "101", "Assertion failed: rounded_avg(5, 5) == '101'");\n\n    return 0;\n}\n```\n\nKey Points in the Translation:\n- The Fortran module `utils` is translated into a C++ class `Utils`.\n- The Fortran function `rounded_avg` and subroutine `assert` are translated into static member functions of the `Utils` class.\n- The Fortran `character(len=:), allocatable` type is translated to `std::string` in C++, which automatically manages memory and can be dynamically resized.\n- The Fortran `write` statement used for converting an integer to a string is replaced with a simple cast to `char` and concatenation with the `temp_out` string.\n- The `exit` function in Fortran is replaced with `std::exit` in C++.\n- The main program logic remains largely unchanged, but is now encapsulated within the `main` function of the C++ program.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can write unit tests. These tests will call the `rounded_avg` function with various inputs and check if the outputs match the expected results.\n\n### Fortran Unit Tests\n\nFor Fortran, we can use a simple approach to test the function by adding test cases directly in the program. Fortran doesn't have a built-in unit testing framework like some other languages, so we'll manually check the results.\n\n```fortran\n! Add this inside the program rounded_avg_program\nsubroutine test_rounded_avg()\n    implicit none\n    character(len=32) :: result\n\n    ! Test case 1\n    result = rounded_avg(1, 5)\n    call assert(result == "11", "Test case 1 failed")\n\n    ! Add more test cases as needed...\n\n    print *, "All tests passed."\nend subroutine test_rounded_avg\n\n! Call the test subroutine at the end of the program\ncall test_rounded_avg()\n```\n\n### C++ Unit Tests\n\nFor C++, we can use a testing framework like Google Test for more comprehensive and automated testing. However, for simplicity, I'll show a basic approach similar to the Fortran example.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Include the Utils class definition here\n\nvoid test_rounded_avg(const std::string& test_case, int n, int m, const std::string& expected) {\n    std::string result = Utils::rounded_avg(n, m);\n    Utils::assert(result == expected, "Test case " + test_case + " failed: Expected " + expected + ", got " + result);\n}\n\nint main() {\n    // Test case 1\n    test_rounded_avg("1", 1, 5, "11");\n\n    // Add more test cases as needed...\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\n### Running the Tests\n\n- **For Fortran**: Compile the Fortran program with a Fortran compiler (e.g., `gfortran`) and run the executable. If all tests pass, it will print "All tests passed."\n\n  ```bash\n  gfortran -o rounded_avg_test rounded_avg_program.f90\n  ./rounded_avg_test\n  ```\n\n- **For C++**: Compile the C++ program with a C++ compiler (e.g., `g++`) and run the executable. If all tests pass, it will print "All tests passed."\n\n  ```bash\n  g++ -o rounded_avg_test rounded_avg_program.cpp\n  ./rounded_avg_test\n  ```\n\nThese tests will help ensure that the `rounded_avg` function behaves as expected in both the original Fortran code and the translated C++ code.
Translating the provided Fortran code to C++ involves several steps, including adapting the module and subroutine structure to a class with methods, handling dynamic arrays with vectors, and converting Fortran-specific features to their C++ equivalents. Here's how the code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Utils {\npublic:\n    struct NumToType {\n        int key;\n        std::string value;\n\n        NumToType(int key, const std::string& value) : key(key), value(value) {}\n    };\n\n    static void sort_array(std::vector<int>& arr) {\n        std::sort(arr.begin(), arr.end());\n    }\n\n    static std::vector<std::string> by_length(const std::vector<int>& arr) {\n        std::vector<std::string> out;\n        std::vector<NumToType> numto = {\n            NumToType(0, "Zero"), NumToType(1, "One"), NumToType(2, "Two"),\n            NumToType(3, "Three"), NumToType(4, "Four"), NumToType(5, "Five"),\n            NumToType(6, "Six"), NumToType(7, "Seven"), NumToType(8, "Eight"),\n            NumToType(9, "Nine")\n        };\n\n        sort_array(const_cast<std::vector<int>&>(arr));\n\n        for (int i = arr.size() - 1; i >= 0; --i) {\n            if (arr[i] >= 1 && arr[i] <= 9) {\n                out.push_back(numto[arr[i]].value);\n            }\n        }\n\n        return out;\n    }\n\n    static bool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n        if (a.size() != b.size()) {\n            return false;\n        }\n\n        for (size_t i = 0; i < a.size(); ++i) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    std::vector<int> arr = {2, 1, 1, 4, 5, 8, 2, 3};\n    std::vector<std::string> result = Utils::by_length(arr);\n    std::vector<std::string> expected1 = {"Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"};\n\n    if (!Utils::issame(result, expected1)) {\n        std::cerr << "Test 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr.clear();\n    result = Utils::by_length(arr);\n    std::vector<std::string> expected2 = {"One"};\n\n    if (!Utils::issame(result, expected2)) {\n        std::cerr << "Test 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {1, -1, 55};\n    result = Utils::by_length(arr);\n\n    if (!Utils::issame(result, expected2)) {\n        std::cerr << "Test 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {1, -1, 3, 2};\n    result = Utils::by_length(arr);\n    std::vector<std::string> expected3 = {"Three", "Two", "One"};\n\n    if (!Utils::issame(result, expected3)) {\n        std::cerr << "Test 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {9, 4, 8};\n    result = Utils::by_length(arr);\n    std::vector<std::string> expected4 = {"Nine", "Eight", "Four"};\n\n    if (!Utils::issame(result, expected4)) {\n        std::cerr << "Test 5: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nKey Points:\n- The `Utils` class encapsulates the functionality of the Fortran module.\n- The `NumToType` struct is used to represent the `numto_type` derived type.\n- The `sort_array` method sorts the input vector using `std::sort`.\n- The `by_length` method converts numbers to their string representations and sorts them according to the original Fortran logic.\n- The `issame` method checks if two vectors of strings are equal.\n- The `main` function contains unit tests similar to the Fortran program.\n\nThis C++ code should provide similar functionality to the original Fortran code, with adjustments for C++ syntax and conventions.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `by_length` and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n  implicit none\n  type :: numto_type\n    integer :: key\n    character(len=10) :: value\n  end type numto_type\ncontains\n  subroutine sort_array(arr, n)\n    integer, intent(inout) :: arr(:)\n    integer, intent(in) :: n\n    integer :: i, j, temp\n    do i = 1, n-1\n      do j = i+1, n\n        if (arr(i) > arr(j)) then\n          temp = arr(i)\n          arr(i) = arr(j)\n          arr(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort_array\n\n  function by_length(arr, n) result(out)\n    integer, intent(inout) :: arr(:)\n    integer, intent(in) :: n\n    character(len=10), allocatable :: out(:)\n    type(numto_type), dimension(10) :: numto\n    integer :: i, count\n\n    numto = (/ numto_type(0, "Zero"), numto_type(1, "One"), numto_type(2, "Two"), &\n               numto_type(3, "Three"), numto_type(4, "Four"), numto_type(5, "Five"), &\n               numto_type(6, "Six"), numto_type(7, "Seven"), numto_type(8, "Eight"), &\n               numto_type(9, "Nine") /)\n\n    call sort_array(arr, n)\n\n    count = 0\n    do i = n, 1, -1\n      if (arr(i) >= 1 .and. arr(i) <= 9) then\n        count = count + 1\n      end if\n    end do\n\n    allocate(out(count))\n    count = 0\n    do i = n, 1, -1\n      if (arr(i) >= 1 .and. arr(i) <= 9) then\n        count = count + 1\n        out(count) = numto(arr(i) + 1)%value\n      end if\n    end do\n  end function by_length\n\n  logical function issame(a, b, n, m)\n    character(len=10), intent(in) :: a(:)\n    character(len=10), intent(in) :: b(:)\n    integer, intent(in) :: n, m\n    integer :: i\n\n    if (n /= m) then\n      issame = .false.\n      return\n    end if\n\n    do i = 1, n\n      if (a(i) /= b(i)) then\n        issame = .false.\n        return\n      end if\n    end do\n\n    issame = .true.\n  end function issame\nend module utils\n\nprogram test\n  use utils\n  implicit none\n  character(len=10), allocatable :: result(:)\n  character(len=10), dimension(8) :: expected1\n  character(
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses standard library features to achieve similar functionality.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to compute the values as in the Fortran code\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0;\n    int prod = 1;\n\n    for (int i = 0; i < n; ++i) {\n        sum += i + 1;\n        prod *= (i + 1);\n        if (i % 2 == 0) {\n            out[i] = prod;\n        } else {\n            out[i] = sum;\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    std::vector<int> expected3 = {1};\n    std::vector<int> expected4 = {1, 2, 6};\n\n    auto result = f(5);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for f(5)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(7);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for f(7)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(1);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for f(1)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(3);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for f(3)" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines the `f` function and the `issame` function to perform the same operations as the Fortran code. The `main` function contains assertions to verify the correctness of the `f` function against expected outcomes. If any assertion fails, the program will print an error message and exit with a non-zero status. If all assertions pass, it will print "All tests passed".\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These unit tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\n    contains\n\n    function f(n) result(out)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: out\n        integer :: i, sum, prod\n\n        allocate(out(n))\n        sum = 0\n        prod = 1\n\n        do i = 1, n\n            sum = sum + i\n            prod = prod * i\n            if (mod(i, 2) == 0) then\n                out(i) = prod\n            else\n                out(i) = sum\n            end if\n        end do\n    end function f\n\n    logical function issame(a, b)\n        implicit none\n        integer, dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    integer, dimension(:), allocatable :: result\n    integer, dimension(5) :: expected1 = [1, 2, 6, 24, 15]\n    integer, dimension(7) :: expected2 = [1, 2, 6, 24, 15, 720, 28]\n    integer, dimension(1) :: expected3 = [1]\n    integer, dimension(3) :: expected4 = [1, 2, 6]\n\n    result = f(5)\n    if (.not. issame(result, expected1)) then\n        write(*,*) "Assertion failed for f(5)"\n        call exit(1)\n    end if\n\n    result = f(7)\n    if (.not. issame(result, expected2)) then\n        write(*,*) "Assertion failed for f(7)"\n        call exit(1)\n    end if\n\n    result = f(1)\n    if (.not. issame(result, expected3)) then\n        write(*,*) "Assertion failed for f(1)"\n        call exit(1)\n    end if\n\n    result = f(3)\n    if (.not. issame(result, expected4)) then\n        write(*,*) "Assertion failed for f(3)"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed"\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to compute the values as in the Fortran code\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0;\n    int prod = 1;\n\n    for (int i = 0; i < n; ++i) {\n        sum += i + 1;\n        prod *= (i + 1);\n        if (i % 2 == 0) {\n            out[i] = prod;\n        } else {\n            out[i] = sum;\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    std::vector<int> expected3 = {1};\n    std::vector<int> expected4 = {1, 2, 6};\n\n    auto result = f(5);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for f(5)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(7);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for f(7)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(1);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for f(1)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(3);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for f(
Translating the given Fortran code to C++ involves several steps, including adapting the syntax, converting the functions, and handling array operations. Here's how the Fortran code can be translated to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> result(2, 0);\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string w = std::to_string(i);\n        std::string p = w;\n        std::reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    result[0] = num2;\n    result[1] = num1;\n    return result;\n}\n\nvoid test_even_odd_palindrome(int n, const std::vector<int>& expected) {\n    std::vector<int> result = even_odd_palindrome(n);\n    if (result != expected) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_even_odd_palindrome(123, {8, 13});\n    test_even_odd_palindrome(12, {4, 6});\n    test_even_odd_palindrome(3, {1, 2});\n    test_even_odd_palindrome(63, {6, 8});\n    test_even_odd_palindrome(25, {5, 6});\n    test_even_odd_palindrome(19, {4, 6});\n    test_even_odd_palindrome(9, {4, 5});\n    test_even_odd_palindrome(1, {0, 1});\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function Conversion**:\n   - The `even_odd_palindrome` function is converted to a C++ function that returns a `std::vector<int>`.\n   - The `reverse_string` function is not needed in C++ as the `std::reverse` algorithm from the `<algorithm>` header can be used to reverse a string.\n\n2. **Array Handling**:\n   - Fortran arrays are converted to `std::vector<int>` in C++ for dynamic sizing and ease of use.\n\n3. **String Handling**:\n   - The Fortran `write` statement for converting integers to strings is replaced with `std::to_string` in C++.\n   - String reversal is handled using `std::reverse`.\n\n4. **Testing**:\n   - The `test_even_odd_palindrome` function is implemented to compare the result of `even_odd_palindrome` with an expected vector.\n\n5. **Main Function**:\n   - The main function in C++ calls `test_even_odd_palindrome` with various test cases.\n\nThis C++ code should provide equivalent functionality to the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, dimension(2) :: result\n    integer :: n\n\n    ! Test cases\n    call test_even_odd_palindrome(123, [8, 13])\n    call test_even_odd_palindrome(12, [4, 6])\n    call test_even_odd_palindrome(3, [1, 2])\n    call test_even_odd_palindrome(63, [6, 8])\n    call test_even_odd_palindrome(25, [5, 6])\n    call test_even_odd_palindrome(19, [4, 6])\n    call test_even_odd_palindrome(9, [4, 5])\n    call test_even_odd_palindrome(1, [0, 1])\n\ncontains\n\n    subroutine test_even_odd_palindrome(n, expected)\n        integer, intent(in) :: n\n        integer, dimension(2), intent(in) :: expected\n        integer, dimension(2) :: result\n\n        result = even_odd_palindrome(n)\n        if (.not. issame(result, expected)) then\n            write(*,*) "Assertion failed for n =", n\n            call exit(1)\n        end if\n    end subroutine test_even_odd_palindrome\n\n    function even_odd_palindrome(n) result(res)\n        integer, intent(in) :: n\n        integer, dimension(2) :: res\n        integer :: i, num1, num2\n        character(len=20) :: w, p\n\n        num1 = 0\n        num2 = 0\n        do i = 1, n\n            write(w, '(I0)') i\n            p = reverse_string(trim(w))\n            if (trim(w) == trim(p)) then\n                if (mod(i, 2) == 1) then\n                    num1 = num1 + 1\n                else\n                    num2 = num2 + 1\n                end if\n            end if\n        end do\n        res = [num2, num1]\n    end function even_odd_palindrome\n\n    function reverse_string(s) result(rev)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: rev\n        integer :: i, len_s\n\n        len_s = len_trim(s)\n        do i = 1, len_s\n            rev(i:i) = s(len_s-i+1:len_s-i+1)\n        end do\n        rev(len_s+1:) = ' '  ! Pad the rest with spaces\n    end function reverse_string\n\n    logical function issame(a, b)\n        integer, dimension(2), intent(in) :: a, b\n        integer :: i\n\n        issame = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n    end function issame\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> result(2, 0);\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string w = std::to_string(i);\n        std::string p = w;\n        std::reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    result[0] = num2;\n    result[1] = num1;\n    return result;\n}\n\nvoid test_even_odd_palindrome(int n, const std::vector<int>& expected) {\n    std::vector<int> result = even_odd_palindrome(n);\n    if (result != expected) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_even_odd_palindrome(123, {8, 13});\n    test_even_odd_palindrome(12, {4, 6});\n    test_even_odd_palindrome(3, {1, 2});\n    test_even_odd_palindrome(63, {6, 8});\n    test_even_odd_palindrome(25, {5, 6});
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same functionality and the same set of tests to verify the correctness of the `count_nums` function.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nint count_nums(const std::vector<int>& n) {\n    int num = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        if (n[i] > 0) {\n            ++num;\n        } else {\n            int sum = 0;\n            int w = std::abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w /= 10;\n            }\n            sum -= w;\n            if (sum > 0) ++num;\n        }\n    }\n    return num;\n}\n\nint main() {\n    std::vector<int> test_case_1 = {0};\n    if (count_nums(test_case_1) != 0) {\n        std::cerr << "Assertion failed: count_nums({0}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_2 = {-1, -2, 0};\n    if (count_nums(test_case_2) != 0) {\n        std::cerr << "Assertion failed: count_nums({-1, -2, 0}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_3 = {1, 1, 2, -2, 3, 4, 5};\n    if (count_nums(test_case_3) != 6) {\n        std::cerr << "Assertion failed: count_nums({1, 1, 2, -2, 3, 4, 5}) == 6" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_4 = {1, 6, 9, -6, 0, 1, 5};\n    if (count_nums(test_case_4) != 5) {\n        std::cerr << "Assertion failed: count_nums({1, 6, 9, -6, 0, 1, 5}) == 5" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_5 = {1, 100, 98, -7, 1, -1};\n    if (count_nums(test_case_5) != 4) {\n        std::cerr << "Assertion failed: count_nums({1, 100, 98, -7, 1, -1}) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_6 = {12, 23, 34, -45, -56, 0};\n    if (count_nums(test_case_6) != 5) {\n        std::cerr << "Assertion failed: count_nums({12, 23, 34, -45, -56, 0}) == 5" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_7 = {-0, 1};\n    if (count_nums(test_case_7) != 1) {\n        std::cerr << "Assertion failed: count_nums({-0, 1}) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_8 = {1};\n    if (count_nums(test_case_8) != 1) {\n        std::cerr << "Assertion failed: count_nums({1}) == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a function `count_nums` that takes a vector of integers as input and returns the number of positive numbers and the number of numbers that have a sum of positive digits (excluding leading zeros) when negated. The `main` function contains a series of tests to verify the correctness of `count_nums` against various input vectors.
Translating the provided Fortran code to C++ involves several steps, including adapting the module and program structure, converting Fortran intrinsic functions and control structures to their C++ equivalents, and handling array allocation and deallocation. Here's how the Fortran code can be translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool move_one_ball(const std::vector<int>& arr) {\n    int num = 0;\n    if (arr.size() == 0) {\n        return true;\n    }\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            num++;\n        }\n    }\n\n    if (arr.back() > arr[0]) {\n        num++;\n    }\n\n    return num < 2;\n}\n\nint main() {\n    std::vector<int> arr;\n    bool result;\n\n    // Test cases\n    arr = {3, 4, 5, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {3, 5, 10, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {4, 3, 1, 2};\n    result = move_one_ball(arr);\n    if (result) {\n        std::cerr << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {3, 5, 4, 1, 2};\n    result = move_one_ball(arr);\n    if (result) {\n        std::cerr << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {}; // Empty vector\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {}" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nKey Points in the Translation:\n\n1. **Module and Program Structure**: Fortran modules are translated to C++ functions or classes. The `main` program is the `main` function in C++.\n\n2. **Array Handling**: Fortran's array handling is replaced with `std::vector<int>` in C++ for dynamic array functionality.\n\n3. **Looping and Conditionals**: Fortran's `do` loop and `if` statements are replaced with C++ `for` loop and `if` statements.\n\n4. **Logical Function**: The Fortran logical function `move_one_ball` is translated to a C++ function returning `bool`.\n\n5. **Error Handling**: Fortran's `write` and `exit` are replaced with `std::cerr` for error output and `std::exit` for terminating the program with an error code.\n\n6. **Array Allocation and Deallocation**: In C++, `std::vector` handles memory allocation and deallocation automatically.\n\nThis translation maintains the logic and structure of the original Fortran code while adapting it to C++ conventions and idioms.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `move_one_ball` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule ball_module\n  implicit none\ncontains\n  logical function move_one_ball(arr)\n    implicit none\n    integer, dimension(:), intent(in) :: arr\n    integer :: i, num\n\n    num = 0\n    if (size(arr) == 0) then\n      move_one_ball = .true.\n      return\n    end if\n\n    do i = 2, size(arr)\n      if (arr(i) < arr(i-1)) num = num + 1\n    end do\n\n    if (arr(size(arr)) > arr(1)) num = num + 1\n\n    if (num < 2) then\n      move_one_ball = .true.\n    else\n      move_one_ball = .false.\n    end if\n  end function move_one_ball\nend module ball_module\n\nprogram main\n  use ball_module\n  implicit none\n  integer, dimension(:), allocatable :: arr\n  logical :: result\n\n  ! Test cases\n  allocate(arr(5))\n  arr = [3, 4, 5, 1, 2]\n  result = move_one_ball(arr)\n  if (.not. result) then\n    write(*,*) "Assertion failed for {3, 4, 5, 1, 2}"\n    call exit(1)\n  end if\n\n  deallocate(arr)\n  allocate(arr(5))\n  arr = [3, 5, 10, 1, 2]\n  result = move_one_ball(arr)\n  if (.not. result) then\n    write(*,*) "Assertion failed for {3, 5, 10, 1, 2}"\n    call exit(1)\n  end if\n\n  deallocate(arr)\n  allocate(arr(4))\n  arr = [4, 3, 1, 2]\n  result = move_one_ball(arr)\n  if (result) then\n    write(*,*) "Assertion failed for {4, 3, 1, 2}"\n    call exit(1)\n  end if\n\n  deallocate(arr)\n  allocate(arr(5))\n  arr = [3, 5, 4, 1, 2]\n  result = move_one_ball(arr)\n  if (result) then\n    write(*,*) "Assertion failed for {3, 5, 4, 1, 2}"\n    call exit(1)\n  end if\n\n  deallocate(arr)\n  allocate(arr(0))\n  result = move_one_ball(arr)\n  if (.not. result) then\n    write(*,*) "Assertion failed for {}"\n    call exit(1)\n  end if\n\n  write(*,*) "All tests passed."\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool move_one_ball(const std::vector<int>& arr) {\n    int num = 0;\n    if (arr.size() == 0) {\n        return true;\n    }\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            num++;\n        }\n    }\n\n    if (arr.back() > arr[0]) {\n        num++;\n    }\n\n    return num < 2;\n}\n\nint main() {\n    std::vector<int> arr;\n    bool result;\n\n    // Test cases\n    arr = {3, 4, 5, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {3, 5, 10, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {4, 3, 1, 
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the necessary headers and uses standard I/O streams for output.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::string exchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int num = 0;\n    for (int i : lst1) {\n        if (i % 2 == 0) num++;\n    }\n    for (int i : lst2) {\n        if (i % 2 == 0) num++;\n    }\n\n    return (num >= lst1.size()) ? "YES" : "NO";\n}\n\nint main() {\n    std::vector<int> lst1 = {1, 2, 3, 4};\n    std::vector<int> lst2 = {1, 2, 3, 4};\n    std::string result;\n\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {1, 5, 3, 4};\n    result = exchange(lst1, lst2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {2, 1, 4, 3};\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 4};\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 3};\n    result = exchange(lst1, lst2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 3}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {3, 2, 6, 1, 8, 9};\n    lst2 = {3, 5, 5, 1, 1, 1};\n    result = exchange(lst1, lst2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {100, 200};\n    lst2 = {200, 200};\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({100, 200}, {200, 200}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a function `exchange` that takes two vectors of integers as input and returns a string indicating whether the exchange is possible based on the criteria described in the Fortran code. The `main` function contains a series of tests to verify the correctness of the `exchange` function. If any test fails, it prints an error message and exits with a non-zero status.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_fortran.f90`:\n\n```fortran\nprogram test_main\n    implicit none\n    character(len=3) :: result\n\n    ! Test 1\n    result = exchange([1, 2, 3, 4], [1, 2, 3, 4])\n    if (result /= 'YES') then\n        write(*,*) "Test 1 failed: exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == 'YES'"\n        call exit(1)\n    end if\n\n    ! Test 2\n    result = exchange([1, 2, 3, 4], [1, 5, 3, 4])\n    if (result /= 'NO') then\n        write(*,*) "Test 2 failed: exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == 'NO'"\n        call exit(1)\n    end if\n\n    ! Test 3\n    result = exchange([1, 2, 3, 4], [2, 1, 4, 3])\n    if (result /= 'YES') then\n        write(*,*) "Test 3 failed: exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == 'YES'"\n        call exit(1)\n    end if\n\n    ! Test 4\n    result = exchange([5, 7, 3], [2, 6, 4])\n    if (result /= 'YES') then\n        write(*,*) "Test 4 failed: exchange({5, 7, 3}, {2, 6, 4}) == 'YES'"\n        call exit(1)\n    end if\n\n    ! Test 5\n    result = exchange([5, 7, 3], [2, 6, 3])\n    if (result /= 'NO') then\n        write(*,*) "Test 5 failed: exchange({5, 7, 3}, {2, 6, 3}) == 'NO'"\n        call exit(1)\n    end if\n\n    ! Test 6\n    result = exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1])\n    if (result /= 'NO') then\n        write(*,*) "Test 6 failed: exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == 'NO'"\n        call exit(1)\n    end if\n\n    ! Test 7\n    result = exchange([100, 200], [200, 200])\n    if (result /= 'YES') then\n        write(*,*) "Test 7 failed: exchange({100, 200}, {200, 200}) == 'YES'"\n        call exit(1)\n    end if\n\n    write(*,*) "All Fortran tests passed."\n\ncontains\n\n    function exchange(lst1, lst2) result(res)\n        implicit none\n        integer, dimension(:), intent(in) :: lst1, lst2\n        character(len=3) :: res\n        integer :: num, i\n\n        num = 0\n        do i = 1, size(lst1)\n            if (mod(lst1(i), 2) == 0) num = num + 1\n        end do\n        do i = 1, size(lst2)\n            if (mod(lst2(i), 2) == 0) num = num +
Translating the given Fortran code to C++ involves several steps, including handling dynamic arrays, string manipulation, and converting Fortran-specific constructs to their C++ equivalents. Below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid odd_count(const std::vector<std::string>& lst, std::vector<std::string>& out) {\n    std::string s = "the number of odd elements in the string i of the input.";\n    out.resize(lst.size());\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int sum = 0;\n        for (char c : lst[i]) {\n            if (c >= '0' && c <= '9') {\n                if (c % 2 == 1) sum++;\n            }\n        }\n\n        std::string s2;\n        size_t pos = 0;\n        for (char c : s) {\n            if (c == 'i') {\n                std::string temp = std::to_string(sum);\n                s2 += temp;\n                pos += temp.size();\n            } else {\n                s2 += c;\n                pos++;\n            }\n        }\n        out[i] = s2;\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid print_results(const std::vector<std::string>& output, const std::vector<std::string>& expected) {\n    std::cout << "Actual Output:" << std::endl;\n    for (const auto& str : output) {\n        std::cout << str << std::endl;\n    }\n\n    std::cout << "Expected Output:" << std::endl;\n    for (const auto& str : expected) {\n        std::cout << str << std::endl;\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> input = {"1234567"};\n    std::vector<std::string> expected = {"the number of odd elements in the string 4 of the input."};\n    std::vector<std::string> output;\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 2\n    input = {"3", "11111111"};\n    expected = {"the number of odd elements in the string 1 of the input.",\n                "the number of odd elements in the string 8 of the input."};\n    output.clear();\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 3\n    input = {"271", "137", "314"};\n    expected = {"the number of odd elements in the string 2 of the input.",\n                "the number of odd elements in the string 3 of the input.",\n                "the number of odd elements in the string 2 of the input."};\n    output.clear();\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Dynamic Arrays**: In C++, `std::vector` is used to handle dynamic arrays.\n2. **String Manipulation**: The `std::string` class is used for string manipulation.\n3. **Function Translation**: The `odd_count` subroutine is translated into a function that modifies its output parameter.\n4. **Loop Constructs**: Fortran's `do` loop is replaced with C++'s `for` loop.\n5. **Character Handling**: The ASCII value of characters is used to check for odd numbers.\n6. **Assertion**: The `assert` function checks if the output matches the expected output.\n7. **Test Cases**: The main function contains test cases that verify the correctness of the `odd_count` function.\n\nThis C++ code should behave similarly to the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    character(len=100), dimension(:), allocatable :: input, output, expected\n\n    ! Test case 1\n    allocate(input(1))\n    input(1) = '1234567'\n    allocate(expected(1))\n    expected(1) = 'the number of odd elements in the string 4 of the input.'\n    call odd_count(input, output)\n    call assert(issame(output, expected))\n    deallocate(input, output, expected)\n\n    ! Test case 2\n    allocate(input(2))\n    input(1) = '3'\n    input(2) = '11111111'\n    allocate(expected(2))\n    expected(1) = 'the number of odd elements in the string 1 of the input.'\n    expected(2) = 'the number of odd elements in the string 8 of the input.'\n    call odd_count(input, output)\n    call assert(issame(output, expected))\n    deallocate(input, output, expected)\n\n    ! Test case 3\n    allocate(input(3))\n    input(1) = '271'\n    input(2) = '137'\n    input(3) = '314'\n    allocate(expected(3))\n    expected(1) = 'the number of odd elements in the string 2 of the input.'\n    expected(2) = 'the number of odd elements in the string 3 of the input.'\n    expected(3) = 'the number of odd elements in the string 2 of the input.'\n    call odd_count(input, output)\n    call assert(issame(output, expected))\n    deallocate(input, output, expected)\n\ncontains\n\n    subroutine odd_count(lst, out)\n        character(len=100), dimension(:), intent(in) :: lst\n        character(len=100), dimension(:), allocatable :: out\n        character(len=100) :: s, s2, temp\n        integer :: i, j, sum, pos\n\n        if (allocated(out)) deallocate(out)\n        allocate(out(size(lst)))\n        s = 'the number of odd elements in the string i of the input.'\n\n        do i = 1, size(lst)\n            sum = 0\n            do j = 1, len_trim(lst(i))\n                if (iachar(lst(i)(j:j)) >= 48 .and. iachar(lst(i)(j:j)) <= 57) then\n                    if (mod(iachar(lst(i)(j:j)), 2) == 1) sum = sum + 1\n                end if\n            end do\n\n            s2 = ''\n            pos = 1\n            do j = 1, len_trim(s)\n                if (s(j:j) == 'i') then\n                    write(temp, '(I0)') sum\n                    s2(pos:pos+len_trim(temp)-1) = temp\n                    pos = pos + len_trim(temp)\n                else\n                    s2(pos:pos) = s(j:j)\n                    pos = pos + 1\n                end if\n            end do\n            out(i) = s2\n        end do\n    end subroutine odd_count\n\n    logical function issame(a, b)\n        character(len=100), dimension(:), intent(in) :: a, b\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if
Translating the provided Fortran code to C++ involves several steps, including changing the syntax for loops, array handling, and function definitions. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nstd::vector<int> sort_array(const std::vector<int>& arr) {\n    std::vector<int> sorted_arr(arr.size());\n    std::vector<int> bin(arr.size());\n\n    // Copy input array to sorted_arr\n    sorted_arr = arr;\n\n    // Calculate the number of 1s in the binary representation of each element\n    for (size_t i = 0; i < arr.size(); ++i) {\n        int b = 0;\n        int n = std::abs(arr[i]);\n        while (n > 0) {\n            b += n % 2;\n            n /= 2;\n        }\n        bin[i] = b;\n    }\n\n    // Sort the array based on the bin values and the original values\n    for (size_t i = 0; i < arr.size(); ++i) {\n        for (size_t j = 1; j < arr.size(); ++j) {\n            if (bin[j] < bin[j - 1] || (bin[j] == bin[j - 1] && sorted_arr[j] < sorted_arr[j - 1])) {\n                std::swap(sorted_arr[j], sorted_arr[j - 1]);\n                std::swap(bin[j], bin[j - 1]);\n            }\n        }\n    }\n\n    return sorted_arr;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_case(const std::vector<int>& arr, const std::vector<int>& expected) {\n    std::vector<int> sorted_arr = sort_array(arr);\n    if (!issame(sorted_arr, expected)) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    // Test cases\n    test_case({1, 5, 2, 3, 4}, {1, 2, 4, 3, 5});\n    test_case({-2, -3, -4, -5, -6}, {-4, -2, -6, -5, -3});\n    test_case({1, 0, 2, 3, 4}, {0, 1, 2, 4, 3});\n    test_case({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}, {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77});\n    test_case({3, 6, 44, 12, 32, 5}, {32, 3, 5, 6, 12, 44});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Key Differences and Considerations:\n\n1. **Array Handling**: C++ uses `std::vector` for dynamic arrays, which is more flexible and safer compared to raw arrays.\n2. **Looping**: The `for` loop syntax in C++ is different from Fortran. The loop variables are declared within the `for` statement.\n3. **Binary Representation**: The binary representation calculation is similar, but C++ uses different operators and functions (`%` for modulus, `/` for division).\n4. **Sorting**: The sorting logic is preserved, but the syntax for swapping elements is different (`std::swap`).\n5. **Testing**: The `test_case` function in C++ checks if the sorted array matches the expected array and reports an error if they do not match.\n6. **Program Structure**: The `main` function in C++ serves as the entry point, similar to the `program` block in Fortran. The `run_tests` function contains the test cases.\n\nThis C++ code should compile and run similarly to the provided Fortran code, ensuring the same functionality and output.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `sort_array` function and the `issame` function.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n\n    call run_tests()\n\ncontains\n\n    function sort_array(arr) result(sorted_arr)\n        integer, dimension(:), intent(in) :: arr\n        integer, dimension(:), allocatable :: sorted_arr\n        integer, dimension(:), allocatable :: bin\n        integer :: i, j, n, b, m\n\n        allocate(sorted_arr(size(arr)))\n        allocate(bin(size(arr)))\n\n        ! Copy input array to sorted_arr\n        sorted_arr = arr\n\n        ! Calculate the number of 1s in the binary representation of each element\n        do i = 1, size(arr)\n            b = 0\n            n = abs(arr(i))\n            do while (n > 0)\n                b = b + mod(n, 2)\n                n = n / 2\n            end do\n            bin(i) = b\n        end do\n\n        ! Sort the array based on the bin values and the original values\n        do i = 1, size(arr)\n            do j = 2, size(arr)\n                if (bin(j) < bin(j-1) .or. (bin(j) == bin(j-1) .and. sorted_arr(j) < sorted_arr(j-1))) then\n                    m = sorted_arr(j)\n                    sorted_arr(j) = sorted_arr(j-1)\n                    sorted_arr(j-1) = m\n                    m = bin(j)\n                    bin(j) = bin(j-1)\n                    bin(j-1) = m\n                end if\n            end do\n        end do\n    end function sort_array\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\n    subroutine test_case(arr, expected)\n        integer, dimension(:), intent(in) :: arr, expected\n        integer, dimension(:), allocatable :: sorted_arr\n\n        sorted_arr = sort_array(arr)\n        if (.not. issame(sorted_arr, expected)) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine test_case\n\n    subroutine run_tests()\n        ! Test cases\n        call test_case([1, 5, 2, 3, 4], [1, 2, 4, 3, 5])\n        call test_case([-2, -3, -4, -5, -6], [-4, -2, -6, -5, -3])\n        call test_case([1, 0, 2, 3, 4], [0, 1, 2, 4, 3])\n       
To translate the provided Fortran code to C++, we need to consider several differences between the two languages, such as string handling, function definitions, and the way arrays and loops are handled. Here's a C++ version of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string get_closest_vowel(const std::string& word) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n\n    for (int i = word.length() - 1; i >= 2; --i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (vowels.find(word[i + 1]) == std::string::npos && vowels.find(word[i - 1]) == std::string::npos) {\n                result = word.substr(i, 1);\n                return result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(get_closest_vowel("yogurt") == "u");\n    assert(get_closest_vowel("full") == "u");\n    assert(get_closest_vowel("easy") == "");\n    assert(get_closest_vowel("eAsy") == "");\n    assert(get_closest_vowel("ali") == "");\n    assert(get_closest_vowel("bad") == "a");\n    assert(get_closest_vowel("most") == "o");\n    assert(get_closest_vowel("ab") == "");\n    assert(get_closest_vowel("ba") == "");\n    assert(get_closest_vowel("quick") == "");\n    assert(get_closest_vowel("anime") == "i");\n    assert(get_closest_vowel("Asia") == "");\n    assert(get_closest_vowel("Above") == "o");\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\nKey Points of the Translation:\n\n1. **String Handling**: C++ uses `std::string` for string operations, which simplifies many operations compared to Fortran's character handling.\n\n2. **Function Definition**: The function `get_closest_vowel` is defined to take a `const std::string&` as its parameter, which is a reference to a constant string, to avoid unnecessary copying of the string object. The return type is `std::string`.\n\n3. **Looping and Conditionals**: The loop structure and conditional checks are adapted to C++ syntax. The `std::string::find` method is used to check if a character is present in the `vowels` string, and the `std::string::substr` method is used to extract the character at the current index.\n\n4. **Error Handling**: The `assert` function is implemented to print an error message and exit the program if the condition is false, similar to the Fortran version.\n\n5. **Test Cases**: The test cases are directly translated into assertions within the `main` function. The `assert` function is used to verify the correctness of the `get_closest_vowel` function.\n\nThis C++ code should behave similarly to the original Fortran code, providing the same functionality and passing the same test cases.\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can create unit tests that cover the specified test cases. Below are the unit test codes for both languages.\n\n### Fortran Unit Test Code\n\nTo compile and run this Fortran code, you might need a Fortran compiler like `gfortran`. Save the code in a file named `test_fortran.f90` and compile it using a command like `gfortran -o test_fortran test_fortran.f90`.\n\n```fortran\nprogram test_main\n    implicit none\n    character(len=100) :: word\n    character(len=1) :: result\n    character(len=10) :: vowels\n    integer :: i\n\n    vowels = "AEIOUaeiou"\n\n    ! Test cases\n    call assert(get_closest_vowel("yogurt") == "u")\n    call assert(get_closest_vowel("full") == "u")\n    call assert(get_closest_vowel("easy") == "")\n    call assert(get_closest_vowel("eAsy") == "")\n    call assert(get_closest_vowel("ali") == "")\n    call assert(get_closest_vowel("bad") == "a")\n    call assert(get_closest_vowel("most") == "o")\n    call assert(get_closest_vowel("ab") == "")\n    call assert(get_closest_vowel("ba") == "")\n    call assert(get_closest_vowel("quick") == "")\n    call assert(get_closest_vowel("anime") == "i")\n    call assert(get_closest_vowel("Asia") == "")\n    call assert(get_closest_vowel("Above") == "o")\n\ncontains\n\n    function get_closest_vowel(word) result(out)\n        character(len=*), intent(in) :: word\n        character(len=1) :: out\n        character(len=10) :: vowels\n        integer :: i\n\n        vowels = "AEIOUaeiou"\n        out = ""\n\n        do i = len(word)-1, 2, -1\n            if (index(vowels, word(i:i)) /= 0) then\n                if (index(vowels, word(i+1:i+1)) == 0 .and. index(vowels, word(i-1:i-1)) == 0) then\n                    out = word(i:i)\n                    return\n                end if\n            end if\n        end do\n    end function get_closest_vowel\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\nTo compile and run this C++ code, you might need a C++ compiler like `g++`. Save the code in a file named `test_cpp.cpp` and compile it using a command like `g++ -o test_cpp test_cpp.cpp`.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string get_closest_vowel(const std::string& word) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n\n    for (int i = word.length() - 1; i >= 2; --i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (vowels.find(word[i + 1]) == std::string::npos && vowels.find(word[i - 1]) == std::string::npos) {\n                result = word.substr(i, 1);\n                return result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(get_closest_vowel("yogurt") == "u");\n    assert(get_closest_vowel("full") == "u");\n    assert(get_closest_vowel("easy") == "");\n    assert(get_closest_vowel("eAsy") == "");\n    assert(get_closest_vowel("ali") == "");\n    assert(get_closest_vowel("bad") == "a");\n    assert(get_closest_vowel("most") == "o");\n   
Translating the provided Fortran code to C++ involves several steps, including changing array handling, subroutine and function definitions, and the way assertions are handled. Here's a C++ version of the code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid bubble_sort(std::vector<int>& arr) {\n    int temp;\n    for (int i = 0; i < arr.size() - 1; ++i) {\n        for (int j = 0; j < arr.size() - i - 1; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nstd::vector<int> maximum(const std::vector<int>& arr, int k) {\n    std::vector<int> sorted_arr = arr;\n    bubble_sort(sorted_arr);\n    return std::vector<int>(sorted_arr.rbegin(), sorted_arr.rbegin() + k);\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(issame(maximum({-3, -4, 5}, 3), {-4, -3, 5}));\n    assert(issame(maximum({4, -4, 4}, 2), {4, 4}));\n    assert(issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1), {2}));\n    assert(issame(maximum({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123}));\n    assert(issame(maximum({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20}));\n    assert(issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15}));\n    assert(issame(maximum({-1, 0, 2, 5, 3, -10}, 2), {3, 5}));\n    assert(issame(maximum({1, 0, 5, -7}, 1), {5}));\n    assert(issame(maximum({4, -4}, 2), {-4, 4}));\n    assert(issame(maximum({-10, 10}, 2), {-10, 10}));\n    // Handle the empty array case separately\n    assert(issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0), {}));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Key Differences and Considerations:\n\n1. **Array Handling**: C++ uses `std::vector<int>` for dynamic arrays, which is more flexible and safer compared to raw arrays.\n2. **Sorting**: The `bubble_sort` function uses nested loops to compare and swap elements, similar to the Fortran version.\n3. **Maximum Function**: The `maximum` function sorts the array and returns the last `k` elements in reverse order.\n4. **Assertions**: The `assert` function checks a condition and prints an error message if the condition is false, then exits the program.\n5. **Testing**: The `run_tests` function contains several assertions to verify the correctness of the `maximum` and `bubble_sort` functions.\n6. **Empty Array Case**: The C++ version handles the empty array case by returning an empty vector, which matches the Fortran behavior.\n\nThis C++ code should behave similarly to the provided Fortran code, ensuring the same functionality and correctness through the unit tests.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `bubble_sort`, `maximum`, and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, dimension(:), allocatable :: expected\n\n    call run_tests()\n\ncontains\n\n    subroutine bubble_sort(arr)\n        integer, dimension(:), intent(inout) :: arr\n        integer :: i, j, temp\n        do i = 1, size(arr) - 1\n            do j = 1, size(arr) - i\n                if (arr(j) > arr(j + 1)) then\n                    temp = arr(j)\n                    arr(j) = arr(j + 1)\n                    arr(j + 1) = temp\n                end if\n            end do\n        end do\n    end subroutine bubble_sort\n\n    function maximum(arr, k) result(out)\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: k\n        integer, dimension(:), allocatable :: out\n        integer, dimension(:), allocatable :: sorted_arr\n        integer :: n\n\n        n = size(arr)\n        allocate(sorted_arr(n))\n        sorted_arr = arr\n        call bubble_sort(sorted_arr)\n        allocate(out(k))\n        out = sorted_arr(n-k+1:n)\n    end function maximum\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\n    subroutine run_tests()\n        integer, dimension(:), allocatable :: expected\n\n        call assert(issame(maximum([-3, -4, 5], 3), [-4, -3, 5]))\n        call assert(issame(maximum([4, -4, 4], 2), [4, 4]))\n        call assert(issame(maximum([-3, 2, 1, 2, -1, -2, 1], 1), [2]))\n        call assert(issame(maximum([123, -123, 20, 0, 1, 2, -3], 3), [2, 20, 123]))\n        call assert(issame(maximum([-123, 20, 0, 1, 2, -3], 4), [0, 1, 2, 20]))\n        call assert(issame(maximum([5, 15, 0, 3, -13, -8, 0], 7), [-13, -8, 0, 0, 3, 5, 15]))\n        call assert(issame(maximum([-1, 0, 2, 5, 3, -10], 2), [3, 5]))\n        call assert(issame(maximum([1, 0, 
Certainly! Below is the equivalent C++ code for the provided Fortran program. This C++ code includes the necessary function to handle the array and perform the calculations as per the Fortran code.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to calculate the sum of odd numbers in the array\nint solutions(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    std::vector<int> test1 = {5, 8, 7, 1};\n    if (solutions(test1) != 12) {\n        std::cerr << "Assertion failed: solutions({5, 8, 7, 1}) == 12" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test2 = {3, 3, 3, 3, 3};\n    if (solutions(test2) != 9) {\n        std::cerr << "Assertion failed: solutions({3, 3, 3, 3, 3}) == 9" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test3 = {30, 13, 24, 321};\n    if (solutions(test3) != 0) {\n        std::cerr << "Assertion failed: solutions({30, 13, 24, 321}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test4 = {5, 9};\n    if (solutions(test4) != 5) {\n        std::cerr << "Assertion failed: solutions({5, 9}) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test5 = {2, 4, 8};\n    if (solutions(test5) != 0) {\n        std::cerr << "Assertion failed: solutions({2, 4, 8}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test6 = {30, 13, 23, 32};\n    if (solutions(test6) != 23) {\n        std::cerr << "Assertion failed: solutions({30, 13, 23, 32}) == 23" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test7 = {3, 13, 2, 9};\n    if (solutions(test7) != 3) {\n        std::cerr << "Assertion failed: solutions({3, 13, 2, 9}) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a `solutions` function that takes a vector of integers as input and returns the sum of the odd numbers in the array, similar to the Fortran version. The `main` function contains several test cases to verify the correctness of the `solutions` function, similar to the Fortran program. If any test case fails, it prints an error message and exits with a non-zero status, indicating a failure.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nnamespace utils {\n    int add_elements(const std::vector<int>& arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; ++i) {\n            if (arr[i] >= -99 && arr[i] <= 99) {\n                sum += arr[i];\n            }\n        }\n        return sum;\n    }\n}\n\nint main() {\n    // Test cases\n    if (utils::add_elements({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3) != -4) {\n        std::cerr << "Assertion failed: result /= -4" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({111, 121, 3, 4000, 5, 6}, 2) != 0) {\n        std::cerr << "Assertion failed: result /= 0" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4) != 125) {\n        std::cerr << "Assertion failed: result /= 125" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4) != 24) {\n        std::cerr << "Assertion failed: result /= 24" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({1}, 1) != 1) {\n        std::cerr << "Assertion failed: result /= 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Namespace `utils`**: This is used to encapsulate the `add_elements` function, similar to how the Fortran module encapsulates the function.\n2. **Function `add_elements`**: This function takes a vector of integers and an integer `k` as input parameters. It iterates through the first `k` elements of the vector and adds them to the sum if they are between -99 and 99 (inclusive).\n3. **Main function**: This contains the test cases that call the `add_elements` function with different inputs and checks if the result matches the expected output. If any test case fails, it prints an error message and returns 1.\n\nThis C++ code should behave similarly to the provided Fortran code and pass all the test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule utils\n    implicit none\ncontains\n    function add_elements(arr, k) result(sum)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: k\n        integer :: sum\n        integer :: i\n\n        sum = 0\n        do i = 1, k\n            if (arr(i) >= -99 .and. arr(i) <= 99) then\n                sum = sum + arr(i)\n            end if\n        end do\n    end function add_elements\nend module utils\n\nprogram main\n    use utils\n    implicit none\n    integer :: result\n\n    ! Test cases\n    result = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3)\n    if (result /= -4) then\n        write(*,*) "Assertion failed: result /= -4"\n        call exit(1)\n    end if\n\n    result = add_elements([111, 121, 3, 4000, 5, 6], 2)\n    if (result /= 0) then\n        write(*,*) "Assertion failed: result /= 0"\n        call exit(1)\n    end if\n\n    result = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4)\n    if (result /= 125) then\n        write(*,*) "Assertion failed: result /= 125"\n        call exit(1)\n    end if\n\n    result = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n    if (result /= 24) then\n        write(*,*) "Assertion failed: result /= 24"\n        call exit(1)\n    end if\n\n    result = add_elements([1], 1)\n    if (result /= 1) then\n        write(*,*) "Assertion failed: result /= 1"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n\nnamespace utils {\n    int add_elements(const std::vector<int>& arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; ++i) {\n            if (arr[i] >= -99 && arr[i] <= 99) {\n                sum += arr[i];\n            }\n        }\n        return sum;\n    }\n}\n\nint main() {\n    // Test cases\n    if (utils::add_elements({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3) != -4) {\n        std::cerr << "Assertion failed: result /= -4" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({111, 121, 3, 4000, 5, 6}, 2) != 0) {\n        std::cerr << "Assertion failed: result /= 0" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4) != 125) {\n        std::cerr << "Assertion failed: result /= 125" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4) != 24) {\n        std::cerr << "Assertion failed: result /= 24" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({1}, 1) != 1) {\n        std::cerr << "Assertion failed: result /= 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code**: This code defines a module `utils` containing the `add_elements` function and a main program that tests this function with various inputs. It prints "All tests passed." if all assertions are successful.\n\n2. **C++ Unit Test Code**: This code defines a namespace `utils` containing the `add_elements` function and a main function that tests this function with the same set of inputs as the Fortran code. It prints "All tests passed." if all assertions are successful.\n\nTo run these tests, you can compile and execute the Fortran code using a Fortran compiler (e.g., `gfortran`) and the C++ code using a C++ compiler (e
To translate the given Fortran code to C++, we need to adapt the Fortran constructs to their C++ equivalents. Here's a C++ version of the code, including the necessary functions and test cases:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to get the Collatz sequence for an odd number\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> out = {1};\n    int temp = n;\n    int count = 1;\n    std::vector<int> temp_array;\n\n    while (temp != 1) {\n        if (temp % 2 == 1) {\n            count++;\n            temp_array.resize(count);\n            std::copy(out.begin(), out.end(), temp_array.begin());\n            temp_array[count - 1] = temp;\n            out = temp_array;\n            temp = temp * 3 + 1;\n        } else {\n            temp = temp / 2;\n        }\n    }\n\n    std::sort(out.begin(), out.end());\n    return out;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine to sort a vector\nvoid sort(std::vector<int>& array) {\n    std::sort(array.begin(), array.end());\n}\n\n// Test function for the odd Collatz sequence\nvoid test_odd_collatz(int n, const std::vector<int>& expected) {\n    std::vector<int> result = get_odd_collatz(n);\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_odd_collatz(14, {1, 5, 7, 11, 13, 17});\n    test_odd_collatz(5, {1, 5});\n    test_odd_collatz(12, {1, 3, 5});\n    test_odd_collatz(1, {1});\n\n    return 0;\n}\n```\n\nThis C++ code includes the necessary functions and test cases to replicate the behavior of the original Fortran code. The `get_odd_collatz` function generates the Collatz sequence for an odd number, `issame` checks if two vectors are equal, and `sort` sorts a vector using the standard library's `std::sort` function. The `test_odd_collatz` function runs the test cases, comparing the generated sequence with the expected results, and exits the program with an error if the test fails.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `get_odd_collatz` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_collatz\n  implicit none\n\n  ! Test cases\n  call test_odd_collatz(14, [1, 5, 7, 11, 13, 17])\n  call test_odd_collatz(5, [1, 5])\n  call test_odd_collatz(12, [1, 3, 5])\n  call test_odd_collatz(1, [1])\n\ncontains\n\n  subroutine test_odd_collatz(n, expected)\n    integer, intent(in) :: n\n    integer, dimension(:), intent(in) :: expected\n    integer, allocatable :: result(:)\n    logical :: is_same\n\n    result = get_odd_collatz(n)\n    is_same = issame(result, expected)\n    if (.not. is_same) then\n      write(*,*) "Assertion failed for n =", n\n      call exit(1)\n    end if\n  end subroutine test_odd_collatz\n\n  function get_odd_collatz(n) result(out)\n    integer, intent(in) :: n\n    integer, allocatable :: out(:)\n    integer :: temp, i, count\n    integer, allocatable :: temp_array(:)\n\n    allocate(out(1))\n    out(1) = 1\n    temp = n\n    count = 1\n\n    do while (temp /= 1)\n      if (mod(temp, 2) == 1) then\n        count = count + 1\n        if (allocated(temp_array)) deallocate(temp_array)\n        allocate(temp_array(count))\n        temp_array(1:count-1) = out\n        temp_array(count) = temp\n        deallocate(out)\n        out = temp_array\n        temp = temp * 3 + 1\n      else\n        temp = temp / 2\n      end if\n    end do\n\n    call sort(out)\n  end function get_odd_collatz\n\n  function issame(a, b) result(is_equal)\n    integer, dimension(:), intent(in) :: a, b\n    logical :: is_equal\n    integer :: i\n\n    if (size(a) /= size(b)) then\n      is_equal = .false.\n      return\n    end if\n\n    is_equal = .true.\n    do i = 1, size(a)\n      if (a(i) /= b(i)) then\n        is_equal = .false.\n        return\n      end if\n    end do\n  end function issame\n\n  subroutine sort(array)\n    integer, dimension(:), intent(inout) :: array\n    integer :: i, j, temp\n\n    do i = 1, size(array) - 1\n      do j = i + 1, size(array)\n        if (array(i) > array(j)) then\n          temp = array(i)\n          array(i) = array(j)\n          array(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort\n\nend program test_collatz\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to get the Collatz sequence for an odd number\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> out = {1};\n    int temp = n;\n    int count = 1;\n    std::vector<int> temp_array;\n\n    while (temp != 1) {\n        if (temp % 2 == 1) {\n            count++;\n            temp_array.resize(count);\n            std::copy(out.begin(), out.end(), temp_array.begin());\n            temp_array[count - 1] = temp;\n            out = temp_array;\n            temp = temp * 3 + 1;\n        } else {\n            temp = temp / 2;\n        }\n    }\n\n    std::sort(out.begin(), out.end());\n    return out;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine to sort a vector\nvoid sort(std::vector<int>& array) {\n    std::sort(array.begin(), array.end());\n}\n\n// Test function for the odd Collatz sequence\nvoid test_odd_collatz(int n, const std::vector<int>& expected) {\n    std::vector<int> result = get_odd_collatz(n);\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n
Translating the given Fortran code to C++ involves several steps, including adapting the syntax, converting the functions, and handling the assertions. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to check if a date is valid\nbool valid_date(const std::string& date);\n\n// Function to pad a string with spaces to make it 10 characters long\nstd::string pad(const std::string& str);\n\n// Assertion function to mimic the Fortran assert\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(valid_date("03-11-2000") == true);\n    assert(valid_date("15-01-2012") == false);\n    assert(valid_date("04-0-2040") == false);\n    assert(valid_date("06-04-2020") == true);\n    assert(valid_date("01-01-2007") == true);\n    assert(valid_date("03-32-2011") == false);\n    assert(valid_date("") == false);\n    assert(valid_date("04-31-3000") == false);\n    assert(valid_date("06-06-2005") == true);\n    assert(valid_date("21-31-2000") == false);\n    assert(valid_date("04-12-2003") == true);\n    assert(valid_date("04122003") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("20030412") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("2003-04") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("2003-04-12") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("04-2003") == false); // Note: This case is not correctly formatted for comparison\n\n    return 0;\n}\n\nbool valid_date(const std::string& date) {\n    if (date.length() != 10) {\n        return false;\n    }\n\n    for (size_t i = 0; i < date.length(); ++i) {\n        if ((i == 2 || i == 5) && date[i] != '-') {\n            return false;\n        } else if (date[i] < '0' || date[i] > '9') {\n            return false;\n        }\n    }\n\n    int mm, dd, yy;\n    std::sscanf(date.substr(0, 2).c_str(), "%d", &mm);\n    std::sscanf(date.substr(3, 2).c_str(), "%d", &dd);\n    std::sscanf(date.substr(6, 4).c_str(), "%d", &yy);\n\n    if (mm < 1 || mm > 12) {\n        return false;\n    }\n\n    if (dd < 1 || dd > 31) {\n        return false;\n    }\n\n    if ((dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11)) || (dd == 30 && mm == 2)) {\n        return false;\n    }\n\n    return true;\n}\n\nstd::string pad(const std::string& str) {\n    std::string padded_str = str;\n    padded_str.append(10 - padded_str.length(), ' ');\n    return padded_str;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n```\n\nThis C++ code includes the necessary headers and defines the functions `valid_date`, `pad`, and `assert` to mimic the behavior of the Fortran code. Note that the `assert` function in C++ is part of the `<cassert>` header, but it's defined here to closely match the Fortran version's behavior. Also, the handling of strings and their manipulation is done using the `std::string` class, which simplifies the operations compared to the Fortran character handling.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `valid_date` function in both languages.\n\n### Fortran Unit Tests\n\nTo compile and run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Here is how you can set up the unit tests:\n\n```fortran\n! valid_date_tests.f90\nprogram valid_date_tests\n    implicit none\n    logical :: result\n\n    ! Test cases\n    result = valid_date("03-11-2000")\n    call assert(result .eqv. .true.)\n\n    result = valid_date("15-01-2012")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("04-0-2040")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("06-04-2020")\n    call assert(result .eqv. .true.)\n\n    result = valid_date("01-01-2007")\n    call assert(result .eqv. .true.)\n\n    result = valid_date("03-32-2011")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("04-31-3000")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("06-06-2005")\n    call assert(result .eqv. .true.)\n\n    result = valid_date("21-31-2000")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("04-12-2003")\n    call assert(result .eqv. .true.)\n\n    result = valid_date("04122003")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("20030412")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("2003-04")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("2003-04-12")\n    call assert(result .eqv. .false.)\n\n    result = valid_date("04-2003")\n    call assert(result .eqv. .false.)\n\ncontains\n\n    logical function valid_date(date)\n        character(len=10), intent(in) :: date\n        integer :: mm, dd, yy\n        integer :: i\n\n        if (len_trim(date) /= 10) then\n            valid_date = .false.\n            return\n        end if\n\n        do i = 1, 10\n            if (i == 3 .or. i == 6) then\n                if (date(i:i) /= '-') then\n                    valid_date = .false.\n                    return\n                end if\n            else\n                if (iachar(date(i:i)) < 48 .or. iachar(date(i:i)) > 57) then\n                    valid_date = .false.\n                    return\n                end if\n            end if\n        end do\n\n        read(date(1:2), '(I2)') mm\n        read(date(4:5), '(I2)') dd\n        read(date(7:10), '(I4)') yy\n\n        if (mm < 1 .or. mm > 12) then\n            valid_date = .false.\n            return\n        end if\n\n        if (dd < 1
Translating the provided Fortran code to C++ involves several steps, including adapting the array handling, the loop constructs, and the subroutine/function definitions to C++ syntax and semantics. Here's how the Fortran code could be translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    std::vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 4, 5, 6};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5, 6, 7};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5, 6, 7};\n    assert(is_sorted(lst) == false);\n\n    lst = {};\n    assert(is_sorted(lst) == true);\n\n    lst = {1};\n    assert(is_sorted(lst) == true);\n\n    lst = {3, 2, 1};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 2, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 3, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 3, 3, 4};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4};\n    assert(is_sorted(lst) == true);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\nKey points in the translation:\n- The `std::vector<int>` is used to handle dynamic arrays in C++, which is a more common and flexible approach compared to raw arrays.\n- The `assert` function in C++ is provided by the `<cassert>` header, but for simplicity and to match the Fortran version's behavior, a custom `assert` function is defined.\n- The `exit(1)` call is used to terminate the program with an error status, similar to the Fortran version.\n- The loop in `is_sorted` has been adapted to C++ syntax, using `size_t` for the index variable to match the size of the vector.\n- The `main` function in C++ serves as the entry point for the program, equivalent to the `program main` in Fortran.\n- The `run_tests` function is a sequence of assertions to validate the `is_sorted` function with various inputs, similar to the Fortran version.\nLet's write some test to verify if the translation is correct. \nBelow are examples of how you could write unit tests for both the Fortran and C++ versions of the code. These tests will verify the correctness of the `is_sorted` function with various inputs.\n\n### Fortran Unit Tests\n\nFor Fortran, you can use a simple testing approach by adding test cases directly in the `run_tests` subroutine. Fortran lacks a built-in unit testing framework, so we'll manually check conditions and print messages accordingly.\n\n```fortran\nprogram test_main\n    implicit none\n    call run_tests()\ncontains\n\n    ! Original functions and subroutines here...\n\n    subroutine run_tests()\n        integer, dimension(:), allocatable :: lst\n\n        ! Test 1\n        if (allocated(lst)) deallocate(lst)\n        allocate(lst(1))\n        lst = [5]\n        call assert(is_sorted(lst) .eqv. .true.)\n\n        ! Add more tests here...\n\n        print *, "All tests passed."\n    end subroutine run_tests\n\nend program test_main\n```\n\n### C++ Unit Tests\n\nFor C++, you can use a unit testing framework like Google Test for more comprehensive and automated testing. Below is an example of how you might set up tests using Google Test.\n\nFirst, ensure you have Google Test installed and set up in your project. Then, create a test file:\n\n```cpp\n#include <gtest/gtest.h>\n#include "your_header_file.h" // Include the header file where is_sorted and assert are declared\n\nTEST(IsSortedTest, HandlesSingleElement) {\n    std::vector<int> lst = {5};\n    EXPECT_TRUE(is_sorted(lst));\n}\n\nTEST(IsSortedTest, HandlesAscendingOrder) {\n    std::vector<int> lst = {1, 2, 3, 4, 5};\n    EXPECT_TRUE(is_sorted(lst));\n}\n\nTEST(IsSortedTest, HandlesDescendingOrder) {\n    std::vector<int> lst = {3, 2, 1};\n    EXPECT_FALSE(is_sorted(lst));\n}\n\n// Add more tests as needed...\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\nThis C++ code snippet assumes you have a basic understanding of how to set up and run Google Test in your project. Each `TEST` macro defines a test case, and `EXPECT_TRUE` or `EXPECT_FALSE` is used to assert whether the `is_sorted` function returns the expected result for the given input.\n\n### Running the Tests\n\n- **Fortran**: Compile and run your Fortran program as usual. If all tests pass, it will print "All tests passed." to the console.\n- **C++ with Google Test**: Compile the test file along with the Google Test library and your implementation file. Running the resulting executable will execute the tests and print the results to the console.\n\nThese tests will help ensure that your `is_sorted` function behaves as expected across both languages.
Translating the provided Fortran code to C++ involves several steps, including changing the syntax for loops, arrays, and function definitions. Here's how the Fortran code could be translated into C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n\nstd::string intersection(const std::pair<int, int>& interval1, const std::pair<int, int>& interval2) {\n    int inter1 = std::max(interval1.first, interval2.first);\n    int inter2 = std::min(interval1.second, interval2.second);\n    int l = inter2 - inter1;\n\n    if (l < 2) {\n        return "NO";\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(l)); ++i) {\n        if (l % i == 0) {\n            return "NO";\n        }\n    }\n\n    return "YES";\n}\n\nint main() {\n    std::pair<int, int> interval1, interval2;\n    std::string result;\n\n    // Test cases\n    interval1 = {1, 2};\n    interval2 = {2, 3};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([1, 2], [2, 3]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-1, 1};\n    interval2 = {0, 4};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([-1, 1], [0, 4]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-3, -1};\n    interval2 = {-5, 5};\n    result = intersection(interval1, interval2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: intersection([-3, -1], [-5, 5]) == 'YES'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-2, 2};\n    interval2 = {-4, 0};\n    result = intersection(interval1, interval2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: intersection([-2, 2], [-4, 0]) == 'YES'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-11, 2};\n    interval2 = {-1, -1};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([-11, 2], [-1, -1]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {1, 2};\n    interval2 = {3, 5};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([1, 2], [3, 5]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {1, 2};\n    interval2 = {1, 2};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([1, 2], [1, 2]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-2, -2};\n    interval2 = {-3, -2};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([-2, -2], [-3, -2]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nKey Points in the Translation:\n- The `std::pair<int, int>` type is used to represent the intervals.\n- The `std::max` and `std::min` functions are used to find the maximum and minimum values, respectively.\n- The `std::sqrt` function is used to calculate the square root.\n- The `std::string` type is used to handle the result string.\n- The `std::cerr` is used for error output, similar to the `write(*,*)` statement in Fortran.\n- The `return` statements are used to exit the function early if a condition is met, similar to the Fortran version.\n- The `main` function contains the test cases, which are translated into C++ using `std::pair` for the intervals and `std::string` for the result.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `intersection` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_intersection\n    implicit none\n    character(len=3) :: result\n    integer, dimension(2) :: interval1, interval2\n\n    ! Test case 1\n    interval1 = [1, 2]\n    interval2 = [2, 3]\n    result = intersection(interval1, interval2)\n    if (result /= 'NO') then\n        write(*,*) "Test case 1 failed: Expected 'NO', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 2\n    interval1 = [-1, 1]\n    interval2 = [0, 4]\n    result = intersection(interval1, interval2)\n    if (result /= 'NO') then\n        write(*,*) "Test case 2 failed: Expected 'NO', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 3\n    interval1 = [-3, -1]\n    interval2 = [-5, 5]\n    result = intersection(interval1, interval2)\n    if (result /= 'YES') then\n        write(*,*) "Test case 3 failed: Expected 'YES', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 4\n    interval1 = [-2, 2]\n    interval2 = [-4, 0]\n    result = intersection(interval1, interval2)\n    if (result /= 'YES') then\n        write(*,*) "Test case 4 failed: Expected 'YES', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 5\n    interval1 = [-11, 2]\n    interval2 = [-1, -1]\n    result = intersection(interval1, interval2)\n    if (result /= 'NO') then\n        write(*,*) "Test case 5 failed: Expected 'NO', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 6\n    interval1 = [1, 2]\n    interval2 = [3, 5]\n    result = intersection(interval1, interval2)\n    if (result /= 'NO') then\n        write(*,*) "Test case 6 failed: Expected 'NO', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 7\n    interval1 = [1, 2]\n    interval2 = [1, 2]\n    result = intersection(interval1, interval2)\n    if (result /= 'NO') then\n        write(*,*) "Test case 7 failed: Expected 'NO', got '", result, "'"\n        stop 1\n    end if\n\n    ! Test case 8\n    interval1 = [-2, -2]\n    interval2 = [-3, -2]\n    result = intersection(interval1, interval2)\n    if (result /= 'NO') then\n        write(*,*) "Test case 8 failed: Expected 'NO', got '", result, "'"\n        stop 1\n    end if\n\n    write(*,*) "All tests passed."\nend program test_intersection\n\nfunction intersection(interval1, interval2) result(res)\n    implicit none\n    integer, dimension(2), intent(in) :: interval1,
Certainly! Here's the equivalent C++ code for the provided Fortran program and function:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty() || (arr.size() == 1 && arr[0] == 0)) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int prods = 1;\n\n    for (int num : arr) {\n        sum += std::abs(num);\n        if (num == 0) {\n            prods = 0;\n        }\n        if (num < 0) {\n            prods = -prods;\n        }\n    }\n\n    return sum * prods;\n}\n\nint main() {\n    std::vector<int> test_case_1 = {1, 2, 2, -4};\n    if (prod_signs(test_case_1) != -9) {\n        std::cerr << "Assertion failed: prod_signs({1, 2, 2, -4}) == -9" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_2 = {0, 1};\n    if (prod_signs(test_case_2) != 0) {\n        std::cerr << "Assertion failed: prod_signs({0, 1}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_3 = {1, 1, 1, 2, 3, -1, 1};\n    if (prod_signs(test_case_3) != -10) {\n        std::cerr << "Assertion failed: prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_4 = {0};\n    if (prod_signs(test_case_4) != -32768) {\n        std::cerr << "Assertion failed: prod_signs({}) == -32768" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_5 = {2, 4, 1, 2, -1, -1, 9};\n    if (prod_signs(test_case_5) != 20) {\n        std::cerr << "Assertion failed: prod_signs({2, 4, 1, 2, -1, -1, 9}) == 20" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_6 = {-1, 1, -1, 1};\n    if (prod_signs(test_case_6) != 4) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, -1, 1}) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_7 = {-1, 1, 1, 1};\n    if (prod_signs(test_case_7) != -4) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, 1, 1}) == -4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_8 = {-1, 1, 1, 0};\n    if (prod_signs(test_case_8) != 0) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, 1, 0}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code defines a `prod_signs` function that computes the product of the signs of the elements in an integer array, similar to the Fortran version. The `main` function contains a series of test cases to verify the correctness of the `prod_signs` function. Each test case checks if the function returns the expected result and prints an error message if the assertion fails.
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, reshaping, and implementing the logic of the `minPath` subroutine and the `issame` function. Below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid minPath(const std::vector<std::vector<int>>& grid, int k, std::vector<int>& result) {\n    int n = grid.size();\n    int x = -1, y = -1;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    int min = n * n;\n    if (x > 0 && grid[x-1][y] < min) min = grid[x-1][y];\n    if (x < n-1 && grid[x+1][y] < min) min = grid[x+1][y];\n    if (y > 0 && grid[x][y-1] < min) min = grid[x][y-1];\n    if (y < n-1 && grid[x][y+1] < min) min = grid[x][y+1];\n\n    result.resize(k);\n    for (int i = 0; i < k; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1;\n        } else {\n            result[i] = min;\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> grid;\n    std::vector<int> result;\n    int k;\n\n    // Test case 1\n    grid = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    k = 3;\n    minPath(grid, k, result);\n    assert(issame(result, {1, 2, 1}));\n\n    // Test case 2\n    grid = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    k = 1;\n    minPath(grid, k, result);\n    assert(issame(result, {1}));\n\n    // Test case 3\n    grid = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    k = 4;\n    minPath(grid, k, result);\n    assert(issame(result, {1, 2, 1, 2}));\n\n    // Add more test cases as needed\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Dynamic Arrays**: In C++, `std::vector` is used to handle dynamic arrays.\n2. **Reshaping**: The reshaping of the 1D array to a 2D array is handled by initializing the `std::vector<std::vector<int>>` directly.\n3. **Logic Translation**: The logic of the `minPath` subroutine and the `issame` function is translated directly.\n4. **Assertions**: The `assert` function is implemented using `std::cerr` for error messages and `std::exit(1)` to terminate the program with an error code.\n\nThis C++ code should behave similarly to the original Fortran code, providing the same functionality and passing the same test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `minPath` subroutine and the `issame` function.\n\n### Fortran Unit Tests\n\nTo run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Here is the complete Fortran program with the unit tests:\n\n```fortran\nprogram main\n    implicit none\n    integer, dimension(:), allocatable :: result\n    integer, dimension(:,:), allocatable :: grid\n    integer :: k\n\n    ! Test cases\n    call test_minPath()\n\ncontains\n\n    subroutine minPath(grid, k, result)\n        integer, dimension(:,:), intent(in) :: grid\n        integer, intent(in) :: k\n        integer, dimension(:), allocatable :: result\n        integer :: i, j, x, y, min, n\n\n        n = size(grid, 1)\n        x = -1\n        y = -1\n\n        ! Find the position of 1 in the grid\n        do i = 1, n\n            do j = 1, n\n                if (grid(i, j) == 1) then\n                    x = i\n                    y = j\n                end if\n            end do\n        end do\n\n        min = n * n\n        if (x > 1 .and. grid(x-1, y) < min) min = grid(x-1, y)\n        if (x < n .and. grid(x+1, y) < min) min = grid(x+1, y)\n        if (y > 1 .and. grid(x, y-1) < min) min = grid(x, y-1)\n        if (y < n .and. grid(x, y+1) < min) min = grid(x, y+1)\n\n        if (allocated(result)) deallocate(result)\n        allocate(result(k))\n        do i = 1, k\n            if (mod(i, 2) == 1) then\n                result(i) = 1\n            else\n                result(i) = min\n            end if\n        end do\n    end subroutine minPath\n\n    function issame(a, b) result(is_equal)\n        integer, dimension(:), intent(in) :: a, b\n        logical :: is_equal\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            is_equal = .false.\n            return\n        end if\n\n        is_equal = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                is_equal = .false.\n                return\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\n    subroutine test_minPath()\n        integer, dimension(:,:), allocatable :: grid\n        integer, dimension(:), allocatable :: result\n        integer :: k\n\n        ! Test case 1\n        allocate(grid(3,3))\n        grid = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3])\n        k = 3\n        call minPath(grid, k, result)\n        call assert(issame(result, [1, 2, 1]))\n        deallocate(grid)\n\n        ! Test case 2\n        allocate(grid(3,3))\n        grid = reshape([5, 9, 3, 4, 1, 6, 7, 8, 2], [3, 3])\n        k = 1\n        call minPath(grid, k, result)\n        call assert(issame(result, [1]))\n        deallocate(grid)\n\n        ! Test case 3\n        allocate
Translating the given Fortran code to C++ involves several steps, including adapting the array handling, subroutine calls, and loop constructs to their C++ equivalents. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nvoid tri(int n, std::vector<int>& out) {\n    if (n == 0) {\n        out = {1};\n        return;\n    }\n\n    out.resize(n + 1);\n    out[0] = 1;\n    out[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = 1 + (i - 1) / 2;\n        } else {\n            out[i] = out[i - 1] + out[i - 2] + 1 + (i / 2);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_tri(int n, const std::vector<int>& expected) {\n    std::vector<int> result;\n    tri(n, result);\n\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    test_tri(3, {1, 3, 2, 8});\n    test_tri(4, {1, 3, 2, 8, 3});\n    test_tri(5, {1, 3, 2, 8, 3, 15});\n    test_tri(6, {1, 3, 2, 8, 3, 15, 4});\n    test_tri(7, {1, 3, 2, 8, 3, 15, 4, 24});\n    test_tri(8, {1, 3, 2, 8, 3, 15, 4, 24, 5});\n    test_tri(9, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35});\n    test_tri(20, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11});\n    test_tri(0, {1});\n    test_tri(1, {1, 3});\n\n    return 0;\n}\n```\n\n### Key Points:\n\n1. **Array Handling**: C++ uses `std::vector<int>` for dynamic arrays, which is more flexible and safer compared to raw arrays.\n\n2. **Subroutine Calls**: Fortran's `call` is replaced by direct function calls in C++.\n\n3. **Loop Constructs**: Fortran's `do` loop is replaced by C++'s `for` loop.\n\n4. **Array Allocation and Initialization**: Fortran's `allocate` and array initialization are replaced by C++'s `std::vector` methods.\n\n5. **Logical Function**: The `issame` function checks if two vectors are equal, which is a common operation in C++.\n\n6. **Error Handling**: Fortran's `write` and `exit` are replaced by C++'s `std::cerr` and `exit(1)`.\n\nThis C++ code should provide equivalent functionality to the original Fortran code, ensuring the same logic and output for the given test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `tri` function and the `issame` function.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: result(:)\n    integer, allocatable :: expected(:)\n    integer :: i\n\n    ! Test cases for the tri function\n    call test_tri(3, [1, 3, 2, 8])\n    call test_tri(4, [1, 3, 2, 8, 3])\n    call test_tri(5, [1, 3, 2, 8, 3, 15])\n    call test_tri(6, [1, 3, 2, 8, 3, 15, 4])\n    call test_tri(7, [1, 3, 2, 8, 3, 15, 4, 24])\n    call test_tri(8, [1, 3, 2, 8, 3, 15, 4, 24, 5])\n    call test_tri(9, [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\n    call test_tri(20, [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\n    call test_tri(0, [1])\n    call test_tri(1, [1, 3])\n\ncontains\n\n    subroutine test_tri(n, expected)\n        integer, intent(in) :: n\n        integer, intent(in) :: expected(:)\n        integer, allocatable :: result(:)\n\n        call tri(n, result)\n        if (.not. issame(result, expected)) then\n            write(*,*) "Assertion failed for n = ", n\n            call exit(1)\n        end if\n    end subroutine test_tri\n\n    subroutine tri(n, out)\n        integer, intent(in) :: n\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i\n\n        if (n == 0) then\n            allocate(out(1))\n            out = [1]\n            return\n        end if\n\n        allocate(out(n+1))\n        out(1) = 1\n        out(2) = 3\n\n        do i = 3, n+1\n            if (mod(i-1, 2) == 0) then\n                out(i) = 1 + (i-1)/2\n            else\n                out(i) = out(i-1) + out(i-2) + 1 + (i/2)\n            end if\n        end do\n    end subroutine tri\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:)\n        integer, intent(in) :: b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nvoid tri(int n, std::vector<int>& out) {\n    if (n == 0) {\n        out = {1};\n        return;\n    }\n\n    out.resize(n + 1);\n    out[0] = 1;\n    out[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint digits(int n) {\n    int prod = 1;\n    int has = 0;\n    std::string s = std::to_string(n); // Convert integer to string\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (s[i] % 2 == 1) {\n            has = 1;\n            prod *= (s[i] - '0');\n        }\n    }\n\n    if (has == 0) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Assertions\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `digits`**:\n   - Converts the integer `n` to a string using `std::to_string`.\n   - Iterates through each character of the string, multiplies `prod` by the digit if it is odd, and sets `has` to 1 if an odd digit is found.\n   - Returns 0 if no odd digits are found, otherwise returns the product of the odd digits.\n\n2. **Function `assert`**:\n   - Checks if the condition is false. If so, it prints an error message and exits the program with a non-zero status.\n\n3. **`main` function**:\n   - Contains assertions similar to the Fortran version.\n\nThis C++ code should behave similarly to the original Fortran code, performing the same calculations and checks.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer :: n\n\n    ! Assertions\n    call assert(digits(5) == 5)\n    call assert(digits(54) == 5)\n    call assert(digits(120) == 1)\n    call assert(digits(5014) == 5)\n    call assert(digits(98765) == 315)\n    call assert(digits(5576543) == 2625)\n    call assert(digits(2468) == 0)\n\ncontains\n\n    integer function digits(n)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i, prod, has\n        character(len=20) :: s\n\n        prod = 1\n        has = 0\n        write(s, '(I0)') n  ! Convert integer to string\n\n        do i = 1, len_trim(s)\n            if (mod(iachar(s(i:i)), 2) == 1) then\n                has = 1\n                prod = prod * (iachar(s(i:i)) - iachar('0'))\n            end if\n        end do\n\n        if (has == 0) then\n            digits = 0\n        else\n            digits = prod\n        end if\n    end function digits\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint digits(int n) {\n    int prod = 1;\n    int has = 0;\n    std::string s = std::to_string(n); // Convert integer to string\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (s[i] % 2 == 1) {\n            has = 1;\n            prod *= (s[i] - '0');\n        }\n    }\n\n    if (has == 0) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Assertions\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code**:\n   - The `test_main` program contains assertions similar to the original Fortran code.\n   - The `digits` function and `assert` subroutine are defined as in the original code.\n\n2. **C++ Unit Test Code**:\n   - The `main` function contains assertions similar to the translated C++ code.\n   - The `digits` function and `assert` function are defined as in the translated code.\n\nThese unit test codes will help verify that the translation from Fortran to C++ is correct by checking the output of the `digits` function with various inputs.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_nested(const std::string& str) {\n    int count = 0;\n    int maxcount = 0;\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (str[i] == '[') {\n            count++;\n        } else if (str[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            count = 0;\n        }\n        if (count > maxcount) {\n            maxcount = count;\n        }\n        if (count <= maxcount - 2) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(is_nested("[[]]") == true);\n    assert(is_nested("[]]]]]]][[[[[]") == false);\n    assert(is_nested("[][]") == false);\n    assert(is_nested("[]") == false);\n    assert(is_nested("[[[[]]]]") == true);\n    assert(is_nested("[]]]]]]]]]]") == false);\n    assert(is_nested("[][][[]]") == true);\n    assert(is_nested("[[]") == false);\n    assert(is_nested("[]]") == false);\n    assert(is_nested("[[]][[") == true);\n    assert(is_nested("[[][]]") == true);\n    assert(is_nested("") == false);\n    assert(is_nested("[[[[[[[[") == false);\n    assert(is_nested("]]]]]]]]") == false);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `is_nested`:**\n   - This function takes a `std::string` as input and returns a `bool`.\n   - It iterates through the string character by character.\n   - It maintains a count of the number of open and closed brackets.\n   - If the count of open brackets is less than the count of closed brackets, it returns `true`.\n\n2. **Subroutine `assert`:**\n   - This function takes a `bool` condition and checks if it is `false`.\n   - If the condition is `false`, it prints an error message and exits the program with a non-zero status.\n\n3. **Subroutine `run_tests`:**\n   - This function contains multiple calls to the `assert` function with different test cases.\n\n4. **Main function:**\n   - The `main` function calls the `run_tests` function to run the tests.\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the Fortran and C++ versions.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_nested_brackets.f90`:\n\n```fortran\nprogram test_nested_brackets\n  implicit none\n\n  call run_tests()\n\ncontains\n\n  logical function is_nested(str)\n    character(len=*), intent(in) :: str\n    integer :: count, maxcount, i\n\n    count = 0\n    maxcount = 0\n    do i = 1, len(str)\n      if (str(i:i) == '[') count = count + 1\n      if (str(i:i) == ']') count = count - 1\n      if (count < 0) count = 0\n      if (count > maxcount) maxcount = count\n      if (count <= maxcount - 2) then\n        is_nested = .true.\n        return\n      end if\n    end do\n    is_nested = .false.\n  end function is_nested\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n      call exit(1)\n    end if\n  end subroutine assert\n\n  subroutine run_tests()\n    call assert(is_nested("[[]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]][[[[[]") .eqv. .false.)\n    call assert(is_nested("[][]") .eqv. .false.)\n    call assert(is_nested("[]") .eqv. .false.)\n    call assert(is_nested("[[[[]]]]") .eqv. .true.)\n    call assert(is_nested("[]]]]]]]]]]") .eqv. .false.)\n    call assert(is_nested("[][][[]]") .eqv. .true.)\n    call assert(is_nested("[[]") .eqv. .false.)\n    call assert(is_nested("[]]") .eqv. .false.)\n    call assert(is_nested("[[]][[") .eqv. .true.)\n    call assert(is_nested("[[][]]") .eqv. .true.)\n    call assert(is_nested("") .eqv. .false.)\n    call assert(is_nested("[[[[[[[[") .eqv. .false.)\n    call assert(is_nested("]]]]]]]]") .eqv. .false.)\n  end subroutine run_tests\n\nend program test_nested_brackets\n```\n\n### C++ Unit Test Code\n\nSave the following C++ code in a file named `test_nested_brackets.cpp`:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_nested(const std::string& str) {\n    int count = 0;\n    int maxcount = 0;\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (str[i] == '[') {\n            count++;\n        } else if (str[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            count = 0;\n        }\n        if (count > maxcount) {\n            maxcount = count;\n        }\n        if (count <= maxcount - 2) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(is_nested("[[]]") == true);\n    assert(is_nested("[]]]]]]][[[[[]") == false);\n    assert(is_nested("[][]") == false);\n    assert(is_nested("[]") == false);\n    assert(is_nested("[[[[]]]]") == true);\n    assert(is_nested("[]]]]]]]]]]") == false);\n    assert(is_nested("[][][[]]") == true);\n    assert(is_nested("[[]") == false);\n    assert(is_nested("[]]") == false);\n    assert(is_nested("[[]][[") == true);\n    assert(is_nested("[[][]]") == true);\n    assert(is_nested("") == false);\n    assert(is_nested("[[[[[[[[") == false);\n    assert(is_nested("]]]]]]]]") == false);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Compilation and Execution\n\n#### Fortran\n\nTo compile and run the Fortran code, use the following commands:\n\n```sh\ngfortran -o test_nested_brackets test_nested_brackets.f90\n./test_nested_brackets\n```\n\n#### C++\n\nTo compile and run the C++ code, use the following commands:\n\n```sh\ng++ -o test_nested_brackets test_nested_brackets.cpp\n./test_nested_brackets\n```\n\nBoth programs should output "All tests passed." if the translation is correct. If there is an assertion failure, the Fortran program will exit with
Translating the provided Fortran code to C++ involves a few steps, including adapting the syntax for loops, array handling, and function definitions. Here's how the Fortran code could be translated into C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdlib>\n\n// Function to calculate the sum of squares of elements in a list\nint sum_squares(const std::vector<double>& lst) {\n    int sum = 0;\n    for (double num : lst) {\n        sum += std::pow(std::ceil(num), 2);\n    }\n    return sum;\n}\n\n// Subroutine to assert a condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Function to run tests\nvoid run_tests() {\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 3.0, 5.0, 7.0}) == 84);\n    assert(sum_squares({1.4, 4.2, 0.0}) == 29);\n    assert(sum_squares({-2.4, 1.0, 1.0}) == 6);\n    assert(sum_squares({100.0, 1.0, 15.0, 2.0}) == 10230);\n    assert(sum_squares({10000.0, 10000.0}) == 200000000);\n    assert(sum_squares({-1.4, 4.6, 6.3}) == 75);\n    assert(sum_squares({-1.4, 17.9, 18.9, 19.9}) == 1086);\n    assert(sum_squares({0.0}) == 0);\n    assert(sum_squares({-1.0}) == 1);\n    assert(sum_squares({-1.0, 1.0, 0.0}) == 2);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Key Differences and Considerations:\n\n1. **Array Handling:** C++ uses `std::vector` for dynamic arrays, which is more flexible and safer compared to raw arrays.\n2. **Looping:** The `for` loop in C++ is different from Fortran's `do` loop. The `for` loop in C++ iterates over elements in a container.\n3. **Math Functions:** The `std::pow` function is used for exponentiation, and `std::ceil` for ceiling.\n4. **Error Handling:** The `assert` function in C++ checks a condition and exits the program if the condition is false.\n5. **Testing:** The `run_tests` function in C++ uses `assert` to verify the correctness of the `sum_squares` function.\n6. **Program Structure:** The C++ program structure is different from Fortran's, with a `main` function acting as the entry point.\n\nThis C++ code aims to closely replicate the functionality and structure of the original Fortran code, ensuring that the translated version behaves as expected.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `sum_squares` function in both implementations.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram sum_squares_program\n  implicit none\n\n  ! Main program\n  call run_tests()\n\ncontains\n\n  function sum_squares(lst) result(sum)\n    real, dimension(:), intent(in) :: lst\n    integer :: sum\n    integer :: i\n\n    sum = 0\n    do i = 1, size(lst)\n      sum = sum + ceiling(lst(i))**2\n    end do\n  end function sum_squares\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n      call exit(1)\n    end if\n  end subroutine assert\n\n  subroutine run_tests()\n    call assert(sum_squares([1.0, 2.0, 3.0]) == 14)\n    call assert(sum_squares([1.0, 2.0, 3.0]) == 14)\n    call assert(sum_squares([1.0, 3.0, 5.0, 7.0]) == 84)\n    call assert(sum_squares([1.4, 4.2, 0.0]) == 29)\n    call assert(sum_squares([-2.4, 1.0, 1.0]) == 6)\n    call assert(sum_squares([100.0, 1.0, 15.0, 2.0]) == 10230)\n    call assert(sum_squares([10000.0, 10000.0]) == 200000000)\n    call assert(sum_squares([-1.4, 4.6, 6.3]) == 75)\n    call assert(sum_squares([-1.4, 17.9, 18.9, 19.9]) == 1086)\n    call assert(sum_squares([0.0]) == 0)\n    call assert(sum_squares([-1.0]) == 1)\n    call assert(sum_squares([-1.0, 1.0, 0.0]) == 2)\n  end subroutine run_tests\n\nend program sum_squares_program\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdlib>\n\n// Function to calculate the sum of squares of elements in a list\nint sum_squares(const std::vector<double>& lst) {\n    int sum = 0;\n    for (double num : lst) {\n        sum += std::pow(std::ceil(num), 2);\n    }\n    return sum;\n}\n\n// Subroutine to assert a condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Function to run tests\nvoid run_tests() {\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 3.0, 5.0, 7.0}) == 84);\n    assert(sum_squares({1.4, 4.2, 0.0}) == 29);\n    assert(sum_squares({-2.4, 1.0, 1.0}) == 6);\n    assert(sum_squares({100.0, 1.0, 15.0, 2.0}) == 10230);\n    assert(sum_squares({10000.0, 10000.0}) == 200000000);\n    assert(sum_squares({-1.4, 4.6, 6.3}) == 75);\n    assert(sum_squares({-1.4, 17.9, 18.9, 19.9}) == 1086);\n    assert(sum_squares({0.0}) == 0);\n    assert(sum_squares({-1.0}) == 1);\n    assert(sum_squares({-1.0, 1.0, 0.0}) == 2);\n}\n\nint main() {\n    run_tests
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nclass CanArrangeModule {\npublic:\n    static int can_arrange(const std::vector<int>& arr, int n) {\n        int max = -1;\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] <= i) max = i;\n        }\n        return max;\n    }\n\n    static int can_arrange_empty() {\n        return -1;\n    }\n};\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 4, 3, 5};\n    if (CanArrangeModule::can_arrange(arr1, 5) != 3) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,3,5}) /= 3" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr2 = {1, 2, 4, 5};\n    if (CanArrangeModule::can_arrange(arr2, 4) != -1) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,5}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr3 = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    if (CanArrangeModule::can_arrange(arr3, 9) != 2) {\n        std::cerr << "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) /= 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr4 = {4, 8, 5, 7, 3};\n    if (CanArrangeModule::can_arrange(arr4, 5) != 4) {\n        std::cerr << "Assertion failed: can_arrange({4,8,5,7,3}) /= 4" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle the empty array case separately\n    if (CanArrangeModule::can_arrange_empty() != -1) {\n        std::cerr << "Assertion failed: can_arrange({}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code includes a class `CanArrangeModule` with static methods `can_arrange` and `can_arrange_empty`, which correspond to the Fortran module's functions. The `main` function contains assertions similar to the Fortran program's tests, ensuring that the translated code behaves as expected.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule can_arrange_module\n    implicit none\ncontains\n    integer function can_arrange(arr, n)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: n\n        integer :: i\n        integer :: max\n\n        max = -1\n        do i = 1, n\n            if (arr(i) <= i - 1) max = i - 1\n        end do\n        can_arrange = max\n    end function can_arrange\n\n    integer function can_arrange_empty()\n        implicit none\n        can_arrange_empty = -1\n    end function can_arrange_empty\nend module can_arrange_module\n\nprogram main\n    use can_arrange_module\n    implicit none\n    integer :: result\n\n    result = can_arrange([1, 2, 4, 3, 5], 5)\n    if (result /= 3) then\n        write(*,*) "Assertion failed: can_arrange({1,2,4,3,5}) /= 3"\n        call exit(1)\n    end if\n\n    result = can_arrange([1, 2, 4, 5], 4)\n    if (result /= -1) then\n        write(*,*) "Assertion failed: can_arrange({1,2,4,5}) /= -1"\n        call exit(1)\n    end if\n\n    result = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10], 9)\n    if (result /= 2) then\n        write(*,*) "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) /= 2"\n        call exit(1)\n    end if\n\n    result = can_arrange([4, 8, 5, 7, 3], 5)\n    if (result /= 4) then\n        write(*,*) "Assertion failed: can_arrange({4,8,5,7,3}) /= 4"\n        call exit(1)\n    end if\n\n    ! Handle the empty array case separately\n    result = can_arrange_empty()\n    if (result /= -1) then\n        write(*,*) "Assertion failed: can_arrange({}) /= -1"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\nend program main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nclass CanArrangeModule {\npublic:\n    static int can_arrange(const std::vector<int>& arr, int n) {\n        int max = -1;\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] <= i) max = i;\n        }\n        return max;\n    }\n\n    static int can_arrange_empty() {\n        return -1;\n    }\n};\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 4, 3, 5};\n    if (CanArrangeModule::can_arrange(arr1, 5) != 3) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,3,5}) /= 3" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr2 = {1, 2, 4, 5};\n    if (CanArrangeModule::can_arrange(arr2, 4) != -1) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,5}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr3 = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    if (CanArrangeModule::can_arrange(arr3, 9) != 2) {\n        std::cerr << "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) /= 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr4 = {4, 8, 5, 7, 3};\n    if (CanArrangeModule::can_arrange(arr4, 5) != 4) {\n        std::cerr << "Assertion failed: can_arrange({4,8,5,7,3}) /= 4" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle the empty array case separately\n    if (CanArrangeModule::can_arrange_empty() != -1) {\n        std::cerr << "Assertion failed: can_arrange({}) /= -1" << std::endl;\n        std::exit(1);\n   
Translating the given Fortran code to C++ involves several steps, including changing the syntax, handling arrays, and implementing the logic for finding the largest and smallest integers in a given array. Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::pair<int, int> largest_smallest_integers(const std::vector<int>& lst) {\n    int maxneg = 0, minpos = 0;\n\n    for (int num : lst) {\n        if (num < 0 && (maxneg == 0 || num > maxneg)) maxneg = num;\n        if (num > 0 && (minpos == 0 || num < minpos)) minpos = num;\n    }\n\n    return {maxneg, minpos};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    std::vector<int> test_array;\n    std::pair<int, int> expected;\n\n    // Test case 1\n    test_array = {2, 4, 1, 3, 5, 7};\n    expected = {0, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 2\n    test_array = {2, 4, 1, 3, 5, 7, 0};\n    expected = {0, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 3\n    test_array = {1, 3, 2, 4, 5, 6, -2};\n    expected = {-2, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 4\n    test_array = {4, 5, 3, 6, 2, 7, -7};\n    expected = {-7, 2};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 5\n    test_array = {7, 3, 8, 4, 9, 2, 5, -9};\n    expected = {-9, 2};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 6\n    test_array = {0};\n    expected = {0, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 7\n    test_array = {-1, -3, -5, -6};\n    expected = {-1, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 8\n    test_array = {-1, -3, -5, -6, 0};\n    expected = {-1, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 9\n    test_array = {-6, -4, -4, -3, 1};\n    expected = {-3, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 10\n    test_array = {-6, -4, -4, -3, -100, 1};\n    expected = {-3, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Special case for empty array\n    test_array = {};\n    expected = {0, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\nThis C++ code includes the necessary headers and uses the `std::vector` container for dynamic arrays, which is a common practice in C++ for handling arrays of unknown size at compile time. The `std::pair` is used to return two values from the `largest_smallest_integers` function, mimicking the behavior of the Fortran function. The `assert` function is implemented to check the correctness of the output against the expected results, similar to the Fortran version. The `run_tests` function contains several test cases to verify the correctness of the `largest_smallest_integers` and `issame` functions.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `largest_smallest_integers` and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n  implicit none\n\n  call run_tests()\n\ncontains\n\n  function largest_smallest_integers(lst) result(res)\n    integer, dimension(:), intent(in) :: lst\n    integer, dimension(2) :: res\n    integer :: i, maxneg, minpos\n\n    maxneg = 0\n    minpos = 0\n\n    do i = 1, size(lst)\n      if (lst(i) < 0 .and. (maxneg == 0 .or. lst(i) > maxneg)) maxneg = lst(i)\n      if (lst(i) > 0 .and. (minpos == 0 .or. lst(i) < minpos)) minpos = lst(i)\n    end do\n\n    res(1) = maxneg\n    res(2) = minpos\n  end function largest_smallest_integers\n\n  function issame(a, b) result(res)\n    integer, dimension(:), intent(in) :: a, b\n    logical :: res\n    integer :: i\n\n    if (size(a) /= size(b)) then\n      res = .false.\n      return\n    end if\n\n    res = .true.\n    do i = 1, size(a)\n      if (a(i) /= b(i)) then\n        res = .false.\n        return\n      end if\n    end do\n  end function issame\n\n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*,*) "Assertion failed"\n      call exit(1)\n    end if\n  end subroutine assert\n\n  subroutine run_tests()\n    implicit none\n    integer, dimension(2) :: expected\n    integer, dimension(:), allocatable :: test_array\n\n    call test_case([2, 4, 1, 3, 5, 7], [0, 1])\n    call test_case([2, 4, 1, 3, 5, 7, 0], [0, 1])\n    call test_case([1, 3, 2, 4, 5, 6, -2], [-2, 1])\n    call test_case([4, 5, 3, 6, 2, 7, -7], [-7, 2])\n    call test_case([7, 3, 8, 4, 9, 2, 5, -9], [-9, 2])\n    call test_case([0], [0, 0])\n    call test_case([-1, -3, -5, -6], [-1, 0])\n    call test_case([-1, -3, -5, -6, 0], [-1, 0])\n    call test_case([-6, -4, -4, -3, 1], [-3, 1])\n    call test_case([-6, -4, -4, -3, -100, 1], [-3, 1])\n\n    ! Special case for empty array\n    call test_case_empty([0, 0])\n\n 
Certainly! Below is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint64_t special_factorial(int n);\n\nint main() {\n    int64_t result;\n\n    // Test cases\n    result = special_factorial(4);\n    if (result != 288) {\n        std::cerr << "special_factorial(4) == 288: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(5);\n    if (result != 34560) {\n        std::cerr << "special_factorial(5) == 34560: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(7);\n    if (result != 125411328000) {\n        std::cerr << "special_factorial(7) == 125411328000: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(1);\n    if (result != 1) {\n        std::cerr << "special_factorial(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nint64_t special_factorial(int n) {\n    int64_t fact = 1;\n    int64_t bfact = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact *= i;\n        bfact *= fact;\n    }\n    return bfact;\n}\n```\n\n### Explanation:\n1. **Header Files**:\n   - `#include <iostream>` for input and output operations.\n   - `#include <cstdlib>` for the `exit()` function.\n\n2. **Function Definition**:\n   - The `special_factorial` function is defined to calculate the special factorial of a given number.\n\n3. **Main Function**:\n   - The `main` function contains the test cases to verify the correctness of the `special_factorial` function.\n   - It uses `std::cerr` for error messages and `std::exit(1)` to exit the program with an error code if any of the assertions fail.\n\n4. **Test Cases**:\n   - The test cases call the `special_factorial` function with different values and check if the results match the expected values.\n\nThis C++ code should behave similarly to the provided Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram special_factorial_test\n  implicit none\n  integer, parameter :: int64 = selected_int_kind(18)\n  integer(int64) :: result\n\n  ! Test cases\n  result = special_factorial(4)\n  if (result /= 288_int64) then\n    write(*,*) "special_factorial(4) == 288: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(5)\n  if (result /= 34560_int64) then\n    write(*,*) "special_factorial(5) == 34560: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(7)\n  if (result /= 125411328000_int64) then\n    write(*,*) "special_factorial(7) == 125411328000: assertion failed"\n    call exit(1)\n  end if\n\n  result = special_factorial(1)\n  if (result /= 1_int64) then\n    write(*,*) "special_factorial(1) == 1: assertion failed"\n    call exit(1)\n  end if\n\ncontains\n\n  function special_factorial(n) result(bfact)\n    implicit none\n    integer, intent(in) :: n\n    integer(int64) :: bfact\n    integer(int64) :: fact\n    integer :: i\n\n    fact = 1\n    bfact = 1\n    do i = 1, n\n      fact = fact * i\n      bfact = bfact * fact\n    end do\n  end function special_factorial\n\nend program special_factorial_test\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint64_t special_factorial(int n);\n\nint main() {\n    int64_t result;\n\n    // Test cases\n    result = special_factorial(4);\n    if (result != 288) {\n        std::cerr << "special_factorial(4) == 288: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(5);\n    if (result != 34560) {\n        std::cerr << "special_factorial(5) == 34560: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(7);\n    if (result != 125411328000) {\n        std::cerr << "special_factorial(7) == 125411328000: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(1);\n    if (result != 1) {\n        std::cerr << "special_factorial(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nint64_t special_factorial(int n) {\n    int64_t fact = 1;\n    int64_t bfact = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact *= i;\n        bfact *= fact;\n    }\n    return bfact;\n}\n```\n\n### Explanation:\n\n1. **Fortran Unit Test Code**:\n   - The Fortran program `special_factorial_test` contains the same test cases as the main program.\n   - It uses `write(*,*)`, `call exit(1)` for error handling.\n\n2. **C++ Unit Test Code**:\n   - The C++ program uses `std::cerr` for error messages and `std::exit(1)` to exit the program with an error code if any of the assertions fail.\n   - The `main` function contains the same test cases as the Fortran version.\n\nThese unit test codes will help verify the correctness of the `special_factorial` function in both Fortran and C++.
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string file_name_check(const std::string& file_name) {\n    int numdigit = 0;\n    int numdot = 0;\n    std::string last;\n    char w;\n\n    if (file_name.length() < 5) {\n        return "No";\n    }\n\n    w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') {\n        return "No";\n    }\n\n    last = file_name.substr(file_name.length() - 4, 4);\n    if (last != ".txt" && last != ".exe" && last != ".dll") {\n        return "No";\n    }\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') {\n            ++numdigit;\n        }\n        if (file_name[i] == '.') {\n            ++numdot;\n        }\n    }\n\n    if (numdigit > 3 || numdot != 1) {\n        return "No";\n    } else {\n        return "Yes";\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(file_name_check("example.txt") == "Yes");\n    assert(file_name_check("1example.dll") == "No");\n    assert(file_name_check("s1sdf3.asd") == "No");\n    assert(file_name_check("K.dll") == "Yes");\n    assert(file_name_check("MY16FILE3.exe") == "Yes");\n    assert(file_name_check("His12FILE94.exe") == "No");\n    assert(file_name_check("_Y.txt") == "No");\n    assert(file_name_check("?aREYA.exe") == "No");\n    assert(file_name_check("/this_is_valid.dll") == "No");\n    assert(file_name_check("this_is_valid.wow") == "No");\n    assert(file_name_check("this_is_valid.txt") == "Yes");\n    assert(file_name_check("this_is_valid.txtexe") == "No");\n    assert(file_name_check("#this2_i4s_5valid.ten") == "No");\n    assert(file_name_check("@this1_is6_valid.exe") == "No");\n    assert(file_name_check("this_is_12valid.6exe4.txt") == "No");\n    assert(file_name_check("all.exe.txt") == "No");\n    assert(file_name_check("I563_No.exe") == "Yes");\n    assert(file_name_check("Is3youfault.txt") == "Yes");\n    assert(file_name_check("no_one#knows.dll") == "Yes");\n    assert(file_name_check("1I563_Yes3.exe") == "No");\n    assert(file_name_check("I563_Yes3.txtt") == "No");\n    assert(file_name_check("final..txt") == "No");\n    assert(file_name_check("final132") == "No");\n    assert(file_name_check("_f4indsartal132.") == "No");\n    assert(file_name_check(".txt") == "No");\n    assert(file_name_check("s.") == "No");\n\n    return 0;\n}\n```\n\nThis C++ code includes the `file_name_check` function and the `assert` function to verify the correctness of the Fortran code's logic. The `main` function contains a series of test cases to verify the correctness of the `file_name_check` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram file_name_check_program\n    implicit none\n\n    ! Test cases\n    call assert(file_name_check('example.txt') == 'Yes')\n    call assert(file_name_check('1example.dll') == 'No')\n    call assert(file_name_check('s1sdf3.asd') == 'No')\n    call assert(file_name_check('K.dll') == 'Yes')\n    call assert(file_name_check('MY16FILE3.exe') == 'Yes')\n    call assert(file_name_check('His12FILE94.exe') == 'No')\n    call assert(file_name_check('_Y.txt') == 'No')\n    call assert(file_name_check('?aREYA.exe') == 'No')\n    call assert(file_name_check('/this_is_valid.dll') == 'No')\n    call assert(file_name_check('this_is_valid.wow') == 'No')\n    call assert(file_name_check('this_is_valid.txt') == 'Yes')\n    call assert(file_name_check('this_is_valid.txtexe') == 'No')\n    call assert(file_name_check('#this2_i4s_5valid.ten') == 'No')\n    call assert(file_name_check('@this1_is6_valid.exe') == 'No')\n    call assert(file_name_check('this_is_12valid.6exe4.txt') == 'No')\n    call assert(file_name_check('all.exe.txt') == 'No')\n    call assert(file_name_check('I563_No.exe') == 'Yes')\n    call assert(file_name_check('Is3youfault.txt') == 'Yes')\n    call assert(file_name_check('no_one#knows.dll') == 'Yes')\n    call assert(file_name_check('1I563_Yes3.exe') == 'No')\n    call assert(file_name_check('I563_Yes3.txtt') == 'No')\n    call assert(file_name_check('final..txt') == 'No')\n    call assert(file_name_check('final132') == 'No')\n    call assert(file_name_check('_f4indsartal132.') == 'No')\n    call assert(file_name_check('.txt') == 'No')\n    call assert(file_name_check('s.') == 'No')\n\ncontains\n\n    character(len=3) function file_name_check(file_name)\n        character(len=*), intent(in) :: file_name\n        integer :: numdigit, numdot, i\n        character(len=4) :: last\n        character(len=1) :: w\n\n        numdigit = 0\n        numdot = 0\n\n        if (len_trim(file_name) < 5) then\n            file_name_check = 'No'\n            return\n        end if\n\n        w = file_name(1:1)\n        if (ichar(w) < 65 .or. (ichar(w) > 90 .and. ichar(w) < 97) .or. ichar(w) > 122) then\n            file_name_check = 'No'\n            return\n        end if\n\n        last = file_name(len_trim(file_name)-3:len_trim(file_name))\n        if (last /= '.txt' .and. last /= '.exe' .and. last /= '.dll') then\n            file_name_check = 'No'\n            return\n        end if\n\n        do i = 1, len_trim(file_name)\n            if (ichar(file_name(i:i)) >= 48 .and. ichar(file_name(i:i)) <= 57) numdigit = numdigit +
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the `simplify` function and a main function to test the assertions as in the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool simplify(const std::string& x, const std::string& n) {\n    int a, b, c, d;\n    size_t pos = x.find('/');\n    a = std::stoi(x.substr(0, pos));\n    b = std::stoi(x.substr(pos + 1));\n\n    pos = n.find('/');\n    c = std::stoi(n.substr(0, pos));\n    d = std::stoi(n.substr(pos + 1));\n\n    return (a * c) % (b * d) == 0;\n}\n\nint main() {\n    bool result;\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/6", "2/1");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('1/6', '2/1') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/1", "3/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('5/1', '3/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/10", "10/2");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('7/10', '10/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/10", "50/10");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/10', '50/10') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/2", "4/2");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('7/2', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("11/6", "6/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('11/6', '6/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/3", "5/2");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('2/3', '5/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/2", "3/5");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('5/2', '3/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "8/4");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/4', '8/4') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "4/2");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/4', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "1/5");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('1/5', '1/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code defines a `simplify` function that takes two strings representing fractions and checks if they are equivalent under the specified condition. The `main` function contains assertions similar to the Fortran code, calling `simplify` with different pairs of fractions and checking the results. If any assertion fails, it prints an error message and exits with a non-zero status.
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, string manipulation, and sorting algorithms. Below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n\nstd::vector<int> order_by_points(const std::vector<int>& nums) {\n    if (nums.empty()) return nums;\n\n    std::vector<int> sumdigit(nums.size());\n    std::vector<int> sorted_nums = nums;\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        std::string w = std::to_string(std::abs(nums[i]));\n        int sum = 0;\n        for (size_t j = 1; j < w.length(); ++j) {\n            sum += w[j] - '0';\n        }\n        if (nums[i] > 0) {\n            sum += w[0] - '0';\n        } else {\n            sum -= w[0] - '0';\n        }\n        sumdigit[i] = sum;\n    }\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        for (size_t j = 0; j < nums.size() - i - 1; ++j) {\n            if (sumdigit[j] > sumdigit[j + 1]) {\n                std::swap(sumdigit[j], sumdigit[j + 1]);\n                std::swap(sorted_nums[j], sorted_nums[j + 1]);\n            }\n        }\n    }\n\n    return sorted_nums;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> nums;\n    std::vector<int> result;\n\n    // Test case 1\n    nums = {1, 11, -1, -11, -12};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-1, -11, 1, -12, 11}));\n\n    // Test case 2\n    nums = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n\n    // Test case 3\n    nums = {};\n    result = order_by_points(nums);\n    assert_condition(issame(result, nums));\n\n    // Test case 4\n    nums = {1, -11, -32, 43, 54, -98, 2, -3};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-3, -32, -98, -11, 1, 2, 43, 54}));\n\n    // Test case 5\n    nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n\n    // Test case 6\n    nums = {0, 6, 6, -76, -21, 23, 4};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-76, -21, 0, 4, 23, 6, 6}));\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Dynamic Arrays**: In C++, we use `std::vector<int>` to handle dynamic arrays.\n2. **String Manipulation**: The `std::string` class is used for string manipulation, especially for converting integers to strings and vice versa.\n3. **Sorting**: The sorting logic is implemented using bubble sort.\n4. **Assertions**: The `assert_condition` function checks the condition and prints an error message if the condition is false, similar to the Fortran `assert` subroutine.\n\nThis C++ code should behave similarly to the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, dimension(:), allocatable :: nums, result\n    integer :: i\n\n    ! Test cases\n    call test_case_1()\n    call test_case_2()\n    call test_case_3()\n    call test_case_4()\n    call test_case_5()\n    call test_case_6()\n\ncontains\n\n    subroutine test_case_1()\n        if (allocated(nums)) deallocate(nums)\n        nums = [1, 11, -1, -11, -12]\n        result = order_by_points(nums)\n        call assert(issame(result, [-1, -11, 1, -12, 11]))\n    end subroutine test_case_1\n\n    subroutine test_case_2()\n        if (allocated(nums)) deallocate(nums)\n        nums = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\n        result = order_by_points(nums)\n        call assert(issame(result, [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]))\n    end subroutine test_case_2\n\n    subroutine test_case_3()\n        if (allocated(nums)) deallocate(nums)\n        allocate(nums(0))\n        result = order_by_points(nums)\n        call assert(issame(result, nums))\n    end subroutine test_case_3\n\n    subroutine test_case_4()\n        if (allocated(nums)) deallocate(nums)\n        nums = [1, -11, -32, 43, 54, -98, 2, -3]\n        result = order_by_points(nums)\n        call assert(issame(result, [-3, -32, -98, -11, 1, 2, 43, 54]))\n    end subroutine test_case_4\n\n    subroutine test_case_5()\n        if (allocated(nums)) deallocate(nums)\n        nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        result = order_by_points(nums)
To translate the provided Fortran code to C++, we need to adapt the Fortran constructs to their C++ equivalents. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // For std::isdigit\n\nclass SpecialFilter {\npublic:\n    static int specialFilter(const std::vector<int>& nums) {\n        int num = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] > 10) {\n                std::string w = std::to_string(nums[i]);\n                if (std::isdigit(w[0]) && std::isdigit(w[w.length() - 1])) {\n                    num += 1;\n                }\n            }\n        }\n        return num;\n    }\n\n    static int specialFilterEmpty() {\n        return 0;\n    }\n};\n\nint main() {\n    // Test cases\n    if (SpecialFilter::specialFilter({5, -2, 1, -5}) != 0) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({15, -73, 14, -15}) != 1) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({33, -2, -3, 45, 21, 109}) != 2) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({43, -12, 93, 125, 121, 109}) != 4) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({71, -2, -33, 75, 21, 19}) != 3) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({1}) != 0) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    // Handle empty array case separately\n    if (SpecialFilter::specialFilterEmpty() != 0) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Class Definition**: The `SpecialFilter` class in C++ encapsulates the functionality of the Fortran module.\n2. **Static Methods**: The `specialFilter` and `specialFilterEmpty` functions are defined as static methods within the `SpecialFilter` class. This allows them to be called without instantiating the class.\n3. **Vector for Arrays**: Fortran arrays are translated to `std::vector<int>` in C++ for dynamic array handling.\n4. **String Conversion**: The Fortran `write` statement used for string conversion is replaced by `std::to_string` in C++.\n5. **Character Checks**: The Fortran character checks are replaced by `std::isdigit` from `<cctype>` in C++ to check if the first and last characters are digits.\n6. **Test Cases**: The test cases are implemented directly in the `main` function.\n\nThis C++ code should provide the same functionality as the original Fortran code, with the necessary adaptations for the differences between the two languages.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule special_filter_module\n    implicit none\ncontains\n\n    function specialFilter(nums) result(num)\n        integer, dimension(:), intent(in) :: nums\n        integer :: num\n        integer :: i\n        character(len=20) :: w\n\n        num = 0\n        do i = 1, size(nums)\n            if (nums(i) > 10) then\n                write(w, '(I0)') nums(i)\n                if (mod(iachar(w(1:1)), 2) == 1 .and. mod(iachar(w(len_trim(w):len_trim(w))), 2) == 1) then\n                    num = num + 1\n                end if\n            end if\n        end do\n    end function specialFilter\n\n    function specialFilterEmpty() result(num)\n        integer :: num\n        num = 0\n    end function specialFilterEmpty\n\nend module special_filter_module\n\nprogram special_filter_program\n    use special_filter_module\n    implicit none\n    integer :: result\n\n    ! Test cases\n    result = specialFilter([5, -2, 1, -5])\n    if (result /= 0) then\n        write(*,*) "Test case 1 failed"\n        call exit(1)\n    end if\n\n    result = specialFilter([15, -73, 14, -15])\n    if (result /= 1) then\n        write(*,*) "Test case 2 failed"\n        call exit(1)\n    end if\n\n    result = specialFilter([33, -2, -3, 45, 21, 109])\n    if (result /= 2) then\n        write(*,*) "Test case 3 failed"\n        call exit(1)\n    end if\n\n    result = specialFilter([43, -12, 93, 125, 121, 109])\n    if (result /= 4) then\n        write(*,*) "Test case 4 failed"\n        call exit(1)\n    end if\n\n    result = specialFilter([71, -2, -33, 75, 21, 19])\n    if (result /= 3) then\n        write(*,*) "Test case 5 failed"\n        call exit(1)\n    end if\n\n    result = specialFilter([1])\n    if (result /= 0) then\n        write(*,*) "Test case 6 failed"\n        call exit(1)\n    end if\n\n    ! Handle empty array case separately\n    result = specialFilterEmpty()\n    if (result /= 0) then\n        write(*,*) "Test case 7 failed"\n        call exit(1)\n    end if\n\n    write(*,*) "All test cases passed"\nend program special_filter_program\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // For std::isdigit\n\nclass SpecialFilter {\npublic:\n    static int specialFilter(const std::vector<int>& nums) {\n        int num = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] > 10) {\n                std::string w = std::to_string(nums[i]);\n                if (std::isdigit(w[0]) && std::isdigit(w[w.length() - 1])) {\n                    num += 1;\n                }\n            }\n        }\n        return num;\n    }\n\n    static int specialFilterEmpty() {\n        return 0;\n    }\n};\n\nint main() {\n    // Test cases\n    if (SpecialFilter::specialFilter({5, -2, 1, -5}) != 0) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({15, -73, 14, -15}) != 1) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({33, -2, -3, 45, 21, 1
Translating the provided Fortran code to C++ involves several steps, including changing the syntax for loops, arrays, and functions. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nclass MatrixTriples {\npublic:\n    static int getMatrixTriples(int n) {\n        std::vector<int> a(n);\n        std::vector<std::vector<int>> sum(n + 1, std::vector<int>(3, 0));\n        std::vector<std::vector<int>> sum2(n + 1, std::vector<int>(3, 0));\n\n        // Initialize arrays\n        sum = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n        sum2 = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n\n        // Fill array 'a' and compute initial sums\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i * i - i + 1) % 3;\n            for (int j = 0; j < 3; ++j) {\n                sum[i + 1][j] = sum[i][j];\n            }\n            sum[i + 1][a[i]] += 1;\n        }\n\n        // Compute sums for times = 1 and 2\n        for (int times = 1; times <= 2; ++times) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < 3; ++j) {\n                    sum2[i + 1][j] = sum2[i][j];\n                }\n                for (int j = -1; j <= 1; ++j) {\n                    sum2[i + 1][(a[i] + j + 3) % 3] += sum[i][(j + 1) % 3];\n                }\n            }\n            sum = sum2;\n            sum2 = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n        }\n\n        return sum[n][0];\n    }\n};\n\nint main() {\n    // Test cases\n    if (MatrixTriples::getMatrixTriples(5) != 1) {\n        std::cerr << "Assertion failed: getMatrixTriples(5) == 1" << std::endl;\n        return 1;\n    }\n\n    if (MatrixTriples::getMatrixTriples(6) != 4) {\n        std::cerr << "Assertion failed: getMatrixTriples(6) == 4" << std::endl;\n        return 1;\n    }\n\n    if (MatrixTriples::getMatrixTriples(10) != 36) {\n        std::cerr << "Assertion failed: getMatrixTriples(10) == 36" << std::endl;\n        return 1;\n    }\n\n    if (MatrixTriples::getMatrixTriples(100) != 53361) {\n        std::cerr << "Assertion failed: getMatrixTriples(100) == 53361" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Key Changes:\n\n1. **Module to Class**: Fortran modules are used to encapsulate functions and data, which is similar to classes in C++. The `getMatrixTriples` function is made static to allow calling it without instantiating the class.\n\n2. **Arrays**: Fortran's allocatable arrays are replaced with `std::vector` in C++ for dynamic array allocation. This also handles memory deallocation automatically.\n\n3. **Loop Indices**: Fortran arrays are 1-based, while C++ arrays are 0-based. Adjustments are made accordingly.\n\n4. **Function Arguments**: The function `getMatrixTriples` now takes `n` as an argument and returns the result directly.\n\n5. **Mathematical Operations**: The modulus operation `%` is used in C++ instead of Fortran's `mod`.\n\n6. **Output and Exit**: Error messages are printed to `std::cerr` and the program exits with a non-zero status if an assertion fails, similar to the Fortran `write` and `exit` statements.\n\nThis C++ code should now provide the same functionality as the original Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the translation by comparing the outputs for the same input values.\n\n### Fortran Unit Test Code\n\n```fortran\nmodule matrix_triples_module\n  implicit none\ncontains\n\n  integer function get_matrix_triples(n)\n    integer, intent(in) :: n\n    integer :: i, j, times\n    integer, dimension(:), allocatable :: a\n    integer, dimension(:,:), allocatable :: sum, sum2\n\n    allocate(a(n))\n    allocate(sum(n+1, 3))\n    allocate(sum2(n+1, 3))\n\n    ! Initialize arrays\n    sum = 0\n    sum2 = 0\n\n    ! Fill array 'a' and compute initial sums\n    do i = 1, n\n      a(i) = mod(i*i - i + 1, 3)\n      sum(i+1, :) = sum(i, :)\n      sum(i+1, a(i)+1) = sum(i+1, a(i)+1) + 1\n    end do\n\n    ! Compute sums for times = 1 and 2\n    do times = 1, 2\n      do i = 1, n\n        sum2(i+1, :) = sum2(i, :)\n        do j = 0, 2\n          sum2(i+1, mod(a(i) + j, 3) + 1) = sum2(i+1, mod(a(i) + j, 3) + 1) + sum(i, j+1)\n        end do\n      end do\n      sum = sum2\n      sum2 = 0\n    end do\n\n    get_matrix_triples = sum(n+1, 1)\n  end function get_matrix_triples\n\nend module matrix_triples_module\n\nprogram matrix_triples\n  use matrix_triples_module\n  implicit none\n  integer :: n, result\n\n  ! Test cases\n  result = get_matrix_triples(5)\n  if (result /= 1) then\n    write(*,*) "Assertion failed: get_matrix_triples(5) == 1"\n    call exit(1)\n  end if\n\n  result = get_matrix_triples(6)\n  if (result /= 4) then\n    write(*,*) "Assertion failed: get_matrix_triples(6) == 4"\n    call exit(1)\n  end if\n\n  result = get_matrix_triples(10)\n  if (result /= 36) then\n    write(*,*) "Assertion failed: get_matrix_triples(10) == 36"\n    call exit(1)\n  end if\n\n  result = get_matrix_triples(100)\n  if (result /= 53361) then\n    write(*,*) "Assertion failed: get_matrix_triples(100) == 53361"\n    call exit(1)\n  end if\n\nend program matrix_triples\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n\nclass MatrixTriples {\npublic:\n    static int getMatrixTriples(int n) {\n        std::vector<int> a(n);\n        std::vector<std::vector<int>> sum(n + 1, std::vector<int>(3, 0));\n        std::vector<std::vector<int>> sum2(n + 1, std::vector<int>(3, 0));\n\n        // Initialize arrays\n        sum = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n        sum2 = std::vector<std::vector<int>>(n + 1,
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same functionality and the same assertions as the original Fortran code.\n\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint x_or_y(int n, int x, int y) {\n    bool isPrime = true;\n    if (n < 2) isPrime = false;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            isPrime = false;\n            break;\n        }\n    }\n\n    return isPrime ? x : y;\n}\n\nint main() {\n    // Assertions\n    if (x_or_y(7, 34, 12) != 34) {\n        std::cerr << "Assertion failed: x_or_y(7, 34, 12) == 34" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(15, 8, 5) != 5) {\n        std::cerr << "Assertion failed: x_or_y(15, 8, 5) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3, 33, 5212) != 33) {\n        std::cerr << "Assertion failed: x_or_y(3, 33, 5212) == 33" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1259, 3, 52) != 3) {\n        std::cerr << "Assertion failed: x_or_y(1259, 3, 52) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(7919, -1, 12) != -1) {\n        std::cerr << "Assertion failed: x_or_y(7919, -1, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3609, 1245, 583) != 583) {\n        std::cerr << "Assertion failed: x_or_y(3609, 1245, 583) == 583" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(91, 56, 129) != 129) {\n        std::cerr << "Assertion failed: x_or_y(91, 56, 129) == 129" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(6, 34, 1234) != 1234) {\n        std::cerr << "Assertion failed: x_or_y(6, 34, 1234) == 1234" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1, 2, 0) != 0) {\n        std::cerr << "Assertion failed: x_or_y(1, 2, 0) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(2, 2, 0) != 2) {\n        std::cerr << "Assertion failed: x_or_y(2, 2, 0) == 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `x_or_y` function in both languages.\n\n### Fortran Unit Tests\n\nTo run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Save the following code in a file named `test_main.f90`:\n\n```fortran\nprogram test_main\n    implicit none\n\n    ! Test cases\n    call test_case(7, 34, 12)\n    call test_case(15, 8, 5)\n    call test_case(3, 33, 5212)\n    call test_case(1259, 3, 52)\n    call test_case(7919, -1, 12)\n    call test_case(3609, 1245, 583)\n    call test_case(91, 56, 129)\n    call test_case(6, 34, 1234)\n    call test_case(1, 2, 0)\n    call test_case(2, 2, 0)\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    function x_or_y(n, x, y) result(res)\n        integer, intent(in) :: n, x, y\n        integer :: res\n        logical :: isp\n        integer :: i\n\n        isp = .true.\n        if (n < 2) isp = .false.\n        do i = 2, int(sqrt(real(n)))\n            if (mod(n, i) == 0) then\n                isp = .false.\n                exit\n            end if\n        end do\n\n        if (isp) then\n            res = x\n        else\n            res = y\n        end if\n    end function x_or_y\n\n    subroutine test_case(n, x, y)\n        integer, intent(in) :: n, x, y\n        integer :: expected, result\n\n        expected = x_or_y(n, x, y)\n        result = x_or_y(n, x, y)\n\n        if (result /= expected) then\n            write(*,*) "Test failed: x_or_y(", n, ", ", x, ", ", y, ") == ", expected, ", got ", result\n            call exit(1)\n        end if\n    end subroutine test_case\n\nend program test_main\n```\n\nCompile and run the Fortran code:\n\n```sh\ngfortran test_main.f90 -o test_main\n./test_main\n```\n\n### C++ Unit Tests\n\nTo run the C++ unit tests, you can use a C++ compiler like `g++`. Save the following code in a file named `test_main.cpp`:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint x_or_y(int n, int x, int y) {\n    bool isPrime = true;\n    if (n < 2) isPrime = false;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            isPrime = false;\n            break;\n        }\n    }\n\n    return isPrime ? x : y;\n}\n\nvoid test_case(int n, int x, int y, int expected) {\n    int result = x_or_y(n, x, y);\n    if (result != expected) {\n        std::cerr << "Test failed: x_or_y(" << n << ", " << x << ", " << y << ") == " << expected << ", got " << result << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_case(7, 34, 12, 34);\n    test_case(15, 8, 5, 5);\n    test_case(3, 33, 5212, 33);\n    test_case(1259, 3, 52, 3);\n    test_case(791
Translating the given Fortran code to C++ involves several steps, including changing the syntax for loops, arrays, and function definitions. Here's how the Fortran code can be translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\nint64_t double_the_difference(const std::vector<double>& lst);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(double_the_difference({0.0}) == 0);\n    assert(double_the_difference({5.0, 4.0}) == 25);\n    assert(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert(double_the_difference({-1.0, -2.0, 8.0}) == 0);\n    assert(double_the_difference({0.2, 3.0, 5.0}) == 34);\n\n    int64_t odd_sum = 0;\n    std::vector<double> lst(100, 0.0);\n\n    // Fill the array and calculate odd_sum\n    for (int i = -99; i <= 99; i += 2) {\n        lst[(i + 101) / 2] = static_cast<double>(i);\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    // Check the final assertion\n    int64_t result = double_the_difference(lst);\n    assert(result == odd_sum);\n\n    return 0;\n}\n\nint64_t double_the_difference(const std::vector<double>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        double rounded_value = std::round(lst[i]);\n        if (std::abs(lst[i] - rounded_value) < 1e-4) {\n            if (lst[i] > 0 && static_cast<int64_t>(std::round(rounded_value)) % 2 == 1) {\n                sum += std::pow(static_cast<int64_t>(std::round(rounded_value)), 2);\n            }\n        }\n    }\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n```\n\n### Key Changes:\n\n1. **Data Types**: Fortran's `integer(8)` is equivalent to C++'s `int64_t` for 64-bit integers. The `real(8)` type in Fortran is equivalent to `double` in C++.\n\n2. **Arrays**: Fortran's allocatable arrays are replaced with `std::vector<double>` in C++ for dynamic array functionality.\n\n3. **Looping**: Fortran's `do` loop is replaced with a `for` loop in C++. The loop indices and conditions are adjusted to match C++ syntax.\n\n4. **Math Functions**: Fortran's `nint` and `abs` functions are replaced with `std::round` and `std::abs` from the `<cmath>` header in C++.\n\n5. **Assertions**: The `assert` subroutine in Fortran is replaced with a custom `assert` function in C++ that uses `std::cerr` for error output and `std::exit(1)` to terminate the program if the condition is false.\n\n6. **Program Structure**: The `program` block in Fortran is replaced with the `main` function in C++. The `contains` section in Fortran is replaced by defining functions and variables before `main`.\n\nThis C++ code should provide equivalent functionality to the original Fortran code, with necessary adjustments for language syntax and conventions.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `double_the_difference` function and the overall logic in both implementations.\n\n### Fortran Unit Test Code\n\nTo compile and run the Fortran unit test, you can use a Fortran compiler like `gfortran`. Save the following code in a file named `test_fortran.f90`:\n\n```fortran\nprogram test_fortran\n    implicit none\n    integer :: i\n    real(8), allocatable :: lst(:)\n    integer(8) :: odd_sum, result\n\n    ! Test cases\n    call assert(double_the_difference([real(0.0, 8)]) == 0)\n    call assert(double_the_difference([5.0_8, 4.0_8]) == 25)\n    call assert(double_the_difference([0.1_8, 0.2_8, 0.3_8]) == 0)\n    call assert(double_the_difference([-10.0_8, -20.0_8, -30.0_8]) == 0)\n    call assert(double_the_difference([-1.0_8, -2.0_8, 8.0_8]) == 0)\n    call assert(double_the_difference([0.2_8, 3.0_8, 5.0_8]) == 34)\n\n    ! Initialize variables\n    odd_sum = 0\n    allocate(lst(100))\n    lst = 0.0_8\n\n    ! Fill the array and calculate odd_sum\n    do i = -99, 99, 2\n        lst((i+101)/2) = real(i, 8)\n        if (i > 0 .and. mod(i, 2) == 1) odd_sum = odd_sum + i*i\n    end do\n\n    ! Check the final assertion\n    result = double_the_difference(lst)\n    call assert(result == odd_sum)\n\ncontains\n\n    function double_the_difference(lst) result(sum)\n        implicit none\n        real(8), intent(in) :: lst(:)\n        integer(8) :: sum\n        integer :: i\n        real(8) :: rounded_value\n\n        sum = 0\n        do i = 1, size(lst)\n            rounded_value = nint(lst(i))\n            if (abs(lst(i) - rounded_value) < 1e-4) then\n                if (lst(i) > 0 .and. mod(int(rounded_value), 2) == 1) then\n                    sum = sum + int(rounded_value)**2\n                end if\n            end if\n        end do\n    end function double_the_difference\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_fortran\n```\n\n### C++ Unit Test Code\n\nTo compile and run the C++ unit test, you can use a C++ compiler like `g++`. Save the following code in a file named `test_cpp.cpp`:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\nint64_t double_the_difference(const std::vector<double>& lst);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(double_the_difference({0.0}) == 0);\n    assert(double_the_difference({5.0, 4.0}) == 25);\n    assert(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert(double_the_difference({-1.0, -2.0, 8.0}) == 0
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool cycpattern_check(const std::string& a, const std::string& b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    bool is_pattern = false;\n\n    for (int i = 0; i < len_b; ++i) {\n        std::string rotate = b.substr(i) + b.substr(0, i);\n        // Debugging print statement\n        // std::cout << "Checking rotation: " << rotate << std::endl;\n        if (a.find(rotate) != std::string::npos) {\n            is_pattern = true;\n            return is_pattern;\n        }\n    }\n\n    return is_pattern;\n}\n\nint main() {\n    bool result;\n\n    result = cycpattern_check("xyzw", "xyw");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('xyzw', 'xyw') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("yello", "ell");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('yello', 'ell') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("whattup", "ptut");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('whattup', 'ptut') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("efef", "fee");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('efef', 'fee') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("abab", "aabb");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('abab', 'aabb') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("winemtt", "tinem");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('winemtt', 'tinem') == true" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ code includes the `cycpattern_check` function, which performs the same logic as the Fortran version. The `main` function contains assertions similar to the Fortran program to validate the correctness of the `cycpattern_check` function. If any assertion fails, it prints an error message and exits with a non-zero status.\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the Fortran and C++ versions of the `cycpattern_check` function. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Tests\n\nTo compile and run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Here is the Fortran code with the unit tests:\n\n```fortran\nprogram cycpattern_check_program\n    implicit none\n    logical :: result\n\n    ! Test cases\n    result = cycpattern_check("xyzw", "xyw")\n    if (result) then\n        write(*,*) "Test failed: cycpattern_check('xyzw', 'xyw')"\n    else\n        write(*,*) "Test passed: cycpattern_check('xyzw', 'xyw')"\n    end if\n\n    result = cycpattern_check("yello", "ell")\n    if (.not. result) then\n        write(*,*) "Test failed: cycpattern_check('yello', 'ell')"\n    else\n        write(*,*) "Test passed: cycpattern_check('yello', 'ell')"\n    end if\n\n    result = cycpattern_check("whattup", "ptut")\n    if (result) then\n        write(*,*) "Test failed: cycpattern_check('whattup', 'ptut')"\n    else\n        write(*,*) "Test passed: cycpattern_check('whattup', 'ptut')"\n    end if\n\n    result = cycpattern_check("efef", "fee")\n    if (.not. result) then\n        write(*,*) "Test failed: cycpattern_check('efef', 'fee')"\n    else\n        write(*,*) "Test passed: cycpattern_check('efef', 'fee')"\n    end if\n\n    result = cycpattern_check("abab", "aabb")\n    if (result) then\n        write(*,*) "Test failed: cycpattern_check('abab', 'aabb')"\n    else\n        write(*,*) "Test passed: cycpattern_check('abab', 'aabb')"\n    end if\n\n    result = cycpattern_check("winemtt", "tinem")\n    if (.not. result) then\n        write(*,*) "Test failed: cycpattern_check('winemtt', 'tinem')"\n    else\n        write(*,*) "Test passed: cycpattern_check('winemtt', 'tinem')"\n    end if\n\ncontains\n\n    function cycpattern_check(a, b) result(is_pattern)\n        implicit none\n        character(len=*), intent(in) :: a, b\n        logical :: is_pattern\n        integer :: i, len_a, len_b\n        character(len=:), allocatable :: rotate\n\n        len_a = len(a)\n        len_b = len(b)\n        is_pattern = .false.\n\n        do i = 0, len_b - 1\n            rotate = b(i+1:len_b) // b(1:i)\n            if (index(a, trim(rotate)) /= 0) then\n                is_pattern = .true.\n                return\n            end if\n        end do\n    end function cycpattern_check\n\nend program cycpattern_check_program\n```\n\n### C++ Unit Tests\n\nTo compile and run the C++ unit tests, you can use a C++ compiler like `g++`. Here is the C++ code with the unit tests:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool cycpattern_check(const std::string& a, const std::string& b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    bool is_pattern = false;\n\n    for (int i = 0; i < len_b; ++i) {\n        std::string rotate = b.substr(i) + b.substr(0, i);\n        if (a.find(rotate) != std::string::npos) {\n            is_pattern = true;\n            return is_pattern;\n        }\n    }\n\n    return is_pattern;\n}\n\nvoid test_cycpattern_check(const std::string& a, const std::string& b, bool expected) {\n    bool result = cycpattern_check(a, b);\n    if (result == expected) {\n        std::cout << "Test passed: cycpattern_check('" << a << "', '" << b << "')" << std::endl;\n    } else {\n        std::cerr << "Test failed: cycpattern_check('" << a << "', '" << b << "')" << std::endl;\n    }\n}\n\nint main() {\n    // Test cases\n    test_cycpattern_check("xyzw", "xyw", false);\n    test_cycpattern_check("yello", "ell", true);\n    test_cycpattern_check("whattup", "ptut", false);\n    test_cycpattern_check("efef", "fee", true);\n    test_cycpattern_check("abab", "aabb", false);\n    test_cycpattern_check("winemtt", "tinem", true);\n\n    return 0;\n}\n```\n\n### Explanation\n\n- **Fortran Unit Test
Certainly! Below is the translated C++ code from the provided Fortran code. This C++ code includes the same functionality and test cases as the original Fortran code.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> even_odd_count(int num) {\n    std::string w = std::to_string(std::abs(num));\n    int n1 = 0, n2 = 0;\n\n    for (char c : w) {\n        if (c % 2 == 1) {\n            n1++;\n        } else {\n            n2++;\n        }\n    }\n\n    return {n2, n1};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result, expected;\n\n    // Test cases\n    result = even_odd_count(7);\n    expected = {0, 1};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-78);\n    expected = {1, 1};\n    assert(issame(result, expected));\n\n    result = even_odd_count(3452);\n    expected = {2, 2};\n    assert(issame(result, expected));\n\n    result = even_odd_count(346211);\n    expected = {3, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-345821);\n    expected = {3, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-2);\n    expected = {1, 0};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-45347);\n    expected = {2, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(0);\n    expected = {1, 0};\n    assert(issame(result, expected));\n\n    return 0;\n}\n```\n\nThis C++ code includes the `even_odd_count` function, which computes the number of even and odd digits in a given integer, and the `issame` function to compare two vectors. The `assert` function is used to verify that the output matches the expected result. The `main` function contains the test cases that call `even_odd_count` with various inputs and verify the results using `assert`.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `even_odd_count` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_even_odd_count\n    implicit none\n    integer, dimension(2) :: result\n    integer, dimension(2) :: expected\n\n    ! Test cases\n    result = even_odd_count(7)\n    expected = (/0, 1/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(-78)\n    expected = (/1, 1/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(3452)\n    expected = (/2, 2/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(346211)\n    expected = (/3, 3/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(-345821)\n    expected = (/3, 3/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(-2)\n    expected = (/1, 0/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(-45347)\n    expected = (/2, 3/)\n    call assert(issame(result, expected))\n\n    result = even_odd_count(0)\n    expected = (/1, 0/)\n    call assert(issame(result, expected))\n\ncontains\n\n    function even_odd_count(num) result(counts)\n        integer, intent(in) :: num\n        integer, dimension(2) :: counts\n        character(len=20) :: w\n        integer :: i, n1, n2, len\n\n        ! Convert number to string and get its absolute value\n        write(w, '(I0)') abs(num)\n        len = len_trim(w)\n        n1 = 0\n        n2 = 0\n\n        ! Count even and odd digits\n        do i = 1, len\n            if (mod(ichar(w(i:i)), 2) == 1) then\n                n1 = n1 + 1\n            else\n                n2 = n2 + 1\n            end if\n        end do\n\n        counts = (/n2, n1/)\n    end function even_odd_count\n\n    function issame(a, b) result(same)\n        integer, dimension(2), intent(in) :: a, b\n        logical :: same\n        integer :: i\n\n        same = .true.\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                same = .false.\n                exit\n            end if\n        end do\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_even_odd_count\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> even_odd_count(int num) {\n    std::string w = std::to_string(std::abs(num));\n    int n1 = 0, n2 = 0;\n\n    for (char c : w) {\n        if (c % 2 == 1) {\n            n1++;\n        } else {\n            n2++;\n        }\n    }\n\n    return {n2, n1};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result, expected;\n\n    // Test cases\n    result = even_odd_count(7);\n    expected = {0, 1};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-78);\n    expected = {1, 1};\n    assert(issame(result, expected));\n\n    result = even_odd_count(3452);\n    expected = {2, 2};\n    assert(issame(result, expected));\n\n    result = even_odd_count(346211);\n    expected = {3, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-345821);\n    expected = {3, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-2);\n    expected = {
Translating the given Fortran code to C++ involves several steps, including changing the syntax for loops, function definitions, and conditionals. Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string int_to_mini_romank(int number) {\n    std::string rep[13] = {"m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "};\n    int num[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    std::string current;\n    int pos = 0;\n    int temp_number = number;\n\n    while (temp_number > 0) {\n        while (temp_number >= num[pos]) {\n            current += rep[pos];\n            temp_number -= num[pos];\n        }\n        if (temp_number > 0) ++pos;\n    }\n\n    return current;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(int_to_mini_romank(19) == "xix");\n    assert(int_to_mini_romank(152) == "clii");\n    assert(int_to_mini_romank(251) == "ccli");\n    assert(int_to_mini_romank(426) == "cdxxvi");\n    assert(int_to_mini_romank(500) == "d");\n    assert(int_to_mini_romank(1) == "i");\n    assert(int_to_mini_romank(4) == "iv");\n    assert(int_to_mini_romank(43) == "xliii");\n    assert(int_to_mini_romank(90) == "xc");\n    assert(int_to_mini_romank(94) == "xciv");\n    assert(int_to_mini_romank(532) == "dxxxii");\n    assert(int_to_mini_romank(900) == "cm");\n    assert(int_to_mini_romank(994) == "cmxciv");\n    assert(int_to_mini_romank(1000) == "m");\n\n    return 0;\n}\n```\n\n### Key Points in the Translation:\n\n1. **Function Definition**: The `int_to_mini_romank` function is translated to return a `std::string` and take an `int` parameter, similar to the Fortran version.\n2. **Arrays**: The arrays `rep` and `num` are translated to `std::string` and `int` arrays, respectively.\n3. **Looping**: The Fortran `do` loop is translated to C++ `while` loops.\n4. **String Concatenation**: The Fortran `trim` function and string concatenation are handled using `+=` operator in C++.\n5. **Assertions**: The `assert` subroutine is translated to a `assert` function in C++ that uses `std::cerr` for error output and `exit(1)` to terminate the program if the condition is false.\n6. **Test Cases**: The test cases are directly translated into assertions within the `main` function.\n\nThis C++ code should behave similarly to the original Fortran code, providing the same functionality and passing the same test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the translation by comparing the outputs of both implementations.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_mini_roman\n    implicit none\n    character(len=100) :: result\n\n    ! Test cases\n    call assert(int_to_mini_romank(19) == "xix")\n    call assert(int_to_mini_romank(152) == "clii")\n    call assert(int_to_mini_romank(251) == "ccli")\n    call assert(int_to_mini_romank(426) == "cdxxvi")\n    call assert(int_to_mini_romank(500) == "d")\n    call assert(int_to_mini_romank(1) == "i")\n    call assert(int_to_mini_romank(4) == "iv")\n    call assert(int_to_mini_romank(43) == "xliii")\n    call assert(int_to_mini_romank(90) == "xc")\n    call assert(int_to_mini_romank(94) == "xciv")\n    call assert(int_to_mini_romank(532) == "dxxxii")\n    call assert(int_to_mini_romank(900) == "cm")\n    call assert(int_to_mini_romank(994) == "cmxciv")\n    call assert(int_to_mini_romank(1000) == "m")\n\ncontains\n\n    function int_to_mini_romank(number) result(current)\n        implicit none\n        integer, intent(in) :: number\n        character(len=100) :: current\n        character(len=2), dimension(13) :: rep = ["m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "]\n        integer, dimension(13) :: num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        integer :: pos, temp_number\n\n        current = ""\n        pos = 1\n        temp_number = number\n\n        do while (temp_number > 0)\n            do while (temp_number >= num(pos))\n                current = trim(current) // trim(rep(pos))\n                temp_number = temp_number - num(pos)\n            end do\n            if (temp_number > 0) pos = pos + 1\n        end do\n    end function int_to_mini_romank\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_mini_roman\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string int_to_mini_romank(int number) {\n    std::string rep[13] = {"m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "};\n    int num[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    std::string current;\n    int pos = 0;\n    int temp_number = number;\n\n    while (temp_number > 0) {\n        while (temp_number >= num[pos]) {\n            current += rep[pos];\n            temp_number -= num[pos];\n        }\n        if (temp_number > 0) ++pos;\n    }\n\n    return current;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n   
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool right_angle_triangle(float a, float b, float c) {\n    float epsilon = 1.0e-4f;\n\n    if (std::abs(a * a + b * b - c * c) < epsilon ||\n        std::abs(a * a + c * c - b * b) < epsilon ||\n        std::abs(b * b + c * c - a * a) < epsilon) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    // Assertions\n    if (!right_angle_triangle(3.0f, 4.0f, 5.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(3, 4, 5) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(1.0f, 2.0f, 3.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(1, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(10.0f, 6.0f, 8.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(10, 6, 8) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(2.0f, 2.0f, 2.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(2, 2, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(7.0f, 24.0f, 25.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(7, 24, 25) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(10.0f, 5.0f, 7.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(10, 5, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(5.0f, 12.0f, 13.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(5, 12, 13) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(15.0f, 8.0f, 17.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(15, 8, 17) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(48.0f, 55.0f, 73.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(48, 55, 73) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(1.0f, 1.0f, 1.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(1, 1, 1) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(2.0f, 2.0f, 10.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(2, 2, 10) == false" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ code includes the `right_angle_triangle` function and the main function with assertions to verify the correctness of the function. The `std::abs` function is used for absolute value calculations, and `std::cerr` and `std::exit` are used for error output and program termination, respectively, similar to the Fortran code.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the Fortran and C++ versions of the `right_angle_triangle` function. These tests will verify the correctness of the function with a variety of input values.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_right_angle_triangle\n  implicit none\n\n  ! Test cases\n  call test_case(3.0, 4.0, 5.0, .true.)\n  call test_case(1.0, 2.0, 3.0, .false.)\n  call test_case(10.0, 6.0, 8.0, .true.)\n  call test_case(2.0, 2.0, 2.0, .false.)\n  call test_case(7.0, 24.0, 25.0, .true.)\n  call test_case(10.0, 5.0, 7.0, .false.)\n  call test_case(5.0, 12.0, 13.0, .true.)\n  call test_case(15.0, 8.0, 17.0, .true.)\n  call test_case(48.0, 55.0, 73.0, .true.)\n  call test_case(1.0, 1.0, 1.0, .false.)\n  call test_case(2.0, 2.0, 10.0, .false.)\n\ncontains\n\n  logical function right_angle_triangle(a, b, c)\n    implicit none\n    real :: a, b, c\n    real :: epsilon\n    epsilon = 1.0e-4\n\n    if (abs(a*a + b*b - c*c) < epsilon .or. abs(a*a + c*c - b*b) < epsilon .or. abs(b*b + c*c - a*a) < epsilon) then\n      right_angle_triangle = .true.\n    else\n      right_angle_triangle = .false.\n    end if\n  end function right_angle_triangle\n\n  subroutine test_case(a, b, c, expected)\n    real :: a, b, c\n    logical :: expected\n    logical :: result\n\n    result = right_angle_triangle(a, b, c)\n    if (result .eqv. expected) then\n      write(*,*) "Test passed for: ", a, b, c\n    else\n      write(*,*) "Test failed for: ", a, b, c, "Expected: ", expected, "Got: ", result\n    end if\n  end subroutine test_case\n\nend program test_right_angle_triangle\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool right_angle_triangle(float a, float b, float c) {\n    float epsilon = 1.0e-4f;\n\n    if (std::abs(a * a + b * b - c * c) < epsilon ||\n        std::abs(a * a + c * c - b * b) < epsilon ||\n        std::abs(b * b + c * c - a * a) < epsilon) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid test_case(float a, float b, float c, bool expected) {\n    bool result = right_angle_triangle(a, b, c);\n    if (result == expected) {\n        std::cout << "Test passed for: " << a << " " << b << " " << c << std::endl;\n    } else {\n        std::cout << "Test failed for: " << a << " " << b << " " << c << ". Expected: " << expected << ". Got: " << result <<
Translating the provided Fortran code to C++ involves several steps, including handling arrays, strings, and the logic of finding the maximum string based on its unique characters. Here's a C++ version of the code, including unit tests similar to the Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string max_word = "";\n    int maxu = 0;\n\n    for (const auto& word : words) {\n        std::string unique;\n        for (char c : word) {\n            if (unique.find(c) == std::string::npos) {\n                unique += c;\n            }\n        }\n        if (unique.length() > maxu || (unique.length() == maxu && word < max_word)) {\n            max_word = word;\n            maxu = unique.length();\n        }\n    }\n    return max_word;\n}\n\nvoid run_tests() {\n    std::vector<std::string> words;\n    std::string result;\n\n    // Test 1\n    words = {"name   ", "of     ", "string "};\n    result = find_max(words);\n    if (result != "string") {\n        std::cerr << "Test 1 failed: expected 'string', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 2\n    words = {"name   ", "enam   ", "game   "};\n    result = find_max(words);\n    if (result != "enam") {\n        std::cerr << "Test 2 failed: expected 'enam', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 3\n    words = {"aaaaaaa", "bb     ", "cc     "};\n    result = find_max(words);\n    if (result != "aaaaaaa") {\n        std::cerr << "Test 3 failed: expected 'aaaaaaa', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 4\n    words = {"abc    ", "cba    "};\n    result = find_max(words);\n    if (result != "abc") {\n        std::cerr << "Test 4 failed: expected 'abc', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 5\n    words = {"play    ", "this    ", "game    ", "of      ", "footbott"};\n    result = find_max(words);\n    if (result != "footbott") {\n        std::cerr << "Test 5 failed: expected 'footbott', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 6\n    words = {"we      ", "are     ", "gonna   ", "rock    "};\n    result = find_max(words);\n    if (result != "gonna") {\n        std::cerr << "Test 6 failed: expected 'gonna', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 7\n    words = {"we      ", "are     ", "a       ", "mad     ", "nation  "};\n    result = find_max(words);\n    if (result != "nation") {\n        std::cerr << "Test 7 failed: expected 'nation', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 8\n    words = {"this    ", "is      ", "a       ", "prrk    "};\n    result = find_max(words);\n    if (result != "this") {\n        std::cerr << "Test 8 failed: expected 'this', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 9\n    words = {"b       "};\n    result = find_max(words);\n    if (result != "b") {\n        std::cerr << "Test 9 failed: expected 'b', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 10\n    words = {"play    ", "play    ", "play    "};\n    result = find_max(words);\n    if (result != "play") {\n        std::cerr << "Test 10 failed: expected 'play', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\nThis C++ code includes the `find_max` function, which takes a vector of strings and returns the string with the maximum number of unique characters, based on the original Fortran logic. The `run_tests` function contains several test cases to verify the correctness of the `find_max` function. If any test fails, it prints an error message and exits with a non-zero status. If all tests pass, it prints "All tests passed."\nLet's write some test to verify if the translation is correct. \nTo verify the correctness of both the original Fortran code and the translated C++ code, we can create unit tests that cover various scenarios. Below are the complete and corrected versions of both the Fortran and C++ code with their respective unit tests.\n\n### Fortran Code with Unit Tests\n\n```fortran\nmodule find_max_module\n    implicit none\ncontains\n\n    function find_max(words) result(max_word)\n        implicit none\n        character(len=100), dimension(:), intent(in) :: words\n        character(len=100) :: max_word\n        character(len=100) :: unique, word\n        integer :: i, j, maxu, len_words\n\n        max_word = ""\n        maxu = 0\n        len_words = size(words)\n\n        do i = 1, len_words\n            word = words(i)\n            unique = ""\n            do j = 1, len_trim(word)\n                if (index(unique, word(j:j)) == 0) then\n                    unique = trim(unique) // word(j:j)\n                end if\n            end do\n            if (len_trim(unique) > maxu .or. (len_trim(unique) == maxu .and. word < max_word)) then\n                max_word = word\n                maxu = len_trim(unique)\n            end if\n        end do\n    end function find_max\n\nend module find_max_module\n\nprogram main\n    use find_max_module\n    implicit none\n    character(len=100), dimension(:), allocatable :: words\n    character(len=100) :: result\n\n    ! Test 1\n    allocate(words(3))\n    words = ['name   ', 'of     ', 'string ']\n    result = find_max(words)\n    if (trim(result) /= 'string') then\n        write(*,*) "Test 1 failed: expected 'string', got ", trim(result)\n        call exit(1)\n    end if\n    deallocate(words)\n\n    ! Test 2\n    allocate(words(3))\n    words = ['name   ', 'enam   ', 'game   ']\n    result = find_max(words)\n    if (trim(result) /= 'enam') then\n        write(*,*) "Test 2 failed: expected 'enam', got ", trim(result)\n        call exit(1)\n    end if\n    deallocate(words)\n\n    ! Test 3\n    allocate(words(3))\n    words = ['aaaaaaa', 'bb     ', 'cc     ']\n    result = find_max(words)\n    if (trim(result) /= 'aaaaaaa') then\n        write(*,*) "Test 3 failed: expected 'aaaaaaa', got ", trim(result)\n        call exit(1)\n    end if\n    deallocate(words)\n\n    ! Test 4\n    allocate(words(2))\n    words = ['abc    ', 'cba    ']\n    result = find_max(words)\n    if (trim(result) /= 'abc') then\n        write(*,*) "Test 4 failed: expected 'abc', got ", trim(result)\n        call
Certainly! Here's the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <array>\n#include <cstdlib>\n\nstd::array<int, 2> eat(int number, int need, int remaining) {\n    if (need > remaining) {\n        return {number + remaining, 0};\n    } else {\n        return {number + need, remaining - need};\n    }\n}\n\nbool issame(const std::array<int, 2>& a, const std::array<int, 2>& b) {\n    for (int i = 0; i < 2; ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::array<int, 2> result;\n    std::array<int, 2> expected;\n\n    // Test cases\n    result = eat(5, 6, 10);\n    expected = {11, 4};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(5, 6, 10) == {11, 4}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(4, 8, 9);\n    expected = {12, 1};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 8, 9) == {12, 1}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(1, 10, 10);\n    expected = {11, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(1, 10, 10) == {11, 0}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(2, 11, 5);\n    expected = {7, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(2, 11, 5) == {7, 0}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(4, 5, 7);\n    expected = {9, 2};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 7) == {9, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(4, 5, 1);\n    expected = {5, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 1) == {5, 0}" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code mirrors the functionality of the original Fortran program, including the `eat` function and the `issame` function to compare the results of the `eat` function with expected values. If any test fails, it prints an error message and exits with a non-zero status. If all tests pass, it prints "All tests passed."\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `eat` function and the `issame` function.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n  implicit none\n\n  call test_eat()\n  call test_issame()\n\ncontains\n\n  subroutine test_eat()\n    integer, dimension(2) :: result\n    integer, dimension(2) :: expected\n\n    ! Test case 1\n    result = eat(5, 6, 10)\n    expected = (/11, 4/)\n    call assert_equal(result, expected, "eat(5, 6, 10)")\n\n    ! Test case 2\n    result = eat(4, 8, 9)\n    expected = (/12, 1/)\n    call assert_equal(result, expected, "eat(4, 8, 9)")\n\n    ! Test case 3\n    result = eat(1, 10, 10)\n    expected = (/11, 0/)\n    call assert_equal(result, expected, "eat(1, 10, 10)")\n\n    ! Test case 4\n    result = eat(2, 11, 5)\n    expected = (/7, 0/)\n    call assert_equal(result, expected, "eat(2, 11, 5)")\n\n    ! Test case 5\n    result = eat(4, 5, 7)\n    expected = (/9, 2/)\n    call assert_equal(result, expected, "eat(4, 5, 7)")\n\n    ! Test case 6\n    result = eat(4, 5, 1)\n    expected = (/5, 0/)\n    call assert_equal(result, expected, "eat(4, 5, 1)")\n\n  end subroutine test_eat\n\n  subroutine test_issame()\n    integer, dimension(2) :: a, b\n    logical :: result\n\n    ! Test case 1\n    a = (/1, 2/)\n    b = (/1, 2/)\n    result = issame(a, b)\n    call assert_true(result, "issame(a, b) with a = (/1, 2/), b = (/1, 2/)")\n\n    ! Test case 2\n    a = (/3, 4/)\n    b = (/5, 6/)\n    result = issame(a, b)\n    call assert_false(result, "issame(a, b) with a = (/3, 4/), b = (/5, 6/)")\n\n  end subroutine test_issame\n\n  function eat(number, need, remaining) result(res)\n    integer, intent(in) :: number, need, remaining\n    integer, dimension(2) :: res\n\n    if (need > remaining) then\n      res = (/number + remaining, 0/)\n    else\n      res = (/number + need, remaining - need/)\n    end if\n  end function eat\n\n  logical function issame(a, b)\n    integer, dimension(2), intent(in) :: a, b\n    integer :: i\n\n    issame = .true.\n    do i = 1, 2\n      if (a(i) /= b(i)) then\n        issame = .false.\n        return\n      end if\n    end do\n  end function issame\n\n  subroutine assert_equal(result, expected, message)\n    integer, dimension(2), intent(in) :: result, expected\n    character(len=*), intent(in) :: message\n\n    if (result /= expected) then\n      write(*,*) "Assertion failed:", trim(message)\n      stop 1\n    end if\n  end subroutine assert_equal\n\n  subroutine assert_true(condition, message)\n    logical, intent(in) :: condition\n    character(len=*), intent(in) :: message\n\n    if (.not. condition) then\n      write(*,*) "Assertion failed:", trim(message)\n      stop 1\n    end if\n  end subroutine assert_true\n\n  subroutine assert_false(condition, message)\n    logical, intent(in) :: condition\n    character(len=*), intent(in) :: message\n\n    if (condition) then\n      write(*,*) "Assertion failed:", trim(message)\n      stop 1\n    end if\n  end subroutine assert_false\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <array>\n#include <cstdlib>\n\nstd::array<int, 2> eat(int number, int need, int remaining) {\n    if (need > remaining) {\n        return {number + remaining, 0};\n    } else {\n        return {number + need, remaining - need};\n   
Certainly! Below is the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cctype> // for std::tolower and std::toupper\n\nstd::string solve(const std::string& s) {\n    std::string out;\n    int nletter = 0;\n    bool is_reversed = true;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (isupper(c)) {\n                out += std::tolower(c);\n            } else {\n                out += std::toupper(c);\n            }\n        } else {\n            nletter++;\n            out += c;\n        }\n    }\n\n    if (nletter == s.size()) {\n        std::reverse(out.begin(), out.end());\n    }\n\n    return out;\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string rev;\n    for (char c : s) {\n        rev += c;\n    }\n    std::reverse(rev.begin(), rev.end());\n    return rev;\n}\n\nint main() {\n    std::string s, result;\n\n    // Test cases\n    s = "AsDf";\n    result = solve(s);\n    if (result != "aSdF") {\n        std::cerr << "Assertion failed: solve('AsDf') == 'aSdF'" << std::endl;\n        return 1;\n    }\n\n    s = "1234";\n    result = solve(s);\n    if (result != "4321") {\n        std::cerr << "Assertion failed: solve('1234') == '4321'" << std::endl;\n        return 1;\n    }\n\n    s = "ab";\n    result = solve(s);\n    if (result != "AB") {\n        std::cerr << "Assertion failed: solve('ab') == 'AB'" << std::endl;\n        return 1;\n    }\n\n    s = "#a@C";\n    result = solve(s);\n    if (result != "#A@c") {\n        std::cerr << "Assertion failed: solve('#a@C') == '#A@c'" << std::endl;\n        return 1;\n    }\n\n    s = "#AsdfW^45";\n    result = solve(s);\n    if (result != "#aSDFw^45") {\n        std::cerr << "Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'" << std::endl;\n        return 1;\n    }\n\n    s = "#6@2";\n    result = solve(s);\n    if (result != "2@6#") {\n        std::cerr << "Assertion failed: solve('#6@2') == '2@6#'" << std::endl;\n        return 1;\n    }\n\n    s = "#$a^D";\n    result = solve(s);\n    if (result != "#$A^d") {\n        std::cerr << "Assertion failed: solve('#$a^D') == '#$A^d'" << std::endl;\n        return 1;\n    }\n\n    s = "#ccc";\n    result = solve(s);\n    if (result != "#CCC") {\n        std::cerr << "Assertion failed: solve('#ccc') == '#CCC'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code includes the `solve` function, which mimics the functionality of the Fortran `solve` function, and the `reverse_string` function, which is used to reverse the string. The `main` function contains the test cases that verify the correctness of the `solve` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `solve` function in both languages.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_solve\n    implicit none\n    character(len=100) :: s, result\n\n    ! Test cases\n    s = "AsDf"\n    result = solve(trim(s))\n    if (trim(result) /= "aSdF") then\n        write(*,*) "Assertion failed: solve('AsDf') == 'aSdF'"\n        call exit(1)\n    end if\n\n    s = "1234"\n    result = solve(trim(s))\n    if (trim(result) /= "4321") then\n        write(*,*) "Assertion failed: solve('1234') == '4321'"\n        call exit(1)\n    end if\n\n    s = "ab"\n    result = solve(trim(s))\n    if (trim(result) /= "AB") then\n        write(*,*) "Assertion failed: solve('ab') == 'AB'"\n        call exit(1)\n    end if\n\n    s = "#a@C"\n    result = solve(trim(s))\n    if (trim(result) /= "#A@c") then\n        write(*,*) "Assertion failed: solve('#a@C') == '#A@c'"\n        call exit(1)\n    end if\n\n    s = "#AsdfW^45"\n    result = solve(trim(s))\n    if (trim(result) /= "#aSDFw^45") then\n        write(*,*) "Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'"\n        call exit(1)\n    end if\n\n    s = "#6@2"\n    result = solve(trim(s))\n    if (trim(result) /= "2@6#") then\n        write(*,*) "Assertion failed: solve('#6@2') == '2@6#'"\n        call exit(1)\n    end if\n\n    s = "#$a^D"\n    result = solve(trim(s))\n    if (trim(result) /= "#$A^d") then\n        write(*,*) "Assertion failed: solve('#$a^D') == '#$A^d'"\n        call exit(1)\n    end if\n\n    s = "#ccc"\n    result = solve(trim(s))\n    if (trim(result) /= "#CCC") then\n        write(*,*) "Assertion failed: solve('#ccc') == '#CCC'"\n        call exit(1)\n    end if\n\n    write(*,*) "All tests passed."\n\ncontains\n\n    function solve(s) result(out)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=100) :: out\n        integer :: i, nletter, len_s\n        character(len=1) :: w\n\n        nletter = 0\n        out = ""\n        len_s = len_trim(s)\n\n        do i = 1, len_s\n            w = s(i:i)\n            if (iachar(w) >= 65 .and. iachar(w) <= 90) then\n                w = achar(iachar(w) + 32)\n            else if (iachar(w) >= 97 .and. iachar(w) <= 122) then\n                w = achar(iachar(w) - 32)\n            else\n                nletter = nletter + 1\n            end if\n            out = trim(out) // w\n        end do\n\n        if (nletter == len_s) then\n            out = reverse_string(trim(out))\n        end if\n    end function solve\n\n    function reverse_string(s) result(rev)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=100) :: rev\n        integer :: i, len_s\n\n        len_s = len_trim(s)\n        rev = ""\n        do i = len_s, 1, -1\n            rev = trim(rev) // s(i:i)\n        end do\n    end function reverse_string\n\nend program test_solve\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream
Translating the provided Fortran code to C++ involves several steps, including handling dynamic arrays, subroutine and function translations, and the logic of generating and comparing arrays of integers. Below is a C++ version of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to generate integers between a and b, inclusive, that are evenly divisible by 2\nstd::vector<int> generate_integers(int a, int b) {\n    std::vector<int> result;\n    int temp_a = a, temp_b = b;\n\n    // Swap if b < a\n    if (temp_b < temp_a) {\n        std::swap(temp_a, temp_b);\n    }\n\n    for (int i = temp_a; i <= temp_b; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\n// Function to compare two vectors\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine equivalent to assert in Fortran\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result;\n    std::vector<int> empty_array;\n\n    // Test 1\n    result = generate_integers(2, 10);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    // Test 2\n    result = generate_integers(10, 2);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    // Test 3\n    result = generate_integers(132, 2);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    // Test 4\n    result = generate_integers(17, 89);\n    assert(issame(result, empty_array)); // Using an empty vector for comparison\n\n    return 0;\n}\n```\n\nKey Points in the Translation:\n\n1. **Dynamic Arrays**: C++ uses `std::vector` for dynamic arrays, which is more flexible and safer than raw pointers.\n\n2. **Function and Subroutine Translation**: Fortran subroutines and functions are translated into C++ functions. The `generate_integers` function and `issame` function are translated directly, and the `assert` subroutine is translated into a function.\n\n3. **Logic Translation**: The logic for generating even-valued integers between two numbers, and comparing two arrays, is directly translated from Fortran to C++.\n\n4. **Assertion**: The `assert` function in C++ is used to check conditions, similar to the Fortran version. If the condition is false, it prints an error message and exits with a non-zero status.\n\n5. **Test Cases**: The main function in C++ serves as the entry point for the program, and it includes several test cases to verify the functionality of `generate_integers` and `issame` functions.\n\nThis C++ code should provide equivalent functionality to the original Fortran code, ensuring the same logic and output for the given test cases.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `generate_integers` and `issame` functions.\n\n### Fortran Unit Test Code\n\n```fortran\nprogram test_main\n    implicit none\n    integer, allocatable :: result(:)\n    integer, allocatable :: empty_array(:)\n    integer :: i\n\n    ! Create a zero-sized array for comparison\n    allocate(empty_array(0))\n\n    ! Test 1\n    call generate_integers(2, 10, result)\n    call assert(issame(result, [2, 4, 6, 8]))\n\n    ! Test 2\n    call generate_integers(10, 2, result)\n    call assert(issame(result, [2, 4, 6, 8]))\n\n    ! Test 3\n    call generate_integers(132, 2, result)\n    call assert(issame(result, [2, 4, 6, 8]))\n\n    ! Test 4\n    call generate_integers(17, 89, result)\n    call assert(issame(result, empty_array))  ! Use the zero-sized array for comparison\n\ncontains\n\n    subroutine generate_integers(a, b, out)\n        integer, intent(in) :: a, b\n        integer, allocatable, intent(out) :: out(:)\n        integer :: i, m, temp_a, temp_b\n        integer, allocatable :: temp(:)\n        integer :: count\n\n        temp_a = a\n        temp_b = b\n\n        if (temp_b < temp_a) then\n            m = temp_a\n            temp_a = temp_b\n            temp_b = m\n        end if\n\n        count = 0\n        allocate(temp(temp_b - temp_a + 1))\n        do i = temp_a, temp_b\n            if (i < 10 .and. mod(i, 2) == 0) then\n                count = count + 1\n                temp(count) = i\n            end if\n        end do\n\n        if (count > 0) then\n            allocate(out(count))\n            out = temp(1:count)\n        else\n            allocate(out(0))\n        end if\n\n        deallocate(temp)\n    end subroutine generate_integers\n\n    logical function issame(a, b)\n        integer, intent(in) :: a(:), b(:)\n        integer :: i\n\n        if (size(a) /= size(b)) then\n            issame = .false.\n            return\n        end if\n\n        do i = 1, size(a)\n            if (a(i) /= b(i)) then\n                issame = .false.\n                return\n            end if\n        end do\n\n        issame = .true.\n    end function issame\n\n    subroutine assert(condition)\n        logical, intent(in) :: condition\n        if (.not. condition) then\n            write(*,*) "Assertion failed"\n            call exit(1)\n        end if\n    end subroutine assert\n\nend program test_main\n```\n\n### C++ Unit Test Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to generate integers between a and b, inclusive, that are evenly divisible by 2\nstd::vector<int> generate_integers(int a, int b) {\n    std::vector<int> result;\n    int temp_a = a, temp_b = b;\n\n    // Swap if b < a\n    if (temp_b < temp_a) {\n        std::swap(temp_a, temp_b);\n    }\n\n    for (int i = temp_a; i <= temp_b; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\n// Function to compare two vectors\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine equivalent to assert in Fortran\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;
