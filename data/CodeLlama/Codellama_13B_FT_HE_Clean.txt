#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test case 1\n    std::vector<double> a = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    if (!has_close_elements(a, 0.3)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.05)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    a = {1.0, 2.0, 5.9, 4.0, 5.0};\n    if (!has_close_elements(a, 0.95)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.8)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    a = {1.0, 2.0, 3.0, 4.0, 5.0};\n    if (!has_close_elements(a, 2.0)) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    a = {1.1, 2.2, 3.1, 4.1, 5.1};\n    if (!has_close_elements(a, 1.0)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, 0.5)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool below_zero(const std::vector<int>& operations) {\n    int num = 0;\n    for (int op : operations) {\n        num += op;\n        if (num < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> operations;\n    bool result;\n\n    // Test case 1: Empty vector\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2: Vector with positive and negative numbers\n    operations = {1, 2, -3, 1, 2, -3};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3: Vector with positive numbers\n    operations = {1, 2, -4, 5, 6};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 4: Vector with positive and negative numbers\n    operations = {1, -1, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 5: Vector with positive and negative numbers\n    operations = {1, -1, 2, -2, 5, -5, 4, -5};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 6: Vector with positive and negative numbers\n    operations = {1, -2, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    int n = numbers.size();\n    float sum = 0.0f;\n    for (int i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    float avg = sum / n;\n\n    float msum = 0.0f;\n    for (int i = 0; i < n; ++i) {\n        msum += std::abs(numbers[i] - avg);\n    }\n    return msum / n;\n}\n\nint main() {\n    // Test cases\n    std::vector<float> test_case_1 = {1.0f, 2.0f, 3.0f};\n    if (std::abs(mean_absolute_deviation(test_case_1) - 2.0f / 3.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<float> test_case_2 = {1.0f, 2.0f, 3.0f, 4.0f};\n    if (std::abs(mean_absolute_deviation(test_case_2) - 1.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    std::vector<float> test_case_3 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    if (std::abs(mean_absolute_deviation(test_case_3) - 6.0f / 5.0f) > 1e-4) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid intersperse(const std::vector<int>& numbers, int delimeter, std::vector<int>& out) {\n    if (numbers.empty()) {\n        out.clear();\n        return;\n    }\n    out.resize(2 * numbers.size() - 1);\n    out[0] = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        out[2 * i - 1] = delimeter;\n        out[2 * i] = numbers[i];\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n    int delimeter;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    intersperse(numbers, 7, result);\n    assert(issame(result, expected));\n\n    // Test case 2\n    numbers = {5, 6, 3, 2};\n    expected = {5, 8, 6, 8, 3, 8, 2};\n    intersperse(numbers, 8, result);\n    assert(issame(result, expected));\n\n    // Test case 3\n    numbers = {2, 2, 2};\n    expected = {2, 2, 2, 2, 2};\n    intersperse(numbers, 2, result);\n    assert(issame(result, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nvoid parse_nested_parens(const std::string& paren_string, std::vector<int>& all_levels) {\n    int level = 0;\n    int max_level = 0;\n    all_levels.clear();\n\n    for (char chr : paren_string) {\n        if (chr == '(') {\n            level++;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level--;\n            if (level == 0) {\n                all_levels.push_back(max_level);\n                max_level = 0;\n            }\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nint main() {\n    std::string paren_string;\n    std::vector<int> result;\n    std::vector<int> expected1 = {2, 3, 1, 3};\n    std::vector<int> expected2 = {1, 2, 3, 4};\n    std::vector<int> expected3 = {4};\n    bool is_same;\n\n    paren_string = "(()()) ((())) () ((())()())";\n    parse_nested_parens(paren_string, result);\n    is_same = issame(result, expected1);\n    if (!is_same) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    paren_string = "() (()) ((())) (((())))";\n    parse_nested_parens(paren_string, result);\n    is_same = issame(result, expected2);\n    if (!is_same) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    paren_string = "(()(())((())))";\n    parse_nested_parens(paren_string, result);\n    is_same = issame(result, expected3);\n    if (!is_same) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> empty_array;\n    std::vector<int> array1 = {1, 1, 1};\n    std::vector<int> array2 = {100, 0};\n    std::vector<int> array3 = {3, 5, 7};\n    std::vector<int> array4 = {10};\n\n    // Test cases\n    auto result = sum_product(empty_array);\n    if (!issame(result, {0, 1})) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array1);\n    if (!issame(result, {3, 1})) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array2);\n    if (!issame(result, {100, 0})) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array3);\n    if (!issame(result, {3 + 5 + 7, 3 * 5 * 7})) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    result = sum_product(array4);\n    if (!issame(result, {10, 10})) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\n// Function to find the rolling maximum\nvoid rolling_max(const std::vector<int>& numbers, std::vector<int>& out) {\n    int max = 0;\n    for (int num : numbers) {\n        if (num > max) max = num;\n        out.push_back(max);\n    }\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\n// Assert function to check conditions\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> numbers{};\n    std::vector<int> result;\n    std::vector<int> expected{};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 2\n    numbers = {1, 2, 3, 4};\n    expected = {1, 2, 3, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 3\n    numbers = {4, 3, 2, 1};\n    expected = {4, 4, 4, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 4\n    numbers = {3, 2, 3, 100, 3};\n    expected = {3, 3, 3, 100, 100};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function prototypes\nbool is_palindrome(const std::string& str);\nstd::string make_palindrome(const std::string& str);\nstd::string reverse_string(const std::string& str);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(make_palindrome("") == "");\n    assert(make_palindrome("x") == "x");\n    assert(make_palindrome("xyz") == "xyzyx");\n    assert(make_palindrome("xyx") == "xyx");\n    assert(make_palindrome("jerry") == "jerryrrej");\n\n    return 0;\n}\n\nbool is_palindrome(const std::string& str) {\n    std::string reversed_str = reverse_string(str);\n    return str == reversed_str;\n}\n\nstd::string make_palindrome(const std::string& str) {\n    std::string rstr, nstr, n2str;\n    for (size_t i = 0; i < str.length(); ++i) {\n        rstr = str.substr(i);\n        if (is_palindrome(rstr)) {\n            nstr = str.substr(0, i);\n            n2str = reverse_string(nstr);\n            return str + n2str;\n        }\n    }\n    n2str = reverse_string(str);\n    return str + n2str;\n}\n\nstd::string reverse_string(const std::string& str) {\n    std::string reversed_str = "";\n    for (size_t i = 0; i < str.length(); ++i) {\n        reversed_str += str[str.length() - i - 1];\n    }\n    return reversed_str;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n
#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(const std::string& a, const std::string& b) {\n    std::string output;\n    size_t len_a = a.length(), len_b = b.length();\n    size_t min_len = std::min(len_a, len_b);\n\n    for (size_t i = 0; i < min_len; ++i) {\n        if (a[i] == b[i]) {\n            output += '0';\n        } else {\n            output += '1';\n        }\n    }\n\n    if (len_a > len_b) {\n        output += a.substr(min_len);\n    } else if (len_b > len_a) {\n        output += b.substr(min_len);\n    }\n\n    return output;\n}\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_xor("111000", "101010");\n    if (result != "010010") {\n        std::cerr << "Assertion failed: string_xor('111000', '101010') /= '010010'" << std::endl;\n        return 1;\n    }\n\n    result = string_xor("1", "1");\n    if (result != "0") {\n        std::cerr << "Assertion failed: string_xor('1', '1') /= '0'" << std::endl;\n        return 1;\n    }\n\n    result = string_xor("0101", "0000");\n    if (result != "0101") {\n        std::cerr << "Assertion failed: string_xor('0101', '0000') /= '0101'" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass StringUtils {\npublic:\n    static std::string longest(const std::vector<std::string>& strings) {\n        if (strings.empty()) return "";\n        std::string longestStr = strings[0];\n        for (size_t i = 1; i < strings.size(); ++i) {\n            longestStr = (longestStr.size() > strings[i].size()) ? longestStr : strings[i];\n        }\n        return longestStr;\n    }\n};\n\nint main() {\n    // Test case 1: Empty array\n    std::vector<std::string> strings1 = {};\n    std::string result1 = StringUtils::longest(strings1);\n    if (!result1.empty()) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2: Array with single character strings\n    std::vector<std::string> strings2 = {"x", "y", "z"};\n    std::string result2 = StringUtils::longest(strings2);\n    if (result2 != "x") {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3: Array with varying length strings\n    std::vector<std::string> strings3 = {"x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "};\n    std::string result3 = StringUtils::longest(strings3);\n    if (result3 != "zzzz    ") {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib>\n\n// Function to calculate the greatest common divisor\nint greatest_common_divisor(int a, int b) {\n    int temp_a = a, temp_b = b;\n\n    while (true) {\n        if (temp_a < temp_b) {\n            std::swap(temp_a, temp_b);\n        }\n        temp_a = temp_a % temp_b;\n        if (temp_a == 0) {\n            return temp_b;\n        }\n    }\n}\n\n// Assert function to verify the correctness\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(greatest_common_divisor(3, 7) == 1, "Assertion failed: gcd(3, 7) == 1");\n    assert(greatest_common_divisor(10, 15) == 5, "Assertion failed: gcd(10, 15) == 5");\n    assert(greatest_common_divisor(49, 14) == 7, "Assertion failed: gcd(49, 14) == 7");\n    assert(greatest_common_divisor(144, 60) == 12, "Assertion failed: gcd(144, 60) == 12");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid all_prefixes(const std::string& str, std::vector<std::string>& out) {\n    if (str.empty()) {\n        out.push_back("");\n        return;\n    }\n\n    out.clear();\n    std::string current;\n    for (size_t i = 0; i < str.length(); ++i) {\n        current += str[i];\n        out.push_back(current);\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<std::string> prefixes;\n    std::vector<std::string> expected;\n\n    // Test case 1\n    all_prefixes("", prefixes);\n    expected = {""};\n    assert(issame(prefixes, expected));\n\n    // Test case 2\n    all_prefixes("asdfgh", prefixes);\n    expected = {"a", "as", "asd", "asdf", "asdfg", "asdfgh"};\n    assert(issame(prefixes, expected));\n\n    // Test case 3\n    all_prefixes("WWW", prefixes);\n    expected = {"W", "WW", "WWW"};\n    assert(issame(prefixes, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    ss << "0";\n    for (int i = 1; i <= n; ++i) {\n        ss << " " << i;\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string result;\n\n    // Test cases\n    result = string_sequence(0);\n    if (result != "0") {\n        std::cerr << "Assertion failed: string_sequence(0) == '0'" << std::endl;\n        exit(1);\n    }\n\n    result = string_sequence(3);\n    if (result != "0 1 2 3") {\n        std::cerr << "Assertion failed: string_sequence(3) == '0 1 2 3'" << std::endl;\n        exit(1);\n    }\n\n    result = string_sequence(10);\n    if (result != "0 1 2 3 4 5 6 7 8 9 10") {\n        std::cerr << "Assertion failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype> // For std::tolower\n\n// Function to count distinct characters in a string\nint count_distinct_characters(const std::string& str) {\n    std::string lower_str = to_lower(str);\n    std::vector<char> distinct;\n    int count = 0;\n\n    for (char c : lower_str) {\n        if (std::find(distinct.begin(), distinct.end(), c) == distinct.end()) {\n            distinct.push_back(c);\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Function to convert a string to lowercase\nstd::string to_lower(const std::string& str) {\n    std::string lower_str = str;\n    for (char& c : lower_str) {\n        c = std::tolower(static_cast<unsigned char>(c));\n    }\n    return lower_str;\n}\n\nint main() {\n    // Test cases\n    std::string str;\n    int result;\n\n    str = "";\n    result = count_distinct_characters(str);\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_distinct_characters('') == 0" << std::endl;\n        return 1;\n    }\n\n    str = "abcde";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('abcde') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "abcdecadeCADE";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('abcdecadeCADE') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "aaaaAAAAaaaa";\n    result = count_distinct_characters(str);\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_distinct_characters('aaaaAAAAaaaa') == 1" << std::endl;\n        return 1;\n    }\n\n    str = "Jerry jERRY JeRRRY";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('Jerry jERRY JeRRRY') == 5" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nstd::vector<int> parse_music(const std::string& music_string) {\n    std::vector<int> out;\n    std::string current;\n    std::string local_music_string = music_string;\n\n    if (!local_music_string.empty()) {\n        local_music_string += ' ';\n    }\n\n    for (size_t i = 0; i < local_music_string.size(); ++i) {\n        if (local_music_string[i] == ' ') {\n            if (current == "o") {\n                out.push_back(4);\n            } else if (current == "o|") {\n                out.push_back(2);\n            } else if (current == ".|") {\n                out.push_back(1);\n            }\n            current.clear();\n        } else {\n            current += local_music_string[i];\n        }\n    }\n\n    return out;\n}\n\nvoid append(std::vector<int>& array, int value) {\n    array.push_back(value);\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(issame(parse_music(""), std::vector<int>{}));\n    assert(issame(parse_music("o o o o"), std::vector<int>{4, 4, 4, 4}));\n    assert(issame(parse_music(".| .| .| .|"), std::vector<int>{1, 1, 1, 1}));\n    assert(issame(parse_music("o| o| .| .| o o o o"), std::vector<int>{2, 2, 1, 1, 4, 4, 4, 4}));\n    assert(issame(parse_music("o| .| o| .| o o| o o|"), std::vector<int>{2, 1, 2, 1, 4, 2, 4, 2}));\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n\n// Function to count the number of times a substring occurs in a string\nint how_many_times(const std::string& str, const std::string& substring) {\n    int out = 0;\n    size_t str_len = str.length();\n    size_t sub_len = substring.length();\n\n    if (str_len == 0) {\n        return 0;\n    }\n\n    for (size_t i = 0; i < str_len - sub_len + 1; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            out++;\n        }\n    }\n\n    return out;\n}\n\nint main() {\n    // Test cases\n    if (how_many_times("", "x") != 0) {\n        std::cerr << "Assertion failed: how_many_times('', 'x') == 0" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("xyxyxyx", "x") != 4) {\n        std::cerr << "Assertion failed: how_many_times('xyxyxyx', 'x') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("cacacacac", "cac") != 4) {\n        std::cerr << "Assertion failed: how_many_times('cacacacac', 'cac') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("john doe", "john") != 1) {\n        std::cerr << "Assertion failed: how_many_times('john doe', 'john') == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(const std::vector<float>& numbers) {\n    std::vector<float> out(2, 0.0f);\n    float min_diff = std::numeric_limits<float>::infinity();\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n                min_diff = diff;\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        std::swap(out[0], out[1]);\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b, float epsilon = 1e-4) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > epsilon) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<float> test1 = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    std::vector<float> test2 = {1.0, 2.0, 5.9, 4.0, 5.0};\n    std::vector<float> test3 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    std::vector<float> test4 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    std::vector<float> test5 = {1.1, 2.2, 3.1, 4.1, 5.1};\n\n    std::vector<float> result;\n\n    result = find_closest_elements(test1);\n    if (!issame(result, {3.9, 4.0})) {\n        std::cerr << "Assertion failed for test1" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test2);\n    if (!issame(result, {5.0, 5.9})) {\n        std::cerr << "Assertion failed for test2" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test3);\n    if (!issame(result, {2.0, 2.2})) {\n        std::cerr << "Assertion failed for test3" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test4);\n    if (!issame(result, {2.0, 2.0})) {\n        std::cerr << "Assertion failed for test4" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test5);\n    if (!issame(result, {2.2, 3.1})) {\n        std::cerr << "Assertion failed for test5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> rescale_to_unit(const std::vector<float>& numbers) {\n    std::vector<float> rescaled(numbers.size());\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return rescaled;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<float> numbers;\n    std::vector<float> result;\n    std::vector<float> expected1 = {0.0, 1.0};\n    std::vector<float> expected2 = {1.0, 0.0};\n    std::vector<float> expected3 = {0.0, 0.25, 0.5, 0.75, 1.0};\n    std::vector<float> expected4 = {0.25, 0.0, 1.0, 0.5, 0.75};\n    std::vector<float> expected5 = {0.25, 0.0, 1.0, 0.5, 0.75};\n\n    // Test case 1\n    numbers = {2.0, 49.9};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    numbers = {100.0, 49.9};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    numbers = {1.0, 2.0, 3.0, 4.0, 5.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    numbers = {2.0, 1.0, 5.0, 3.0, 4.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for test case 4" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    numbers = {12.0, 11.0, 15.0, 13.0, 14.0};\n    result = rescale_to_unit(numbers);\n    if (!issame(result, expected5)) {\n        std::cerr << "Assertion failed for test case 5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to get the length of a string\nint strlen(const std::string& str) {\n    return str.length();\n}\n\nvoid run_assertions() {\n    // Assertions\n    if (strlen("") != 0) {\n        std::cerr << "Assertion failed: strlen(\"\") == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen("x") != 1) {\n        std::cerr << "Assertion failed: strlen(\"x\") == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen("asdasnakj") != 9) {\n        std::cerr << "Assertion failed: strlen(\"asdasnakj\") == 9" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nint main() {\n    // Main program logic\n    run_assertions();\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_divisor(int n) {\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = largest_divisor(3);\n    if (result != 1) {\n        std::cerr << "Assertion failed: largest_divisor(3) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(7);\n    if (result != 1) {\n        std::cerr << "Assertion failed: largest_divisor(7) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(10);\n    if (result != 5) {\n        std::cerr << "Assertion failed: largest_divisor(10) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(100);\n    if (result != 50) {\n        std::cerr << "Assertion failed: largest_divisor(100) == 50" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(49);\n    if (result != 7) {\n        std::cerr << "Assertion failed: largest_divisor(49) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nvoid factorize(int n, std::vector<int>& out) {\n    int m = n;\n    int count = 0;\n    out.clear();\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (m <= 1) break;\n        while (m % i == 0) {\n            m /= i;\n            ++count;\n            out.push_back(i);\n        }\n    }\n\n    if (m > 1) {\n        out.push_back(m);\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nint main() {\n    std::vector<int> factors;\n    bool result;\n\n    factorize(2, factors);\n    result = issame(factors, {2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(2)" << std::endl;\n        return 1;\n    }\n\n    factorize(4, factors);\n    result = issame(factors, {2, 2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(4)" << std::endl;\n        return 1;\n    }\n\n    factorize(8, factors);\n    result = issame(factors, {2, 2, 2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(8)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19, factors);\n    result = issame(factors, {3, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19, factors);\n    result = issame(factors, {3, 3, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19 * 3 * 19, factors);\n    result = issame(factors, {3, 3, 3, 19, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 19 * 19, factors);\n    result = issame(factors, {3, 19, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 19 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 2 * 3, factors);\n    result = issame(factors, {2, 3, 3});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 2 * 3)" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> remove_duplicates(const std::vector<int>& numbers) {\n    std::vector<int> has1, has2, out;\n\n    if (numbers.empty()) return out;\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int j : has2) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) continue;\n\n        found = false;\n        for (int j : has1) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            has2.push_back(num);\n        } else {\n            has1.push_back(num);\n        }\n    }\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int j : has2) {\n            if (j == num) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            out.push_back(num);\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_condition(issame(remove_duplicates({1, 2, 3, 4}), {1, 2, 3, 4}));\n    assert_condition(issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5}));\n    assert_condition(remove_duplicates({}).empty());\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string flip_case(const std::string& str) {\n    std::string out;\n    for (size_t i = 0; i < str.length(); ++i) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w = w - 32; // Convert lowercase to uppercase\n        } else if (w >= 'A' && w <= 'Z') {\n            w = w + 32; // Convert uppercase to lowercase\n        }\n        out += w;\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(flip_case("") == "");\n    assert(flip_case("Hello!") == "hELLO!");\n    assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\nint main() {\n    // Test with an empty array\n    std::vector<std::string> strings;\n    std::string result = concatenate(strings);\n    if (result != "") {\n        std::cerr << "Assertion failed: concatenate([]) /= ''" << std::endl;\n        exit(1);\n    }\n\n    // Test with an array of strings\n    strings = {"x", "y", "z"};\n    result = concatenate(strings);\n    if (result != "xyz") {\n        std::cerr << "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'" << std::endl;\n        exit(1);\n    }\n\n    // Test with a larger array of strings\n    strings = {"x", "y", "z", "w", "k"};\n    result = concatenate(strings);\n    if (result != "xyzwk") {\n        std::cerr << "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> filter_by_prefix(const std::vector<std::string>& strings, const std::string& prefix) {\n    std::vector<std::string> out;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            out.push_back(str);\n        }\n    }\n    return out;\n}\n\nvoid add_to_array(std::vector<std::string>& array, const std::string& element) {\n    array.push_back(element);\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nvoid test_cases() {\n    // Test case 1\n    std::vector<std::string> strings;\n    std::string prefix = "john";\n    auto result = filter_by_prefix(strings, prefix);\n    if (!issame(result, strings)) {\n        std::cerr << "Assertion failed: filter_by_prefix({}, 'john')" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    strings = {"xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "};\n    prefix = "xxx";\n    result = filter_by_prefix(strings, prefix);\n    std::vector<std::string> expected = {"xxx     ", "xxxAAA  ", "xxx     "};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: filter_by_prefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_cases();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to get positive numbers from a vector\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> out;\n    for (float num : l) {\n        if (num > 0.0f) {\n            out.push_back(num);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are equal\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4f) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> input = {-1.0f, -2.0f, 4.0f, 5.0f, 6.0f};\n    std::vector<float> expected = {4.0f, 5.0f, 6.0f};\n    std::vector<float> result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    input = {5.0f, 3.0f, -5.0f, 2.0f, 3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n    expected = {5.0f, 3.0f, 2.0f, 3.0f, 3.0f, 9.0f, 123.0f, 1.0f};\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    input = {-1.0f, -2.0f};\n    expected.clear(); // No positive numbers in input\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    input.clear(); // Empty vector\n    expected.clear(); // Expected to be empty as well\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false;\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    // Assertions to test the is_prime function\n    if (!is_prime(6)) {\n        std::cerr << "Assertion failed: is_prime(6) == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(101)) {\n        std::cerr << "Assertion failed: is_prime(101) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(11)) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(13441)) {\n        std::cerr << "Assertion failed: is_prime(13441) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(61)) {\n        std::cerr << "Assertion failed: is_prime(61) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(4)) {\n        std::cerr << "Assertion failed: is_prime(4) == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(1)) {\n        std::cerr << "Assertion failed: is_prime(1) == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(5)) {\n        std::cerr << "Assertion failed: is_prime(5) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(11)) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_prime(17)) {\n        std::cerr << "Assertion failed: is_prime(17) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(5 * 17)) {\n        std::cerr << "Assertion failed: is_prime(5 * 17) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(11 * 7)) {\n        std::cerr << "Assertion failed: is_prime(11 * 7) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(13441 * 19)) {\n        std::cerr << "Assertion failed: is_prime(13441 * 19) == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nnamespace polynomial_module {\n    // Define the poly function\n    double poly(const std::vector<double>& xs, int n, double x) {\n        double sum = 0.0;\n        for (int i = 0; i < n; ++i) {\n            sum += xs[i] * std::pow(x, i);\n        }\n        return sum;\n    }\n\n    // Define the find_zero function\n    double find_zero(const std::vector<double>& xs, int n) {\n        double ans = 0.0;\n        double value = poly(xs, n, ans);\n        while (std::abs(value) > 1e-6) {\n            double driv = 0.0;\n            for (int i = 1; i < n; ++i) {\n                driv += xs[i] * (i) * std::pow(ans, i - 1);\n            }\n            ans -= value / driv;\n            value = poly(xs, n, ans);\n        }\n        return ans;\n    }\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i < 100; ++i) {\n        int ncoeff = 2 * (1 + std::rand() % 4);\n        std::vector<double> coeffs(ncoeff);\n\n        for (int j = 0; j < ncoeff; ++j) {\n            coeffs[j] = -10 + std::rand() % 21;\n            if (coeffs[j] == 0) coeffs[j] = 1;\n        }\n\n        double solution = polynomial_module::find_zero(coeffs, ncoeff);\n        if (std::abs(polynomial_module::poly(coeffs, ncoeff, solution)) >= 1e-3) {\n            std::cerr << "Assertion failed: abs(poly(coeffs, solution)) < 1e-3" << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to sort an array\nvoid sort_array(std::vector<int>& arr) {\n    for (size_t i = 0; i < arr.size() - 1; ++i) {\n        for (size_t j = i + 1; j < arr.size(); ++j) {\n            if (arr[i] > arr[j]) {\n                std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n}\n\n// Function to sort every third element of the input array\nstd::vector<int> sort_third(const std::vector<int>& l) {\n    std::vector<int> third;\n    std::vector<int> out(l.size());\n\n    // Extract every third element\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third.push_back(l[i]);\n    }\n\n    // Sort the third array\n    sort_array(third);\n\n    // Reconstruct the output array\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\n// Function to check if two vectors are equal\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine to assert a condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Subroutine to run tests\nvoid run_tests() {\n    assert(issame(sort_third({1, 2, 3}), sort_third({1, 2, 3})));\n    assert(issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert(issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert(issame(sort_third({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5}));\n    assert(issame(sort_third({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5}));\n    assert(issame(sort_third({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5}));\n    assert(issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid unique(const std::vector<int>& input, std::vector<int>& result) {\n    std::vector<int> temp;\n    std::sort(input.begin(), input.end()); // Sort the input array\n\n    // Remove duplicates\n    for (int num : input) {\n        if (temp.empty() || num != temp.back()) {\n            temp.push_back(num);\n        }\n    }\n\n    result = temp;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    std::vector<int> expected = {0, 2, 3, 5, 9, 123};\n    std::vector<int> result;\n\n    unique(input, result);\n\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: result is not as expected" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to find the maximum element in a vector\nfloat max_element(const std::vector<float>& arr) {\n    float max_val = -10000.0f;\n    for (float num : arr) {\n        if (max_val < num) max_val = num;\n    }\n    return max_val;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> arr1 = {1.0f, 2.0f, 3.0f};\n    float result1 = max_element(arr1);\n    if (std::abs(result1 - 3.0f) > 1e-4f) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<float> arr2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 124.0f, 1.0f, -10.0f};\n    float result2 = max_element(arr2);\n    if (std::abs(result2 - 124.0f) > 1e-4f) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint fizz_buzz(int n);\nvoid assert(bool condition, const std::string& message);\n\nint main() {\n    int result;\n\n    // Main program logic\n    result = fizz_buzz(50);\n    assert(result == 0, "fizz_buzz(50) == 0: assertion failed");\n\n    result = fizz_buzz(78);\n    assert(result == 2, "fizz_buzz(78) == 2: assertion failed");\n\n    result = fizz_buzz(79);\n    assert(result == 3, "fizz_buzz(79) == 3: assertion failed");\n\n    result = fizz_buzz(100);\n    assert(result == 3, "fizz_buzz(100) == 3: assertion failed");\n\n    result = fizz_buzz(200);\n    assert(result == 6, "fizz_buzz(200) == 6: assertion failed");\n\n    result = fizz_buzz(4000);\n    assert(result == 192, "fizz_buzz(4000) == 192: assertion failed");\n\n    result = fizz_buzz(10000);\n    assert(result == 639, "fizz_buzz(10000) == 639: assertion failed");\n\n    result = fizz_buzz(100000);\n    assert(result == 8026, "fizz_buzz(100000) == 8026: assertion failed");\n\n    return 0;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) {\n                    ++count;\n                }\n                q /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> sort_even(const std::vector<float>& l) {\n    std::vector<float> out(l.size());\n    std::vector<float> even(l.size() / 2 + l.size() % 2);\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < even.size(); ++i) {\n        even[i] = l[i * 2];\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even.begin(), even.end());\n\n    // Merge sorted even-indexed elements back into the output array\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\nvoid sort_array(std::vector<float>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid run_tests() {\n    // Test case 1\n    std::vector<float> l = {1.0, 2.0, 3.0};\n    std::vector<float> expected = {1.0, 2.0, 3.0};\n    std::vector<float> result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    expected = {-10.0, 3.0, -5.0, 2.0, -3.0, 3.0, 5.0, 0.0, 9.0, 1.0, 123.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {5.0, 8.0, -12.0, 4.0, 23.0, 2.0, 3.0, 11.0, 12.0, -10.0};\n    expected = {-12.0, 8.0, 3.0, 4.0, 5.0, 2.0, 12.0, 11.0, 23.0, -10.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint car_race_collision(int n);\n\nint main() {\n    // Assertions\n    if (car_race_collision(2) != 4) {\n        std::cerr << "Assertion failed: car_race_collision(2) == 4" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(3) != 9) {\n        std::cerr << "Assertion failed: car_race_collision(3) == 9" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(4) != 16) {\n        std::cerr << "Assertion failed: car_race_collision(4) == 16" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(8) != 64) {\n        std::cerr << "Assertion failed: car_race_collision(8) == 64" << std::endl;\n        std::exit(1);\n    }\n\n    if (car_race_collision(10) != 100) {\n        std::cerr << "Assertion failed: car_race_collision(10) == 100" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint car_race_collision(int n) {\n    return n * n;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::vector<int> incr_list(const std::vector<int>& l) {\n    std::vector<int> res(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        res[i] = l[i] + 1;\n    }\n    return res;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> l, result, expected;\n    bool condition;\n\n    // Test case 1\n    l = {0};\n    expected = {0};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2\n    l = {3, 2, 1};\n    expected = {4, 3, 2};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3\n    l = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    expected = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    result = incr_list(l);\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> l;\n    bool result;\n\n    // Test case 1\n    l = {1, 3, 5, 0};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {1, 3, -2, 1};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {1, 2, 3, 7};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4\n    l = {2, 4, -5, 3, 5, 7};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5\n    l = {1};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 6\n    l = {-3, 9, -1, 3, 2, 30};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 7\n    l = {-3, 9, -1, 3, 2, 31};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 8\n    l = {-3, 9, -1, 4, 2, 30};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 8 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 9\n    l = {-3, 9, -1, 4, 2, 31};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cerr << "Test case 9 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to change base\nstd::string change_base(int x, int base) {\n    std::string out;\n    int temp_x = x;\n    while (temp_x > 0) {\n        int remainder = temp_x % base;\n        out = std::to_string(remainder) + out;\n        temp_x = temp_x / base;\n    }\n    return out;\n}\n\n// Integer to string conversion function\nstd::string itoa(int num) {\n    return std::to_string(num);\n}\n\nint main() {\n    // Assertions\n    if (change_base(8, 3) != "22") {\n        std::cerr << "Assertion failed: change_base(8, 3) == '22'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(9, 3) != "100") {\n        std::cerr << "Assertion failed: change_base(9, 3) == '100'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(234, 2) != "11101010") {\n        std::cerr << "Assertion failed: change_base(234, 2) == '11101010'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(16, 2) != "10000") {\n        std::cerr << "Assertion failed: change_base(16, 2) == '10000'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(8, 2) != "1000") {\n        std::cerr << "Assertion failed: change_base(8, 2) == '1000'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(7, 2) != "111") {\n        std::cerr << "Assertion failed: change_base(7, 2) == '111'" << std::endl;\n        std::exit(1);\n    }\n\n    for (int x = 2; x <= 7; ++x) {\n        if (change_base(x, x + 1) != itoa(x)) {\n            std::cerr << "Assertion failed: change_base(" << x << ", " << x + 1 << ") == " << x << std::endl;\n            std::exit(1);\n        }\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\ndouble triangle_area(double a, double h);\n\nint main() {\n    double result;\n\n    // Test cases\n    result = triangle_area(5.0, 3.0);\n    if (std::abs(result - 7.5) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(5, 3) should be 7.5" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(2.0, 2.0);\n    if (std::abs(result - 2.0) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(2, 2) should be 2.0" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(10.0, 8.0);\n    if (std::abs(result - 40.0) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(10, 8) should be 40.0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n\n// Function definition\ndouble triangle_area(double a, double h) {\n    return (a * h) * 0.5;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint fib4(int n);\n\nint main() {\n    // Assertions\n    if (fib4(5) != 4) {\n        std::cerr << "fib4(5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fib4(8) != 28) {\n        std::cerr << "fib4(8) == 28: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fib4(10) != 104) {\n        std::cerr << "fib4(10) == 104: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fib4(12) != 386) {\n        std::cerr << "fib4(12) == 386: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint fib4(int n) {\n    static int f[100]; // Static array to store the sequence\n    if (n < 4) {\n        // Initialize the first four elements\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n    }\n\n    // Compute the sequence if not already computed\n    if (f[n] == 0) {\n        f[n] = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4);\n    }\n\n    return f[n];\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n\nnamespace utilities {\n    void sort(std::vector<float>& arr) {\n        int n = arr.size();\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (arr[i] > arr[j]) {\n                    std::swap(arr[i], arr[j]);\n                }\n            }\n        }\n    }\n\n    float median(const std::vector<float>& arr) {\n        std::vector<float> sorted_arr = arr;\n        sort(sorted_arr);\n        int n = sorted_arr.size();\n        if (n % 2 == 1) {\n            return sorted_arr[n / 2];\n        } else {\n            return (sorted_arr[n / 2 - 1] + sorted_arr[n / 2]) / 2.0f;\n        }\n    }\n}\n\nvoid median_test() {\n    using namespace utilities;\n\n    // Test cases\n    float result = median({3.0f, 1.0f, 2.0f, 4.0f, 5.0f});\n    if (std::abs(result - 3.0f) > 1e-4) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({-10.0f, 4.0f, 6.0f, 1000.0f, 10.0f, 20.0f});\n    if (std::abs(result - 8.0f) > 1e-4) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({5.0f});\n    if (std::abs(result - 5.0f) > 1e-4) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({6.0f, 5.0f});\n    if (std::abs(result - 5.5f) > 1e-4) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    result = median({8.0f, 1.0f, 3.0f, 9.0f, 9.0f, 2.0f, 7.0f});\n    if (std::abs(result - 7.0f) > 1e-4) {\n        std::cerr << "Test case 5 failed: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All test cases passed." << std::endl;\n}\n\nint main() {\n    median_test();\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const std::string& text) {\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return (reversed_text == text);\n}\n\nint main() {\n    // Main program\n    if (!is_palindrome("")) {\n        std::cerr << "Assertion failed: is_palindrome('') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aba")) {\n        std::cerr << "Assertion failed: is_palindrome('aba') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        std::cerr << "Assertion failed: is_palindrome('aaaaa') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("zbcd")) {\n        std::cerr << "Assertion failed: is_palindrome('zbcd') == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyx') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywyz")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyz') == false" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywzx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywzx') == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint modp(int n, int p);\n\nint main() {\n    // Variable declaration\n    int result;\n\n    // Assertions\n    result = modp(3, 5);\n    if (result != 3) {\n        std::cerr << "modp(3, 5) == 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(1101, 101);\n    if (result != 2) {\n        std::cerr << "modp(1101, 101) == 2: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(0, 101);\n    if (result != 1) {\n        std::cerr << "modp(0, 101) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(3, 11);\n    if (result != 8) {\n        std::cerr << "modp(3, 11) == 8: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(100, 101);\n    if (result != 1) {\n        std::cerr << "modp(100, 101) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(30, 5);\n    if (result != 4) {\n        std::cerr << "modp(30, 5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = modp(31, 5);\n    if (result != 3) {\n        std::cerr << "modp(31, 5) == 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint modp(int n, int p) {\n    int result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n\nstd::string encode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = (s[i] + 5 - 'a') % 26 + 'a';\n        out[i] = static_cast<char>(w);\n    }\n    return out;\n}\n\nstd::string decode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = (s[i] + 21 - 'a') % 26 + 'a';\n        out[i] = static_cast<char>(w);\n    }\n    return out;\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i < 100; ++i) {\n        int l = 10 + std::rand() % 11;\n        std::string str = "";\n        for (int j = 0; j < l; ++j) {\n            int chr = 'a' + std::rand() % 26;\n            str += static_cast<char>(chr);\n        }\n\n        std::string encoded_str = encode_shift(str);\n        std::string decoded_str = decode_shift(encoded_str);\n\n        if (str != decoded_str) {\n            std::cerr << "Assertion failed: decoded string does not match original" << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_vowels(const std::string& text) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\nvoid assert_test(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_test(remove_vowels("") == "");\n    assert_test(remove_vowels("abcdef//nghijklm") == "bcdf//nghjklm");\n    assert_test(remove_vowels("fedcba") == "fdcb");\n    assert_test(remove_vowels("eeeee") == "");\n    assert_test(remove_vowels("acBAA") == "cB");\n    assert_test(remove_vowels("EcBOO") == "cB");\n    assert_test(remove_vowels("ybcd") == "ybcd");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> l;\n    int t;\n\n    // Test cases\n    l = {1, 2, 4, 10};\n    t = 100;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 20, 4, 10};\n    t = 5;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 20, 4, 10};\n    t = 21;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 20, 4, 10};\n    t = 22;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 8, 4, 10};\n    t = 11;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1, 8, 4, 10};\n    t = 10;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n#include <ctime> // For srand() and rand()\n\n// Function declaration\nint add(int x, int y);\n\nint main() {\n    // Assertions\n    if (add(0, 1) != 1) {\n        std::cerr << "Assertion failed: add(0, 1) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (add(1, 0) != 1) {\n        std::cerr << "Assertion failed: add(1, 0) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (add(2, 3) != 5) {\n        std::cerr << "Assertion failed: add(2, 3) == 5" << std::endl;\n        exit(1);\n    }\n\n    if (add(5, 7) != 12) {\n        std::cerr << "Assertion failed: add(5, 7) == 12" << std::endl;\n        exit(1);\n    }\n\n    if (add(7, 5) != 12) {\n        std::cerr << "Assertion failed: add(7, 5) == 12" << std::endl;\n        exit(1);\n    }\n\n    // Seed the random number generator\n    srand(static_cast<unsigned int>(time(nullptr)));\n\n    // Loop with random number generation and assertions\n    for (int i = 1; i <= 100; ++i) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        if (add(x, y) != x + y) {\n            std::cerr << "Assertion failed: add(" << x << ", " << y << ") == " << (x + y) << std::endl;\n            exit(1);\n        }\n    }\n\n    return 0;\n}\n\n// Function definition\nint add(int x, int y) {\n    return x + y;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool same_chars(const std::string& s0, const std::string& s1) {\n    for (size_t i = 0; i < s0.size(); ++i) {\n        if (s1.find(s0[i]) == std::string::npos) {\n            return false;\n        }\n    }\n\n    for (size_t i = 0; i < s1.size(); ++i) {\n        if (s0.find(s1[i]) == std::string::npos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    bool result;\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddeddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("abcd", "dddddddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabc') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("dddddddabc", "abcd");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('dddddddabc', 'abcd') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("eabcd", "dddddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcd', 'dddddddabc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("abcd", "dddddddabcf");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabcf') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("aabb", "aaccc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('aabb', 'aaccc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\nint fib(int n) {\n    int f[1000];\n    f[1] = 0;\n    f[2] = 1;\n    for (int i = 3; i <= n + 1; ++i) {\n        f[i] = f[i-1] + f[i-2];\n    }\n    return f[n+1];\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = fib(10);\n    if (result != 55) {\n        std::cerr << "fib(10) == 55: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(1);\n    if (result != 1) {\n        std::cerr << "fib(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(8);\n    if (result != 21) {\n        std::cerr << "fib(8) == 21: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(11);\n    if (result != 89) {\n        std::cerr << "fib(11) == 89: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(12);\n    if (result != 144) {\n        std::cerr << "fib(12) == 144: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n// Function to check if the array is monotonic\nbool is_monotonic(const std::vector<float>& l) {\n    bool incr = false;\n    bool decr = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) incr = true;\n        if (l[i] < l[i - 1]) decr = true;\n    }\n\n    return !(incr && decr);\n}\n\nint main() {\n    // Test cases\n    std::vector<float> l;\n\n    l = {1.0, 2.0, 4.0, 10.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 4, 10} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 2.0, 4.0, 20.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 4, 20} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 20.0, 4.0, 10.0};\n    if (is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 20, 4, 10} should not be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {4.0, 1.0, 0.0, -10.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {4, 1, 0, -10} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {4.0, 1.0, 1.0, 0.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {4, 1, 1, 0} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 2.0, 3.0, 2.0, 5.0, 60.0};\n    if (is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 3, 2, 5, 60} should not be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {1.0, 2.0, 3.0, 4.0, 5.0, 60.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 3, 4, 5, 60} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    l = {9.0, 9.0, 9.0, 9.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {9, 9, 9, 9} should be monotonic" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to sort an array\nvoid sort(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to check if two arrays are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to find the common elements between two arrays\nvoid common(const std::vector<int>& l1, const std::vector<int>& l2, std::vector<int>& out) {\n    std::vector<int> temp(l1.size());\n    size_t n = 0;\n\n    for (size_t i = 0; i < l1.size(); ++i) {\n        bool found = false;\n        for (size_t j = 0; j < n; ++j) {\n            if (temp[j] == l1[i]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (std::any_of(l2.begin(), l2.end(), [&l1, i](int val) { return val == l1[i]; })) {\n                temp[n] = l1[i];\n                ++n;\n            }\n        }\n    }\n\n    if (n > 0) {\n        sort(temp);\n        out = std::vector<int>(temp.begin(), temp.begin() + n);\n    } else {\n        out.clear();\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> l1 = {1, 4, 3, 34, 653, 2, 5};\n    std::vector<int> l2 = {5, 7, 1, 5, 9, 653, 121};\n    std::vector<int> expected = {1, 5, 653};\n    std::vector<int> result;\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    l1 = {5, 3, 2, 8};\n    l2 = {3, 2};\n    expected = {2, 3};\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    l1 = {4, 3, 2, 8};\n    l2 = {3, 2, 4};\n    expected = {2, 3, 4};\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    l1 = {4, 3, 2, 8};\n    l2.clear();\n    expected.clear();\n    common(l1, l2, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_prime_factor(int n) {\n    int num = n;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        while (num % i == 0 && num > i) {\n            num /= i;\n        }\n    }\n    return num;\n}\n\nint main() {\n    // Assertions\n    if (largest_prime_factor(15) != 5) {\n        std::cerr << "Assertion failed: largest_prime_factor(15) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(27) != 3) {\n        std::cerr << "Assertion failed: largest_prime_factor(27) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(63) != 7) {\n        std::cerr << "Assertion failed: largest_prime_factor(63) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(330) != 11) {\n        std::cerr << "Assertion failed: largest_prime_factor(330) == 11" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(13195) != 29) {\n        std::cerr << "Assertion failed: largest_prime_factor(13195) == 29" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint sum_to_n(int n);\n\nint main() {\n    // Assertions\n    if (sum_to_n(1) != 1) {\n        std::cerr << "sum_to_n(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(6) != 21) {\n        std::cerr << "sum_to_n(6) == 21: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(11) != 66) {\n        std::cerr << "sum_to_n(11) == 66: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(30) != 465) {\n        std::cerr << "sum_to_n(30) == 465: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(100) != 5050) {\n        std::cerr << "sum_to_n(100) == 5050: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n
#include <iostream>\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    int level = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            level++;\n        } else if (c == ')') {\n            level--;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nint main() {\n    // Test cases\n    if (!correct_bracketing("()")) {\n        std::cerr << "Assertion failed: ()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("(()())")) {\n        std::cerr << "Assertion failed: (()())" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()(()())()")) {\n        std::cerr << "Assertion failed: ()()(()())()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()((()()())())(()()(()))")) {\n        std::cerr << "Assertion failed: ()()((()()())())(()()(()))" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("((()())))")) {\n        std::cerr << "Assertion failed: ((()())))" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing(")()(")) {\n        std::cerr << "Assertion failed: )(()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("(")) {\n        std::cerr << "Assertion failed: (" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("((((")) {\n        std::cerr << "Assertion failed: ((((" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing(")")) {\n        std::cerr << "Assertion failed: )" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("(()")) {\n        std::cerr << "Assertion failed: (()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("()()(()())())(()")) {\n        std::cerr << "Assertion failed: ()()(()())())(()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("()()(()())()))()")) {\n        std::cerr << "Assertion failed: ()()(()())()))()" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint fibfib(int n);\n\nint main() {\n    // Assertions\n    if (fibfib(2) != 1) {\n        std::cerr << "fibfib(2) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(1) != 0) {\n        std::cerr << "fibfib(1) == 0: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(5) != 4) {\n        std::cerr << "fibfib(5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(8) != 24) {\n        std::cerr << "fibfib(8) == 24: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(10) != 81) {\n        std::cerr << "fibfib(10) == 81: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(12) != 274) {\n        std::cerr << "fibfib(12) == 274: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(14) != 927) {\n        std::cerr << "fibfib(14) == 927: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint fibfib(int n) {\n    int ff[n+1]; // Dynamic array, size is n+1\n\n    // Initial values\n    ff[0] = 0;\n    ff[1] = 0;\n    ff[2] = 1;\n\n    // Compute the sequence\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i-1] + ff[i-2] + ff[i-3];\n    }\n\n    return ff[n];\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to count vowels in a string\nint vowels_count(const std::string& s) {\n    int count = 0;\n    const std::string vowels = "aeiouAEIOU";\n\n    for (char c : s) {\n        if (vowels.find(c) != std::string::npos) {\n            count++;\n        }\n    }\n\n    // Special handling for 'y' at the end of the string\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n\nint main() {\n    std::string s;\n    int count;\n\n    // Test cases\n    s = "abcde";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cerr << "Assertion failed for 'abcde'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "Alone";\n    count = vowels_count(s);\n    if (count != 3) {\n        std::cerr << "Assertion failed for 'Alone'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "key";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cerr << "Assertion failed for 'key'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "bye";\n    count = vowels_count(s);\n    if (count != 1) {\n        std::cerr << "Assertion failed for 'bye'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "keY";\n    count = vowels_count(s);\n    if (count != 2) {\n        std::cerr << "Assertion failed for 'keY'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "bYe";\n    count = vowels_count(s);\n    if (count != 1) {\n        std::cerr << "Assertion failed for 'bYe'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "ACEDY";\n    count = vowels_count(s);\n    if (count != 3) {\n        std::cerr << "Assertion failed for 'ACEDY'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string circular_shift(int x, int shift) {\n    std::string xs = std::to_string(x);\n    int len_xs = xs.length();\n    if (len_xs < shift) {\n        std::string reversed = reverse_string(xs);\n        return reversed.substr(0, shift % len_xs) + reversed.substr(0, len_xs - (shift % len_xs));\n    } else {\n        int actual_shift = shift % len_xs;\n        return xs.substr(len_xs - actual_shift, actual_shift) + xs.substr(0, len_xs - actual_shift);\n    }\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string reversed;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        reversed += s[i];\n    }\n    return reversed;\n}\n\nint main() {\n    std::string result;\n\n    result = circular_shift(100, 2);\n    if (result != "001") {\n        std::cerr << "Assertion failed: circular_shift(100, 2) == '001'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 2);\n    if (result != "12") {\n        std::cerr << "Assertion failed: circular_shift(12, 2) == '12'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(97, 8);\n    if (result != "79") {\n        std::cerr << "Assertion failed: circular_shift(97, 8) == '79'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 1);\n    if (result != "21") {\n        std::cerr << "Assertion failed: circular_shift(12, 1) == '21'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(11, 101);\n    if (result != "11") {\n        std::cerr << "Assertion failed: circular_shift(11, 101) == '11'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to calculate the sum of the ASCII values of the uppercase letters in a string\nint digitSum(const std::string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Assertions\n    if (digitSum("") != 0) {\n        std::cerr << "Assertion failed: digitSum('') == 0" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("abAB") != 131) {\n        std::cerr << "Assertion failed: digitSum('abAB') == 131" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("abcCd") != 67) {\n        std::cerr << "Assertion failed: digitSum('abcCd') == 67" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("helloE") != 69) {\n        std::cerr << "Assertion failed: digitSum('helloE') == 69" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("woArBld") != 131) {\n        std::cerr << "Assertion failed: digitSum('woArBld') == 131" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("aAaaaXa") != 153) {\n        std::cerr << "Assertion failed: digitSum('aAaaaXa') == 153" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum(" How are yOu?") != 151) {\n        std::cerr << "Assertion failed: digitSum(' How are yOu?') == 151" << std::endl;\n        exit(1);\n    }\n\n    if (digitSum("You arE Very Smart") != 327) {\n        std::cerr << "Assertion failed: digitSum('You arE Very Smart') == 327" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function declaration\nint fruit_distribution(const std::string& s, int n);\n\nint main() {\n    std::string s;\n    int n;\n\n    // Test cases\n    s = "5 apples and 6 oranges";\n    n = 19;\n    if (fruit_distribution(s, n) != 8) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "5 apples and 6 oranges";\n    n = 21;\n    if (fruit_distribution(s, n) != 10) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "0 apples and 1 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "1 apples and 0 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 100;\n    if (fruit_distribution(s, n) != 95) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 5;\n    if (fruit_distribution(s, n) != 0) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "1 apples and 100 oranges";\n    n = 120;\n    if (fruit_distribution(s, n) != 19) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n\nint fruit_distribution(const std::string& s, int n) {\n    std::string num1, num2;\n    int is12 = 0;\n    int num1_val = 0, num2_val = 0;\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1 += s[i];\n            } else if (is12 == 1) {\n                num2 += s[i];\n            }\n        } else if (is12 == 0 && !num1.empty()) {\n            is12 = 1;\n        }\n    }\n\n    if (!num1.empty()) {\n        num1_val = std::stoi(num1);\n    }\n    if (!num2.empty()) {\n        num2_val = std::stoi(num2);\n    }\n\n    return n - num1_val - num2_val;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid pluck(const std::vector<int>& arr, std::vector<int>& out) {\n    out.clear();\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (out.empty() || arr[i] < out[0])) {\n            out.clear();\n            out.push_back(arr[i]);\n            out.push_back(i);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> arr, result, empty;\n\n    // Test cases\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {4, 2, 3};\n    pluck(arr, result);\n    assert_condition(issame(result, {2, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {1, 2, 3};\n    pluck(arr, result);\n    assert_condition(issame(result, {2, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {};\n    pluck(arr, result);\n    assert_condition(issame(result, empty));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {5, 0, 3, 0, 4, 2};\n    pluck(arr, result);\n    assert_condition(issame(result, {0, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {1, 2, 3, 0, 5, 3};\n    pluck(arr, result);\n    assert_condition(issame(result, {0, 3}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {5, 4, 8, 4, 8};\n    pluck(arr, result);\n    assert_condition(issame(result, {4, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {7, 6, 7, 1};\n    pluck(arr, result);\n    assert_condition(issame(result, {6, 1}));\n\n    if (!arr.empty()) {\n        arr.clear();\n    }\n    arr = {7, 9, 7, 1};\n    pluck(arr, result);\n    assert_condition(issame(result, empty));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n// Utility functions\nvoid extend_array(std::vector<std::vector<int>>& array, int new_size) {\n    std::vector<std::vector<int>> temp(array.size(), std::vector<int>(new_size));\n    for (size_t i = 0; i < array.size(); ++i) {\n        for (size_t j = 0; j < array[i].size(); ++j) {\n            temp[i][j] = array[i][j];\n        }\n    }\n    array = temp;\n}\n\nint search(const std::vector<int>& lst) {\n    std::vector<std::vector<int>> freq(2, std::vector<int>(0));\n    int max = -1;\n    bool has;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        has = false;\n        for (size_t j = 0; j < freq[1].size(); ++j) {\n            if (lst[i] == freq[0][j]) {\n                freq[1][j] += 1;\n                has = true;\n                if (freq[1][j] >= freq[0][j] && freq[0][j] > max) {\n                    max = freq[0][j];\n                }\n            }\n        }\n        if (!has) {\n            freq[0].push_back(lst[i]);\n            freq[1].push_back(1);\n            if (max == -1 && lst[i] == 1) {\n                max = 1;\n            }\n        }\n    }\n    return max;\n}\n\nint main() {\n    std::vector<int> test_case1 = {5, 5, 5, 5, 1};\n    if (search(test_case1) != 1) {\n        std::cerr << "Assertion failed: search([5, 5, 5, 5, 1]) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case2 = {4, 1, 4, 1, 4, 4};\n    if (search(test_case2) != 4) {\n        std::cerr << "Assertion failed: search([4, 1, 4, 1, 4, 4]) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case3 = {3, 3};\n    if (search(test_case3) != -1) {\n        std::cerr << "Assertion failed: search([3, 3]) == -1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case4 = {8, 8, 8, 8, 8, 8, 8, 8};\n    if (search(test_case4) != 8) {\n        std::cerr << "Assertion failed: search([8, 8, 8, 8, 8, 8, 8, 8]) == 8" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case5 = {2, 3, 3, 2, 2};\n    if (search(test_case5) != 2) {\n        std::cerr << "Assertion failed: search([2, 3, 3, 2, 2]) == 2" << std::endl;\n        return 1;\n    }\n\n    // Add more test cases as needed...\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <gtest/gtest.h>\n#include <vector>\n#include <algorithm>\n\n// Function to sort the list in the strange order\nvoid strange_sort_list(const std::vector<int>& lst, std::vector<int>& out) {\n    int n = lst.size();\n    if (n == 0) {\n        out.clear();\n        return;\n    }\n\n    std::vector<int> sorted_lst = lst;\n    // Bubble sort\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (sorted_lst[j] > sorted_lst[j + 1]) {\n                std::swap(sorted_lst[j], sorted_lst[j + 1]);\n            }\n        }\n    }\n\n    out.resize(n);\n    int l = 0, r = n - 1;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = sorted_lst[l];\n            ++l;\n        } else {\n            out[i] = sorted_lst[r];\n            --r;\n        }\n    }\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Unit tests\nTEST(StrangeSortTest, HandlesEmptyArray) {\n    std::vector<int> out;\n    strange_sort_list(std::vector<int>(), out);\n    EXPECT_TRUE(out.empty());\n}\n\nTEST(StrangeSortTest, HandlesOddSizeArray) {\n    std::vector<int> out;\n    std::vector<int> lst = {1, 2, 3, 4, 5};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {1, 5, 2, 4, 3};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesEvenSizeArray) {\n    std::vector<int> out;\n    std::vector<int> lst = {5, 6, 7, 8, 9, 1};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {1, 9, 5, 8, 6, 7};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesRepeatedElements) {\n    std::vector<int> out;\n    std::vector<int> lst = {5, 5, 5, 5};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {5, 5, 5, 5};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesSingleElement) {\n    std::vector<int> out;\n    std::vector<int> lst = {111111};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {111111};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nTEST(StrangeSortTest, HandlesMixedElements) {\n    std::vector<int> out;\n    std::vector<int> lst = {0, 2, 2, 2, 5, 5, -5, -5};\n    strange_sort_list(lst, out);\n    std::vector<int> expected = {-5, 5, -5, 5, 0, 2, 2, 2};\n    EXPECT_TRUE(issame(out, expected));\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\ndouble triangle_area(double a, double b, double c);\nvoid check_assertion(bool condition, const std::string& message);\n\nint main() {\n    // Main program body\n    check_assertion(std::abs(triangle_area(3.0, 4.0, 5.0) - 6.0) < 0.01, "Assertion failed: triangle_area(3, 4, 5)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 10)");\n    check_assertion(std::abs(triangle_area(4.0, 8.0, 5.0) - 8.18) < 0.01, "Assertion failed: triangle_area(4, 8, 5)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 2.0) - 1.73) < 0.01, "Assertion failed: triangle_area(2, 2, 2)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 3)");\n    check_assertion(std::abs(triangle_area(10.0, 5.0, 7.0) - 16.25) < 0.01, "Assertion failed: triangle_area(10, 5, 7)");\n    check_assertion(std::abs(triangle_area(2.0, 6.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 6, 3)");\n    check_assertion(std::abs(triangle_area(1.0, 1.0, 1.0) - 0.43) < 0.01, "Assertion failed: triangle_area(1, 1, 1)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 2, 10)");\n\n    return 0;\n}\n\ndouble triangle_area(double a, double b, double c) {\n    double h, area;\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        area = -1.0;\n    } else {\n        h = (a + b + c) / 2.0;\n        area = std::sqrt(h * (h - a) * (h - b) * (h - c));\n    }\n    return area;\n}\n\nvoid check_assertion(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cout << message << std::endl;\n        std::exit(1);\n    }\n}\n
#include <iostream>\n#include <vector>\n\nclass FlightModule {\npublic:\n    static bool will_it_fly(const std::vector<int>& q, int w) {\n        int sum = 0;\n        int n = q.size();\n        bool result = true;\n\n        for (int i = 0; i < n; ++i) {\n            if (q[i] != q[n - 1 - i]) {\n                result = false;\n                return result;\n            }\n            sum += q[i];\n        }\n\n        if (sum > w) {\n            result = false;\n        }\n        return result;\n    }\n};\n\nint main() {\n    std::vector<int> q;\n    int w;\n\n    // Test cases\n    q = {3, 2, 3};\n    w = 9;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2};\n    w = 5;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3};\n    w = 5;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    q = {3, 2, 3};\n    w = 1;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    q = {1, 2, 3};\n    w = 6;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    q = {5};\n    w = 5;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint smallest_change(const std::vector<int>& arr) {\n    int out = 0;\n    int n = arr.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++out;\n        }\n    }\n    return out;\n}\n\nint main() {\n    std::vector<int> test_case_1 = {1, 2, 3, 5, 4, 7, 9, 6};\n    if (smallest_change(test_case_1) != 4) {\n        std::cerr << "Assertion failed: smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_2 = {1, 2, 3, 4, 3, 2, 2};\n    if (smallest_change(test_case_2) != 1) {\n        std::cerr << "Assertion failed: smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_3 = {1, 4, 2};\n    if (smallest_change(test_case_3) != 1) {\n        std::cerr << "Assertion failed: smallest_change([1, 4, 2]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_4 = {1, 4, 4, 2};\n    if (smallest_change(test_case_4) != 1) {\n        std::cerr << "Assertion failed: smallest_change([1, 4, 4, 2]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_5 = {1, 2, 3, 2, 1};\n    if (smallest_change(test_case_5) != 0) {\n        std::cerr << "Assertion failed: smallest_change([1, 2, 3, 2, 1]) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_6 = {3, 1, 1, 3};\n    if (smallest_change(test_case_6) != 0) {\n        std::cerr << "Assertion failed: smallest_change([3, 1, 1, 3]) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_7 = {1};\n    if (smallest_change(test_case_7) != 0) {\n        std::cerr << "Assertion failed: smallest_change([1]) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case_8 = {0, 1};\n    if (smallest_change(test_case_8) != 1) {\n        std::cerr << "Assertion failed: smallest_change([0, 1]) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::string> total_match(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    int num1 = 0, num2 = 0;\n    for (const auto& str : lst1) {\n        num1 += str.size();\n    }\n    for (const auto& str : lst2) {\n        num2 += str.size();\n    }\n\n    if (num1 > num2) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "condition: assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nstd::string pad(const std::string& str, size_t len) {\n    std::string padded_str = str;\n    padded_str.resize(len, ' ');\n    return padded_str;\n}\n\nint main() {\n    // Test cases\n    assert_condition(issame({"hi", "admin"}, {"hi", "hi"}));\n    assert_condition(issame({"hi", "admin"}, {"hi", "hi", "admin", "project"}));\n    assert_condition(issame({"4"}, {"1", "2", "3", "4", "5"}));\n    assert_condition(issame({"hi", "admin"}, {"hI", "Hi"}));\n    assert_condition(issame({"hi", "admin"}, {"hI", "hi", "hi"}));\n    assert_condition(issame({"hi", "admin"}, {"hI", "hi", "hii"}));\n    assert_condition(issame({}, {"this"}));\n    assert_condition(issame({"this"}, {}));\n\n    // Demonstrating the use of total_match\n    std::vector<std::string> lst1 = {"hi", "admin"};\n    std::vector<std::string> lst2 = {"hI", "Hi", "hi", "hii"};\n    std::vector<std::string> result = total_match(lst1, lst2);\n    std::cout << "total_match result: ";\n    for (const auto& str : result) {\n        std::cout << '"' << str << "\" ";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    int p = 1;\n    int count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) {\n            return true;\n        }\n        p *= n;\n        ++count;\n    }\n    return false;\n}\n\nint main() {\n    // Test cases\n    if (!is_simple_power(1, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 4) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(2, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(2, 2) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(8, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(8, 2) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(3, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(3, 2) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(3, 1)) {\n        std::cerr << "Assertion failed: is_simple_power(3, 1) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(5, 3)) {\n        std::cerr << "Assertion failed: is_simple_power(5, 3) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(16, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(16, 2) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(143214, 16)) {\n        std::cerr << "Assertion failed: is_simple_power(143214, 16) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(4, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(4, 2) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(9, 3)) {\n        std::cerr << "Assertion failed: is_simple_power(9, 3) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(16, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(16, 4) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(24, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(24, 2) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(128, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(128, 4) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(12, 6)) {\n        std::cerr << "Assertion failed: is_simple_power(12, 6) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(1, 1)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 1) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(1, 12)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 12) == true" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool iscuber(int a) {\n    bool result = false;\n    for (int i = 0; i <= static_cast<int>(std::pow(std::abs(a), 1.0 / 3.0)); ++i) {\n        if (i * i * i == std::abs(a)) {\n            result = true;\n            return result;\n        }\n    }\n    return result;\n}\n\nint main() {\n    // Assertions\n    if (!iscuber(1)) {\n        std::cerr << "iscuber(1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(2)) {\n        std::cerr << "iscuber(2): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(-1)) {\n        std::cerr << "iscuber(-1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(64)) {\n        std::cerr << "iscuber(64): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(180)) {\n        std::cerr << "iscuber(180): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(1000)) {\n        std::cerr << "iscuber(1000): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(0)) {\n        std::cerr << "iscuber(0): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(1729)) {\n        std::cerr << "iscuber(1729): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nconst std::string key = "2357BD";\n\nint hex_key(const std::string& num) {\n    int out = 0;\n    for (size_t i = 0; i < num.length(); ++i) {\n        if (key.find(num[i]) != std::string::npos) {\n            out += 1;\n        }\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assert(hex_key("AB") == 1);\n    assert(hex_key("1077E") == 2);\n    assert(hex_key("ABED1A33") == 4);\n    assert(hex_key("2020") == 2);\n    assert(hex_key("123456789ABCDEF0") == 6);\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert(hex_key("") == 0);\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n\nstd::string decimal_to_binary(int decimal) {\n    std::string out;\n    if (decimal == 0) {\n        return "db0db";\n    }\n\n    int temp = decimal;\n    while (temp > 0) {\n        out += (temp % 2 == 0) ? '0' : '1';\n        temp /= 2;\n    }\n\n    return "db" + out + "db";\n}\n\nvoid test_decimal_to_binary() {\n    std::string result;\n\n    result = decimal_to_binary(0);\n    if (result != "db0db") {\n        std::cerr << "Assertion failed: decimal_to_binary(0) == 'db0db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(32);\n    if (result != "db100000db") {\n        std::cerr << "Assertion failed: decimal_to_binary(32) == 'db100000db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(103);\n    if (result != "db1100111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(103) == 'db1100111db'" << std::endl;\n        std::exit(1);\n    }\n\n    result = decimal_to_binary(15);\n    if (result != "db1111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(15) == 'db1111db'" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_decimal_to_binary();\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_happy(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (size_t i = 3; i <= s.length(); ++i) {\n        if (s[i - 1] == s[i - 2] || s[i - 1] == s[i - 3]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    // Test cases\n    if (!is_happy("a")) {\n        std::cout << "Test 1 passed" << std::endl;\n    } else {\n        std::cout << "Test 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("aa")) {\n        std::cout << "Test 2 passed" << std::endl;\n    } else {\n        std::cout << "Test 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (is_happy("abcd")) {\n        std::cout << "Test 3 passed" << std::endl;\n    } else {\n        std::cout << "Test 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("aabb")) {\n        std::cout << "Test 4 passed" << std::endl;\n    } else {\n        std::cout << "Test 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (is_happy("adb")) {\n        std::cout << "Test 5 passed" << std::endl;\n    } else {\n        std::cout << "Test 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("xyy")) {\n        std::cout << "Test 6 passed" << std::endl;\n    } else {\n        std::cout << "Test 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (is_happy("iopaxpoi")) {\n        std::cout << "Test 7 passed" << std::endl;\n    } else {\n        std::cout << "Test 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!is_happy("iopaxioi")) {\n        std::cout << "Test 8 passed" << std::endl;\n    } else {\n        std::cout << "Test 8 failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nvoid numerical_letter_grade(const std::vector<float>& grades, std::vector<std::string>& out) {\n    out.resize(grades.size());\n\n    for (size_t i = 0; i < grades.size(); ++i) {\n        if (grades[i] >= 3.9999) {\n            out[i] = "A+";\n        } else if (grades[i] > 3.7001 && grades[i] < 3.9999) {\n            out[i] = "A ";\n        } else if (grades[i] > 3.3001 && grades[i] <= 3.7001) {\n            out[i] = "A-";\n        } else if (grades[i] > 3.0001 && grades[i] <= 3.3001) {\n            out[i] = "B+";\n        } else if (grades[i] > 2.7001 && grades[i] <= 3.0001) {\n            out[i] = "B ";\n        } else if (grades[i] > 2.3001 && grades[i] <= 2.7001) {\n            out[i] = "B-";\n        } else if (grades[i] > 2.0001 && grades[i] <= 2.3001) {\n            out[i] = "C+";\n        } else if (grades[i] > 1.7001 && grades[i] <= 2.0001) {\n            out[i] = "C ";\n        } else if (grades[i] > 1.3001 && grades[i] <= 1.7001) {\n            out[i] = "C-";\n        } else if (grades[i] > 1.0001 && grades[i] <= 1.3001) {\n            out[i] = "D+";\n        } else if (grades[i] > 0.7001 && grades[i] <= 1.0001) {\n            out[i] = "D ";\n        } else if (grades[i] > 0.0001 && grades[i] <= 0.7001) {\n            out[i] = "D-";\n        } else {\n            out[i] = "E ";\n        }\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::string> result;\n    std::vector<std::string> expected1 = {"A+", "B ", "C-", "C ", "A-"};\n    std::vector<std::string> expected2 = {"D+"};\n    std::vector<std::string> expected3 = {"D-"};\n    std::vector<std::string> expected4 = {"E "};\n    std::vector<std::string> expected5 = {"D ", "D-", "C-", "B ", "B+"};\n    std::vector<std::string> expected6 = {"E ", "D-"};\n\n    numerical_letter_grade({4.0, 3.0, 1.7, 2.0, 3.5}, result);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({1.2}, result);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({0.5}, result);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({0.0}, result);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for test case 4" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({1.0, 0.3, 1.5, 2.8, 3.3}, result);\n    if (!issame(result, expected5)) {\n        std::cerr << "Assertion failed for test case 5" << std::endl;\n        return 1;\n    }\n\n    numerical_letter_grade({0.0, 0.7}, result);\n    if (!issame(result, expected6)) {\n        std::cerr << "Assertion failed for test case 6" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\nbool is_prime_length(const std::string& s) {\n    int l = s.length();\n    if (l < 2) {\n        return false;\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(l)); ++i) {\n        if (l % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid run_tests() {\n    struct Test {\n        std::string str;\n        bool expected;\n    };\n\n    Test tests[] = {\n        {"Hello", true},\n        {"abcdcba", true},\n        {"kittens", true},\n        {"orange", false},\n        {"wow", true},\n        {"world", true},\n        {"MadaM", true},\n        {"Wow", true},\n        {"", false},\n        {"HI", true},\n        {"go", true},\n        {"gogo", false},\n        {"aaaaaaaaaaaaaaa", false},\n        {"Madam", true},\n        {"M", false},\n        {"0", false}\n    };\n\n    bool all_tests_passed = true;\n    for (const auto& test : tests) {\n        bool result = is_prime_length(test.str);\n        if (result != test.expected) {\n            std::cerr << "is_prime_length('" << test.str << "') == "\n                      << std::boolalpha << test.expected << ": assertion failed" << std::endl;\n            all_tests_passed = false;\n        }\n    }\n\n    if (all_tests_passed) {\n        std::cout << "All tests passed successfully." << std::endl;\n    }\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint starts_one_ends(int n);\n\nint main() {\n    // Assertions\n    if (starts_one_ends(1) != 1) {\n        std::cerr << "Assertion failed: starts_one_ends(1) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(2) != 18) {\n        std::cerr << "Assertion failed: starts_one_ends(2) == 18" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(3) != 180) {\n        std::cerr << "Assertion failed: starts_one_ends(3) == 180" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(4) != 1800) {\n        std::cerr << "Assertion failed: starts_one_ends(4) == 1800" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(5) != 18000) {\n        std::cerr << "Assertion failed: starts_one_ends(5) == 18000" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint starts_one_ends(int n) {\n    if (n < 1) {\n        return 0;\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    int out = 18;\n    for (int i = 2; i <= n - 1; ++i) {\n        out *= 10;\n    }\n\n    return out;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function prototype\nstd::string solve(int N);\n\nint main() {\n    std::string result;\n\n    result = solve(1000);\n    if (result != "1") {\n        std::cerr << "Assertion failed for solve(1000)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(150);\n    if (result != "110") {\n        std::cerr << "Assertion failed for solve(150)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(147);\n    if (result != "1100") {\n        std::cerr << "Assertion failed for solve(147)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(333);\n    if (result != "1001") {\n        std::cerr << "Assertion failed for solve(333)" << std::endl;\n        exit(1);\n    }\n\n    result = solve(963);\n    if (result != "10010") {\n        std::cerr << "Assertion failed for solve(963)" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nstd::string solve(int N) {\n    std::string str = std::to_string(N); // Convert integer N to string\n    int sum = 0;\n\n    // Calculate the sum of digits\n    for (char c : str) {\n        sum += c - '0'; // Subtract '0' to get the digit value\n    }\n\n    std::string bi = "";\n\n    // Convert sum to binary\n    while (sum > 0) {\n        bi = static_cast<char>(sum % 2) + bi; // Append digit to the beginning\n        sum /= 2;\n    }\n\n    // Handle the case when sum is 0\n    if (bi.empty()) {\n        bi = "0";\n    }\n\n    return bi;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nint add(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size() / 2; ++i) {\n        if (lst[2 * i + 1] % 2 == 0) {\n            sum += lst[2 * i + 1];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    if (add({4, 88}) != 88) {\n        std::cerr << "Assertion failed: add({4, 88}) == 88" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 5, 6, 7, 2, 122}) != 122) {\n        std::cerr << "Assertion failed: add({4, 5, 6, 7, 2, 122}) == 122" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 0, 6, 7}) != 0) {\n        std::cerr << "Assertion failed: add({4, 0, 6, 7}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (add({4, 4, 6, 8}) != 12) {\n        std::cerr << "Assertion failed: add({4, 4, 6, 8}) == 12" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> sort_array(const std::vector<int>& array) {\n    std::vector<int> out = array;\n    int n = out.size();\n\n    if (n == 0) {\n        return out;\n    }\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (out[j] > out[j + 1]) {\n                std::swap(out[j], out[j + 1]);\n            }\n        }\n    }\n\n    if (out[0] + out[n - 1] % 2 == 1) {\n        return out;\n    } else {\n        std::reverse(out.begin(), out.end());\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid test_cases() {\n    assert(issame(sort_array({0}), {0}));\n    assert(issame(sort_array({5}), {5}));\n    assert(issame(sort_array({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5}));\n    assert(issame(sort_array({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0}));\n    assert(issame(sort_array({2, 1}), {1, 2}));\n    assert(issame(sort_array({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87}));\n    assert(issame(sort_array({21, 14, 23, 11}), {23, 21, 14, 11}));\n}\n\nint main() {\n    test_cases();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Utilities {\npublic:\n    static int next_smallest(const std::vector<int>& lst) {\n        if (lst.empty()) {\n            return -1;\n        }\n\n        std::vector<int> sorted_lst = lst;\n        std::sort(sorted_lst.begin(), sorted_lst.end());\n\n        int res = -1;\n        for (size_t i = 1; i < sorted_lst.size(); ++i) {\n            if (sorted_lst[i] != sorted_lst[i - 1]) {\n                res = sorted_lst[i];\n                break;\n            }\n        }\n        return res;\n    }\n\n    static void sort(std::vector<int>& arr) {\n        std::sort(arr.begin(), arr.end());\n    }\n};\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test case 1\n    lst = {1, 2, 3, 4, 5};\n    result = Utilities::next_smallest(lst);\n    if (result != 2) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    lst = {5, 1, 4, 3, 2};\n    result = Utilities::next_smallest(lst);\n    if (result != 2) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    lst = {};\n    result = Utilities::next_smallest(lst);\n    if (result != -1) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    lst = {1, 1};\n    result = Utilities::next_smallest(lst);\n    if (result != -1) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    lst = {1, 1, 1, 1, 0};\n    result = Utilities::next_smallest(lst);\n    if (result != 1) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 6\n    lst = {-35, 34, 12, -45};\n    result = Utilities::next_smallest(lst);\n    if (result != -35) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint is_bored(const std::string& S) {\n    int sum = 0;\n    bool isstart = true;\n    bool isi = false;\n    int lenS = S.length();\n\n    for (int i = 0; i < lenS; ++i) {\n        if (S[i] == ' ' && isi) {\n            isi = false;\n            sum++;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = true;\n        } else {\n            isi = false;\n        }\n        if (S[i] != ' ') {\n            isstart = false;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = true;\n        }\n    }\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(is_bored("Hello world") == 0);\n    assert(is_bored("Is the sky blue?") == 0);\n    assert(is_bored("I love It !") == 1);\n    assert(is_bored("bIt") == 0);\n    assert(is_bored("I feel good today. I will be productive. will kill It") == 2);\n    assert(is_bored("You and I are going for a walk") == 0);\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool any_int(double a, double b, double c) {\n    if (std::round(a) != a || std::round(b) != b || std::round(c) != c) {\n        return false;\n    }\n    if (a + b == c || a + c == b || b + c == a) {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    bool result;\n\n    result = any_int(2.0, 3.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 3, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.5, 2.0, 3.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.5, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(1.5, 5.0, 3.5);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(1.5, 5, 3.5) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0, 6.0, 2.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2, 6, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(4.0, 2.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(4, 2, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.2, 2.2, 2.2);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.2, 2.2, 2.2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(-4.0, 6.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(-4, 6, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0, 1.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 1, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.0, 4.0, 7.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(3, 4, 7) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.01, 4.0, 7.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(3.01, 4, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint largestPrime(const std::vector<int>& lst) {\n    int largest = 0;\n    for (int i : lst) {\n        if (i > largest && isPrime(i)) {\n            largest = i;\n        }\n    }\n    return largest;\n}\n\nint sumDigits(int n) {\n    std::string s = std::to_string(n);\n    int sum = 0;\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nint skjkasdkd(const std::vector<int>& lst) {\n    int largest = largestPrime(lst);\n    return sumDigits(largest);\n}\n\nint main() {\n    std::vector<int> testCases[] = {\n        {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3},\n        {1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1},\n        {1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3},\n        {0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6},\n        {0, 81, 12, 3, 1, 21},\n        {0, 8, 1, 2, 1, 7},\n        {8191},\n        {8191, 123456, 127, 7},\n        {127, 97, 8192}\n    };\n\n    bool allTestsPassed = true;\n    for (const auto& testCase : testCases) {\n        int result = skjkasdkd(testCase);\n        if (result != 10) {\n            std::cerr << "Assertion failed: result /= 10" << std::endl;\n            allTestsPassed = false;\n        }\n    }\n\n    if (allTestsPassed) {\n        std::cout << "All tests passed." << std::endl;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint multiply(int a, int b);\n\nint main() {\n    int result;\n\n    // Assertions\n    result = multiply(148, 412);\n    if (result != 16) {\n        std::cerr << "Assertion failed: multiply(148, 412) == 16" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(19, 28);\n    if (result != 72) {\n        std::cerr << "Assertion failed: multiply(19, 28) == 72" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(2020, 1851);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(2020, 1851) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(14, -15);\n    if (result != 20) {\n        std::cerr << "Assertion failed: multiply(14, -15) == 20" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(76, 67);\n    if (result != 42) {\n        std::cerr << "Assertion failed: multiply(76, 67) == 42" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(17, 27);\n    if (result != 49) {\n        std::cerr << "Assertion failed: multiply(17, 27) == 49" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(0, 1);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(0, 1) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(0, 0);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(0, 0) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint multiply(int a, int b) {\n    return (a % 10) * (b % 10);\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function prototype\nint count_upper(const std::string& s);\n\nint main() {\n    int result;\n\n    // Test cases\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_upper('aBCdEf') == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('abcdefg') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("dBBE");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('dBBE') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("B");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('B') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("U");\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_upper('U') == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("");\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_upper('') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = count_upper("EEEE");\n    if (result != 2) {\n        std::cerr << "Assertion failed: count_upper('EEEE') == 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nint count_upper(const std::string& s) {\n    const std::string uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = s.length();\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (uvowel.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n#include <cmath> // For round()\n#include <string>\n\n// Function to find the closest integer to a given floating-point number\nint closest_integer(const std::string& value) {\n    double w;\n    // Assuming the value is a floating-point number represented as a string\n    std::stringstream(value) >> w;\n    return std::round(w);\n}\n\n// Subroutine to assert conditions\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Main program body\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid make_a_pile(int n, std::vector<int>& out) {\n    out.resize(n);\n    out[0] = n;\n    for (int i = 1; i < n; ++i) {\n        out[i] = out[i - 1] + 2;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> pile;\n    int n;\n\n    make_a_pile(3, pile);\n    assert(issame(pile, {3, 5, 7}));\n\n    make_a_pile(4, pile);\n    assert(issame(pile, {4, 6, 8, 10}));\n\n    make_a_pile(5, pile);\n    assert(issame(pile, {5, 7, 9, 11, 13}));\n\n    make_a_pile(6, pile);\n    assert(issame(pile, {6, 8, 10, 12, 14, 16}));\n\n    make_a_pile(8, pile);\n    assert(issame(pile, {8, 10, 12, 14, 16, 18, 20, 22}));\n\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint choose_num(int x, int y);\n\nint main() {\n    int result;\n\n    result = choose_num(12, 15);\n    if (result != 14) {\n        std::cerr << "Assertion failed: choose_num(12, 15) == 14" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(13, 12);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(13, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        std::cerr << "Assertion failed: choose_num(33, 12354) == 12354" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(5234, 5233);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(5234, 5233) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(6, 29);\n    if (result != 28) {\n        std::cerr << "Assertion failed: choose_num(6, 29) == 28" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(27, 10);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(27, 10) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(7, 7);\n    if (result != -1) {\n        std::cerr << "Assertion failed: choose_num(7, 7) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(546, 546);\n    if (result != 546) {\n        std::cerr << "Assertion failed: choose_num(546, 546) == 546" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nint choose_num(int x, int y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && x % 2 == 1) {\n        return -1;\n    } else if (x % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nclass Utils {\npublic:\n    static std::string rounded_avg(int n, int m) {\n        if (n > m) {\n            return "-1";\n        }\n\n        int num = (m + n) / 2;\n        std::string temp_out = "";\n        while (num > 0) {\n            int remainder = num % 2;\n            temp_out = std::string(1, static_cast<char>(remainder + '0')) + temp_out;\n            num = num / 2;\n        }\n\n        if (temp_out.empty()) {\n            temp_out = "0";\n        }\n\n        return temp_out;\n    }\n\n    static void assert(bool condition, const std::string& message) {\n        if (!condition) {\n            std::cerr << message << std::endl;\n            exit(1);\n        }\n    }\n};\n\nint main() {\n    // Main program\n    Utils::assert(Utils::rounded_avg(1, 5) == "11", "Assertion failed: rounded_avg(1, 5) == '11'");\n    Utils::assert(Utils::rounded_avg(7, 13) == "1010", "Assertion failed: rounded_avg(7, 13) == '1010'");\n    Utils::assert(Utils::rounded_avg(964, 977) == "1111001010", "Assertion failed: rounded_avg(964, 977) == '1111001010'");\n    Utils::assert(Utils::rounded_avg(996, 997) == "1111100100", "Assertion failed: rounded_avg(996, 997) == '1111100100'");\n    Utils::assert(Utils::rounded_avg(560, 851) == "1011000001", "Assertion failed: rounded_avg(560, 851) == '1011000001'");\n    Utils::assert(Utils::rounded_avg(185, 546) == "101101101", "Assertion failed: rounded_avg(185, 546) == '101101101'");\n    Utils::assert(Utils::rounded_avg(362, 496) == "110101101", "Assertion failed: rounded_avg(362, 496) == '110101101'");\n    Utils::assert(Utils::rounded_avg(350, 902) == "1001110010", "Assertion failed: rounded_avg(350, 902) == '1001110010'");\n    Utils::assert(Utils::rounded_avg(197, 233) == "11010111", "Assertion failed: rounded_avg(197, 233) == '11010111'");\n    Utils::assert(Utils::rounded_avg(7, 5) == "-1", "Assertion failed: rounded_avg(7, 5) == '-1'");\n    Utils::assert(Utils::rounded_avg(5, 1) == "-1", "Assertion failed: rounded_avg(5, 1) == '-1'");\n    Utils::assert(Utils::rounded_avg(5, 5) == "101", "Assertion failed: rounded_avg(5, 5) == '101'");\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Utils {\npublic:\n    struct NumToType {\n        int key;\n        std::string value;\n\n        NumToType(int key, const std::string& value) : key(key), value(value) {}\n    };\n\n    static void sort_array(std::vector<int>& arr) {\n        std::sort(arr.begin(), arr.end());\n    }\n\n    static std::vector<std::string> by_length(const std::vector<int>& arr) {\n        std::vector<std::string> out;\n        std::vector<NumToType> numto = {\n            NumToType(0, "Zero"), NumToType(1, "One"), NumToType(2, "Two"),\n            NumToType(3, "Three"), NumToType(4, "Four"), NumToType(5, "Five"),\n            NumToType(6, "Six"), NumToType(7, "Seven"), NumToType(8, "Eight"),\n            NumToType(9, "Nine")\n        };\n\n        sort_array(const_cast<std::vector<int>&>(arr));\n\n        for (int i = arr.size() - 1; i >= 0; --i) {\n            if (arr[i] >= 1 && arr[i] <= 9) {\n                out.push_back(numto[arr[i]].value);\n            }\n        }\n\n        return out;\n    }\n\n    static bool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n        if (a.size() != b.size()) {\n            return false;\n        }\n\n        for (size_t i = 0; i < a.size(); ++i) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    std::vector<int> arr = {2, 1, 1, 4, 5, 8, 2, 3};\n    std::vector<std::string> result = Utils::by_length(arr);\n    std::vector<std::string> expected1 = {"Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"};\n\n    if (!Utils::issame(result, expected1)) {\n        std::cerr << "Test 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr.clear();\n    result = Utils::by_length(arr);\n    std::vector<std::string> expected2 = {"One"};\n\n    if (!Utils::issame(result, expected2)) {\n        std::cerr << "Test 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {1, -1, 55};\n    result = Utils::by_length(arr);\n\n    if (!Utils::issame(result, expected2)) {\n        std::cerr << "Test 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {1, -1, 3, 2};\n    result = Utils::by_length(arr);\n    std::vector<std::string> expected3 = {"Three", "Two", "One"};\n\n    if (!Utils::issame(result, expected3)) {\n        std::cerr << "Test 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {9, 4, 8};\n    result = Utils::by_length(arr);\n    std::vector<std::string> expected4 = {"Nine", "Eight", "Four"};\n\n    if (!Utils::issame(result, expected4)) {\n        std::cerr << "Test 5: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to compute the values as in the Fortran code\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0;\n    int prod = 1;\n\n    for (int i = 0; i < n; ++i) {\n        sum += i + 1;\n        prod *= (i + 1);\n        if (i % 2 == 0) {\n            out[i] = prod;\n        } else {\n            out[i] = sum;\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    std::vector<int> expected3 = {1};\n    std::vector<int> expected4 = {1, 2, 6};\n\n    auto result = f(5);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for f(5)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(7);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for f(7)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(1);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for f(1)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(3);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for f(3)" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> result(2, 0);\n    int num1 = 0, num2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string w = std::to_string(i);\n        std::string p = w;\n        std::reverse(p.begin(), p.end());\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    result[0] = num2;\n    result[1] = num1;\n    return result;\n}\n\nvoid test_even_odd_palindrome(int n, const std::vector<int>& expected) {\n    std::vector<int> result = even_odd_palindrome(n);\n    if (result != expected) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_even_odd_palindrome(123, {8, 13});\n    test_even_odd_palindrome(12, {4, 6});\n    test_even_odd_palindrome(3, {1, 2});\n    test_even_odd_palindrome(63, {6, 8});\n    test_even_odd_palindrome(25, {5, 6});\n    test_even_odd_palindrome(19, {4, 6});\n    test_even_odd_palindrome(9, {4, 5});\n    test_even_odd_palindrome(1, {0, 1});\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n\nint count_nums(const std::vector<int>& n) {\n    int num = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        if (n[i] > 0) {\n            ++num;\n        } else {\n            int sum = 0;\n            int w = std::abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w /= 10;\n            }\n            sum -= w;\n            if (sum > 0) ++num;\n        }\n    }\n    return num;\n}\n\nint main() {\n    std::vector<int> test_case_1 = {0};\n    if (count_nums(test_case_1) != 0) {\n        std::cerr << "Assertion failed: count_nums({0}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_2 = {-1, -2, 0};\n    if (count_nums(test_case_2) != 0) {\n        std::cerr << "Assertion failed: count_nums({-1, -2, 0}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_3 = {1, 1, 2, -2, 3, 4, 5};\n    if (count_nums(test_case_3) != 6) {\n        std::cerr << "Assertion failed: count_nums({1, 1, 2, -2, 3, 4, 5}) == 6" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_4 = {1, 6, 9, -6, 0, 1, 5};\n    if (count_nums(test_case_4) != 5) {\n        std::cerr << "Assertion failed: count_nums({1, 6, 9, -6, 0, 1, 5}) == 5" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_5 = {1, 100, 98, -7, 1, -1};\n    if (count_nums(test_case_5) != 4) {\n        std::cerr << "Assertion failed: count_nums({1, 100, 98, -7, 1, -1}) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_6 = {12, 23, 34, -45, -56, 0};\n    if (count_nums(test_case_6) != 5) {\n        std::cerr << "Assertion failed: count_nums({12, 23, 34, -45, -56, 0}) == 5" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_7 = {-0, 1};\n    if (count_nums(test_case_7) != 1) {\n        std::cerr << "Assertion failed: count_nums({-0, 1}) == 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_8 = {1};\n    if (count_nums(test_case_8) != 1) {\n        std::cerr << "Assertion failed: count_nums({1}) == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool move_one_ball(const std::vector<int>& arr) {\n    int num = 0;\n    if (arr.size() == 0) {\n        return true;\n    }\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            num++;\n        }\n    }\n\n    if (arr.back() > arr[0]) {\n        num++;\n    }\n\n    return num < 2;\n}\n\nint main() {\n    std::vector<int> arr;\n    bool result;\n\n    // Test cases\n    arr = {3, 4, 5, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {3, 5, 10, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {4, 3, 1, 2};\n    result = move_one_ball(arr);\n    if (result) {\n        std::cerr << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {3, 5, 4, 1, 2};\n    result = move_one_ball(arr);\n    if (result) {\n        std::cerr << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    arr = {}; // Empty vector\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {}" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::string exchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int num = 0;\n    for (int i : lst1) {\n        if (i % 2 == 0) num++;\n    }\n    for (int i : lst2) {\n        if (i % 2 == 0) num++;\n    }\n\n    return (num >= lst1.size()) ? "YES" : "NO";\n}\n\nint main() {\n    std::vector<int> lst1 = {1, 2, 3, 4};\n    std::vector<int> lst2 = {1, 2, 3, 4};\n    std::string result;\n\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {1, 5, 3, 4};\n    result = exchange(lst1, lst2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {2, 1, 4, 3};\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 4};\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 3};\n    result = exchange(lst1, lst2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 3}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {3, 2, 6, 1, 8, 9};\n    lst2 = {3, 5, 5, 1, 1, 1};\n    result = exchange(lst1, lst2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    lst1 = {100, 200};\n    lst2 = {200, 200};\n    result = exchange(lst1, lst2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({100, 200}, {200, 200}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid odd_count(const std::vector<std::string>& lst, std::vector<std::string>& out) {\n    std::string s = "the number of odd elements in the string i of the input.";\n    out.resize(lst.size());\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int sum = 0;\n        for (char c : lst[i]) {\n            if (c >= '0' && c <= '9') {\n                if (c % 2 == 1) sum++;\n            }\n        }\n\n        std::string s2;\n        size_t pos = 0;\n        for (char c : s) {\n            if (c == 'i') {\n                std::string temp = std::to_string(sum);\n                s2 += temp;\n                pos += temp.size();\n            } else {\n                s2 += c;\n                pos++;\n            }\n        }\n        out[i] = s2;\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid print_results(const std::vector<std::string>& output, const std::vector<std::string>& expected) {\n    std::cout << "Actual Output:" << std::endl;\n    for (const auto& str : output) {\n        std::cout << str << std::endl;\n    }\n\n    std::cout << "Expected Output:" << std::endl;\n    for (const auto& str : expected) {\n        std::cout << str << std::endl;\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> input = {"1234567"};\n    std::vector<std::string> expected = {"the number of odd elements in the string 4 of the input."};\n    std::vector<std::string> output;\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 2\n    input = {"3", "11111111"};\n    expected = {"the number of odd elements in the string 1 of the input.",\n                "the number of odd elements in the string 8 of the input."};\n    output.clear();\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 3\n    input = {"271", "137", "314"};\n    expected = {"the number of odd elements in the string 2 of the input.",\n                "the number of odd elements in the string 3 of the input.",\n                "the number of odd elements in the string 2 of the input."};\n    output.clear();\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nstd::vector<int> sort_array(const std::vector<int>& arr) {\n    std::vector<int> sorted_arr(arr.size());\n    std::vector<int> bin(arr.size());\n\n    // Copy input array to sorted_arr\n    sorted_arr = arr;\n\n    // Calculate the number of 1s in the binary representation of each element\n    for (size_t i = 0; i < arr.size(); ++i) {\n        int b = 0;\n        int n = std::abs(arr[i]);\n        while (n > 0) {\n            b += n % 2;\n            n /= 2;\n        }\n        bin[i] = b;\n    }\n\n    // Sort the array based on the bin values and the original values\n    for (size_t i = 0; i < arr.size(); ++i) {\n        for (size_t j = 1; j < arr.size(); ++j) {\n            if (bin[j] < bin[j - 1] || (bin[j] == bin[j - 1] && sorted_arr[j] < sorted_arr[j - 1])) {\n                std::swap(sorted_arr[j], sorted_arr[j - 1]);\n                std::swap(bin[j], bin[j - 1]);\n            }\n        }\n    }\n\n    return sorted_arr;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_case(const std::vector<int>& arr, const std::vector<int>& expected) {\n    std::vector<int> sorted_arr = sort_array(arr);\n    if (!issame(sorted_arr, expected)) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    // Test cases\n    test_case({1, 5, 2, 3, 4}, {1, 2, 4, 3, 5});\n    test_case({-2, -3, -4, -5, -6}, {-4, -2, -6, -5, -3});\n    test_case({1, 0, 2, 3, 4}, {0, 1, 2, 4, 3});\n    test_case({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}, {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77});\n    test_case({3, 6, 44, 12, 32, 5}, {32, 3, 5, 6, 12, 44});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string get_closest_vowel(const std::string& word) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n\n    for (int i = word.length() - 1; i >= 2; --i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (vowels.find(word[i + 1]) == std::string::npos && vowels.find(word[i - 1]) == std::string::npos) {\n                result = word.substr(i, 1);\n                return result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(get_closest_vowel("yogurt") == "u");\n    assert(get_closest_vowel("full") == "u");\n    assert(get_closest_vowel("easy") == "");\n    assert(get_closest_vowel("eAsy") == "");\n    assert(get_closest_vowel("ali") == "");\n    assert(get_closest_vowel("bad") == "a");\n    assert(get_closest_vowel("most") == "o");\n    assert(get_closest_vowel("ab") == "");\n    assert(get_closest_vowel("ba") == "");\n    assert(get_closest_vowel("quick") == "");\n    assert(get_closest_vowel("anime") == "i");\n    assert(get_closest_vowel("Asia") == "");\n    assert(get_closest_vowel("Above") == "o");\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid bubble_sort(std::vector<int>& arr) {\n    int temp;\n    for (int i = 0; i < arr.size() - 1; ++i) {\n        for (int j = 0; j < arr.size() - i - 1; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nstd::vector<int> maximum(const std::vector<int>& arr, int k) {\n    std::vector<int> sorted_arr = arr;\n    bubble_sort(sorted_arr);\n    return std::vector<int>(sorted_arr.rbegin(), sorted_arr.rbegin() + k);\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(issame(maximum({-3, -4, 5}, 3), {-4, -3, 5}));\n    assert(issame(maximum({4, -4, 4}, 2), {4, 4}));\n    assert(issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1), {2}));\n    assert(issame(maximum({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123}));\n    assert(issame(maximum({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20}));\n    assert(issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15}));\n    assert(issame(maximum({-1, 0, 2, 5, 3, -10}, 2), {3, 5}));\n    assert(issame(maximum({1, 0, 5, -7}, 1), {5}));\n    assert(issame(maximum({4, -4}, 2), {-4, 4}));\n    assert(issame(maximum({-10, 10}, 2), {-10, 10}));\n    // Handle the empty array case separately\n    assert(issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0), {}));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to calculate the sum of odd numbers in the array\nint solutions(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    std::vector<int> test1 = {5, 8, 7, 1};\n    if (solutions(test1) != 12) {\n        std::cerr << "Assertion failed: solutions({5, 8, 7, 1}) == 12" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test2 = {3, 3, 3, 3, 3};\n    if (solutions(test2) != 9) {\n        std::cerr << "Assertion failed: solutions({3, 3, 3, 3, 3}) == 9" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test3 = {30, 13, 24, 321};\n    if (solutions(test3) != 0) {\n        std::cerr << "Assertion failed: solutions({30, 13, 24, 321}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test4 = {5, 9};\n    if (solutions(test4) != 5) {\n        std::cerr << "Assertion failed: solutions({5, 9}) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test5 = {2, 4, 8};\n    if (solutions(test5) != 0) {\n        std::cerr << "Assertion failed: solutions({2, 4, 8}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test6 = {30, 13, 23, 32};\n    if (solutions(test6) != 23) {\n        std::cerr << "Assertion failed: solutions({30, 13, 23, 32}) == 23" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test7 = {3, 13, 2, 9};\n    if (solutions(test7) != 3) {\n        std::cerr << "Assertion failed: solutions({3, 13, 2, 9}) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n\nnamespace utils {\n    int add_elements(const std::vector<int>& arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; ++i) {\n            if (arr[i] >= -99 && arr[i] <= 99) {\n                sum += arr[i];\n            }\n        }\n        return sum;\n    }\n}\n\nint main() {\n    // Test cases\n    if (utils::add_elements({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3) != -4) {\n        std::cerr << "Assertion failed: result /= -4" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({111, 121, 3, 4000, 5, 6}, 2) != 0) {\n        std::cerr << "Assertion failed: result /= 0" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4) != 125) {\n        std::cerr << "Assertion failed: result /= 125" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4) != 24) {\n        std::cerr << "Assertion failed: result /= 24" << std::endl;\n        return 1;\n    }\n\n    if (utils::add_elements({1}, 1) != 1) {\n        std::cerr << "Assertion failed: result /= 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to get the Collatz sequence for an odd number\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> out = {1};\n    int temp = n;\n    int count = 1;\n    std::vector<int> temp_array;\n\n    while (temp != 1) {\n        if (temp % 2 == 1) {\n            count++;\n            temp_array.resize(count);\n            std::copy(out.begin(), out.end(), temp_array.begin());\n            temp_array[count - 1] = temp;\n            out = temp_array;\n            temp = temp * 3 + 1;\n        } else {\n            temp = temp / 2;\n        }\n    }\n\n    std::sort(out.begin(), out.end());\n    return out;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine to sort a vector\nvoid sort(std::vector<int>& array) {\n    std::sort(array.begin(), array.end());\n}\n\n// Test function for the odd Collatz sequence\nvoid test_odd_collatz(int n, const std::vector<int>& expected) {\n    std::vector<int> result = get_odd_collatz(n);\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_odd_collatz(14, {1, 5, 7, 11, 13, 17});\n    test_odd_collatz(5, {1, 5});\n    test_odd_collatz(12, {1, 3, 5});\n    test_odd_collatz(1, {1});\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to check if a date is valid\nbool valid_date(const std::string& date);\n\n// Function to pad a string with spaces to make it 10 characters long\nstd::string pad(const std::string& str);\n\n// Assertion function to mimic the Fortran assert\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(valid_date("03-11-2000") == true);\n    assert(valid_date("15-01-2012") == false);\n    assert(valid_date("04-0-2040") == false);\n    assert(valid_date("06-04-2020") == true);\n    assert(valid_date("01-01-2007") == true);\n    assert(valid_date("03-32-2011") == false);\n    assert(valid_date("") == false);\n    assert(valid_date("04-31-3000") == false);\n    assert(valid_date("06-06-2005") == true);\n    assert(valid_date("21-31-2000") == false);\n    assert(valid_date("04-12-2003") == true);\n    assert(valid_date("04122003") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("20030412") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("2003-04") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("2003-04-12") == false); // Note: This case is not correctly formatted for comparison\n    assert(valid_date("04-2003") == false); // Note: This case is not correctly formatted for comparison\n\n    return 0;\n}\n\nbool valid_date(const std::string& date) {\n    if (date.length() != 10) {\n        return false;\n    }\n\n    for (size_t i = 0; i < date.length(); ++i) {\n        if ((i == 2 || i == 5) && date[i] != '-') {\n            return false;\n        } else if (date[i] < '0' || date[i] > '9') {\n            return false;\n        }\n    }\n\n    int mm, dd, yy;\n    std::sscanf(date.substr(0, 2).c_str(), "%d", &mm);\n    std::sscanf(date.substr(3, 2).c_str(), "%d", &dd);\n    std::sscanf(date.substr(6, 4).c_str(), "%d", &yy);\n\n    if (mm < 1 || mm > 12) {\n        return false;\n    }\n\n    if (dd < 1 || dd > 31) {\n        return false;\n    }\n\n    if ((dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11)) || (dd == 30 && mm == 2)) {\n        return false;\n    }\n\n    return true;\n}\n\nstd::string pad(const std::string& str) {\n    std::string padded_str = str;\n    padded_str.append(10 - padded_str.length(), ' ');\n    return padded_str;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    std::vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 4, 5, 6};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5, 6, 7};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5, 6, 7};\n    assert(is_sorted(lst) == false);\n\n    lst = {};\n    assert(is_sorted(lst) == true);\n\n    lst = {1};\n    assert(is_sorted(lst) == true);\n\n    lst = {3, 2, 1};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 2, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 3, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 3, 3, 4};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4};\n    assert(is_sorted(lst) == true);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n\nstd::string intersection(const std::pair<int, int>& interval1, const std::pair<int, int>& interval2) {\n    int inter1 = std::max(interval1.first, interval2.first);\n    int inter2 = std::min(interval1.second, interval2.second);\n    int l = inter2 - inter1;\n\n    if (l < 2) {\n        return "NO";\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(l)); ++i) {\n        if (l % i == 0) {\n            return "NO";\n        }\n    }\n\n    return "YES";\n}\n\nint main() {\n    std::pair<int, int> interval1, interval2;\n    std::string result;\n\n    // Test cases\n    interval1 = {1, 2};\n    interval2 = {2, 3};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([1, 2], [2, 3]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-1, 1};\n    interval2 = {0, 4};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([-1, 1], [0, 4]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-3, -1};\n    interval2 = {-5, 5};\n    result = intersection(interval1, interval2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: intersection([-3, -1], [-5, 5]) == 'YES'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-2, 2};\n    interval2 = {-4, 0};\n    result = intersection(interval1, interval2);\n    if (result != "YES") {\n        std::cerr << "Assertion failed: intersection([-2, 2], [-4, 0]) == 'YES'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-11, 2};\n    interval2 = {-1, -1};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([-11, 2], [-1, -1]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {1, 2};\n    interval2 = {3, 5};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([1, 2], [3, 5]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {1, 2};\n    interval2 = {1, 2};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([1, 2], [1, 2]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    interval1 = {-2, -2};\n    interval2 = {-3, -2};\n    result = intersection(interval1, interval2);\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection([-2, -2], [-3, -2]) == 'NO'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty() || (arr.size() == 1 && arr[0] == 0)) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int prods = 1;\n\n    for (int num : arr) {\n        sum += std::abs(num);\n        if (num == 0) {\n            prods = 0;\n        }\n        if (num < 0) {\n            prods = -prods;\n        }\n    }\n\n    return sum * prods;\n}\n\nint main() {\n    std::vector<int> test_case_1 = {1, 2, 2, -4};\n    if (prod_signs(test_case_1) != -9) {\n        std::cerr << "Assertion failed: prod_signs({1, 2, 2, -4}) == -9" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_2 = {0, 1};\n    if (prod_signs(test_case_2) != 0) {\n        std::cerr << "Assertion failed: prod_signs({0, 1}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_3 = {1, 1, 1, 2, 3, -1, 1};\n    if (prod_signs(test_case_3) != -10) {\n        std::cerr << "Assertion failed: prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_4 = {0};\n    if (prod_signs(test_case_4) != -32768) {\n        std::cerr << "Assertion failed: prod_signs({}) == -32768" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_5 = {2, 4, 1, 2, -1, -1, 9};\n    if (prod_signs(test_case_5) != 20) {\n        std::cerr << "Assertion failed: prod_signs({2, 4, 1, 2, -1, -1, 9}) == 20" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_6 = {-1, 1, -1, 1};\n    if (prod_signs(test_case_6) != 4) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, -1, 1}) == 4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_7 = {-1, 1, 1, 1};\n    if (prod_signs(test_case_7) != -4) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, 1, 1}) == -4" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> test_case_8 = {-1, 1, 1, 0};\n    if (prod_signs(test_case_8) != 0) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, 1, 0}) == 0" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid minPath(const std::vector<std::vector<int>>& grid, int k, std::vector<int>& result) {\n    int n = grid.size();\n    int x = -1, y = -1;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    int min = n * n;\n    if (x > 0 && grid[x-1][y] < min) min = grid[x-1][y];\n    if (x < n-1 && grid[x+1][y] < min) min = grid[x+1][y];\n    if (y > 0 && grid[x][y-1] < min) min = grid[x][y-1];\n    if (y < n-1 && grid[x][y+1] < min) min = grid[x][y+1];\n\n    result.resize(k);\n    for (int i = 0; i < k; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1;\n        } else {\n            result[i] = min;\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> grid;\n    std::vector<int> result;\n    int k;\n\n    // Test case 1\n    grid = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    k = 3;\n    minPath(grid, k, result);\n    assert(issame(result, {1, 2, 1}));\n\n    // Test case 2\n    grid = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    k = 1;\n    minPath(grid, k, result);\n    assert(issame(result, {1}));\n\n    // Test case 3\n    grid = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    k = 4;\n    minPath(grid, k, result);\n    assert(issame(result, {1, 2, 1, 2}));\n\n    // Add more test cases as needed\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nvoid tri(int n, std::vector<int>& out) {\n    if (n == 0) {\n        out = {1};\n        return;\n    }\n\n    out.resize(n + 1);\n    out[0] = 1;\n    out[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = 1 + (i - 1) / 2;\n        } else {\n            out[i] = out[i - 1] + out[i - 2] + 1 + (i / 2);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_tri(int n, const std::vector<int>& expected) {\n    std::vector<int> result;\n    tri(n, result);\n\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    test_tri(3, {1, 3, 2, 8});\n    test_tri(4, {1, 3, 2, 8, 3});\n    test_tri(5, {1, 3, 2, 8, 3, 15});\n    test_tri(6, {1, 3, 2, 8, 3, 15, 4});\n    test_tri(7, {1, 3, 2, 8, 3, 15, 4, 24});\n    test_tri(8, {1, 3, 2, 8, 3, 15, 4, 24, 5});\n    test_tri(9, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35});\n    test_tri(20, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11});\n    test_tri(0, {1});\n    test_tri(1, {1, 3});\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint digits(int n) {\n    int prod = 1;\n    int has = 0;\n    std::string s = std::to_string(n); // Convert integer to string\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (s[i] % 2 == 1) {\n            has = 1;\n            prod *= (s[i] - '0');\n        }\n    }\n\n    if (has == 0) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Assertions\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_nested(const std::string& str) {\n    int count = 0;\n    int maxcount = 0;\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (str[i] == '[') {\n            count++;\n        } else if (str[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            count = 0;\n        }\n        if (count > maxcount) {\n            maxcount = count;\n        }\n        if (count <= maxcount - 2) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(is_nested("[[]]") == true);\n    assert(is_nested("[]]]]]]][[[[[]") == false);\n    assert(is_nested("[][]") == false);\n    assert(is_nested("[]") == false);\n    assert(is_nested("[[[[]]]]") == true);\n    assert(is_nested("[]]]]]]]]]]") == false);\n    assert(is_nested("[][][[]]") == true);\n    assert(is_nested("[[]") == false);\n    assert(is_nested("[]]") == false);\n    assert(is_nested("[[]][[") == true);\n    assert(is_nested("[[][]]") == true);\n    assert(is_nested("") == false);\n    assert(is_nested("[[[[[[[[") == false);\n    assert(is_nested("]]]]]]]]") == false);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdlib>\n\n// Function to calculate the sum of squares of elements in a list\nint sum_squares(const std::vector<double>& lst) {\n    int sum = 0;\n    for (double num : lst) {\n        sum += std::pow(std::ceil(num), 2);\n    }\n    return sum;\n}\n\n// Subroutine to assert a condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Function to run tests\nvoid run_tests() {\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 3.0, 5.0, 7.0}) == 84);\n    assert(sum_squares({1.4, 4.2, 0.0}) == 29);\n    assert(sum_squares({-2.4, 1.0, 1.0}) == 6);\n    assert(sum_squares({100.0, 1.0, 15.0, 2.0}) == 10230);\n    assert(sum_squares({10000.0, 10000.0}) == 200000000);\n    assert(sum_squares({-1.4, 4.6, 6.3}) == 75);\n    assert(sum_squares({-1.4, 17.9, 18.9, 19.9}) == 1086);\n    assert(sum_squares({0.0}) == 0);\n    assert(sum_squares({-1.0}) == 1);\n    assert(sum_squares({-1.0, 1.0, 0.0}) == 2);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nclass CanArrangeModule {\npublic:\n    static int can_arrange(const std::vector<int>& arr, int n) {\n        int max = -1;\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] <= i) max = i;\n        }\n        return max;\n    }\n\n    static int can_arrange_empty() {\n        return -1;\n    }\n};\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 4, 3, 5};\n    if (CanArrangeModule::can_arrange(arr1, 5) != 3) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,3,5}) /= 3" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr2 = {1, 2, 4, 5};\n    if (CanArrangeModule::can_arrange(arr2, 4) != -1) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,5}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr3 = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    if (CanArrangeModule::can_arrange(arr3, 9) != 2) {\n        std::cerr << "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) /= 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> arr4 = {4, 8, 5, 7, 3};\n    if (CanArrangeModule::can_arrange(arr4, 5) != 4) {\n        std::cerr << "Assertion failed: can_arrange({4,8,5,7,3}) /= 4" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle the empty array case separately\n    if (CanArrangeModule::can_arrange_empty() != -1) {\n        std::cerr << "Assertion failed: can_arrange({}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nstd::pair<int, int> largest_smallest_integers(const std::vector<int>& lst) {\n    int maxneg = 0, minpos = 0;\n\n    for (int num : lst) {\n        if (num < 0 && (maxneg == 0 || num > maxneg)) maxneg = num;\n        if (num > 0 && (minpos == 0 || num < minpos)) minpos = num;\n    }\n\n    return {maxneg, minpos};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    std::vector<int> test_array;\n    std::pair<int, int> expected;\n\n    // Test case 1\n    test_array = {2, 4, 1, 3, 5, 7};\n    expected = {0, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 2\n    test_array = {2, 4, 1, 3, 5, 7, 0};\n    expected = {0, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 3\n    test_array = {1, 3, 2, 4, 5, 6, -2};\n    expected = {-2, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 4\n    test_array = {4, 5, 3, 6, 2, 7, -7};\n    expected = {-7, 2};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 5\n    test_array = {7, 3, 8, 4, 9, 2, 5, -9};\n    expected = {-9, 2};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 6\n    test_array = {0};\n    expected = {0, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 7\n    test_array = {-1, -3, -5, -6};\n    expected = {-1, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 8\n    test_array = {-1, -3, -5, -6, 0};\n    expected = {-1, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 9\n    test_array = {-6, -4, -4, -3, 1};\n    expected = {-3, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Test case 10\n    test_array = {-6, -4, -4, -3, -100, 1};\n    expected = {-3, 1};\n    assert(issame(largest_smallest_integers(test_array), expected));\n\n    // Special case for empty array\n    test_array = {};\n    expected = {0, 0};\n    assert(issame(largest_smallest_integers(test_array), expected));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint64_t special_factorial(int n);\n\nint main() {\n    int64_t result;\n\n    // Test cases\n    result = special_factorial(4);\n    if (result != 288) {\n        std::cerr << "special_factorial(4) == 288: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(5);\n    if (result != 34560) {\n        std::cerr << "special_factorial(5) == 34560: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(7);\n    if (result != 125411328000) {\n        std::cerr << "special_factorial(7) == 125411328000: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(1);\n    if (result != 1) {\n        std::cerr << "special_factorial(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nint64_t special_factorial(int n) {\n    int64_t fact = 1;\n    int64_t bfact = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact *= i;\n        bfact *= fact;\n    }\n    return bfact;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string file_name_check(const std::string& file_name) {\n    int numdigit = 0;\n    int numdot = 0;\n    std::string last;\n    char w;\n\n    if (file_name.length() < 5) {\n        return "No";\n    }\n\n    w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') {\n        return "No";\n    }\n\n    last = file_name.substr(file_name.length() - 4, 4);\n    if (last != ".txt" && last != ".exe" && last != ".dll") {\n        return "No";\n    }\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') {\n            ++numdigit;\n        }\n        if (file_name[i] == '.') {\n            ++numdot;\n        }\n    }\n\n    if (numdigit > 3 || numdot != 1) {\n        return "No";\n    } else {\n        return "Yes";\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(file_name_check("example.txt") == "Yes");\n    assert(file_name_check("1example.dll") == "No");\n    assert(file_name_check("s1sdf3.asd") == "No");\n    assert(file_name_check("K.dll") == "Yes");\n    assert(file_name_check("MY16FILE3.exe") == "Yes");\n    assert(file_name_check("His12FILE94.exe") == "No");\n    assert(file_name_check("_Y.txt") == "No");\n    assert(file_name_check("?aREYA.exe") == "No");\n    assert(file_name_check("/this_is_valid.dll") == "No");\n    assert(file_name_check("this_is_valid.wow") == "No");\n    assert(file_name_check("this_is_valid.txt") == "Yes");\n    assert(file_name_check("this_is_valid.txtexe") == "No");\n    assert(file_name_check("#this2_i4s_5valid.ten") == "No");\n    assert(file_name_check("@this1_is6_valid.exe") == "No");\n    assert(file_name_check("this_is_12valid.6exe4.txt") == "No");\n    assert(file_name_check("all.exe.txt") == "No");\n    assert(file_name_check("I563_No.exe") == "Yes");\n    assert(file_name_check("Is3youfault.txt") == "Yes");\n    assert(file_name_check("no_one#knows.dll") == "Yes");\n    assert(file_name_check("1I563_Yes3.exe") == "No");\n    assert(file_name_check("I563_Yes3.txtt") == "No");\n    assert(file_name_check("final..txt") == "No");\n    assert(file_name_check("final132") == "No");\n    assert(file_name_check("_f4indsartal132.") == "No");\n    assert(file_name_check(".txt") == "No");\n    assert(file_name_check("s.") == "No");\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool simplify(const std::string& x, const std::string& n) {\n    int a, b, c, d;\n    size_t pos = x.find('/');\n    a = std::stoi(x.substr(0, pos));\n    b = std::stoi(x.substr(pos + 1));\n\n    pos = n.find('/');\n    c = std::stoi(n.substr(0, pos));\n    d = std::stoi(n.substr(pos + 1));\n\n    return (a * c) % (b * d) == 0;\n}\n\nint main() {\n    bool result;\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/6", "2/1");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('1/6', '2/1') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/1", "3/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('5/1', '3/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/10", "10/2");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('7/10', '10/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/10", "50/10");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/10', '50/10') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/2", "4/2");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('7/2', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("11/6", "6/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('11/6', '6/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/3", "5/2");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('2/3', '5/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/2", "3/5");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('5/2', '3/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "8/4");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/4', '8/4') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "4/2");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/4', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "1/5");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('1/5', '1/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n\nstd::vector<int> order_by_points(const std::vector<int>& nums) {\n    if (nums.empty()) return nums;\n\n    std::vector<int> sumdigit(nums.size());\n    std::vector<int> sorted_nums = nums;\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        std::string w = std::to_string(std::abs(nums[i]));\n        int sum = 0;\n        for (size_t j = 1; j < w.length(); ++j) {\n            sum += w[j] - '0';\n        }\n        if (nums[i] > 0) {\n            sum += w[0] - '0';\n        } else {\n            sum -= w[0] - '0';\n        }\n        sumdigit[i] = sum;\n    }\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        for (size_t j = 0; j < nums.size() - i - 1; ++j) {\n            if (sumdigit[j] > sumdigit[j + 1]) {\n                std::swap(sumdigit[j], sumdigit[j + 1]);\n                std::swap(sorted_nums[j], sorted_nums[j + 1]);\n            }\n        }\n    }\n\n    return sorted_nums;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> nums;\n    std::vector<int> result;\n\n    // Test case 1\n    nums = {1, 11, -1, -11, -12};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-1, -11, 1, -12, 11}));\n\n    // Test case 2\n    nums = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n\n    // Test case 3\n    nums = {};\n    result = order_by_points(nums);\n    assert_condition(issame(result, nums));\n\n    // Test case 4\n    nums = {1, -11, -32, 43, 54, -98, 2, -3};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-3, -32, -98, -11, 1, 2, 43, 54}));\n\n    // Test case 5\n    nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n\n    // Test case 6\n    nums = {0, 6, 6, -76, -21, 23, 4};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-76, -21, 0, 4, 23, 6, 6}));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // For std::isdigit\n\nclass SpecialFilter {\npublic:\n    static int specialFilter(const std::vector<int>& nums) {\n        int num = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] > 10) {\n                std::string w = std::to_string(nums[i]);\n                if (std::isdigit(w[0]) && std::isdigit(w[w.length() - 1])) {\n                    num += 1;\n                }\n            }\n        }\n        return num;\n    }\n\n    static int specialFilterEmpty() {\n        return 0;\n    }\n};\n\nint main() {\n    // Test cases\n    if (SpecialFilter::specialFilter({5, -2, 1, -5}) != 0) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({15, -73, 14, -15}) != 1) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({33, -2, -3, 45, 21, 109}) != 2) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({43, -12, 93, 125, 121, 109}) != 4) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({71, -2, -33, 75, 21, 19}) != 3) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    if (SpecialFilter::specialFilter({1}) != 0) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    // Handle empty array case separately\n    if (SpecialFilter::specialFilterEmpty() != 0) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n\nclass MatrixTriples {\npublic:\n    static int getMatrixTriples(int n) {\n        std::vector<int> a(n);\n        std::vector<std::vector<int>> sum(n + 1, std::vector<int>(3, 0));\n        std::vector<std::vector<int>> sum2(n + 1, std::vector<int>(3, 0));\n\n        // Initialize arrays\n        sum = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n        sum2 = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n\n        // Fill array 'a' and compute initial sums\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i * i - i + 1) % 3;\n            for (int j = 0; j < 3; ++j) {\n                sum[i + 1][j] = sum[i][j];\n            }\n            sum[i + 1][a[i]] += 1;\n        }\n\n        // Compute sums for times = 1 and 2\n        for (int times = 1; times <= 2; ++times) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < 3; ++j) {\n                    sum2[i + 1][j] = sum2[i][j];\n                }\n                for (int j = -1; j <= 1; ++j) {\n                    sum2[i + 1][(a[i] + j + 3) % 3] += sum[i][(j + 1) % 3];\n                }\n            }\n            sum = sum2;\n            sum2 = std::vector<std::vector<int>>(n + 1, std::vector<int>(3, 0));\n        }\n\n        return sum[n][0];\n    }\n};\n\nint main() {\n    // Test cases\n    if (MatrixTriples::getMatrixTriples(5) != 1) {\n        std::cerr << "Assertion failed: getMatrixTriples(5) == 1" << std::endl;\n        return 1;\n    }\n\n    if (MatrixTriples::getMatrixTriples(6) != 4) {\n        std::cerr << "Assertion failed: getMatrixTriples(6) == 4" << std::endl;\n        return 1;\n    }\n\n    if (MatrixTriples::getMatrixTriples(10) != 36) {\n        std::cerr << "Assertion failed: getMatrixTriples(10) == 36" << std::endl;\n        return 1;\n    }\n\n    if (MatrixTriples::getMatrixTriples(100) != 53361) {\n        std::cerr << "Assertion failed: getMatrixTriples(100) == 53361" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint x_or_y(int n, int x, int y) {\n    bool isPrime = true;\n    if (n < 2) isPrime = false;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            isPrime = false;\n            break;\n        }\n    }\n\n    return isPrime ? x : y;\n}\n\nint main() {\n    // Assertions\n    if (x_or_y(7, 34, 12) != 34) {\n        std::cerr << "Assertion failed: x_or_y(7, 34, 12) == 34" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(15, 8, 5) != 5) {\n        std::cerr << "Assertion failed: x_or_y(15, 8, 5) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3, 33, 5212) != 33) {\n        std::cerr << "Assertion failed: x_or_y(3, 33, 5212) == 33" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1259, 3, 52) != 3) {\n        std::cerr << "Assertion failed: x_or_y(1259, 3, 52) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(7919, -1, 12) != -1) {\n        std::cerr << "Assertion failed: x_or_y(7919, -1, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3609, 1245, 583) != 583) {\n        std::cerr << "Assertion failed: x_or_y(3609, 1245, 583) == 583" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(91, 56, 129) != 129) {\n        std::cerr << "Assertion failed: x_or_y(91, 56, 129) == 129" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(6, 34, 1234) != 1234) {\n        std::cerr << "Assertion failed: x_or_y(6, 34, 1234) == 1234" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1, 2, 0) != 0) {\n        std::cerr << "Assertion failed: x_or_y(1, 2, 0) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(2, 2, 0) != 2) {\n        std::cerr << "Assertion failed: x_or_y(2, 2, 0) == 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `x_or_y` function in both languages.\n\n### Fortran Unit Tests\n\nTo run the Fortran unit tests, you can use a Fortran compiler like `gfortran`. Save the following code in a file named `test_main.f90`:\n\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototype\nint64_t double_the_difference(const std::vector<double>& lst);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(double_the_difference({0.0}) == 0);\n    assert(double_the_difference({5.0, 4.0}) == 25);\n    assert(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert(double_the_difference({-1.0, -2.0, 8.0}) == 0);\n    assert(double_the_difference({0.2, 3.0, 5.0}) == 34);\n\n    int64_t odd_sum = 0;\n    std::vector<double> lst(100, 0.0);\n\n    // Fill the array and calculate odd_sum\n    for (int i = -99; i <= 99; i += 2) {\n        lst[(i + 101) / 2] = static_cast<double>(i);\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    // Check the final assertion\n    int64_t result = double_the_difference(lst);\n    assert(result == odd_sum);\n\n    return 0;\n}\n\nint64_t double_the_difference(const std::vector<double>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        double rounded_value = std::round(lst[i]);\n        if (std::abs(lst[i] - rounded_value) < 1e-4) {\n            if (lst[i] > 0 && static_cast<int64_t>(std::round(rounded_value)) % 2 == 1) {\n                sum += std::pow(static_cast<int64_t>(std::round(rounded_value)), 2);\n            }\n        }\n    }\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool cycpattern_check(const std::string& a, const std::string& b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    bool is_pattern = false;\n\n    for (int i = 0; i < len_b; ++i) {\n        std::string rotate = b.substr(i) + b.substr(0, i);\n        // Debugging print statement\n        // std::cout << "Checking rotation: " << rotate << std::endl;\n        if (a.find(rotate) != std::string::npos) {\n            is_pattern = true;\n            return is_pattern;\n        }\n    }\n\n    return is_pattern;\n}\n\nint main() {\n    bool result;\n\n    result = cycpattern_check("xyzw", "xyw");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('xyzw', 'xyw') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("yello", "ell");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('yello', 'ell') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("whattup", "ptut");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('whattup', 'ptut') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("efef", "fee");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('efef', 'fee') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("abab", "aabb");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('abab', 'aabb') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("winemtt", "tinem");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('winemtt', 'tinem') == true" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> even_odd_count(int num) {\n    std::string w = std::to_string(std::abs(num));\n    int n1 = 0, n2 = 0;\n\n    for (char c : w) {\n        if (c % 2 == 1) {\n            n1++;\n        } else {\n            n2++;\n        }\n    }\n\n    return {n2, n1};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result, expected;\n\n    // Test cases\n    result = even_odd_count(7);\n    expected = {0, 1};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-78);\n    expected = {1, 1};\n    assert(issame(result, expected));\n\n    result = even_odd_count(3452);\n    expected = {2, 2};\n    assert(issame(result, expected));\n\n    result = even_odd_count(346211);\n    expected = {3, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-345821);\n    expected = {3, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-2);\n    expected = {1, 0};\n    assert(issame(result, expected));\n\n    result = even_odd_count(-45347);\n    expected = {2, 3};\n    assert(issame(result, expected));\n\n    result = even_odd_count(0);\n    expected = {1, 0};\n    assert(issame(result, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string int_to_mini_romank(int number) {\n    std::string rep[13] = {"m ", "cm", "d ", "cd", "c ", "xc", "l ", "xl", "x ", "ix", "v ", "iv", "i "};\n    int num[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    std::string current;\n    int pos = 0;\n    int temp_number = number;\n\n    while (temp_number > 0) {\n        while (temp_number >= num[pos]) {\n            current += rep[pos];\n            temp_number -= num[pos];\n        }\n        if (temp_number > 0) ++pos;\n    }\n\n    return current;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(int_to_mini_romank(19) == "xix");\n    assert(int_to_mini_romank(152) == "clii");\n    assert(int_to_mini_romank(251) == "ccli");\n    assert(int_to_mini_romank(426) == "cdxxvi");\n    assert(int_to_mini_romank(500) == "d");\n    assert(int_to_mini_romank(1) == "i");\n    assert(int_to_mini_romank(4) == "iv");\n    assert(int_to_mini_romank(43) == "xliii");\n    assert(int_to_mini_romank(90) == "xc");\n    assert(int_to_mini_romank(94) == "xciv");\n    assert(int_to_mini_romank(532) == "dxxxii");\n    assert(int_to_mini_romank(900) == "cm");\n    assert(int_to_mini_romank(994) == "cmxciv");\n    assert(int_to_mini_romank(1000) == "m");\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool right_angle_triangle(float a, float b, float c) {\n    float epsilon = 1.0e-4f;\n\n    if (std::abs(a * a + b * b - c * c) < epsilon ||\n        std::abs(a * a + c * c - b * b) < epsilon ||\n        std::abs(b * b + c * c - a * a) < epsilon) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    // Assertions\n    if (!right_angle_triangle(3.0f, 4.0f, 5.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(3, 4, 5) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(1.0f, 2.0f, 3.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(1, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(10.0f, 6.0f, 8.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(10, 6, 8) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(2.0f, 2.0f, 2.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(2, 2, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(7.0f, 24.0f, 25.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(7, 24, 25) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(10.0f, 5.0f, 7.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(10, 5, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(5.0f, 12.0f, 13.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(5, 12, 13) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(15.0f, 8.0f, 17.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(15, 8, 17) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(48.0f, 55.0f, 73.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(48, 55, 73) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(1.0f, 1.0f, 1.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(1, 1, 1) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(2.0f, 2.0f, 10.0f)) {\n        std::cerr << "Assertion failed: right_angle_triangle(2, 2, 10) == false" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string max_word = "";\n    int maxu = 0;\n\n    for (const auto& word : words) {\n        std::string unique;\n        for (char c : word) {\n            if (unique.find(c) == std::string::npos) {\n                unique += c;\n            }\n        }\n        if (unique.length() > maxu || (unique.length() == maxu && word < max_word)) {\n            max_word = word;\n            maxu = unique.length();\n        }\n    }\n    return max_word;\n}\n\nvoid run_tests() {\n    std::vector<std::string> words;\n    std::string result;\n\n    // Test 1\n    words = {"name   ", "of     ", "string "};\n    result = find_max(words);\n    if (result != "string") {\n        std::cerr << "Test 1 failed: expected 'string', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 2\n    words = {"name   ", "enam   ", "game   "};\n    result = find_max(words);\n    if (result != "enam") {\n        std::cerr << "Test 2 failed: expected 'enam', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 3\n    words = {"aaaaaaa", "bb     ", "cc     "};\n    result = find_max(words);\n    if (result != "aaaaaaa") {\n        std::cerr << "Test 3 failed: expected 'aaaaaaa', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 4\n    words = {"abc    ", "cba    "};\n    result = find_max(words);\n    if (result != "abc") {\n        std::cerr << "Test 4 failed: expected 'abc', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 5\n    words = {"play    ", "this    ", "game    ", "of      ", "footbott"};\n    result = find_max(words);\n    if (result != "footbott") {\n        std::cerr << "Test 5 failed: expected 'footbott', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 6\n    words = {"we      ", "are     ", "gonna   ", "rock    "};\n    result = find_max(words);\n    if (result != "gonna") {\n        std::cerr << "Test 6 failed: expected 'gonna', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 7\n    words = {"we      ", "are     ", "a       ", "mad     ", "nation  "};\n    result = find_max(words);\n    if (result != "nation") {\n        std::cerr << "Test 7 failed: expected 'nation', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 8\n    words = {"this    ", "is      ", "a       ", "prrk    "};\n    result = find_max(words);\n    if (result != "this") {\n        std::cerr << "Test 8 failed: expected 'this', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 9\n    words = {"b       "};\n    result = find_max(words);\n    if (result != "b") {\n        std::cerr << "Test 9 failed: expected 'b', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    // Test 10\n    words = {"play    ", "play    ", "play    "};\n    result = find_max(words);\n    if (result != "play") {\n        std::cerr << "Test 10 failed: expected 'play', got " << result << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <array>\n#include <cstdlib>\n\nstd::array<int, 2> eat(int number, int need, int remaining) {\n    if (need > remaining) {\n        return {number + remaining, 0};\n    } else {\n        return {number + need, remaining - need};\n    }\n}\n\nbool issame(const std::array<int, 2>& a, const std::array<int, 2>& b) {\n    for (int i = 0; i < 2; ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::array<int, 2> result;\n    std::array<int, 2> expected;\n\n    // Test cases\n    result = eat(5, 6, 10);\n    expected = {11, 4};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(5, 6, 10) == {11, 4}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(4, 8, 9);\n    expected = {12, 1};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 8, 9) == {12, 1}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(1, 10, 10);\n    expected = {11, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(1, 10, 10) == {11, 0}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(2, 11, 5);\n    expected = {7, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(2, 11, 5) == {7, 0}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(4, 5, 7);\n    expected = {9, 2};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 7) == {9, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    result = eat(4, 5, 1);\n    expected = {5, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 1) == {5, 0}" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cctype> // for std::tolower and std::toupper\n\nstd::string solve(const std::string& s) {\n    std::string out;\n    int nletter = 0;\n    bool is_reversed = true;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (isupper(c)) {\n                out += std::tolower(c);\n            } else {\n                out += std::toupper(c);\n            }\n        } else {\n            nletter++;\n            out += c;\n        }\n    }\n\n    if (nletter == s.size()) {\n        std::reverse(out.begin(), out.end());\n    }\n\n    return out;\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string rev;\n    for (char c : s) {\n        rev += c;\n    }\n    std::reverse(rev.begin(), rev.end());\n    return rev;\n}\n\nint main() {\n    std::string s, result;\n\n    // Test cases\n    s = "AsDf";\n    result = solve(s);\n    if (result != "aSdF") {\n        std::cerr << "Assertion failed: solve('AsDf') == 'aSdF'" << std::endl;\n        return 1;\n    }\n\n    s = "1234";\n    result = solve(s);\n    if (result != "4321") {\n        std::cerr << "Assertion failed: solve('1234') == '4321'" << std::endl;\n        return 1;\n    }\n\n    s = "ab";\n    result = solve(s);\n    if (result != "AB") {\n        std::cerr << "Assertion failed: solve('ab') == 'AB'" << std::endl;\n        return 1;\n    }\n\n    s = "#a@C";\n    result = solve(s);\n    if (result != "#A@c") {\n        std::cerr << "Assertion failed: solve('#a@C') == '#A@c'" << std::endl;\n        return 1;\n    }\n\n    s = "#AsdfW^45";\n    result = solve(s);\n    if (result != "#aSDFw^45") {\n        std::cerr << "Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'" << std::endl;\n        return 1;\n    }\n\n    s = "#6@2";\n    result = solve(s);\n    if (result != "2@6#") {\n        std::cerr << "Assertion failed: solve('#6@2') == '2@6#'" << std::endl;\n        return 1;\n    }\n\n    s = "#$a^D";\n    result = solve(s);\n    if (result != "#$A^d") {\n        std::cerr << "Assertion failed: solve('#$a^D') == '#$A^d'" << std::endl;\n        return 1;\n    }\n\n    s = "#ccc";\n    result = solve(s);\n    if (result != "#CCC") {\n        std::cerr << "Assertion failed: solve('#ccc') == '#CCC'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to generate integers between a and b, inclusive, that are evenly divisible by 2\nstd::vector<int> generate_integers(int a, int b) {\n    std::vector<int> result;\n    int temp_a = a, temp_b = b;\n\n    // Swap if b < a\n    if (temp_b < temp_a) {\n        std::swap(temp_a, temp_b);\n    }\n\n    for (int i = temp_a; i <= temp_b; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\n// Function to compare two vectors\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine equivalent to assert in Fortran\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result;\n    std::vector<int> empty_array;\n\n    // Test 1\n    result = generate_integers(2, 10);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    // Test 2\n    result = generate_integers(10, 2);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    // Test 3\n    result = generate_integers(132, 2);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    // Test 4\n    result = generate_integers(17, 89);\n    assert(issame(result, empty_array)); // Using an empty vector for comparison\n\n    return 0;\n}\n
