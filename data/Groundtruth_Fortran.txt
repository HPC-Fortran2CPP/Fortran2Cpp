program DRB093_doall2_collapse_orig_no\n    use omp_lib\n    use DRB093\n    implicit none\n\n    integer :: len, i, j\n    len = 100\n\n    allocate (a(len,len))\n\n    !$omp parallel do collapse(2)\n    do i = 1, len\n        do j = 1, len\n            a(i,j) = a(i,j)+1\n        end do\n    end do\n    !$omp end parallel do\nend program
program DRB096_doall2_taskloop_collapse_orig_no\n    use omp_lib\n    use DRB096\n    implicit none\n\n    integer :: len, i, j\n    len = 100\n\n    allocate (a(len,len))\n\n    !$omp parallel\n        !$omp single\n            !$omp taskloop collapse(2)\n            do i = 1, len\n                do j = 1, len\n                    a(i,j) = a(i,j)+1\n                end do\n            end do\n            !$omp end taskloop\n        !$omp end single\n    !$omp end parallel\n\n    print 100, a(50,50)\n    100 format ('a(50,50) =',i3)\n\nend program
program DRB024_simdtruedep_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len\n    integer, dimension(:), allocatable :: a\n    integer, dimension(:), allocatable :: b\n\n    len = 100\n\n    allocate (a(len))\n    allocate (b(len))\n\n    do i = 1, len\n        a(i) = i\n        b(i) = i+1\n    end do\n\n    !$omp simd\n    do i = 1, len-1\n        a(i+1) = a(i) + b(i)\n    end do\n\n    do i = 1, len\n        write(6,*) 'Values for i and a(i) are:', i, a(i)\n    end do\n\n    deallocate(a,b)\nend program
program DRB134_taskdep4_orig_yes_omp_45\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task depend(in: x) depend(inout: y) shared(x, y)\n        y = y-x                                 !!2nd child task\n        !$omp end task\n\n        !$omp task depend(in: x) if(.FALSE.)    !!1st taskwait\n        !$omp end task\n\n        print*, "x=", x\n        print*, "y=", y\n\n        !$omp taskwait                          !!2nd taskwait\n    end subroutine foo\nend program
program DRB052_indirectaccesssharebase_orig_no\n    use omp_lib\n    implicit none\n\n    integer, dimension(:), allocatable :: indexSet\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), pointer :: xa1, xa2\n    real(dp), dimension(:), allocatable, target :: base\n    integer :: N = 180\n    integer:: i, idx1,idx2\n\n    allocate (xa1(2025))\n    allocate (xa2(2025))\n    allocate (base(2025))\n    allocate (indexSet(180))\n    xa1 => base(1:2025)\n    xa2 => base(1:2025)\n\n    indexSet = (/ 521, 523, 525, 527, 529, 531, 547, 549, &\n            551, 553, 555, 557, 573, 575, 577, 579, 581, 583, 599, &\n            601, 603, 605, 607, 609, 625, 627, 629, 631, 633, 635, &\n            651, 653, 655, 657, 659, 661, 859, 861, 863, 865, 867, &\n            869, 885, 887, 889, 891, 893, 895, 911, 913, 915, 917, &\n            919, 921, 937, 939, 941, 943, 945, 947, 963, 965, 967, &\n            969, 971, 973, 989, 991, 993, 995, 997, 999, 1197, 1199, &\n            1201, 1203, 1205, 1207, 1223, 1225, 1227, 1229, 1231, &\n            1233, 1249, 1251, 1253, 1255, 1257, 1259, 1275, 1277, &\n            1279, 1281, 1283, 1285, 1301, 1303, 1305, 1307, 1309, &\n            1311, 1327, 1329, 1331, 1333, 1335, 1337, 1535, 1537, &\n            1539, 1541, 1543, 1545, 1561, 1563, 1565, 1567, 1569, &\n            1571, 1587, 1589, 1591, 1593, 1595, 1597, 1613, 1615, &\n            1617, 1619, 1621, 1623, 1639, 1641, 1643, 1645, 1647, &\n            1649, 1665, 1667, 1669, 1671, 1673, 1675, 1873, 1875, &\n            1877, 1879, 1881, 1883, 1899, 1901, 1903, 1905, 1907, &\n            1909, 1925, 1927, 1929, 1931, 1933, 1935, 1951, 1953, &\n            1955, 1957, 1959, 1961, 1977, 1979, 1981, 1983, 1985, &\n            1987, 2003, 2005, 2007, 2009, 2011, 2013 /)\n\n    do i = 521, 2025\n        base(i) = 0.0\n    end do\n\n    !$omp parallel do private(idx1,idx2)\n    do i = 1, N\n        idx1 = indexSet(i)\n        idx2 = indexSet(i)+12\n        base(idx1) = base(idx1)+1.0\n        base(idx2) = base(idx2)+3.0\n    end do\n    !$omp end parallel do\n\n    do i = 521, 2025\n        if (base(i) == 4.0) then\n            print*,'i= ',i,' base =',base(i)\n        end if\n    end do\n\n    deallocate(base,indexSet)\n    nullify(xa1,xa2)\nend program
program DRB068_restrictpointer2_orig_no\n    use omp_lib\n    use DRB068\n    implicit none\n\n    integer :: n = 1000\n    integer, dimension(:), pointer :: a=>null(), b=>null(), c=>null(), d=>null()\n\n    allocate (a(n))\n    allocate (b(n))\n    allocate (c(n))\n    allocate (d(n))\n\n    call foo(n,a,b,c,d)\n\n    if(associated(a))nullify(a)\n    if(associated(b))nullify(b)\n    if(associated(c))nullify(c)\n    if(associated(d))nullify(d)\n\nend program
program DRB063_outeronly1_orig_no\n    use omp_lib\n    implicit none\n\n    call foo()\ncontains\n    subroutine foo()\n        integer :: i, j, n, m, len\n        real, dimension(:,:), allocatable :: b\n\n        len = 100\n        allocate (b(len,len))\n        n = len\n        m = len\n        !$omp parallel do private(j)\n        do i = 1, n\n            do j = 1, m-1\n                b(i,j) = b(i,j+1)\n            end do\n        end do\n        !$omp end parallel do\n\n    end subroutine foo\nend program
program DRB086_static_data_member_orig_yes\n    use omp_lib\n    use DRB086\n    implicit none\n\n    type(A) :: c\n    c = A(0,0)\n\n    !$omp parallel\n    call foo()\n    !$omp end parallel\n\n    print *,counter,pcounter\nend program
program DRB082_declared_in_func_orig_yes\n    use omp_lib\n    use global_foo\n    implicit none\n\n    !$omp parallel\n    call foo()\n    !$omp end parallel\nend program
program DRB137_simdsafelen_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i, m, n\n    real :: b(4)\n\n    m = 2\n    n = 4\n\n    !$omp simd safelen(2)\n    do i = m+1, n\n        b(i) = b(i-m) - 1.0\n    end do\n\n    print*, b(3)\nend program
program DRB156_missingordered_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var(100)\n    integer :: i\n\n    do i = 1, 100\n        var(i) = 1\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n    do i = 2, 100\n        var(i) = var(i-1)+1\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    print*,var(100)\nend program
program DRB133_taskdep5_orig_no_omp45\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task depend(in: x) depend(inout: y) shared(x, y)\n        y = y-x                                 !!2nd child task\n        !$omp end task\n\n        !$omp task depend(in: x) if(.FALSE.)    !!1st taskwait\n        !$omp end task\n\n        print*, "x=", x\n\n        !$omp taskwait                          !!2nd taskwait\n\n        print*, "y=", y\n\n    end subroutine\nend program
program DRB020_privatemissing_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, tmp, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension (:), allocatable :: a\n\n    len = 100\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, len\n        tmp = a(i) + i\n        a(i) = tmp\n    end do\n    !$omp end parallel do\n\n    print 100, a(50)\n    100 format ("a(50)=",i3)\n\n    deallocate(args,a)\n\nend program
program DRB074_flush_orig_yes\n    use omp_lib\n    use DRB074\n    implicit none\n\n    integer :: i, sum\n    i = 0\n    sum =  0\n\n    !$omp parallel reduction(+:sum) num_threads(10)\n    call f1(i)\n    sum = sum+i\n    !$omp end parallel\n\n    if (sum /= 10) then\n        print*,'sum =',sum\n    end if\nend program
program DRB065_pireduction_orig_no\n    use omp_lib\n    implicit none\n\n    real(kind = 16) :: x, interval_width, pi\n    integer(kind = 8) :: i, num_steps\n\n    pi = 0.0\n    num_steps = 2000000000\n    interval_width = 1.0/num_steps\n\n    !$omp parallel do reduction(+:pi) private(x)\n    do i = 1, num_steps\n        x = (i + 0.5) * interval_width\n        pi = pi + 1.0 / (x*x + 1.0);\n    end do\n    !$omp end parallel do\n\n    pi = pi * 4.0 * interval_width;\n    print 100, pi\n    100 format ("PI =",F24.20)\n\nend program
program DRB130_mergeable_taskwait_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: x\n    x = 2\n\n    !$omp task shared(x) mergeable\n    x = x+1\n    !$omp end task\n\n    print 100, x\n    100 format ('x =',3i8)\nend program
program DRB009_lastprivatemissing_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, x, len\n    len = 10000\n\n    !$omp parallel do private(i)\n    do i = 0, len\n        x = i\n    end do\n    !$omp end parallel do\n\n    write(*,*) 'x =', x\nend program
program DRB144_atomiccritical_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n        do i = 1, 200\n            !$omp critical\n            var = var+1\n            !$omp end critical\n        end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    print*,var\nend program
program DRB087_static_data_member2_orig_yes\n    use omp_lib\n    use DRB087\n    implicit none\n\n    type(A) :: c\n    c = A(0,0)\n\n    !$omp parallel\n    counter = counter+1\n    pcounter = pcounter+1\n    !$omp end parallel\n\n    print *,counter,pcounter\nend program
program DRB004_antidep2_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    real, dimension (:,:), allocatable :: a\n    len = 1000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len,len))\n\n\n    do i = 1, len\n        do j = 1, len\n            a(i,j) = 0.5\n        end do\n    end do\n\n    !$omp parallel do private(j)\n    do i = 1, len-1\n        do j = 1, len\n            a(i,j) = a(i,j) + a(i+1,j)\n        end do\n    end do\n    !$omp end parallel do\n\n    write(*,*) 'a(10,10) =', a(10,10)\n\n    deallocate(a)\n    deallocate(args)\n\nend program
program DRB059_lastprivate_orig_no\n    use omp_lib\n    implicit none\n    !$omp parallel\n    call foo()\n    !$omp end parallel\ncontains\n    subroutine foo()\n        integer :: i, x\n        !$omp parallel do private(i) lastprivate(x)\n        do i = 1, 100\n            x = i\n        end do\n        !$omp end parallel do\n        print 100, x\n        100 format ("x =",i3)\n    end subroutine foo\nend program
program DRB028_privatemissing_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, tmp, len\n    integer, dimension(:), allocatable :: a\n\n    len = 100\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, len\n        tmp = a(i) + i\n        a(i) = tmp\n    end do\n    !$omp end parallel do\n\n    print 100, a(50)\n    100 format ('a(50)=',i3)\n\n    deallocate(a)\nend program
program DRB157_missingorderedsimd_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var(100)\n    integer :: i\n\n    do i = 1, 100\n        var(i) = 1\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do simd safelen(16)\n    do i = 17, 100\n        var(i) = var(i-16)+1\n    end do\n    !$omp end teams distribute parallel do simd\n    !$omp end target\n\n    print*,var(98)\nend program
program DRB171_input_dependence_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, N, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: a\n\n    N = 100\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) N\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(N))\n\n    call load_from_input(a, N)\n\n    \n    !$omp parallel do shared(a)\n    do i = 1, N\n        a(i) = i\n        if(N .gt. 10000) a(1) = 1\n    end do\n    !$omp end parallel do\n\nend program
program DRB095_doall2_taskloop_orig_yes\n    use omp_lib\n    use DRB095\n    implicit none\n\n    integer :: len, i, j\n    len = 100\n    allocate (a(len,len))\n\n    !$omp parallel\n        !$omp single\n            !$omp taskloop\n            do i = 1, len\n                do j = 1, len\n                    a(i,j) = a(i,j)+1\n                end do\n            end do\n            !$omp end taskloop\n        !$omp end single\n    !$omp end parallel\n\n    print 100, a(50,50)\n    100 format ('a(50,50) =',i3)\n\nend program
module DRB128\ninteger :: tp, var\n!$omp threadprivate(tp)\ncontains\nsubroutine foo\n!$omp task\n!$omp task\ntp = 1\n!$omp task\n!$omp end task\nvar = tp\n!$omp end task\n!$omp end task\nend subroutine\nend module program DRB128_tasking_threadprivate2_orig_no\n    use omp_lib\n    use DRB128\n    implicit none\n\n    call foo()\n    print*,var\nend program
program DRB021_reductionmissing_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, len\n    real :: temp, getSum\n    real, dimension (:,:), allocatable :: u\n\n    len = 100\n    getSum = 0.0\n\n    allocate (u(len, len))\n\n    do i = 1, len\n        do j = 1, len\n            u(i,j) = 0.5\n        end do\n    end do\n\n    !$omp parallel do private(temp, i, j)\n    do i = 1, len\n        do j = 1, len\n            temp = u(i,j)\n            getSum = getSum + temp * temp\n        end do\n    end do\n    !$omp end parallel do\n\n    print*,"sum =", getSum\n    deallocate(u)\nend program
program DRB110_ordered_orig_no\n    use omp_lib\n    implicit none\n\n    integer x, i\n    x=0\n    \n    !$omp parallel do ordered\n    do i = 1, 100\n        !$omp ordered\n        x = x+1\n        !$omp end ordered\n    end do\n    !$omp end parallel do    \n\n    print*,'x =',x\nend program
program DRB079_taskdep3_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i, j, k\n    i = 0\n\n    !$omp parallel\n        !$omp single\n            !$omp task depend (out:i)\n                call sleep(3)\n                i = 1\n            !$omp end task\n            !$omp task depend (in:i)\n                j = i\n            !$omp end task\n            !$omp task depend (in:i)\n                k = i\n            !$omp end task\n        !$omp end single\n    !$omp end parallel\n\n    print 100, j, k\n    100 format ('j =',i3,2x,'k =',i3)\n\n    if (j /= 1 .and. k /= 1) then\n        print*, 'Race Condition'\n    end if\n\nend program
program DRB029_truedep1_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len\n    integer, dimension(:), allocatable :: a\n\n    len = 100\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, len-1\n        a(i+1) = a(i)+1\n    end do\n    !$omp end parallel do\n\n    print 100, a(50)\n    100 format ('a(50)=',i3)\n\n    deallocate(a)\nend program
program DRB158_missingtaskbarrier_orig_gpu_no\n    use omp_lib\n    use DRB158\n    implicit none\n\n    do i = 1, 64\n        x(i) = 0\n        y(i) = 3\n    end do\n\n    a = 5\n\n    !$omp target map(to:y,a) map(tofrom:x) device(0)\n    do i = 1, 64\n        !$omp task depend(inout:x(i))\n        x(i) = a*x(i)\n        !$omp end task\n\n        !$omp task depend(inout:x(i))\n        x(i) = x(i)+y(i)\n        !$omp end task\n    end do\n    !$omp end target\n\n    do i = 1, 64\n        if (x(i) /= 3) then\n            print*,x(i)\n        end if\n    end do\n\n    !$omp taskwait\n\nend program
program DRB142_acquirerelease_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: x, y, thrd\n    integer :: tmp\n    x = 0\n\n    !$omp parallel num_threads(2) private(thrd) private(tmp)\n        thrd = omp_get_thread_num()\n        if (thrd == 0) then\n            !$omp critical\n            x = 10\n            !$omp end critical\n            !$omp atomic write\n            y = 1\n            !$omp end atomic\n        else\n            tmp = 0\n            do while(tmp == 0)\n            !$omp atomic read acquire ! or seq_cst\n            tmp = x\n            !$omp end atomic\n            end do\n            !$omp critical\n            print *, "x = ", x\n            !$omp end critical\n        end if\n    !$omp end parallel\nend program
program DRB069_sectionslock1_orig_no\n    use omp_lib\n    implicit none\n\n    integer (kind=omp_lock_kind) lock\n    integer :: i\n    i = 0\n    call omp_init_lock(lock)\n\n    !$omp parallel sections\n        !$omp section\n        call omp_set_lock(lock)\n        i = i + 1\n        call omp_unset_lock(lock)\n        !$omp section\n        call omp_set_lock(lock)\n        i = i + 2\n        call omp_unset_lock(lock)\n    !$omp end parallel sections\n\n    call omp_destroy_lock(lock)\n\n    print 100, i\n    100 format ('I =',i3)\nend program
program DRB013_nowait_orig_yes\n    use omp_lib\n    implicit none\n\n    integer i, error, len, b\n    integer, dimension (:), allocatable :: a\n\n    b = 5\n    len = 1000\n\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel shared(b, error)\n        !$omp parallel\n            !$omp do\n            do i = 1, len\n                a(i) = b + a(i)*5\n            end do\n            !$omp end do nowait\n            !$omp single\n            error = a(10) + 1;\n            !$omp end single\n        !$omp end parallel\n    !$omp end parallel\n\n    print*,"error =",error\n\n    deallocate(a)\nend program
program DRB166_taskdep4_orig_no_omp50\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task shared(y)\n        y = y-1                                 !!2nd child task\n        !$omp end task\n\n        !$omp taskwait depend(in: x)            !!1st taskwait\n\n        print*, "x=", x\n\n        !$omp taskwait                          !!2nd taskwait\n\n        print*, "y=", y\n\n    end subroutine\nend program
program DRB151_missinglock3_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n    do i = 1, 100\n        var = var+1\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    print*, var\nend program
program DRB092_threadprivatemissing2_orig_yes\n    use omp_lib\n    use DRB092\n    implicit none\n\n    integer :: i, sum\n    sum = 0\n    sum0 = 0\n    sum1 = 0\n\n    !$omp parallel\n        !$omp do\n        do i = 1, 1001\n            sum0 = sum0+i\n        end do\n        !$omp end do\n        !$omp critical\n        sum = sum+sum0\n        !$omp end critical\n    !$omp end parallel\n\n    do i = 1, 1001\n        sum1=sum1+i\n    end do\n\n    print*,'sum =',sum,'sum1 =',sum1\n\nend program
program DRB027_taskdependmissing_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i\n    i=0\n\n    !$omp parallel\n    !$omp single\n    !$omp task\n    i = 1\n    !$omp end task\n    !$omp task\n    i = 2\n    !$omp end task\n    !$omp end single\n    !$omp end parallel\n\n    print 100, i\n    100 format ("i=",i3)\n\nend program
program DRB064_outeronly2_orig_no\n    use omp_lib\n    implicit none\n\n    call foo()\ncontains\n    subroutine foo()\n        integer :: i, j, n, m, len\n        real, dimension(:,:), allocatable :: b\n\n        len = 100\n        allocate (b(len,len))\n        n = len\n        m = len\n\n        !$omp parallel do private(j)\n        do i = 1, n\n            do j = 2, m\n                b(i,j) = b(i,j-1)\n            end do\n        end do\n        !$omp end parallel do\n    end subroutine foo\nend program
program DRB036_truedepscalar_var_yes\n    use omp_lib\n    implicit none\n\n    integer i, tmp, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: a\n\n    len = 100\n    tmp = 10\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n\n    !$omp parallel do\n    do i = 1, len\n        a(i) = tmp\n        tmp = a(i) + i\n    end do\n    !$omp end parallel do\n\n    deallocate(args,a)\nend program
program DRB122_taskundeferred_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp parallel sections\n    do i = 1, 10\n        !$omp task shared(var) if(.FALSE.)\n        var = var+1;\n        !$omp end task\n    end do\n    !$omp end parallel sections\n\n    print 100, var\n    100 format ('var =', 3i8)\nend program
program DRB012_minusminus_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len, numNodes, numNodes2, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension (:), allocatable :: x\n\n    len = 100\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (x(len))\n\n    numNodes=len\n    numNodes2=0\n    !initialize x()\n    do i = 1, len\n        if (MOD(i,2) == 0) then\n            x(i) = 5\n        else\n            x(i) = -5\n        end if\n    end do\n\n    !$omp parallel do\n    do i = numNodes, 1, -1\n        if (x(i) <= 0) then\n            numNodes2 = numNodes2-1\n        end if\n    end do\n    !$omp end parallel do\n\n    print*,"numNodes2 =", numNodes2\n\n    deallocate(args,x)\nend program
program DRB067_restrictpointer1_orig_no\n    use omp_lib\n    use DRB067\n    implicit none\n\n    integer :: len = 1000\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp),dimension(:), pointer :: newSxx, newSyy\n\n    allocate (newSxx(len))\n    allocate (newSyy(len))\n\n    call foo(newSxx, newSyy, len)\n\n    if(associated(newSxx))nullify(newSxx)\n    if(associated(newSyy))nullify(newSyy)\nend program
program DRB163_simdmissinglock1_orig_gpu_no\n    use omp_lib\n    use DRB163\n    implicit none\n\n    do i = 1, 16\n        var(i) = 0\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do reduction(+:var)\n    do i = 1, 20\n        !$omp simd\n        do j = 1, 16\n            var(j) = var(j)+1\n        end do\n        !$omp end simd\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    do i = 1, 16\n        if (var(i) /= 20) then\n            print*, var(i), i\n        end if\n    end do\n\nend program
program DRB159_nobarrier_orig_gpu_no\n    use omp_lib\n    use DRB159\n    implicit none\n\n    do i = 1, 8\n        b(i) = 0\n        c(i) = 2\n        temp(i) = 0\n    end do\n\n    a = 2\n\n    !$omp target map(tofrom:b) map(to:c,temp,a) device(0)\n    !$omp parallel\n    do i = 1, 100\n        !$omp do\n        do j = 1, 8\n            temp(j) = b(j)+c(j)\n        end do\n        !$omp end do\n\n        !$omp do\n        do j = 8, 1, k-1\n            b(j) = temp(j)*a\n        end do\n        !$omp end do\n    end do\n    !$omp end parallel\n    !$omp end target\n\n    do i = 1, 100\n        val = val+2\n        val = val*2\n    end do\n\n    do i = 1, 8\n        if (val /= b(i)) then\n            print*,b(i),val\n        end if\n    end do\n\nend program
program DRB050_functionparameter_orig_no\n    use omp_lib\n    use DRB050\n    implicit none\n\n    allocate (o1(100))\n    allocate (c(100))\n\n    call foo1(o1, c, 100)\nend program
program DRB030_truedep1_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: a\n\n    len = 100\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, len-1\n        a(i+1) = a(i)+1\n    end do\n    !$omp end parallel do\n\n    print 100, a(50)\n    100 format ('a(50)=',i3)\n\n    deallocate(args,a)\nend program
program DRB124_master_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: init, local\n\n    !$omp parallel shared(init) private(local)\n        !$omp master\n        init = 10\n        !$omp end master\n        local = init\n    !$omp end parallel\n\nend program
program DRB152_missinglock2_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer (kind=omp_lock_kind) :: lck\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams num_teams(1)\n    !$omp distribute parallel do\n    do i = 1, 100\n        call omp_set_lock(lck)\n        var = var+1\n        call omp_unset_lock(lck)\n    end do\n    !$omp end distribute parallel do\n    !$omp end teams\n    !$omp end target\nend program
program DRB006_indirectaccess2_orig_yes\n    use omp_lib\n    use DRB006\n    implicit none\n\n    integer :: i, idx1, idx2\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), pointer :: xa1=>NULL(), xa2=>NULL()\n    real(dp), dimension(2025), target :: base\n\n    allocate (xa1(2025))\n    allocate (xa2(2025))\n\n    xa1 => base(1:2025)\n    xa2 => base(1:2025)\n\n    n=180\n\n    indexSet = (/ 521, 523, 525, 527, 529, 531, 547, 549, &\n    551, 553, 555, 557, 573, 575, 577, 579, 581, 583, 599, &\n    601, 603, 605, 607, 609, 625, 627, 629, 631, 633, 635, &\n    651, 653, 655, 657, 659, 661, 859, 861, 863, 865, 867, &\n    869, 885, 887, 889, 891, 893, 895, 911, 913, 915, 917, &\n    919, 921, 937, 939, 941, 943, 945, 947, 963, 965, 967, &\n    969, 971, 973, 989, 991, 993, 995, 997, 999, 1197, 1199, &\n    1201, 1203, 1205, 1207, 1223, 1225, 1227, 1229, 1231, &\n    1233, 1249, 1251, 1253, 1255, 1257, 1259, 1275, 1277, &\n    1279, 1281, 1283, 1285, 1301, 1303, 1305, 1307, 1309, &\n    1311, 1327, 1329, 1331, 1333, 1335, 1337, 1535, 1537, &\n    1539, 1541, 1543, 1545, 1561, 1563, 1565, 1567, 1569, &\n    1571, 1587, 1589, 1591, 1593, 1595, 1597, 1613, 1615, &\n    1617, 1619, 1621, 1623, 1639, 1641, 1643, 1645, 1647, &\n    1649, 1665, 1667, 1669, 1671, 1673, 1675, 1873, 1875, &\n    1877, 1879, 1881, 1883, 1899, 1901, 1903, 1905, 1907, &\n    1909, 1925, 1927, 1929, 1931, 1933, 1935, 1951, 1953, &\n    1955, 1957, 1959, 1961, 1977, 1979, 1981, 1983, 1985, &\n    1987, 2003, 2005, 2007, 2009, 2011, 2013 /)\n\n    do i = 521, 2025\n        base(i) = 0.5*i\n    end do\n\n    !$omp parallel do\n    do i = 1, n\n        idx1 = indexSet(i)\n        idx2 = indexSet(i)+12\n        base(idx1) = base(idx1)+1.0\n        base(idx2) = base(idx2)+3.0\n    end do\n    !$omp end parallel do\n\n    print*,'xa1(999) =',base(999),' xa2(1285) =',base(1285)\n  \n    nullify(xa1,xa2)\nend program
program DRB038_truedepseconddimension_var_yes\n    use omp_lib\n    implicit none\n\n    integer i, j, n, m, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    real, dimension(:,:), allocatable :: b\n\n    len = 1000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    n = len\n    m = len\n\n    allocate (b(len,len))\n\n    do i = 1, n\n        !$omp parallel do\n        do j = 2, m\n            b(i,j) = b(i,j-1)\n        end do\n        !$omp end parallel do\n    end do\n!    print 100, b(5,5)\n!    100 format ('b(5,5) =', F20.6)\n\n    deallocate(args,b)\nend program
program DRB137_simdsafelen_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i, m, n\n    real :: b(4)\n\n    m = 1\n    n = 4\n\n    !$omp simd safelen(2)\n    do i = m+1, n\n        b(i) = b(i-m) - 1.0\n    end do\n\n    print*, b(3)\nend program
module DRB127\ninteger :: tp, var\n!$omp threadprivate(tp)\ncontains\nsubroutine foo\n!$omp task\n!$omp task\ntp = 1\n!$omp task\n!$omp end task\nvar = tp                ! value of var can be 1 or 2\n!$omp end task\ntp = 2\n!$omp end task\nend subroutine\nend module program DRB127_tasking_threadprivate1_orig_no\n    use omp_lib\n    use DRB127\n    implicit none\n\n    call foo()\n\nend program
program DRB140_reduction_barrier_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: a, i\n\n    !$omp parallel shared(a) private(i)\n        !$omp master\n        a = 0\n        !$omp end master\n\n        !$omp do reduction(+:a)\n        do i = 1, 10\n            a = a+i\n        end do\n        !$omp end do\n\n        !$omp single\n        print*, "Sum is ", A\n        !$omp end single\n\n    !$omp end parallel\nend program
program DRB002_antidep1_var_yes\n    use omp_lib\n    implicit none\n    integer :: i, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension (:), allocatable :: a\n    len = 1000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, len-1\n        a(i) = a(i+1)+1\n    end do\n    !$omp end parallel do\n\n    deallocate(a)\n    deallocate(args)\n\nend program
program DRB073_doall2_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, len\n    integer, dimension(:,:), allocatable :: a\n    len = 100\n\n    allocate (a(len,len))\n\n    !$omp parallel do\n    do i = 1, 100\n        do j = 1, 100\n            a(i,j) = a(i,j)+1\n        end do\n    end do\n    !$omp end parallel do\n\n\n    deallocate(a)\nend program
program DRB141_reduction_barrier_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: a, i\n\n    !$omp parallel shared(a) private(i)\n        !$omp master\n        a = 0\n        !$omp end master\n        \n        !$omp barrier        \n\n        !$omp do reduction(+:a)\n        do i = 1, 10\n            a = a+i\n        end do\n        !$omp end do\n\n        !$omp single\n        print*, "Sum is ", A\n        !$omp end single\n\n    !$omp end parallel\nend program
program DRB031_truedepfirstdimension_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, n, m\n    real, dimension(:,:), allocatable :: b\n\n    n = 1000\n    m = 1000\n    allocate (b(n,m))\n\n    do i = 1, n\n        do j = 1, m\n            b(i,j) = 0.5\n        end do\n    end do\n\n    !$omp parallel do private(j)\n    do i = 2, n\n        do j = 2, m\n            b(i,j) = b(i-1, j-1)\n        end do\n    end do\n    !$omp end parallel do\n\n    print 100, b(500,500)\n    100 format ('b(500,500) =',F10.6)\n\n    deallocate(b)\nend program
program DRB116_target_teams_orig_yes\n    use omp_lib\n    implicit none\n\n    integer i, len\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), allocatable :: a\n\n    len = 100\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = (real(i,dp))/2.0\n    end do\n\n    !$omp target map(tofrom: a(0:len))\n        !$omp teams num_teams(2)\n        a(50) = a(50)*2.0\n        !$omp end teams\n    !$omp end target\n\n    print*,'a(50)=',a(50)\n\n    deallocate(a)\nend program
program DRB149_missingdata1_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer :: len, i, j\n    integer, dimension(:), allocatable :: a, b, c\n\n    len = 100\n\n    allocate (a(len))\n    allocate (b(len+len*len))\n    allocate (c(len))\n\n    do i = 1, len\n        do j = 1, len\n            b(j+i*len)=1\n        end do\n        a(i) = 1\n        c(i) = 0\n    end do\n\n    !$omp target map(to:a,b) map(tofrom:c) device(0)\n    !$omp teams distribute parallel do\n    do i = 1, len\n        do j = 1, len\n            c(i) = c(i)+a(j)*b(j+i*len)\n        end do\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    do i = 1, len\n        if (c(i)/=len) then\n            print*, c(i)\n        end if\n    end do\n\n    deallocate(a,b,c)\nend program
program DRB145_atomiccritical_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do reduction(+:var)\n        do i = 1, 200\n            if (var<101) then\n                var = var+1\n            end if\n        end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\nend program
program DRB139_worksharingcritical_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i\n    i = 1\n\n    !$OMP PARALLEL SECTIONS\n    !$OMP SECTION\n        !$OMP CRITICAL (NAME)\n            !$OMP PARALLEL\n                !$OMP SINGLE\n                i = i + 1\n                !$OMP END SINGLE\n            !$OMP END PARALLEL\n        !$OMP END CRITICAL (NAME)\n    !$OMP END PARALLEL SECTIONS\n\n    print 100,i\n    100 format ("i = ", 3i8)\nend program
program DRB135_taskdep_mutexinoutset_orig_no_omp50\n    use omp_lib\n    implicit none\n\n    integer :: a, b, c, d\n\n    !$omp parallel\n    !$omp single\n        !$omp task depend(out: c)\n        c = 1      ! Task T1\n        !$omp end task\n        !$omp task depend(out: a)\n        a = 2      ! Task T2\n        !$omp end task\n        !$omp task depend(out: b)\n        b = 3      ! Task T3\n        !$omp end task\n        !$omp task depend(in: a)\n        c = c + a  ! Task T4\n        !$omp end task\n        !$omp task depend(in: b) \n        c = c + b  ! Task T5\n        !$omp end task\n        !$omp task depend(in: c)\n        d = c      ! Task T6\n        !$omp end task\n    !$omp end single\n    !$omp end parallel\n\n    print *, d\nend program
program DRB026_targetparallelfor_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len\n    integer, dimension(:), allocatable :: a\n\n    len = 1000\n\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp target map(a)\n        !$omp parallel do\n        do i = 1, len-1\n            a(i) = a(i+1) + 1\n        end do\n        !$omp end parallel do\n    !$omp end target\n\n    do i = 1, len\n        write(6,*) 'Values for i and a(i) are:', i, a(i)\n    end do\n\n    deallocate(a)\nend program
program DRB053_inneronly1_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i, j\n\n    real, dimension(:,:), allocatable :: a\n    allocate (a(20,20))\n\n    do i = 1, 20\n        do j = 1, 20\n            a(i,j) = 0.0\n        end do\n    end do\n\n    do i = 1, 19\n    !$omp parallel do\n        do j = 1, 20\n            a(i,j) = a(i,j)+a(i+1,j)\n        end do\n    !$omp end parallel do\n    end do\n\n    deallocate(a)\nend program
program DRB070_simd1_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: len, i\n    integer, dimension(:), allocatable :: a, b, c\n    len = 100\n    allocate (a(len))\n    allocate (b(len))\n    allocate (c(len))\n\n    !$omp simd\n    do i = 1, len\n        a(i) = b(i) + c(i)\n    end do\n    !$omp end simd\n\n    deallocate(a,b,c)\nend program
program DRB010_lastprivatemissing_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len, argCount, allocStatus, rdErr, x, ix\n    character(len=80), dimension(:), allocatable :: args\n    len = 10000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    !$omp parallel do private(i)\n    do i = 0, len\n        x = i\n    end do\n    !$omp end parallel do\n    write(*,*) 'x =', x\n\n    deallocate(args)\nend program
program DRB154_missinglock3_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer (kind=omp_lock_kind) :: lck\n    integer :: var, i\n    var = 0\n\n    call omp_init_lock (lck)\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute reduction(+:var)\n    do i = 1, 100\n        call omp_set_lock(lck)\n        var = var+1\n        call omp_unset_lock(lck)\n    end do\n    !$omp end teams distribute\n    !$omp end target\n\n    call omp_destroy_lock(lck)\n\n    print*, var\nend program
program DRB046_doall2_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i, j\n    integer :: a(100,100)\n\n    !$omp parallel do private(j)\n    do i = 1, 100\n        do j = 1, 100\n            a(i,j) = a(i,j)+1\n        end do\n    end do\n    !$omp end parallel do\nend program
program DRB035_truedepscalar_orig_yes\n    use omp_lib\n    implicit none\n\n    integer i, tmp, len\n    integer, dimension(:), allocatable :: a\n\n    len = 100\n    tmp = 10\n    allocate (a(len))\n\n    !$omp parallel do\n    do i = 1, len\n        a(i) = tmp\n        tmp = a(i) + i\n    end do\n    !$omp end parallel do\n\n    print 100, a(50)\n    100 format ('a(50) =',i3)\n\n    deallocate(a)\nend program
program DRB018_plusplus_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, inLen, outLen\n    integer :: input(1000)\n    integer :: output(1000)\n\n    inLen = 1000\n    outLen = 1\n\n    do i = 1, inLen\n        input(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, inLen\n        output(outLen) = input(i)\n        outLen = outLen + 1\n    end do\n    !$omp end parallel do\n\n    print 100, output(500)\n    100 format ("output(500)=",i3)\nend program
module DRB005\n    implicit none\n\n    integer, dimension(180) :: indexSet\n    integer :: n\n\nend module\n\n\nprogram DRB005_indirectaccess1_orig_yes\n    use omp_lib\n    use DRB005\n    implicit none\n\n    integer :: i, idx1, idx2\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), pointer :: xa1=>NULL(), xa2=>NULL()\n    real(dp), dimension(2025), target :: base\n\n    allocate (xa1(2025))\n    allocate (xa2(2025))\n\n    xa1 => base(1:2025)\n    xa2 => base(1:2025)\n\n    n=180\n\n    indexSet = (/ 521, 523, 525, 527, 529, 531, 547, 549, &\n    551, 553, 555, 557, 573, 575, 577, 579, 581, 583, 599, &\n    601, 603, 605, 607, 609, 625, 627, 629, 631, 633, 635, &\n    651, 653, 655, 657, 659, 661, 859, 861, 863, 865, 867, &\n    869, 885, 887, 889, 891, 893, 895, 911, 913, 915, 917, &\n    919, 921, 937, 939, 941, 943, 945, 947, 963, 965, 967, &\n    969, 971, 973, 989, 991, 993, 995, 997, 999, 1197, 1199, &\n    1201, 1203, 1205, 1207, 1223, 1225, 1227, 1229, 1231, &\n    1233, 1249, 1251, 1253, 1255, 1257, 1259, 1275, 1277, &\n    1279, 1281, 1283, 1285, 1301, 1303, 1305, 1307, 1309, &\n    1311, 1327, 1329, 1331, 1333, 1335, 1337, 1535, 1537, &\n    1539, 1541, 1543, 1545, 1561, 1563, 1565, 1567, 1569, &\n    1571, 1587, 1589, 1591, 1593, 1595, 1597, 1613, 1615, &\n    1617, 1619, 1621, 1623, 1639, 1641, 1643, 1645, 1647, &\n    1649, 1665, 1667, 1669, 1671, 1673, 1675, 1873, 1875, &\n    1877, 1879, 1881, 1883, 1899, 1901, 1903, 1905, 1907, &\n    1909, 1925, 1927, 1929, 1931, 1933, 1935, 1951, 1953, &\n    1955, 1957, 1959, 1961, 1977, 1979, 1981, 1983, 1985, &\n    1987, 2003, 2005, 2007, 2009, 2011, 2013 /)\n\n    do i = 521, 2025\n        base(i) = 0.5*i\n    end do\n\n    !$omp parallel do schedule(static,1)\n    do i = 1, n\n        idx1 = indexSet(i)\n        idx2 = indexSet(i)+12\n        base(idx1) = base(idx1)+1.0\n        base(idx2) = base(idx2)+3.0\n    end do\n    !$omp end parallel do\n\n    print*,'xa1(999) =',base(999),' xa2(1285) =',base(1285)\n\n    nullify(xa1,xa2)\nend program
program DRB008_indirectaccess4_orig_yes\n    use omp_lib\n    use DRB008\n    implicit none\n\n    integer :: i, idx1, idx2\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), pointer :: xa1=>NULL(), xa2=>NULL()\n    real(dp), dimension(2025), target :: base\n\n    allocate (xa1(2025))\n    allocate (xa2(2025))\n\n    xa1 => base(1:2025)\n    xa2 => base(1:2025)\n\n    n=180\n\n    indexSet = (/ 521, 533, 525, 527, 529, 531, 547, 549, &\n    551, 553, 555, 557, 573, 575, 577, 579, 581, 583, 599, &\n    601, 603, 605, 607, 609, 625, 627, 629, 631, 633, 635, &\n    651, 653, 655, 657, 659, 661, 859, 861, 863, 865, 867, &\n    869, 885, 887, 889, 891, 893, 895, 911, 913, 915, 917, &\n    919, 921, 937, 939, 941, 943, 945, 947, 963, 965, 967, &\n    969, 971, 973, 989, 991, 993, 995, 997, 999, 1197, 1199, &\n    1201, 1203, 1205, 1207, 1223, 1225, 1227, 1229, 1231, &\n    1233, 1249, 1251, 1253, 1255, 1257, 1259, 1275, 1277, &\n    1279, 1281, 1283, 1285, 1301, 1303, 1305, 1307, 1309, &\n    1311, 1327, 1329, 1331, 1333, 1335, 1337, 1535, 1537, &\n    1539, 1541, 1543, 1545, 1561, 1563, 1565, 1567, 1569, &\n    1571, 1587, 1589, 1591, 1593, 1595, 1597, 1613, 1615, &\n    1617, 1619, 1621, 1623, 1639, 1641, 1643, 1645, 1647, &\n    1649, 1665, 1667, 1669, 1671, 1673, 1675, 1873, 1875, &\n    1877, 1879, 1881, 1883, 1899, 1901, 1903, 1905, 1907, &\n    1909, 1925, 1927, 1929, 1931, 1933, 1935, 1951, 1953, &\n    1955, 1957, 1959, 1961, 1977, 1979, 1981, 1983, 1985, &\n    1987, 2003, 2005, 2007, 2009, 2011, 2013 /)\n\n    do i = 521, 2025\n        base(i) = 0.5*i\n    end do\n\n    !$omp parallel do\n    do i = 1, n\n        idx1 = indexSet(i)\n        idx2 = indexSet(i)+12\n        base(idx1) = base(idx1)+1.0\n        base(idx2) = base(idx2)+3.0\n    end do\n    !$omp end parallel do\n\n    print*,'xa1(999) =',base(999),' xa2(1285) =',base(1285)\n\n    nullify(xa1,xa2)\nend program
program DRB109_orderedmissing_orig_yes\n    use omp_lib\n    implicit none\n\n    integer x,i\n\n    !$omp parallel do ordered\n    do i = 1, 100\n        x = x+1\n    end do\n    !$omp end parallel do\n\n    print*,'x =',x\n\nend program
program DRB112_linear_orig_no\n    use omp_lib\n    implicit none\n\n    integer len, i, j\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), allocatable :: a,b,c\n\n    len = 100\n    i = 0\n    j = 0\n\n    allocate (a(len))\n    allocate (b(len))\n    allocate (c(len))\n\n    do i = 1, len\n        a(i) = (real(i,dp))/2.0\n        b(i) = (real(i,dp))/3.0\n        c(i) = (real(i,dp))/7.0\n    end do\n\n    !$omp parallel do linear(j)\n    do i = 1, len\n        c(j) = c(j)+a(i)*b(i)\n        j = j+1\n    end do\n    !$omp end parallel do\n\n    !print*,'c(50) =',c(50)\n\n    if(allocated(a))deallocate(a)\n    if(allocated(b))deallocate(b)\nend program
program DRB120_barrier_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: var\n\n    !$omp parallel shared(var)\n    !$omp single\n    var = var + 1;\n    !$omp end single\n    !$omp barrier\n\n    !$omp single\n    var = var + 1;\n    !$omp end single\n    !$omp end parallel\n\n    print 100, var\n    100 format ('var =',i3)\nend program
program DRB003_antidep2_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, len\n    real :: a(20,20)\n\n    len = 20\n\n    do i = 1, len\n        do j = 1, len\n            a(i,j) = 0.5\n        end do\n    end do\n\n    !$omp parallel do private(j)\n    do i = 1, len-1\n        do j = 1, len\n            a(i,j) = a(i,j) + a(i+1,j)\n        end do\n    end do\n    !$omp end parallel do\n\n    write(*,*) 'a(10,10) =', a(10,10)\n\nend program
program DRB078_taskdep2_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i\n    i = 0\n\n    !$omp parallel\n        !$omp single\n            !$omp task depend (out:i)\n                call sleep(3)\n                i=3\n            !$omp end task\n            !$omp task depend (out:i)\n                i=2\n            !$omp end task\n        !$omp end single\n    !$omp end parallel\n\n    if (i /=2 ) then\n        print 100, i\n        100 format (i3)\n    end if\nend program
program DRB150_missinglock1_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    integer (kind=omp_lock_kind) :: lck\n    call omp_init_lock (lck)\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n    do i = 1, 10\n        call omp_set_lock(lck)\n        var = var+1\n        call omp_unset_lock(lck)\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    call omp_destroy_lock(lck)\n\n    print*, var\nend program
program DRB161_nolocksimd_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var(8)\n    integer :: i, j\n\n    do i = 1, 8\n        var(i) = 0\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams num_teams(1) thread_limit(1048)\n    !$omp distribute parallel do\n    do i = 1, 20\n        !$omp simd\n        do j = 1, 8\n            var(j) = var(j)+1\n        end do\n        !$omp end simd\n    end do\n    !$omp end distribute parallel do\n    !$omp end teams\n    !$omp end target\n\n    print*,var(8)\nend program
program DRB032_truedepfirstdimension_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, n, m, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    real, dimension(:,:), allocatable :: b\n\n    len = 1000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    n = len\n    m = len\n    allocate (b(n,m))\n\n    do i = 1, n\n        do j = 1, m\n            b(i,j) = 0.5\n        end do\n    end do\n\n    !$omp parallel do private(j)\n    do i = 2, n\n        do j = 2, m\n            b(i,j) = b(i-1, j-1)\n        end do\n    end do\n    !$omp end parallel do\n\n    print 100, b(500,500)\n    100 format ('b(500,500) =',F10.6)\n\n\n    deallocate(args,b)\nend program
program DRB104_nowait_barrier_orig_no\n    use omp_lib\n    implicit none\n\n    integer i, error, len, b\n    integer, dimension(:), allocatable :: a\n\n    len = 1000\n    b = 5\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel shared(b, error)\n        !$omp do\n        do i = 1, len\n            a(i) = b+a(i)*5\n        end do\n        !$omp end do nowait\n    !$omp end parallel\n\n    !$omp barrier\n    !$omp single\n    error = a(9)+1\n    !$omp end single\n\n    print 100, error\n    100 format ('error =',3i8)\n\n    deallocate(a)\nend program
module DRB058\nuse omp_lib\nimplicit none\n\ninteger :: MSIZE\ninteger :: n,m,mits\ninteger, parameter :: dp = kind(1.0d0)\nreal(dp), dimension(:,:), pointer :: u,f,uold\nreal(dp) :: dx,dy,tol,relax,alpha\n\ncontains\nsubroutine initialize()\ninteger :: i,j,xx,yy\n\nMSIZE = 200\nmits = 1000\ntol=0.0000000001\nrelax = 1.0\nalpha = 0.0543\nn = MSIZE\nm = MSIZE\nallocate(u(MSIZE,MSIZE))\nallocate(f(MSIZE,MSIZE))\nallocate(uold(MSIZE,MSIZE))\n\ndx = 2.0D0 / DBLE(n-1)\ndy = 2.0D0 / DBLE(m-1)\n\ndo i = 1, n\ndo j = 1, m\nxx = int(-1.0 + dx * (i-1))\nyy = int(-1.0 + dy * (i-1))\nu(i,j) = 0.0\nf(i,j) = -1.0 * alpha * (1.0-xx*xx) * (1.0-yy*yy) - 2.0* (1.0-xx*xx) -2.0 * (1.0-yy*yy)\nend do\nend do\n\nend subroutine\n\nsubroutine jacobi()\ninteger, parameter :: dp = kind(1.0d0)\nreal(dp) :: omega\ninteger :: i, j, k\nreal(dp) :: error, resid,  ax, ay, b\n\nMSIZE = 200\nmits = 1000\ntol=0.0000000001\nrelax = 1.0\nalpha = 0.0543\nn = MSIZE\nm = MSIZE\n\nomega = relax\ndx = 2.0D0 / DBLE(n-1)\ndy = 2.0D0 / DBLE(m-1)\n\nax = 1.0D0 / (dx * dx);         !/* X-direction coef */\nay = 1.0D0 / (dy * dy);         !/* Y-direction coef */\nb = -2.0D0 / (dx * dx) - 2.0D0 / (dy * dy) - alpha;\n\nerror = 10.0 * tol\nk = 1\n\ndo k = 1, mits\nerror = 0.0\n\n!Copy new solution into old\n!$omp parallel\n!$omp do private(i,j)\ndo i = 1, n\ndo j = 1, m\nuold(i,j) = u(i,j)\nend do\nend do\n!$omp end do\n!$omp do private(i,j,resid) reduction(+:error)\ndo i = 2, (n-1)\ndo j = 2, (m-1)\nresid = (ax * (uold(i - 1,j) + uold(i + 1,j)) + ay * (uold(i,j - 1) + uold(i,j + 1)) + b * uold(i,j) - f(i,j)) / b\nu(i,j) = uold(i,j) - omega * resid\nerror = error + resid * resid\nend do\nend do\n!$omp end do nowait\n!$omp end parallel\n\n!Error check\nerror = sqrt(error)/(n*m)\nend do\n\nprint*,"Total number of iterations: ",k\nprint*,"Residual: ",error\n\nend subroutine\nend module program DRB058_jacobikernel_orig_no\n    use omp_lib\n    use DRB058\n    implicit none\n\n    call initialize()\n    call jacobi()\nend program
program DRB025_simdtruedep_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: a\n    integer, dimension(:), allocatable :: b\n\n    len = 100\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n    allocate (b(len))\n\n    do i = 1, len\n        a(i) = i\n        b(i) = i+1\n    end do\n\n    !$omp simd\n    do i = 1, len-1\n        a(i+1) = a(i) + b(i)\n    end do\n\n    do i = 1, len\n        write(6,*) 'Values for i and a(i) are:', i, a(i)\n    end do\n\n    deallocate(args,a,b)\n\nend program
program DRB071_targetparallelfor_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i, len\n    integer, dimension(:), allocatable :: a\n\n    allocate(a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp target map(a(1:len))\n    !$omp parallel do\n    do i = 1, len\n        a(i) = a(i)+1\n    end do\n    !$omp end target\n\n    deallocate(a)\nend program
program DRB114_if_orig_yes\n    use omp_lib\n    implicit none\n\n    integer i, len, rem, j\n    real :: u\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), allocatable :: a\n\n    len = 100\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    call random_number(u)\n    j = FLOOR(100*u)\n\n    !$omp parallel do if (MOD(j,2)==0)\n    do i = 1, len-1\n        a(i+1) = a(i)+1\n    end do\n    !$omp end parallel do\n\n    print*,'a(50) =',a(50)\n\n    deallocate(a)\nend program
program DRB016_outputdep_orig_yes\n    use omp_lib\n    use globalArray\n\n    implicit none\n\n    integer len, i, x\n\n    len = 100\n    x = 10\n\n    call useGlobalArray(len)\n\n    !$omp parallel do\n    do i = 1, len\n        a(i) = x\n        x = i\n    end do\n    !$omp end parallel do\n\n    write(*,*) "x =",x\nend program
program DRB100_task_reference_orig_no\n    use omp_lib\n    use DRB100\n    implicit none\n\n    integer :: i\n    allocate (a(100))\n\n    !$omp parallel\n        !$omp single\n        do i = 1, 100\n            call gen_task(i)\n        end do\n        !$omp end single\n    !$omp end parallel\n\n    do i = 1, 100\n        if (a(i) /= i+1) then\n            print*,'warning: a(',i,') =',a(i),' not expected',i+1\n        end if\n!        print*,a(i),i+1\n    end do\nend program
program DRB131_taskdep4_orig_yes_omp_45\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task shared(y)\n        y = y-1                                 !!2nd child task\n        !$omp end task\n\n        !$omp task depend(in: x) if(.FALSE.)    !!1st taskwait\n        !$omp end task\n\n        print*, "x=", x\n        print*, "y=", y\n\n        !$omp taskwait                          !!2nd taskwait\n    end subroutine foo\nend program
program DRB160_nobarrier_orig_gpu_yes\n    use omp_lib\n    use DRB160\n    implicit none\n\n    do i = 1, 8\n        b(i) = 0\n        c(i) = 2\n        temp(i) = 0\n    end do\n\n    a = 2\n    val = 0\n\n    !$omp target map(tofrom:b) map(to:c,temp,a) device(0)\n    !$omp teams\n    do i = 1, 100\n        !$omp distribute\n        do j = 1, 8\n            temp(j) = b(j)+c(j)\n        end do\n        !$omp end distribute\n\n        !$omp distribute\n        do j = 8, 1, k-1\n            b(j) = temp(j)*a\n        end do\n        !$omp end distribute\n    end do\n    !$omp end teams\n    !$omp end target\n\n    do i = 1, 100\n        val = val+2\n        val = val*2\n    end do\n\n    do i = 1, 8\n        if (val /= b(i)) then\n            print*,b(i),val\n        end if\n    end do\n\nend program
program DRB135_taskdep_mutexinoutset_orig_no_omp50\n    use omp_lib\n    implicit none\n\n    integer :: a, b, c, d\n\n    !$omp parallel\n    !$omp single\n        !$omp task depend(out: c)\n        c = 1      ! Task T1\n        !$omp end task\n        !$omp task depend(out: a)\n        a = 2      ! Task T2\n        !$omp end task\n        !$omp task depend(out: b)\n        b = 3      ! Task T3\n        !$omp end task\n        !$omp task depend(in: a) depend(mutexinoutset: c)\n        c = c + a  ! Task T4\n        !$omp end task\n        !$omp task depend(in: b) depend(mutexinoutset: c)\n        c = c + b  ! Task T5\n        !$omp end task\n        !$omp task depend(in: c)\n        d = c      ! Task T6\n        !$omp end task\n    !$omp end single\n    !$omp end parallel\n\n    print *, d\nend program
program DRB168_taskdep5_orig_yes_omp_50\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task shared(y)\n        y = y-x                                 !!2nd child task\n        !$omp end task\n\n        !$omp taskwait depend(in: x)            !!1st taskwait\n\n        print*, "x=", x\n        print*, "y=", y\n\n        !$omp taskwait                          !!2nd taskwait\n    end subroutine foo\nend program
program DRB108_atomic_orig_no\n    use omp_lib\n    implicit none\n\n    integer a\n    a = 0\n\n    !$omp parallel\n    !$omp atomic\n    a = a+1\n    !$omp end atomic\n    !$omp end parallel\n\n    print 100, a\n    100 format ('a =',3i8)\nend program
program DRB039_truedepsingleelement_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: len, i\n    integer, dimension(:), allocatable :: a\n\n    len = 1000\n    allocate (a(len))\n\n    a(1) = 2\n\n    !$omp parallel do\n    do i = 1, len\n        a(i) = a(i)+a(1)\n    end do\n    !$omp end parallel do\n\n    print 100, a(500)\n    100 format ('a(500) =',i3)\n\n    deallocate(a)\nend program
program DRB115_forsimd_orig_yes\n    use omp_lib\n    implicit none\n\n    integer i, len\n    integer, dimension(:), allocatable :: a,b\n\n    len = 100\n    allocate (a(len))\n    allocate (b(len))\n\n    do i = 1, len\n        a(i) = i\n        b(i) = i+1\n    end do\n\n    !$omp simd\n    do i = 1, len-1\n        a(i+1)=a(i)+b(i)\n    end do\n\n    print*,'a(50) =',a(50)\n\n    deallocate(a,b)\nend program
program DRB132_taskdep4_orig_no_omp45\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task shared(y)\n        y = y-1                                 !!2nd child task\n        !$omp end task\n\n        !$omp task depend(in: x) if(.FALSE.)    !!1st taskwait\n        !$omp end task\n\n        print*, "x=", x\n\n        !$omp taskwait                          !!2nd taskwait\n\n        print*, "y=", y\n\n    end subroutine\nend program
program DRB076_flush_orig_no\n    use omp_lib\n    use DRB076\n    implicit none\n\n    integer :: i, sum\n    i = 0\n    sum = 0\n\n    !$omp parallel reduction(+:sum) num_threads(10) private(i)\n    call f1(i)\n    sum = sum + i\n    !$omp end parallel\n\n    if (sum /= 10) then\n        print*,'sum =',sum\n    end if\nend program
program DRB147_critical1_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n        do i = 0, 100\n            !$omp atomic\n            var = var+1\n            !$omp atomic\n            var = var-2\n        end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    print*, var\nend program
program DRB049_fprintf_orig_no\n    use omp_lib\n    implicit none\n\n    integer i, ret, len, stat\n    integer :: a(1000)\n    logical :: exist\n\n    len = 1000\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    inquire(file="mytempfile.txt", exist=exist)\n\n    if (exist) then\n        open(6, file="mytempfile.txt", iostat=stat, status="old", position="append", action="write")\n    else\n        open(6, file="mytempfile.txt", iostat=stat, status="new", action="write")\n    end if\n\n    !$omp parallel do\n    do i = 1, len\n        write(6, *) a(i)\n    end do\n    !$omp end parallel do\n\n    if (stat == 0) close(6, status='delete')\n\nend program
program DRB045_doall1_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i\n    integer :: a(100)\n\n    !$omp parallel do\n    do i = 1, 100\n        a(i) = a(i)+1\n    end do\n    !$omp end parallel do\n\nend program
program DRB051_getthreadnum_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: numThreads\n\n    !$omp parallel\n    if (omp_get_thread_num() == 0) then\n        numThreads = omp_get_num_threads()\n    end if\n    !$omp end parallel\n\n    print 100, numThreads\n    100 format ('numThreads =',i3)\nend program
program DRB085_threadprivate_orig_no\n    use omp_lib\n    use DRB085\n    implicit none\n\n    integer :: len\n    integer (kind=8) :: i, sum\n    len = 1000\n    sum = 0\n\n    !$omp parallel copyin(sum0)\n        !$omp do\n        do i = 1, len\n            call foo(i)\n        end do\n        !$omp end do\n        !$omp critical\n        sum = sum+sum0\n        !$omp end critical\n    !$omp end parallel\n\n    do i = 1, len\n        sum1=sum1+i\n    end do\n\n    print*,'sum = ',sum,'sum1 =',sum1\nend program
program DRB007_indirectaccess3_orig_yes\n    use omp_lib\n    use DRB007\n    implicit none\n\n    integer :: i, idx1, idx2\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), pointer :: xa1=>NULL(), xa2=>NULL()\n    real(dp), dimension(2025), target :: base\n\n    allocate (xa1(2025))\n    allocate (xa2(2025))\n\n    xa1 => base(1:2025)\n    xa2 => base(1:2025)\n\n    n=180\n\n    indexSet = (/ 521, 523, 525, 533, 529, 531, 547, 549, &\n    551, 553, 555, 557, 573, 575, 577, 579, 581, 583, 599, &\n    601, 603, 605, 607, 609, 625, 627, 629, 631, 633, 635, &\n    651, 653, 655, 657, 659, 661, 859, 861, 863, 865, 867, &\n    869, 885, 887, 889, 891, 893, 895, 911, 913, 915, 917, &\n    919, 921, 937, 939, 941, 943, 945, 947, 963, 965, 967, &\n    969, 971, 973, 989, 991, 993, 995, 997, 999, 1197, 1199, &\n    1201, 1203, 1205, 1207, 1223, 1225, 1227, 1229, 1231, &\n    1233, 1249, 1251, 1253, 1255, 1257, 1259, 1275, 1277, &\n    1279, 1281, 1283, 1285, 1301, 1303, 1305, 1307, 1309, &\n    1311, 1327, 1329, 1331, 1333, 1335, 1337, 1535, 1537, &\n    1539, 1541, 1543, 1545, 1561, 1563, 1565, 1567, 1569, &\n    1571, 1587, 1589, 1591, 1593, 1595, 1597, 1613, 1615, &\n    1617, 1619, 1621, 1623, 1639, 1641, 1643, 1645, 1647, &\n    1649, 1665, 1667, 1669, 1671, 1673, 1675, 1873, 1875, &\n    1877, 1879, 1881, 1883, 1899, 1901, 1903, 1905, 1907, &\n    1909, 1925, 1927, 1929, 1931, 1933, 1935, 1951, 1953, &\n    1955, 1957, 1959, 1961, 1977, 1979, 1981, 1983, 1985, &\n    1987, 2003, 2005, 2007, 2009, 2011, 2013 /)\n\n    do i = 521, 2025\n        base(i) = 0.5*i\n    end do\n\n    !$omp parallel do\n    do i = 1, n\n        idx1 = indexSet(i)\n        idx2 = indexSet(i)+12\n        base(idx1) = base(idx1)+1.0\n        base(idx2) = base(idx2)+3.0\n    end do\n    !$omp end parallel do\n\n    print*,'xa1(999) =',base(999),' xa2(1285) =',base(1285)\n\n    nullify(xa1,xa2)\nend program
program DRB060_matrixmultiply_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: N,M,K, len, i, j, l\n    real, dimension(:,:), allocatable :: a, b, c\n\n    len = 100\n    N=len\n    M=len\n    K=len\n\n    allocate (a(N,M))\n    allocate (b(M,K))\n    allocate (c(K,N))\n\n    !$omp parallel do private(j, l)\n    do i = 1, N\n        do l = 1, K\n            do j = 1, M\n                c(i,j) = c(i,j)+a(i,l)*b(l,j)\n            end do\n        end do\n    end do\n    !$omp end parallel do\n\n    deallocate(a,b,c)\nend program
program DRB023_sections1_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i\n    i = 0\n\n    !$omp parallel sections\n    !$omp section\n    i=1\n    !$omp section\n    i=2\n    !$omp end parallel sections\n\n    print 100, i\n    100 format ("i=",i3)\n\nend program
program DRB102_copyprivate_orig_no\n    use omp_lib\n    use DRB102\n    implicit none\n\n    !$omp parallel\n        !$omp single\n        x=1.0\n        y=1\n        !$omp end single copyprivate(x,y)\n    !$omp end parallel\n\n    print 100, x, y\n    100 format ('x =',F3.1,2x,'y =',i3)\n\nend program
program DRB155_missingordered_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer :: var(100)\n    integer :: i\n\n    do i = 1, 100\n        var(i) = 1\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp parallel do ordered\n    do i = 2, 100\n        !$omp ordered\n        var(i) = var(i-1)+1\n        !$omp end ordered\n    end do\n    !$omp end parallel do\n    !$omp end target\n\n    do i = 1, 100\n        if (var(i)/=i) then\n            print*,"Data Race Present"\n        end if\n    end do\n\nend program
program DRB111_linearmissing_orig_yes\n    use omp_lib\n    implicit none\n\n    integer len, i, j\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), allocatable :: a,b,c\n\n    len = 100\n    i = 0\n    j = 0\n\n    allocate (a(len))\n    allocate (b(len))\n    allocate (c(len))\n\n    do i = 1, len\n        a(i) = (real(i,dp))/2.0\n        b(i) = (real(i,dp))/3.0\n        c(i) = (real(i,dp))/7.0\n    end do\n\n    !$omp parallel do\n    do i = 1, len\n        c(j) = c(j)+a(i)*b(i)\n        j = j+1\n    end do\n    !$omp end parallel do\n\n    print*,'c(50) =',c(50)\n\n    if(allocated(a))deallocate(a)\n    if(allocated(b))deallocate(b)\n   \nend program
program DRB061_matrixvector1_orig_no\n    use omp_lib\n    implicit none\n    call foo\ncontains\n    subroutine foo()\n        integer :: i, j, N\n        real :: sum\n        real, dimension(:,:), allocatable :: a\n        real, dimension(:), allocatable :: v, v_out\n\n        N = 100\n        allocate (a(N,N))\n        allocate (v(N))\n        allocate (v_out(N))\n\n        !$omp parallel do private (i,j,sum)\n        do i = 1, N\n            do j = 1, N\n                sum = sum + a(i,j)*v(j)\n            end do\n            v_out(i) = sum\n        end do\n        !$omp end parallel do\n\n    end subroutine foo\nend program
program DRB153_missinglock2_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams num_teams(1)\n        !$omp distribute parallel do\n        do i = 1, 100\n            var = var + 1\n        end do\n        !$omp end distribute parallel do\n    !$omp end teams\n    !$omp end target\n\n    print*, var\nend program
program DRB033_truedeplinear_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len\n    integer, dimension(:), allocatable :: a\n\n    len = 2000\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, 1000\n        a(2*i) = a(i) + 1\n    end do\n    !$omp end parallel do\n\n    print 100, a(1002)\n    100 format ('a(1002) =',i3)\n\n    deallocate(a)\nend program
program DRB162_nolocksimd_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer :: var(8)\n    integer :: i,j\n\n    do i = 1, 8\n        var(i) = 0\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams num_teams(1) thread_limit(1048)\n    !$omp distribute parallel do reduction(+:var)\n    do i = 1, 20\n        !$omp simd\n        do j = 1, 8\n            var(j) = var(j)+1\n        end do\n        !$omp end simd\n    end do\n    !$omp end distribute parallel do\n    !$omp end teams\n    !$omp end target\n\n    do i = 1, 8\n        if (var(i) /= 20) then\n            print*,var(i)\n        end if\n    end do\n\nend program
program DRB103_master_orig_no\n    use omp_lib\n    implicit none\n\n    integer k\n\n    !$omp parallel\n    !$omp master\n    k = omp_get_num_threads()\n    print 100, k\n    100 format ('Number of threads requested =',3i8)\n    !$omp end master\n    !$omp end parallel\n\nend program
program DRB167_taskdep5_orig_no_omp50\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task shared(y)\n        y = y-x                                 !!2nd child task\n        !$omp end task\n\n        !$omp taskwait depend(in: x)            !!1st taskwait\n\n        print*, "x=", x\n\n        !$omp taskwait                          !!2nd taskwait\n\n        print*, "y=", y\n\n    end subroutine\nend program
program DRB088_dynamic_storage_orig_yes\n    use omp_lib\n    implicit none\n    integer, pointer :: counter\n\n    allocate(counter)\n\n    counter = 0\n\n    !$omp parallel\n    counter = counter+1\n    !$omp end parallel\n\n    print*,counter\n\n    deallocate(counter)\n\nend program
program DRB097_target_teams_distribute_orig_no\n    use omp_lib\n    use ISO_C_Binding\n    implicit none\n    integer, parameter :: dp = kind(1.0d0)\n    integer, parameter :: double_kind = c_double\n    integer (kind=8) :: i, i2, len, l_limit, tmp\n    real(dp) :: sum, sum2\n    real(dp), dimension(:), allocatable :: a, b\n\n    len = 2560\n    sum = real(0.0,dp)\n    sum2 = real(0.0,dp)\n\n    allocate (a(len))\n    allocate (b(len))\n\n    do i = 1, len\n        a(i) = real(i,dp)/real(2.0,dp)\n        b(i) = real(i,dp)/real(3.0,dp)\n    end do\n\n    !$omp target map(to: a(0:len), b(0:len)) map(tofrom: sum)\n    !$omp teams num_teams(10) thread_limit(256) reduction (+:sum)\n    !$omp distribute\n        do i2 = 1, len, 256\n            !$omp parallel do reduction (+:sum)\n            do i = i2+1, merge(i2+256,len,i2+256<len)\n                sum = sum+a(i)*b(i)\n            end do\n            !$omp end parallel do\n        end do\n    !$omp end distribute\n    !$omp end teams\n    !$omp end target\n\n    !$omp parallel do reduction (+:sum2)\n    do i = 1, len\n        sum2 = sum2+a(i)*b(i)\n    end do\n    !$omp end parallel do\n\n    print*,'sum =',int(sum),'; sum2 =',int(sum2)\n\n    deallocate(a,b)\nend program
program DRB080_func_arg_orig_yes\n    use omp_lib\n    use global\n    implicit none\n\n    integer :: i\n    i = 0\n\n    !$omp parallel\n    call f1(i)\n    !$omp end parallel\n\n    if (i /= 0) then\n        print 100, i\n        100 format ('i =',i3)\n    end if\nend program
program DRB072_taskdep1_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: i\n    i = 0\n\n    !$omp parallel\n        !$omp single\n            !$omp task depend (out:i)\n            i = 1\n            !$omp end task\n            !$omp task depend (in:i)\n            i = 2\n            !$omp end task\n        !$omp end single\n    !$omp end parallel\n\n    if (i/=2) then\n        print*,'i is not equal to 2'\n    end if\nend program
program DRB094_doall2_ordered_orig_no\n    use omp_lib\n    use DRB094\n    implicit none\n\n    integer :: len, i, j\n    len = 100\n\n    allocate (a(len,len))\n\n    !$omp parallel do ordered(2)\n    do i = 1, len\n        do j = 1, len\n            a(i,j) = a(i,j)+1\n            !$omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n            print*,'test i =',i,'  j =',j\n            !$omp ordered depend(source)\n        end do\n    end do\n    !$omp end parallel do\n\n\nend program
program DRB011_minusminus_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len, numNodes, numNodes2\n    integer :: x(100)\n    len = 100\n    numNodes=len\n    numNodes2=0\n\n    do i = 1, len\n        if (MOD(i,2) == 0) then\n            x(i) = 5\n        else\n            x(i) = -5\n        end if\n    end do\n\n    !$omp parallel do\n    do i = numNodes, 1, -1\n        if (x(i) <= 0) then\n            numNodes2 = numNodes2-1\n        end if\n    end do\n    !$omp end parallel do\n\n    print*,"numNodes2 =", numNodes2\nend program
program DRB040_truedepsingleelement_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: len, i, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: a\n\n    len = 1000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n\n    a(1) = 2\n\n    !$omp parallel do\n    do i = 1, len\n        a(i) = a(i)+a(1)\n    end do\n    !$omp end parallel do\n\n    print 100, a(0)\n    100 format ('a(0) =',i3)\n\n    deallocate(args,a)\nend program
program DRB048_firstprivate_orig_no\n    use omp_lib\n    use DRB048\n    implicit none\n\n    allocate (a(100))\n    call foo(a, 100, 7)\n    print*,a(50)\nend program
program DRB163_simdmissinglock1_orig_gpu_no\n    use omp_lib\n    use DRB163\n    implicit none\n\n    do i = 1, 16\n        var(i) = 0\n    end do\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n    do i = 1, 20\n        !$omp simd\n        do j = 1, 16\n            var(j) = var(j)+1\n        end do\n        !$omp end simd\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    print*,var(16)\n\nend program
program DRB037_truedepseconddimension_orig_yes\n    use omp_lib\n    implicit none\n\n    integer i, j, n, m, len\n    real, dimension(:,:), allocatable :: b\n\n    len = 1000\n    n = len\n    m = len\n\n    allocate (b(len,len))\n\n    do i = 1, n\n        !$omp parallel do\n        do j = 2, m\n            b(i,j) = b(i,j-1)\n        end do\n        !$omp end parallel do\n    end do\n\n    print 100, b(500,500)\n    100 format ('b(500,500) =', F20.6)\n\n    deallocate(b)\nend program
program DRB083_declared_in_func_orig_no\n    use omp_lib\n    use DRB083\n    implicit none\n\n    !$omp parallel\n    call foo()\n    !$omp end parallel\nend program
program DRB054_inneronly2_orig_no\n    use omp_lib\n    implicit none\n\n    integer i,j,n,m\n    real, dimension(:,:), allocatable :: b\n\n    n = 100\n    m = 100\n\n    allocate (b(n,m))\n\n    do i = 1, n\n        do j = 1, m\n            b(i,j) = i*j\n        end do\n    end do\n\n    do i = 2, n\n        !$omp parallel do\n        do j =2, m\n            b(i,j)=b(i-1,j-1)\n        end do\n        !$omp end parallel do\n    end do\n\n    deallocate(b)\nend program
program DRB066_pointernoaliasing_orig_no\n    use omp_lib\n    use DRB066\n    implicit none\n\n    integer :: N\n    N = 1000\n\n    call setup(N)\n\nend program
program DRB001_antidep1_orig_yes\nuse omp_lib\n    implicit none\n    integer :: i, len\n    integer :: a(1000)\n\n    len = 1000\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, len-1\n        a(i) = a(i+1) + 1\n    end do\n    !$omp end parallel do\n\n    print 100, a(500)\n    100 format ('a(500)=',i3)\nend program
module DRB057\nuse omp_lib\nimplicit none\n\ninteger :: MSIZE\ninteger :: n,m,mits\ninteger, parameter :: dp = kind(1.0d0)\nreal(dp), dimension(:,:), pointer :: u,f,uold\nreal(dp) :: dx,dy,tol,relax,alpha\n\ncontains\nsubroutine initialize()\ninteger :: i,j,xx,yy\n\nMSIZE = 200\nmits = 1000\nrelax = 1.0\nalpha = 0.0543\nn = MSIZE\nm = MSIZE\nallocate(u(MSIZE,MSIZE))\nallocate(f(MSIZE,MSIZE))\nallocate(uold(MSIZE,MSIZE))\n\ndx = 2.0D0 / DBLE(n-1)\ndy = 2.0D0 / DBLE(m-1)\n\n!Initialize initial condition and RHS\n!$omp parallel do private(i,j,xx,yy)\ndo i = 1, n\ndo j = 1, m\nxx = int(-1.0 + dx * (i-1))\nyy = int(-1.0 + dy * (i-1))\nu(i,j) = 0.0\nf(i,j) = -1.0 * alpha * (1.0-xx*xx) * (1.0-yy*yy) - 2.0* (1.0-xx*xx) -2.0 * (1.0-yy*yy)\nend do\nend do\n!$omp end parallel do\n\nend subroutine\nend module program DRB057_jacobiinitialize_orig_no\n    use omp_lib\n    use DRB057\n    implicit none\n\n    call initialize()\nend program
program DRB107_taskgroup_orig_no\n    use omp_lib\n    implicit none\n\n    integer result\n    result = 0\n\n    !$omp parallel\n    !$omp single\n        !$omp taskgroup\n            !$omp task\n            call sleep(3)\n            result = 1\n            !$omp end task\n        !$omp end taskgroup\n        !$omp task\n        result = 2\n        !$omp end task\n    !$omp end single\n    !$omp end parallel\n\n    print 100, result\n    100 format ('result =',3i8)\n\nend program
program DRB126_firstprivatesections_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: section_count\n\n    section_count = 0\n\n    call omp_set_dynamic(.FALSE.)\n    call omp_set_num_threads(1)\n\n    !$omp parallel\n    !$omp sections firstprivate( section_count )\n        !$omp section\n        section_count = section_count+1\n        print 100, section_count\n        100 format ('section_count =',3i8)\n\n        !$omp section\n        section_count = section_count+1\n        print 101, section_count\n        101 format ('section_count =',3i8)\n    !$omp end sections\n    !$omp end parallel\nend program
program DRB088_dynamic_storage_orig_yes\n    use omp_lib\n    use DRB088\n    implicit none\n\n    allocate(counter)\n\n    counter = 0\n\n    !$omp parallel\n    call foo()\n    !$omp end parallel\n\n    print*,counter\n\n    deallocate(counter)\n\nend program
program DRB129_mergeable_taskwait_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: x\n    x = 2\n\n    !$omp task mergeable\n    x = x+1\n    !$omp end task\n\n    print 100, x\n    100 format ('x =',3i8)\nend program
program DRB117_taskwait_waitonlychild_orig_yes\n    use omp_lib\n    implicit none\n\n    integer, dimension(:), allocatable :: a, psum\n    integer :: sum, i\n\n    allocate(a(4))\n    allocate(psum(4))\n\n    !$omp parallel num_threads(2)\n        !$omp do schedule(dynamic, 1)\n        do i = 1, 4\n            a(i) = i\n        end do\n        !$omp end do\n\n        !$omp single\n            !$omp task\n                !$omp task\n                  psum(2) = a(3)+a(4)\n                !$omp end task\n               psum(1) = a(1)+a(2)\n            !$omp end task\n            !$omp taskwait\n            sum = psum(2)+psum(1)\n        !$omp end single\n    !$omp end parallel\n\n    print*,'sum =',sum\n\n    deallocate(a,psum)\nend program
program DRB090_static_local_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len\n    integer, dimension(:), allocatable :: a, b\n    integer, save :: tmp\n    integer :: tmp2\n\n    len = 100\n    allocate (a(len))\n    allocate (b(len))\n\n    do i = 1, len\n        a(i) = i\n        b(i) = i\n    end do\n\n    !$omp parallel\n        !$omp do\n        do i = 1, len\n            tmp = a(i)+i\n            a(i) = tmp\n        end do\n        !$omp end do\n    !$omp end parallel\n\n    !$omp parallel\n        !$omp do\n        do i = 1, len\n            tmp2 = b(i)+i\n            b(i) = tmp2\n        end do\n        !$omp end do\n    !$omp end parallel\n\n    print 100, a(50), b(50)\n    100 format (i3,3x,i3)\n\n    deallocate(a,b)\n\nend program
program DRB077_single_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: count\n    count = 0\n\n    !$omp parallel shared(count)\n        !$omp single\n        count = count + 1\n        !$omp end single\n    !$omp end parallel\n\n    print 100, count\n    100 format ('count =',i3)\nend program
program DRB118_nestlock_orig_no\n    use omp_lib\n    use DRB118\n    implicit none\n\n    integer :: a, b\n\n    type(pair) :: p\n    p%a = 0\n    p%b = 0\n    call omp_init_nest_lock(p%lck);\n\n    !$omp parallel sections\n    !$omp section\n        call omp_set_nest_lock(p%lck)\n        call incr_b(p, a)\n        call incr_a(p, b)\n        call omp_unset_nest_lock(p%lck)\n\n    !$omp section\n        call incr_b(p, b);\n\n    !$omp end parallel sections\n\n    call omp_destroy_nest_lock(p%lck)\n\n    print*,p%b\n\nend program
program DRB121_reduction_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: var, i, sum1, sum2\n\n    var = 0\n    sum1 = 0\n    sum2 = 0\n\n    !$omp parallel reduction(+: var)\n        !$omp do schedule(static) reduction(+: sum1)\n        do i = 1, 5\n            sum1 = sum1+i\n        end do\n        !$omp end do\n\n        !$omp do schedule(static) reduction(+: sum2)\n        do i = 1, 5\n            sum2 = sum2+i\n        end do\n        !$omp end do\n\n        var = sum1 + sum2\n    !$omp end parallel\n\n    print 100, var\n    100 format ('var =',3i8)\nend program
program DRB099_targetparallelfor2_orig_no\n    use omp_lib\n    use DRB099\n    implicit none\n\n    integer :: i, len\n  integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:), allocatable :: a,b\n    real :: x\n\n    len = 1000\n\n    allocate(a(len))\n    allocate(b(len))\n\n    do i = 1, len\n        a(i) = (real(i,dp))/2.0\n        b(i) = 0.0\n    end do\n\n    x=foo(a,b,len)\n    print*,'b(50) =',b(50)\n  \n    deallocate(a,b)\nend program
program DRB118_nestlock_orig_no\n    use omp_lib\n    use DRB118\n    implicit none\n\n    integer :: a, b\n\n    type(pair) :: p\n    p%a = 0\n    p%b = 0\n    call omp_init_nest_lock(p%lck);\n\n    !$omp parallel sections\n    !$omp section\n        call omp_set_nest_lock(p%lck)\n        call incr_b(p, a)\n        call incr_a(p, b)\n        call omp_unset_nest_lock(p%lck)\n\n    !$omp section\n        call incr_b(p, b);\n\n    !$omp end parallel sections\n\n    call omp_destroy_nest_lock(p%lck)\n\n    print*,p%b\n\nend program
program DRB034_truedeplinear_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, len, uLen, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: a\n\n    len = 2000\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n\n    do i = 1, len\n        a(i) = i\n    end do\n\n    uLen = len/2\n\n    !$omp parallel do\n    do i = 1, uLen\n        a(2*i) = a(i) + 1\n    end do\n    !$omp end parallel do\n\n    deallocate(args,a)\nend program
program DRB091_threadprivate2_orig_no\n    use omp_lib\n    use DRB091\n    implicit none\n\n    integer :: len, i, sum\n    len = 1000\n    sum = 0\n\n    !$omp parallel copyin(sum0)\n        !$omp do\n        do i = 1, len\n            sum0 = sum0+i\n        end do\n        !$omp end do\n        !$omp critical\n        sum = sum+sum0\n        !$omp end critical\n    !$omp end parallel\n\n    do i = 1, len\n        sum1 = sum1+i\n    end do\n\n    print*,'sum =',sum,'sum1 =',sum1\n\nend program
module DRB106\n    implicit none\n    integer (kind=4) input\n\ncontains\n    recursive function fib(n) result(r)\n        use omp_lib\n        implicit none\n        integer (kind=4) :: n, i, j, r\n\n        if (n<2) then\n            r = n\n        else\n            !$omp task shared(i)\n            i = fib(n-1)\n            !$omp end task\n            !$omp task shared(j)\n            j = fib(n-2)\n            !$omp end task\n            r = i+j\n        end if\n        !$omp taskwait\n    end function\nend module\n\nprogram DRB106_taskwaitmissing_orig_yes\n    use omp_lib\n    use DRB106\n    implicit none\n\n    integer :: result\n    input = 30\n\n    !$omp parallel\n    !$omp single\n    result = fib(input)\n    !$omp end single\n    !$omp end parallel\n\n    print*,'Fib for ',input,' =',result\n\nend program
program DRB062_matrixvector2_orig_no\n    use omp_lib\n    implicit none\n\n    call foo\ncontains\n    subroutine foo()\n        integer :: i, j, N\n        real :: sum\n        real, dimension(:,:), allocatable :: a\n        real, dimension(:), allocatable :: v, v_out\n\n        N = 1000\n        allocate (a(N,N))\n        allocate (v(N))\n        allocate (v_out(N))\n\n        do i = 1, N\n            sum = 0.0\n            !$omp parallel do reduction(+:sum)\n            do j = 1, N\n                sum = sum + a(i,j)*v(j)\n                print*,sum\n            end do\n            !$omp end parallel do\n            v_out(i) = sum\n        end do\n\n    end subroutine foo\nend program
program DRB017_outputdep_var_yes\n    use omp_lib\n    implicit none\n\n    integer len, i, x, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension (:), allocatable :: a\n\n    len = 100\n    x = 10\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (a(len))\n    !$omp parallel do\n    do i = 1, len\n        a(i) = x\n        x = i\n    end do\n    !$omp end parallel do\n\n    print 100, x, a(0)\n    100 format ("x=",i3,2x,"a(0)=",i3)\n\n    deallocate(args,a)\nend program
program DRB075_getthreadnum_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: numThreads\n    numThreads = 0\n\n    !$omp parallel\n    if ( omp_get_thread_num()==0 ) then\n        numThreads = omp_get_num_threads();\n    else\n        print*,'numThreads =',numThreads\n    end if\n    !$omp endparallel\nend program
subroutine error_norm(rms)\n\n\n\nuse sp_data\nimplicit none\n\ninteger i, j, k, m, d\ndouble precision xi, eta, zeta, u_exact(5), rms(5), add\n\ndo m = 1, 5\nrms(m) = 0.0d0\nenddo\n\ndo   k = 0, grid_points(3)-1\ndo   j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ndo   i = 0, grid_points(1)-1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, u_exact)\n\ndo   m = 1, 5\nadd = u(m,i,j,k)-u_exact(m)\nrms(m) = rms(m) + add*add\nend do\nend do\nend do\nend do\n\ndo    m = 1, 5\ndo    d = 1, 3\nrms(m) = rms(m) / dble(grid_points(d)-2)\nend do\nrms(m) = dsqrt(rms(m))\nend do\n\nreturn\nend\n\n\n\nsubroutine rhs_norm(rms)\n\nuse sp_data\nimplicit none\n\ninteger i, j, k, d, m\ndouble precision rms(5), add\n\ndo m = 1, 5\nrms(m) = 0.0d0\nenddo\n\ndo k = 1, nz2\ndo j = 1, ny2\ndo i = 1, nx2\ndo m = 1, 5\nadd = rhs(m,i,j,k)\nrms(m) = rms(m) + add*add\nend do\nend do\nend do\nend do\n\ndo   m = 1, 5\ndo   d = 1, 3\nrms(m) = rms(m) / dble(grid_points(d)-2)\nend do\nrms(m) = dsqrt(rms(m))\nend do\n\nreturn\nend
subroutine  set_constants\n\n\nuse bt_data\nimplicit none\n\nce(1,1)  = 2.0d0\nce(1,2)  = 0.0d0\nce(1,3)  = 0.0d0\nce(1,4)  = 4.0d0\nce(1,5)  = 5.0d0\nce(1,6)  = 3.0d0\nce(1,7)  = 0.5d0\nce(1,8)  = 0.02d0\nce(1,9)  = 0.01d0\nce(1,10) = 0.03d0\nce(1,11) = 0.5d0\nce(1,12) = 0.4d0\nce(1,13) = 0.3d0\n\nce(2,1)  = 1.0d0\nce(2,2)  = 0.0d0\nce(2,3)  = 0.0d0\nce(2,4)  = 0.0d0\nce(2,5)  = 1.0d0\nce(2,6)  = 2.0d0\nce(2,7)  = 3.0d0\nce(2,8)  = 0.01d0\nce(2,9)  = 0.03d0\nce(2,10) = 0.02d0\nce(2,11) = 0.4d0\nce(2,12) = 0.3d0\nce(2,13) = 0.5d0\n\nce(3,1)  = 2.0d0\nce(3,2)  = 2.0d0\nce(3,3)  = 0.0d0\nce(3,4)  = 0.0d0\nce(3,5)  = 0.0d0\nce(3,6)  = 2.0d0\nce(3,7)  = 3.0d0\nce(3,8)  = 0.04d0\nce(3,9)  = 0.03d0\nce(3,10) = 0.05d0\nce(3,11) = 0.3d0\nce(3,12) = 0.5d0\nce(3,13) = 0.4d0\n\nce(4,1)  = 2.0d0\nce(4,2)  = 2.0d0\nce(4,3)  = 0.0d0\nce(4,4)  = 0.0d0\nce(4,5)  = 0.0d0\nce(4,6)  = 2.0d0\nce(4,7)  = 3.0d0\nce(4,8)  = 0.03d0\nce(4,9)  = 0.05d0\nce(4,10) = 0.04d0\nce(4,11) = 0.2d0\nce(4,12) = 0.1d0\nce(4,13) = 0.3d0\n\nce(5,1)  = 5.0d0\nce(5,2)  = 4.0d0\nce(5,3)  = 3.0d0\nce(5,4)  = 2.0d0\nce(5,5)  = 0.1d0\nce(5,6)  = 0.4d0\nce(5,7)  = 0.3d0\nce(5,8)  = 0.05d0\nce(5,9)  = 0.04d0\nce(5,10) = 0.03d0\nce(5,11) = 0.1d0\nce(5,12) = 0.3d0\nce(5,13) = 0.2d0\n\nc1 = 1.4d0\nc2 = 0.4d0\nc3 = 0.1d0\nc4 = 1.0d0\nc5 = 1.4d0\n\ndnxm1 = 1.0d0 / dble(grid_points(1)-1)\ndnym1 = 1.0d0 / dble(grid_points(2)-1)\ndnzm1 = 1.0d0 / dble(grid_points(3)-1)\n\nc1c2 = c1 * c2\nc1c5 = c1 * c5\nc3c4 = c3 * c4\nc1345 = c1c5 * c3c4\n\nconz1 = (1.0d0-c1c5)\n\ntx1 = 1.0d0 / (dnxm1 * dnxm1)\ntx2 = 1.0d0 / (2.0d0 * dnxm1)\ntx3 = 1.0d0 / dnxm1\n\nty1 = 1.0d0 / (dnym1 * dnym1)\nty2 = 1.0d0 / (2.0d0 * dnym1)\nty3 = 1.0d0 / dnym1\n\ntz1 = 1.0d0 / (dnzm1 * dnzm1)\ntz2 = 1.0d0 / (2.0d0 * dnzm1)\ntz3 = 1.0d0 / dnzm1\n\ndx1 = 0.75d0\ndx2 = 0.75d0\ndx3 = 0.75d0\ndx4 = 0.75d0\ndx5 = 0.75d0\n\ndy1 = 0.75d0\ndy2 = 0.75d0\ndy3 = 0.75d0\ndy4 = 0.75d0\ndy5 = 0.75d0\n\ndz1 = 1.0d0\ndz2 = 1.0d0\ndz3 = 1.0d0\ndz4 = 1.0d0\ndz5 = 1.0d0\n\ndxmax = dmax1(dx3, dx4)\ndymax = dmax1(dy2, dy4)\ndzmax = dmax1(dz2, dz3)\n\ndssp = 0.25d0 * dmax1(dx1, dmax1(dy1, dz1) )\n\nc4dssp = 4.0d0 * dssp\nc5dssp = 5.0d0 * dssp\n\ndttx1 = dt*tx1\ndttx2 = dt*tx2\ndtty1 = dt*ty1\ndtty2 = dt*ty2\ndttz1 = dt*tz1\ndttz2 = dt*tz2\n\nc2dttx1 = 2.0d0*dttx1\nc2dtty1 = 2.0d0*dtty1\nc2dttz1 = 2.0d0*dttz1\n\ndtdssp = dt*dssp\n\ncomz1  = dtdssp\ncomz4  = 4.0d0*dtdssp\ncomz5  = 5.0d0*dtdssp\ncomz6  = 6.0d0*dtdssp\n\nc3c4tx3 = c3c4*tx3\nc3c4ty3 = c3c4*ty3\nc3c4tz3 = c3c4*tz3\n\ndx1tx1 = dx1*tx1\ndx2tx1 = dx2*tx1\ndx3tx1 = dx3*tx1\ndx4tx1 = dx4*tx1\ndx5tx1 = dx5*tx1\n\ndy1ty1 = dy1*ty1\ndy2ty1 = dy2*ty1\ndy3ty1 = dy3*ty1\ndy4ty1 = dy4*ty1\ndy5ty1 = dy5*ty1\n\ndz1tz1 = dz1*tz1\ndz2tz1 = dz2*tz1\ndz3tz1 = dz3*tz1\ndz4tz1 = dz4*tz1\ndz5tz1 = dz5*tz1\n\nc2iv  = 2.5d0\ncon43 = 4.0d0/3.0d0\ncon16 = 1.0d0/6.0d0\n\nxxcon1 = c3c4tx3*con43*tx3\nxxcon2 = c3c4tx3*tx3\nxxcon3 = c3c4tx3*conz1*tx3\nxxcon4 = c3c4tx3*con16*tx3\nxxcon5 = c3c4tx3*c1c5*tx3\n\nyycon1 = c3c4ty3*con43*ty3\nyycon2 = c3c4ty3*ty3\nyycon3 = c3c4ty3*conz1*ty3\nyycon4 = c3c4ty3*con16*ty3\nyycon5 = c3c4ty3*c1c5*ty3\n\nzzcon1 = c3c4tz3*con43*tz3\nzzcon2 = c3c4tz3*tz3\nzzcon3 = c3c4tz3*conz1*tz3\nzzcon4 = c3c4tz3*con16*tz3\nzzcon5 = c3c4tz3*c1c5*tz3\n\nreturn\nend
subroutine  set_constants\n\n\nuse sp_data\nimplicit none\n\nce(1,1)  = 2.0d0\nce(1,2)  = 0.0d0\nce(1,3)  = 0.0d0\nce(1,4)  = 4.0d0\nce(1,5)  = 5.0d0\nce(1,6)  = 3.0d0\nce(1,7)  = 0.5d0\nce(1,8)  = 0.02d0\nce(1,9)  = 0.01d0\nce(1,10) = 0.03d0\nce(1,11) = 0.5d0\nce(1,12) = 0.4d0\nce(1,13) = 0.3d0\n\nce(2,1)  = 1.0d0\nce(2,2)  = 0.0d0\nce(2,3)  = 0.0d0\nce(2,4)  = 0.0d0\nce(2,5)  = 1.0d0\nce(2,6)  = 2.0d0\nce(2,7)  = 3.0d0\nce(2,8)  = 0.01d0\nce(2,9)  = 0.03d0\nce(2,10) = 0.02d0\nce(2,11) = 0.4d0\nce(2,12) = 0.3d0\nce(2,13) = 0.5d0\n\nce(3,1)  = 2.0d0\nce(3,2)  = 2.0d0\nce(3,3)  = 0.0d0\nce(3,4)  = 0.0d0\nce(3,5)  = 0.0d0\nce(3,6)  = 2.0d0\nce(3,7)  = 3.0d0\nce(3,8)  = 0.04d0\nce(3,9)  = 0.03d0\nce(3,10) = 0.05d0\nce(3,11) = 0.3d0\nce(3,12) = 0.5d0\nce(3,13) = 0.4d0\n\nce(4,1)  = 2.0d0\nce(4,2)  = 2.0d0\nce(4,3)  = 0.0d0\nce(4,4)  = 0.0d0\nce(4,5)  = 0.0d0\nce(4,6)  = 2.0d0\nce(4,7)  = 3.0d0\nce(4,8)  = 0.03d0\nce(4,9)  = 0.05d0\nce(4,10) = 0.04d0\nce(4,11) = 0.2d0\nce(4,12) = 0.1d0\nce(4,13) = 0.3d0\n\nce(5,1)  = 5.0d0\nce(5,2)  = 4.0d0\nce(5,3)  = 3.0d0\nce(5,4)  = 2.0d0\nce(5,5)  = 0.1d0\nce(5,6)  = 0.4d0\nce(5,7)  = 0.3d0\nce(5,8)  = 0.05d0\nce(5,9)  = 0.04d0\nce(5,10) = 0.03d0\nce(5,11) = 0.1d0\nce(5,12) = 0.3d0\nce(5,13) = 0.2d0\n\nc1 = 1.4d0\nc2 = 0.4d0\nc3 = 0.1d0\nc4 = 1.0d0\nc5 = 1.4d0\n\nbt = dsqrt(0.5d0)\n\ndnxm1 = 1.0d0 / dble(grid_points(1)-1)\ndnym1 = 1.0d0 / dble(grid_points(2)-1)\ndnzm1 = 1.0d0 / dble(grid_points(3)-1)\n\nc1c2 = c1 * c2\nc1c5 = c1 * c5\nc3c4 = c3 * c4\nc1345 = c1c5 * c3c4\n\nconz1 = (1.0d0-c1c5)\n\ntx1 = 1.0d0 / (dnxm1 * dnxm1)\ntx2 = 1.0d0 / (2.0d0 * dnxm1)\ntx3 = 1.0d0 / dnxm1\n\nty1 = 1.0d0 / (dnym1 * dnym1)\nty2 = 1.0d0 / (2.0d0 * dnym1)\nty3 = 1.0d0 / dnym1\n\ntz1 = 1.0d0 / (dnzm1 * dnzm1)\ntz2 = 1.0d0 / (2.0d0 * dnzm1)\ntz3 = 1.0d0 / dnzm1\n\ndx1 = 0.75d0\ndx2 = 0.75d0\ndx3 = 0.75d0\ndx4 = 0.75d0\ndx5 = 0.75d0\n\ndy1 = 0.75d0\ndy2 = 0.75d0\ndy3 = 0.75d0\ndy4 = 0.75d0\ndy5 = 0.75d0\n\ndz1 = 1.0d0\ndz2 = 1.0d0\ndz3 = 1.0d0\ndz4 = 1.0d0\ndz5 = 1.0d0\n\ndxmax = dmax1(dx3, dx4)\ndymax = dmax1(dy2, dy4)\ndzmax = dmax1(dz2, dz3)\n\ndssp = 0.25d0 * dmax1(dx1, dmax1(dy1, dz1) )\n\nc4dssp = 4.0d0 * dssp\nc5dssp = 5.0d0 * dssp\n\ndttx1 = dt*tx1\ndttx2 = dt*tx2\ndtty1 = dt*ty1\ndtty2 = dt*ty2\ndttz1 = dt*tz1\ndttz2 = dt*tz2\n\nc2dttx1 = 2.0d0*dttx1\nc2dtty1 = 2.0d0*dtty1\nc2dttz1 = 2.0d0*dttz1\n\ndtdssp = dt*dssp\n\ncomz1  = dtdssp\ncomz4  = 4.0d0*dtdssp\ncomz5  = 5.0d0*dtdssp\ncomz6  = 6.0d0*dtdssp\n\nc3c4tx3 = c3c4*tx3\nc3c4ty3 = c3c4*ty3\nc3c4tz3 = c3c4*tz3\n\ndx1tx1 = dx1*tx1\ndx2tx1 = dx2*tx1\ndx3tx1 = dx3*tx1\ndx4tx1 = dx4*tx1\ndx5tx1 = dx5*tx1\n\ndy1ty1 = dy1*ty1\ndy2ty1 = dy2*ty1\ndy3ty1 = dy3*ty1\ndy4ty1 = dy4*ty1\ndy5ty1 = dy5*ty1\n\ndz1tz1 = dz1*tz1\ndz2tz1 = dz2*tz1\ndz3tz1 = dz3*tz1\ndz4tz1 = dz4*tz1\ndz5tz1 = dz5*tz1\n\nc2iv  = 2.5d0\ncon43 = 4.0d0/3.0d0\ncon16 = 1.0d0/6.0d0\n\nxxcon1 = c3c4tx3*con43*tx3\nxxcon2 = c3c4tx3*tx3\nxxcon3 = c3c4tx3*conz1*tx3\nxxcon4 = c3c4tx3*con16*tx3\nxxcon5 = c3c4tx3*c1c5*tx3\n\nyycon1 = c3c4ty3*con43*ty3\nyycon2 = c3c4ty3*ty3\nyycon3 = c3c4ty3*conz1*ty3\nyycon4 = c3c4ty3*con16*ty3\nyycon5 = c3c4ty3*c1c5*ty3\n\nzzcon1 = c3c4tz3*con43*tz3\nzzcon2 = c3c4tz3*tz3\nzzcon3 = c3c4tz3*conz1*tz3\nzzcon4 = c3c4tz3*con16*tz3\nzzcon5 = c3c4tz3*c1c5*tz3\n\nreturn\nend
subroutine makea( n, nz, a, colidx, rowstr,  &\n&                  firstrow, lastrow, firstcol, lastcol,  &\n&                  arow, acol, aelt, v, iv )\n\nuse tinfo\nuse cg_data, only : nonzer, rcond, shift\n\nimplicit none\n\ninteger             n\ninteger(kz)         nz, rowstr(n+1)\ninteger             firstrow, lastrow, firstcol, lastcol\ninteger             colidx(nz)\ninteger             iv(n+nz), arow(n), acol(nonzer+1,n)\ndouble precision    aelt(nonzer+1,n), v(nz)\ndouble precision    a(nz)\n\n\ninteger          i, iouter, ivelt, nzv, nn1\ninteger          ivc(nonzer+1)\ndouble precision vc(nonzer+1)\n\n\nexternal          sparse, sprnvc, vecset\ninteger           work\n\n\n\nnn1 = 1\n50   continue\nnn1 = 2 * nn1\nif (nn1 .lt. n) goto 50\n\nnum_threads = 1\nmyid = 0\nif (num_threads .gt. max_threads) then\nif (myid .eq. 0) write(*,100) num_threads, max_threads\n100      format(' Warning: num_threads',i6,  &\n&          ' exceeded an internal limit',i6)\nnum_threads = max_threads\nendif\nwork  = (n + num_threads - 1)/num_threads\nilow  = work * myid + 1\nihigh = ilow + work - 1\nif (ihigh .gt. n) ihigh = n\n\ndo iouter = 1, ihigh\nnzv = nonzer\ncall sprnvc( n, nzv, nn1, vc, ivc )\nif ( iouter .ge. ilow ) then\ncall vecset( n, vc, ivc, nzv, iouter, .5D0 )\narow(iouter) = nzv\ndo ivelt = 1, nzv\nacol(ivelt, iouter) = ivc(ivelt)\naelt(ivelt, iouter) = vc(ivelt)\nenddo\nendif\nenddo\n\ncall sparse( a, colidx, rowstr, n, nz, nonzer, arow, acol,  &\n&             aelt, firstrow, lastrow,  &\n&             v, iv(1), iv(nz+1), rcond, shift )\nreturn\n\nend
subroutine  initialize\n\n\n\nuse sp_data\nimplicit none\n\ninteger i, j, k, m, ix, iy, iz\ndouble precision  xi, eta, zeta, Pface(5,3,2), Pxi, Peta,  &\n&                   Pzeta, temp(5)\n\n\ndo k = 0, grid_points(3)-1\ndo j = 0, grid_points(2)-1\ndo i = 0, grid_points(1)-1\nu(1,i,j,k) = 1.0\nu(2,i,j,k) = 0.0\nu(3,i,j,k) = 0.0\nu(4,i,j,k) = 0.0\nu(5,i,j,k) = 1.0\nend do\nend do\nend do\n\ndo  k = 0, grid_points(3)-1\ndo  j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ndo   i = 0, grid_points(1)-1\nxi = dble(i) * dnxm1\n\ndo ix = 1, 2\nPxi = dble(ix-1)\ncall exact_solution(Pxi, eta, zeta,  &\n&                                    Pface(1,1,ix))\nend do\n\ndo    iy = 1, 2\nPeta = dble(iy-1)\ncall exact_solution(xi, Peta, zeta,  &\n&                                    Pface(1,2,iy))\nend do\n\ndo    iz = 1, 2\nPzeta = dble(iz-1)\ncall exact_solution(xi, eta, Pzeta,   &\n&                                    Pface(1,3,iz))\nend do\n\ndo   m = 1, 5\nPxi   = xi   * Pface(m,1,2) +  &\n&                        (1.0d0-xi)   * Pface(m,1,1)\nPeta  = eta  * Pface(m,2,2) +  &\n&                        (1.0d0-eta)  * Pface(m,2,1)\nPzeta = zeta * Pface(m,3,2) +  &\n&                        (1.0d0-zeta) * Pface(m,3,1)\n\nu(m,i,j,k) = Pxi + Peta + Pzeta -  &\n&                          Pxi*Peta - Pxi*Pzeta - Peta*Pzeta +  &\n&                          Pxi*Peta*Pzeta\n\nend do\nend do\nend do\nend do\n\n\n\nxi = 0.0d0\ni  = 0\ndo  k = 0, grid_points(3)-1\ndo   j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ncall exact_solution(xi, eta, zeta, temp)\ndo   m = 1, 5\nu(m,i,j,k) = temp(m)\nend do\nend do\nend do\n\n\nxi = 1.0d0\ni  = grid_points(1)-1\ndo   k = 0, grid_points(3)-1\ndo   j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ncall exact_solution(xi, eta, zeta, temp)\ndo   m = 1, 5\nu(m,i,j,k) = temp(m)\nend do\nend do\nend do\n\n\neta = 0.0d0\nj   = 0\ndo  k = 0, grid_points(3)-1\ndo   i = 0, grid_points(1)-1\nzeta = dble(k) * dnzm1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo   m = 1, 5\nu(m,i,j,k) = temp(m)\nend do\nend do\nend do\n\n\n\neta = 1.0d0\nj   = grid_points(2)-1\ndo   k = 0, grid_points(3)-1\ndo   i = 0, grid_points(1)-1\nzeta = dble(k) * dnzm1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo   m = 1, 5\nu(m,i,j,k) = temp(m)\nend do\nend do\nend do\n\n\nzeta = 0.0d0\nk    = 0\ndo   j = 0, grid_points(2)-1\ndo   i =0, grid_points(1)-1\neta = dble(j) * dnym1\nxi = dble(i) *dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo   m = 1, 5\nu(m,i,j,k) = temp(m)\nend do\nend do\nend do\n\n\nzeta = 1.0d0\nk    = grid_points(3)-1\ndo   j = 0, grid_points(2)-1\ndo   i =0, grid_points(1)-1\neta = dble(j) * dnym1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo   m = 1, 5\nu(m,i,j,k) = temp(m)\nend do\nend do\nend do\n\nreturn\nend
subroutine read_input\n\n\nuse lu_data\nimplicit none\n\ninteger  fstatus\n\n\n\nwrite(*, 1000)\n\nopen (unit=3,file='inputlu.data',status='old',  &\n&         access='sequential',form='formatted', iostat=fstatus)\nif (fstatus .eq. 0) then\n\nwrite(*, *) 'Reading from input file inputlu.data'\n\nread (3,*)\nread (3,*)\nread (3,*) ipr, inorm\nread (3,*)\nread (3,*)\nread (3,*) itmax\nread (3,*)\nread (3,*)\nread (3,*) dt\nread (3,*)\nread (3,*)\nread (3,*) omega\nread (3,*)\nread (3,*)\nread (3,*) tolrsd(1),tolrsd(2),tolrsd(3),tolrsd(4),tolrsd(5)\nread (3,*)\nread (3,*)\nread (3,*) nx0, ny0, nz0\nclose(3)\nelse\nipr = ipr_default\ninorm = inorm_default\nitmax = itmax_default\ndt = dt_default\nomega = omega_default\ntolrsd(1) = tolrsd1_def\ntolrsd(2) = tolrsd2_def\ntolrsd(3) = tolrsd3_def\ntolrsd(4) = tolrsd4_def\ntolrsd(5) = tolrsd5_def\nnx0 = isiz1\nny0 = isiz2\nnz0 = isiz3\nendif\n\n\nif ( ( nx0 .lt. 4 ) .or.  &\n&        ( ny0 .lt. 4 ) .or.  &\n&        ( nz0 .lt. 4 ) ) then\n\nwrite (*,2001)\n2001       format (5x,'PROBLEM SIZE IS TOO SMALL - ',  &\n&           /5x,'SET EACH OF NX, NY AND NZ AT LEAST EQUAL TO 5')\nstop\n\nend if\n\nif ( ( nx0 .gt. isiz1 ) .or.  &\n&        ( ny0 .gt. isiz2 ) .or.  &\n&        ( nz0 .gt. isiz3 ) ) then\n\nwrite (*,2002)\n2002       format (5x,'PROBLEM SIZE IS TOO LARGE - ',  &\n&           /5x,'NX, NY AND NZ SHOULD BE EQUAL TO ',  &\n&           /5x,'ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY')\nstop\n\nend if\n\n\nwrite(*, 1001) nx0, ny0, nz0\nwrite(*, 1002) itmax\nwrite(*, *)\n\n\n1000 format(//,' NAS Parallel Benchmarks (NPB3.4-OMP)',  &\n&          ' - LU Benchmark', /)\n1001    format(' Size: ', i4, 'x', i4, 'x', i4)\n1002    format(' Iterations:                  ', i5)\n1003    format(' Number of available threads: ', i5)\n\n\n\nreturn\nend
subroutine  ninvr\n\n\n\nuse sp_data\nimplicit none\n\ninteger  i, j, k\ndouble precision r1, r2, r3, r4, r5, t1, t2\n\nif (timeron) call timer_start(t_ninvr)\ndo k = 1, nz2\ndo j = 1, ny2\ndo i = 1, nx2\n\nr1 = rhs(1,i,j,k)\nr2 = rhs(2,i,j,k)\nr3 = rhs(3,i,j,k)\nr4 = rhs(4,i,j,k)\nr5 = rhs(5,i,j,k)\n\nt1 = bt * r3\nt2 = 0.5d0 * ( r4 + r5 )\n\nrhs(1,i,j,k) = -r2\nrhs(2,i,j,k) =  r1\nrhs(3,i,j,k) = bt * ( r4 - r5 )\nrhs(4,i,j,k) = -t1 + t2\nrhs(5,i,j,k) =  t1 + t2\nenddo\nenddo\nenddo\nif (timeron) call timer_stop(t_ninvr)\n\nreturn\nend
subroutine l2norm ( ldx, ldy, ldz,  &\n&                    nx0, ny0, nz0,  &\n&                    ist, iend,  &\n&                    jst, jend,  &\n&                    v, sum )\n\n\nimplicit none\n\ninteger ldx, ldy, ldz\ninteger nx0, ny0, nz0\ninteger ist, iend\ninteger jst, jend\ndouble precision  v(5,ldx/2*2+1,ldy/2*2+1,*), sum(5)\n\ninteger i, j, k, m\n\n\ndo m = 1, 5\nsum(m) = 0.0d+00\nend do\n\ndo k = 2, nz0-1\ndo j = jst, jend\ndo i = ist, iend\ndo m = 1, 5\nsum(m) = sum(m) + v(m,i,j,k)*v(m,i,j,k)\nend do\nend do\nend do\nend do\n\ndo m = 1, 5\nsum(m) = sqrt ( sum(m) / ( dble(nx0-2)*(ny0-2)*(nz0-2) ) )\nend do\n\nreturn\nend
subroutine evolve(u0, u1, twiddle, d1, d2, d3)\n\n\n\nuse ft_data\nimplicit none\n\ninteger d1, d2, d3\ndouble complex   u0(d1+1,d2,d3)\ndouble complex   u1(d1+1,d2,d3)\ndouble precision twiddle(d1+1,d2,d3)\ninteger i, j, k\n\ndo k = 1, d3\ndo j = 1, d2\ndo i = 1, d1\nu0(i,j,k) = u0(i,j,k) * twiddle(i,j,k)\nu1(i,j,k) = u0(i,j,k)\nend do\nend do\nend do\n\nreturn\nend
subroutine domain\n\n\nuse lu_data\nimplicit none\n\n\n\nnx = nx0\nny = ny0\nnz = nz0\n\nif ( ( nx .lt. 4 ) .or.  &\n&     ( ny .lt. 4 ) .or.  &\n&     ( nz .lt. 4 ) ) then\nwrite (*,2001) nx, ny, nz\n2001    format (5x,'SUBDOMAIN SIZE IS TOO SMALL - ',  &\n&        /5x,'ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS',  &\n&        /5x,'SO THAT NX, NY AND NZ ARE GREATER THAN OR EQUAL',  &\n&        /5x,'TO 4 THEY ARE CURRENTLY', 3I3)\nstop\nend if\n\nif ( ( nx .gt. isiz1 ) .or.  &\n&     ( ny .gt. isiz2 ) .or.  &\n&     ( nz .gt. isiz3 ) ) then\nwrite (*,2002) nx, ny, nz\n2002    format (5x,'SUBDOMAIN SIZE IS TOO LARGE - ',  &\n&        /5x,'ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS',  &\n&        /5x,'SO THAT NX, NY AND NZ ARE LESS THAN OR EQUAL TO ',  &\n&        /5x,'ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY.  THEY ARE',  &\n&        /5x,'CURRENTLY', 3I4)\nstop\nend if\n\nist = 2\niend = nx - 1\n\njst = 2\njend = ny - 1\n\nii1 = 2\nii2 = nx0 - 1\nji1 = 2\nji2 = ny0 - 2\nki1 = 3\nki2 = nz0 - 1\n\nreturn\nend
subroutine  tzetar\n\n\n\nuse sp_data\nimplicit none\n\ninteger i, j, k\ndouble precision  t1, t2, t3, ac, xvel, yvel, zvel, r1, r2, r3,  &\n&                   r4, r5, btuz, ac2u, uzik1\n\n\nif (timeron) call timer_start(t_tzetar)\ndo    k = 1, nz2\ndo    j = 1, ny2\ndo    i = 1, nx2\n\nxvel = us(i,j,k)\nyvel = vs(i,j,k)\nzvel = ws(i,j,k)\nac   = speed(i,j,k)\n\nac2u = ac*ac\n\nr1 = rhs(1,i,j,k)\nr2 = rhs(2,i,j,k)\nr3 = rhs(3,i,j,k)\nr4 = rhs(4,i,j,k)\nr5 = rhs(5,i,j,k)\n\nuzik1 = u(1,i,j,k)\nbtuz  = bt * uzik1\n\nt1 = btuz/ac * (r4 + r5)\nt2 = r3 + t1\nt3 = btuz * (r4 - r5)\n\nrhs(1,i,j,k) = t2\nrhs(2,i,j,k) = -uzik1*r2 + xvel*t2\nrhs(3,i,j,k) =  uzik1*r1 + yvel*t2\nrhs(4,i,j,k) =  zvel*t2  + t3\nrhs(5,i,j,k) =  uzik1*(-xvel*r2 + yvel*r1) +  &\n&                    qs(i,j,k)*t2 + c2iv*ac2u*t1 + zvel*t3\n\nend do\nend do\nend do\nif (timeron) call timer_stop(t_tzetar)\n\nreturn\nend
subroutine rep_nrm(u,n1,n2,n3,title,kk)\n\n\n\nuse mg_data\nimplicit none\n\ninteger n1, n2, n3, kk\ndouble precision u(n1,n2,n3)\ncharacter*8 title\n\ndouble precision rnm2, rnmu\n\n\ncall norm2u3(u,n1,n2,n3,rnm2,rnmu,nx(kk),ny(kk),nz(kk))\nwrite(*,7)kk,title,rnm2,rnmu\n7    format(' Level',i2,' in ',a8,': norms =',D21.14,D21.14)\n\nreturn\nend
subroutine pinvr\n\n\n\nuse sp_data\nimplicit none\n\ninteger i, j, k\ndouble precision r1, r2, r3, r4, r5, t1, t2\n\nif (timeron) call timer_start(t_pinvr)\ndo   k = 1, nz2\ndo   j = 1, ny2\ndo   i = 1, nx2\n\nr1 = rhs(1,i,j,k)\nr2 = rhs(2,i,j,k)\nr3 = rhs(3,i,j,k)\nr4 = rhs(4,i,j,k)\nr5 = rhs(5,i,j,k)\n\nt1 = bt * r1\nt2 = 0.5d0 * ( r4 + r5 )\n\nrhs(1,i,j,k) =  bt * ( r4 - r5 )\nrhs(2,i,j,k) = -r3\nrhs(3,i,j,k) =  r2\nrhs(4,i,j,k) = -t1 + t2\nrhs(5,i,j,k) =  t1 + t2\nend do\nend do\nend do\nif (timeron) call timer_stop(t_pinvr)\n\nreturn\nend
subroutine cffts1(is, d1, d2, d3, x, xout, y1, y2)\n\n\nuse ft_data\nimplicit none\n\ninteger is, d1, d2, d3, logd1\ndouble complex x(d1+1,d2,d3)\ndouble complex xout(d1+1,d2,d3)\ndouble complex y1(fftblockpad, d1), y2(fftblockpad, d1)\ninteger i, j, k, jj, jn\n\nlogd1 = ilog2(d1)\n\nif (timers_enabled) call timer_start(T_fftx)\ndo k = 1, d3\ndo jn = 0, d2/fftblock - 1\njj = jn*fftblock\ndo j = 1, fftblock\ndo i = 1, d1\ny1(j,i) = x(i,j+jj,k)\nenddo\nenddo\n\ncall cfftz (is, logd1, d1, y1, y2)\n\n\ndo j = 1, fftblock\ndo i = 1, d1\nxout(i,j+jj,k) = y1(j,i)\nenddo\nenddo\nenddo\nenddo\nif (timers_enabled) call timer_stop(T_fftx)\n\nreturn\nend
subroutine error\n\n\n\nuse lu_data\nimplicit none\n\ninteger i, j, k, m\ndouble precision  tmp\ndouble precision  u000ijk(5)\n\n\ndo m = 1, 5\nerrnm(m) = 0.0d+00\nend do\n\ndo k = 2, nz-1\ndo j = jst, jend\ndo i = ist, iend\ncall exact( i, j, k, u000ijk )\ndo m = 1, 5\ntmp = ( u000ijk(m) - u(m,i,j,k) )\nerrnm(m) = errnm(m) + tmp * tmp\nend do\nend do\nend do\nend do\n\ndo m = 1, 5\nerrnm(m) = sqrt ( errnm(m) / ( dble(nx0-2)*(ny0-2)*(nz0-2) ) )\nend do\n\n\n1002 format (1x/1x,'RMS-norm of error in soln. to ',  &\n& 'first pde  = ',1pe12.5/,  &\n& 1x,'RMS-norm of error in soln. to ',  &\n& 'second pde = ',1pe12.5/,  &\n& 1x,'RMS-norm of error in soln. to ',  &\n& 'third pde  = ',1pe12.5/,  &\n& 1x,'RMS-norm of error in soln. to ',  &\n& 'fourth pde = ',1pe12.5/,  &\n& 1x,'RMS-norm of error in soln. to ',  &\n& 'fifth pde  = ',1pe12.5)\n\nreturn\nend
subroutine cffts3(is, d1, d2, d3, x, xout, y1, y2)\n\n\nuse ft_data\nimplicit none\n\ninteger is, d1, d2, d3, logd3\ndouble complex x(d1+1,d2,d3)\ndouble complex xout(d1+1,d2,d3)\ndouble complex y1(fftblockpad, d3), y2(fftblockpad, d3)\ninteger i, j, k, ii, in\n\nlogd3 = ilog2(d3)\n\nif (timers_enabled) call timer_start(T_fftz)\ndo j = 1, d2\ndo in = 0, d1/fftblock - 1\nii = in*fftblock\ndo k = 1, d3\ndo i = 1, fftblock\ny1(i,k) = x(i+ii,j,k)\nenddo\nenddo\n\ncall cfftz (is, logd3, d3, y1, y2)\n\ndo k = 1, d3\ndo i = 1, fftblock\nxout(i+ii,j,k) = y1(i,k)\nenddo\nenddo\nenddo\nenddo\nif (timers_enabled) call timer_stop(T_fftz)\n\nreturn\nend
subroutine setcoeff\n\n\nuse lu_data\nimplicit none\n\n\n\ndxi = 1.0d+00 / ( nx0 - 1 )\ndeta = 1.0d+00 / ( ny0 - 1 )\ndzeta = 1.0d+00 / ( nz0 - 1 )\n\ntx1 = 1.0d+00 / ( dxi * dxi )\ntx2 = 1.0d+00 / ( 2.0d+00 * dxi )\ntx3 = 1.0d+00 / dxi\n\nty1 = 1.0d+00 / ( deta * deta )\nty2 = 1.0d+00 / ( 2.0d+00 * deta )\nty3 = 1.0d+00 / deta\n\ntz1 = 1.0d+00 / ( dzeta * dzeta )\ntz2 = 1.0d+00 / ( 2.0d+00 * dzeta )\ntz3 = 1.0d+00 / dzeta\n\ndx1 = 0.75d+00\ndx2 = dx1\ndx3 = dx1\ndx4 = dx1\ndx5 = dx1\n\ndy1 = 0.75d+00\ndy2 = dy1\ndy3 = dy1\ndy4 = dy1\ndy5 = dy1\n\ndz1 = 1.00d+00\ndz2 = dz1\ndz3 = dz1\ndz4 = dz1\ndz5 = dz1\n\ndssp = ( max (dx1, dy1, dz1 ) ) / 4.0d+00\n\nce(1,1) = 2.0d+00\nce(1,2) = 0.0d+00\nce(1,3) = 0.0d+00\nce(1,4) = 4.0d+00\nce(1,5) = 5.0d+00\nce(1,6) = 3.0d+00\nce(1,7) = 5.0d-01\nce(1,8) = 2.0d-02\nce(1,9) = 1.0d-02\nce(1,10) = 3.0d-02\nce(1,11) = 5.0d-01\nce(1,12) = 4.0d-01\nce(1,13) = 3.0d-01\n\nce(2,1) = 1.0d+00\nce(2,2) = 0.0d+00\nce(2,3) = 0.0d+00\nce(2,4) = 0.0d+00\nce(2,5) = 1.0d+00\nce(2,6) = 2.0d+00\nce(2,7) = 3.0d+00\nce(2,8) = 1.0d-02\nce(2,9) = 3.0d-02\nce(2,10) = 2.0d-02\nce(2,11) = 4.0d-01\nce(2,12) = 3.0d-01\nce(2,13) = 5.0d-01\n\nce(3,1) = 2.0d+00\nce(3,2) = 2.0d+00\nce(3,3) = 0.0d+00\nce(3,4) = 0.0d+00\nce(3,5) = 0.0d+00\nce(3,6) = 2.0d+00\nce(3,7) = 3.0d+00\nce(3,8) = 4.0d-02\nce(3,9) = 3.0d-02\nce(3,10) = 5.0d-02\nce(3,11) = 3.0d-01\nce(3,12) = 5.0d-01\nce(3,13) = 4.0d-01\n\nce(4,1) = 2.0d+00\nce(4,2) = 2.0d+00\nce(4,3) = 0.0d+00\nce(4,4) = 0.0d+00\nce(4,5) = 0.0d+00\nce(4,6) = 2.0d+00\nce(4,7) = 3.0d+00\nce(4,8) = 3.0d-02\nce(4,9) = 5.0d-02\nce(4,10) = 4.0d-02\nce(4,11) = 2.0d-01\nce(4,12) = 1.0d-01\nce(4,13) = 3.0d-01\n\nce(5,1) = 5.0d+00\nce(5,2) = 4.0d+00\nce(5,3) = 3.0d+00\nce(5,4) = 2.0d+00\nce(5,5) = 1.0d-01\nce(5,6) = 4.0d-01\nce(5,7) = 3.0d-01\nce(5,8) = 5.0d-02\nce(5,9) = 4.0d-02\nce(5,10) = 3.0d-02\nce(5,11) = 1.0d-01\nce(5,12) = 3.0d-01\nce(5,13) = 2.0d-01\n\nreturn\nend
subroutine  initialize\n\n\n\nuse bt_data\nimplicit none\n\ninteger i, j, k, m, ix, iy, iz\ndouble precision  xi, eta, zeta, Pface(5,3,2), Pxi, Peta,   &\n&     Pzeta, temp(5)\n\n\ndo k = 0, grid_points(3)-1\ndo j = 0, grid_points(2)-1\ndo i = 0, grid_points(1)-1\ndo m = 1, 5\nu(m,i,j,k) = 1.0\nend do\nend do\nend do\nend do\n\n\n\ndo k = 0, grid_points(3)-1\ndo j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ndo i = 0, grid_points(1)-1\nxi = dble(i) * dnxm1\n\ndo ix = 1, 2\ncall exact_solution(dble(ix-1), eta, zeta,   &\n&                    Pface(1,1,ix))\nenddo\n\ndo iy = 1, 2\ncall exact_solution(xi, dble(iy-1) , zeta,   &\n&                    Pface(1,2,iy))\nenddo\n\ndo iz = 1, 2\ncall exact_solution(xi, eta, dble(iz-1),     &\n&                    Pface(1,3,iz))\nenddo\n\ndo m = 1, 5\nPxi   = xi   * Pface(m,1,2) +   &\n&                    (1.0d0-xi)   * Pface(m,1,1)\nPeta  = eta  * Pface(m,2,2) +   &\n&                    (1.0d0-eta)  * Pface(m,2,1)\nPzeta = zeta * Pface(m,3,2) +   &\n&                    (1.0d0-zeta) * Pface(m,3,1)\n\nu(m,i,j,k) = Pxi + Peta + Pzeta -   &\n&                    Pxi*Peta - Pxi*Pzeta - Peta*Pzeta +   &\n&                    Pxi*Peta*Pzeta\n\nenddo\nenddo\nenddo\nenddo\n\n\ni = 0\nxi = 0.0d0\ndo k = 0, grid_points(3)-1\ndo j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ncall exact_solution(xi, eta, zeta, temp)\ndo m = 1, 5\nu(m,i,j,k) = temp(m)\nenddo\nenddo\nenddo\n\n\ni = grid_points(1)-1\nxi = 1.0d0\ndo k = 0, grid_points(3)-1\ndo j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ncall exact_solution(xi, eta, zeta, temp)\ndo m = 1, 5\nu(m,i,j,k) = temp(m)\nenddo\nenddo\nenddo\n\nj = 0\neta = 0.0d0\ndo k = 0, grid_points(3)-1\ndo i = 0, grid_points(1)-1\nzeta = dble(k) * dnzm1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo m = 1, 5\nu(m,i,j,k) = temp(m)\nenddo\nenddo\nenddo\n\n\nj = grid_points(2)-1\neta = 1.0d0\ndo k = 0, grid_points(3)-1\ndo i = 0, grid_points(1)-1\nzeta = dble(k) * dnzm1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo m = 1, 5\nu(m,i,j,k) = temp(m)\nenddo\nenddo\nenddo\n\nk = 0\nzeta = 0.0d0\ndo j = 0, grid_points(2)-1\ndo i =0, grid_points(1)-1\neta = dble(j) * dnym1\nxi = dble(i) *dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo m = 1, 5\nu(m,i,j,k) = temp(m)\nenddo\nenddo\nenddo\n\nk = grid_points(3)-1\nzeta = 1.0d0\ndo j = 0, grid_points(2)-1\ndo i =0, grid_points(1)-1\neta = dble(j) * dnym1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, temp)\ndo m = 1, 5\nu(m,i,j,k) = temp(m)\nenddo\nenddo\nenddo\n\nreturn\nend
subroutine conj_grad ( rnorm )\n\n\nuse cg_data\nimplicit none\n\ninteger   j\ninteger   cgit, cgitmax\ninteger(kz) k\n\ndouble precision   d, sum, rho, rho0, alpha, beta, rnorm, suml\n\ndata      cgitmax / 25 /\n\n\nrho = 0.0d0\nsum = 0.0d0\n\n\ndo j=1,naa+1\nq(j) = 0.0d0\nz(j) = 0.0d0\nr(j) = x(j)\np(j) = r(j)\nenddo\n\n\ndo j=1, lastcol-firstcol+1\nrho = rho + r(j)*r(j)\nenddo\n\ndo cgit = 1, cgitmax\n\nrho0 = rho\nd = 0.d0\nrho = 0.d0\n\ndo j=1,lastrow-firstrow+1\nsuml = 0.d0\ndo k=rowstr(j),rowstr(j+1)-1\nsuml = suml + a(k)*p(colidx(k))\nenddo\nq(j) = suml\nenddo\n\n\n\n\ndo j=1, lastcol-firstcol+1\nd = d + p(j)*q(j)\nenddo\n\n\nalpha = rho0 / d\n\ndo j=1, lastcol-firstcol+1\nz(j) = z(j) + alpha*p(j)\nr(j) = r(j) - alpha*q(j)\n\nrho = rho + r(j)*r(j)\nenddo\n\nbeta = rho / rho0\n\ndo j=1, lastcol-firstcol+1\np(j) = r(j) + beta*p(j)\nenddo\n\n\nenddo                             ! end of do cgit=1,cgitmax\n\n\ndo j=1,lastrow-firstrow+1\nsuml = 0.d0\ndo k=rowstr(j),rowstr(j+1)-1\nsuml = suml + a(k)*z(colidx(k))\nenddo\nr(j) = suml\nenddo\n\n\ndo j=1, lastcol-firstcol+1\nsuml = x(j) - r(j)\nsum  = sum + suml*suml\nenddo\n\nrnorm = sqrt( sum )\n\n\n\nreturn\nend
subroutine sparse( a, colidx, rowstr, n, nz, nonzer, arow, acol,  &\n&                   aelt, firstrow, lastrow,  &\n&                   v, iv, nzloc, rcond, shift )\n\nuse tinfo\n\nimplicit           none\n\ninteger            colidx(*), iv(*)\ninteger            firstrow, lastrow\ninteger            n, nonzer, arow(*), acol(nonzer+1,*)\ninteger(kz)        nz, rowstr(*)\ndouble precision   a(*), aelt(nonzer+1,*), v(*), rcond, shift\n\ninteger            nzloc(n), nrows\n\n\ninteger            i, j, jcol\ninteger(kz)        j1, j2, nza, k, kk, nzrow\ndouble precision   xi, size, scale, ratio, va\n\nnrows = lastrow - firstrow + 1\nj1 = ilow + 1\nj2 = ihigh + 1\n\ndo j = j1, j2\nrowstr(j) = 0\nenddo\n\ndo i = 1, n\ndo nza = 1, arow(i)\nj = acol(nza, i)\nif (j.ge.ilow .and. j.le.ihigh) then\nj = j + 1\nrowstr(j) = rowstr(j) + arow(i)\nendif\nend do\nend do\n\nif (myid .eq. 0) then\nrowstr(1) = 1\nj1 = 1\nendif\ndo j = j1+1, j2\nrowstr(j) = rowstr(j) + rowstr(j-1)\nenddo\nif (myid .lt. num_threads) last_n(myid) = rowstr(j2)\n\nnzrow = 0\nif (myid .lt. num_threads) then\ndo i = 0, myid-1\nnzrow = nzrow + last_n(i)\nend do\nendif\nif (nzrow .gt. 0) then\ndo j = j1, j2\nrowstr(j) = rowstr(j) + nzrow\nenddo\nendif\nnza = rowstr(nrows+1) - 1\n\n\nif (nza .gt. nz) then\nwrite(*,*) 'Space for matrix elements exceeded in sparse'\nwrite(*,*) 'nza, nzmax = ',nza, nz\nstop\nendif\n\n\ndo j = ilow, ihigh\ndo k = rowstr(j), rowstr(j+1)-1\nv(k) = 0.d0\niv(k) = 0\nenddo\nnzloc(j) = 0\nenddo\n\n\nsize = 1.0D0\nratio = rcond ** (1.0D0 / dfloat(n))\n\ndo i = 1, n\ndo nza = 1, arow(i)\nj = acol(nza, i)\n\nif (j .lt. ilow .or. j .gt. ihigh) goto 60\n\nscale = size * aelt(nza, i)\ndo nzrow = 1, arow(i)\njcol = acol(nzrow, i)\nva = aelt(nzrow, i) * scale\n\nif (jcol .eq. j .and. j .eq. i) then\nva = va + rcond - shift\nendif\n\ndo k = rowstr(j), rowstr(j+1)-1\nif (iv(k) .gt. jcol) then\ndo kk = rowstr(j+1)-2, k, -1\nif (iv(kk) .gt. 0) then\nv(kk+1)  = v(kk)\niv(kk+1) = iv(kk)\nendif\nenddo\niv(k) = jcol\nv(k)  = 0.d0\ngoto 40\nelse if (iv(k) .eq. 0) then\niv(k) = jcol\ngoto 40\nelse if (iv(k) .eq. jcol) then\nnzloc(j) = nzloc(j) + 1\ngoto 40\nendif\nenddo\nprint *,'internal error in sparse: i=',i\nstop\n40          continue\nv(k) = v(k) + va\nenddo\n60       continue\nenddo\nsize = size * ratio\nenddo\n\n\ndo j = ilow+1, ihigh\nnzloc(j) = nzloc(j) + nzloc(j-1)\nenddo\nif (myid .lt. num_threads) last_n(myid) = nzloc(ihigh)\n\nnzrow = 0\nif (myid .lt. num_threads) then\ndo i = 0, myid-1\nnzrow = nzrow + last_n(i)\nend do\nendif\nif (nzrow .gt. 0) then\ndo j = ilow, ihigh\nnzloc(j) = nzloc(j) + nzrow\nenddo\nendif\n\ndo j = 1, nrows\nif (j .gt. 1) then\nj1 = rowstr(j) - nzloc(j-1)\nelse\nj1 = 1\nendif\nj2 = rowstr(j+1) - nzloc(j) - 1\nnza = rowstr(j)\ndo k = j1, j2\na(k) = v(nza)\ncolidx(k) = iv(nza)\nnza = nza + 1\nenddo\nenddo\ndo j = 2, nrows+1\nrowstr(j) = rowstr(j) - nzloc(j-1)\nenddo\nnza = rowstr(nrows+1) - 1\n\n\nreturn\n11000   format ( //,'final nonzero count in sparse ',  &\n&            /,'number of nonzeros       = ', i16 )\nend
subroutine exact_solution(xi,eta,zeta,dtemp)\n\n\n\nuse bt_data\nimplicit none\n\ndouble precision  xi, eta, zeta, dtemp(5)\ninteger m\n\ndo m = 1, 5\ndtemp(m) =  ce(m,1) +  &\n&     xi*(ce(m,2) + xi*(ce(m,5) + xi*(ce(m,8) + xi*ce(m,11)))) +  &\n&     eta*(ce(m,3) + eta*(ce(m,6) + eta*(ce(m,9) + eta*ce(m,12))))+  &\n&     zeta*(ce(m,4) + zeta*(ce(m,7) + zeta*(ce(m,10) +   &\n&     zeta*ce(m,13))))\nenddo\n\nreturn\nend
subroutine exact( i, j, k, u000ijk )\n\n\n\nuse lu_data\nimplicit none\n\ninteger i, j, k\ndouble precision u000ijk(*)\n\ninteger m\ndouble precision xi, eta, zeta\n\nxi  = ( dble ( i - 1 ) ) / ( nx0 - 1 )\neta  = ( dble ( j - 1 ) ) / ( ny0 - 1 )\nzeta = ( dble ( k - 1 ) ) / ( nz - 1 )\n\n\ndo m = 1, 5\nu000ijk(m) =  ce(m,1)  &\n&        + (ce(m,2)  &\n&        + (ce(m,5)  &\n&        + (ce(m,8)  &\n&        +  ce(m,11) * xi) * xi) * xi) * xi  &\n&        + (ce(m,3)  &\n&        + (ce(m,6)  &\n&        + (ce(m,9)  &\n&        +  ce(m,12) * eta) * eta) * eta) * eta  &\n&        + (ce(m,4)  &\n&        + (ce(m,7)  &\n&        + (ce(m,10)  &\n&        +  ce(m,13) * zeta) * zeta) * zeta) * zeta\nend do\n\nreturn\nend
subroutine cfftz (is, m, n, x, y)\n\n\n\nuse ft_data\nimplicit none\n\ninteger is,m,n,i,j,l,mx\ndouble complex x, y\n\ndimension x(fftblockpad,n), y(fftblockpad,n)\n\nmx = u(1)\nif ((is .ne. 1 .and. is .ne. -1) .or. m .lt. 1 .or. m .gt. mx)    &\n&  then\nwrite (*, 1)  is, m, mx\n1      format ('CFFTZ: Either U has not been initialized, or else'/    &\n&    'one of the input parameters is invalid', 3I5)\nstop\nendif\n\ndo l = 1, m, 2\ncall fftz2 (is, l, m, n, fftblock, fftblockpad, u, x, y)\nif (l .eq. m) goto 160\ncall fftz2 (is, l + 1, m, n, fftblock, fftblockpad, u, y, x)\nenddo\n\ngoto 180\n\n160  do j = 1, n\ndo i = 1, fftblock\nx(i,j) = y(i,j)\nenddo\nenddo\n\n180  continue\n\nreturn\nend
subroutine ipow46(a, exponent, result)\n\n\n\nimplicit none\ndouble precision a, result, dummy, q, r\ninteger exponent, n, n2\nexternal randlc\ndouble precision randlc\nresult = 1\nif (exponent .eq. 0) return\nq = a\nr = 1\nn = exponent\n\n\ndo while (n .gt. 1)\nn2 = n/2\nif (n2 * 2 .eq. n) then\ndummy = randlc(q, q)\nn = n2\nelse\ndummy = randlc(r, q)\nn = n-1\nendif\nend do\ndummy = randlc(r, q)\nresult = r\nreturn\nend
subroutine  adi\n\n\ncall compute_rhs\n\ncall txinvr\n\ncall x_solve\n\ncall y_solve\n\ncall z_solve\n\ncall add\n\nreturn\nend
subroutine sprnvc( n, nz, nn1, v, iv )\n\nuse cg_data, only : amult, tran\n\nimplicit           none\n\ndouble precision   v(*)\ninteger            n, nz, nn1, iv(*)\n\n\n\ninteger            nzv, ii, i, icnvrt\n\nexternal           randlc, icnvrt\ndouble precision   randlc, vecelt, vecloc\n\n\nnzv = 0\n\n100     continue\nif (nzv .ge. nz) goto 110\n\nvecelt = randlc( tran, amult )\n\nvecloc = randlc(tran, amult)\ni = icnvrt(vecloc, nn1) + 1\nif (i .gt. n) goto 100\n\ndo ii = 1, nzv\nif (iv(ii) .eq. i) goto 100\nenddo\nnzv = nzv + 1\nv(nzv) = vecelt\niv(nzv) = i\ngoto 100\n110     continue\n\nreturn\nend
subroutine ssor(niter)\n\n\n\nuse lu_data\nimplicit none\n\ninteger niter\n\ninteger i, j, k, m, n\ninteger istep\ndouble precision  tmp, tmp2\ndouble precision  delunm(5)\n\nexternal timer_read\ndouble precision timer_read\n\n\ntmp = 1.0d+00 / ( omega * ( 2.0d+00 - omega ) )\n\ndo i = 1, t_last\ncall timer_clear(i)\nend do\n\ncall rhs\n\ncall l2norm( isiz1, isiz2, isiz3, nx0, ny0, nz0,  &\n&             ist, iend, jst, jend,  &\n&             rsd, rsdnm )\n\n\ndo i = 1, t_last\ncall timer_clear(i)\nend do\ncall timer_start(1)\n\ndo istep = 1, niter\n\nif (mod ( istep, 20) .eq. 0 .or.  &\n&         istep .eq. itmax .or.  &\n&         istep .eq. 1) then\nif (niter .gt. 1) write( *, 200) istep\n200        format(' Time step ', i4)\nendif\n\nif (timeron) call timer_start(t_rhs)\ntmp2 = dt\ndo k = 2, nz - 1\ndo j = jst, jend\ndo i = ist, iend\ndo m = 1, 5\nrsd(m,i,j,k) = tmp2 * rsd(m,i,j,k)\nend do\nend do\nend do\nend do\nif (timeron) call timer_stop(t_rhs)\n\nif (timeron) call timer_start(t_blts)\ndo k = 2, nz -1\ndo j = jst, jend\n\ncall jacld(j, k)\n\ncall blts( isiz1, isiz2, isiz3,  &\n&                    nx, ny, nz,  &\n&                    omega,  &\n&                    rsd,  &\n&                    a, b, c, d,  &\n&                    ist, iend, j, k )\n\nend do\nend do\nif (timeron) call timer_stop(t_blts)\n\nif (timeron) call timer_start(t_buts)\ndo k = nz - 1, 2, -1\ndo j = jend, jst, -1\n\ncall jacu(j, k)\n\ncall buts( isiz1, isiz2, isiz3,  &\n&                    nx, ny, nz,  &\n&                    omega,  &\n&                    rsd,  &\n&                    d, a, b, c,  &\n&                    ist, iend, j, k )\n\nend do\nend do\nif (timeron) call timer_stop(t_buts)\n\n\nif (timeron) call timer_start(t_add)\ntmp2 = tmp\ndo k = 2, nz-1\ndo j = jst, jend\ndo i = ist, iend\ndo m = 1, 5\nu( m, i, j, k ) = u( m, i, j, k )  &\n&                    + tmp2 * rsd( m, i, j, k )\nend do\nend do\nend do\nend do\nif (timeron) call timer_stop(t_add)\n\nif ( mod ( istep, inorm ) .eq. 0 ) then\nif (timeron) call timer_start(t_l2norm)\ncall l2norm( isiz1, isiz2, isiz3, nx0, ny0, nz0,  &\n&                   ist, iend, jst, jend,  &\n&                   rsd, delunm )\nif (timeron) call timer_stop(t_l2norm)\nend if\n\ncall rhs\n\nif ( ( mod ( istep, inorm ) .eq. 0 ) .or.  &\n&        ( istep .eq. itmax ) ) then\nif (timeron) call timer_start(t_l2norm)\ncall l2norm( isiz1, isiz2, isiz3, nx0, ny0, nz0,  &\n&                   ist, iend, jst, jend,  &\n&                   rsd, rsdnm )\nif (timeron) call timer_stop(t_l2norm)\nend if\n\nif ( ( rsdnm(1) .lt. tolrsd(1) ) .and.  &\n&        ( rsdnm(2) .lt. tolrsd(2) ) .and.  &\n&        ( rsdnm(3) .lt. tolrsd(3) ) .and.  &\n&        ( rsdnm(4) .lt. tolrsd(4) ) .and.  &\n&        ( rsdnm(5) .lt. tolrsd(5) ) ) then\nwrite (*,1004) istep\ngo to 900\nend if\n\nend do\n900 continue\n\ncall timer_stop(1)\nmaxtime= timer_read(1)\n\n\n\nreturn\n\n1001 format (1x/5x,'pseudo-time SSOR iteration no.=',i4/)\n1004 format (1x/1x,'convergence was achieved after ',i4,  &\n&   ' pseudo-time steps' )\n1006 format (1x/1x,'RMS-norm of SSOR-iteration correction ',  &\n& 'for first pde  = ',1pe12.5/,  &\n& 1x,'RMS-norm of SSOR-iteration correction ',  &\n& 'for second pde = ',1pe12.5/,  &\n& 1x,'RMS-norm of SSOR-iteration correction ',  &\n& 'for third pde  = ',1pe12.5/,  &\n& 1x,'RMS-norm of SSOR-iteration correction ',  &\n& 'for fourth pde = ',1pe12.5/,  &\n& 1x,'RMS-norm of SSOR-iteration correction ',  &\n& 'for fifth pde  = ',1pe12.5)\n1007 format (1x/1x,'RMS-norm of steady-state residual for ',  &\n& 'first pde  = ',1pe12.5/,  &\n& 1x,'RMS-norm of steady-state residual for ',  &\n& 'second pde = ',1pe12.5/,  &\n& 1x,'RMS-norm of steady-state residual for ',  &\n& 'third pde  = ',1pe12.5/,  &\n& 1x,'RMS-norm of steady-state residual for ',  &\n& 'fourth pde = ',1pe12.5/,  &\n& 1x,'RMS-norm of steady-state residual for ',  &\n& 'fifth pde  = ',1pe12.5)\n\nend
subroutine comm3(u,n1,n2,n3,kk)\n\n\n\nuse mg_data\nimplicit none\n\ninteger n1, n2, n3, kk\ndouble precision u(n1,n2,n3)\ninteger i1, i2, i3\n\nif (timeron) call timer_start(T_comm3)\ndo  i3=2,n3-1\ndo  i2=2,n2-1\nu( 1,i2,i3) = u(n1-1,i2,i3)\nu(n1,i2,i3) = u(   2,i2,i3)\nenddo\n\ndo  i1=1,n1\nu(i1, 1,i3) = u(i1,n2-1,i3)\nu(i1,n2,i3) = u(i1,   2,i3)\nenddo\nenddo\n\ndo  i2=1,n2\ndo  i1=1,n1\nu(i1,i2, 1) = u(i1,i2,n3-1)\nu(i1,i2,n3) = u(i1,i2,   2)\nenddo\nenddo\nif (timeron) call timer_stop(T_comm3)\n\nreturn\nend
subroutine exact_solution(xi,eta,zeta,dtemp)\n\n\n\nuse sp_data\nimplicit none\n\ndouble precision  xi, eta, zeta\ndouble precision  dtemp(5)\ninteger m\n\ndo  m = 1, 5\ndtemp(m) =  ce(m,1) +  &\n&    xi*(ce(m,2) + xi*(ce(m,5) + xi*(ce(m,8) + xi*ce(m,11)))) +  &\n&    eta*(ce(m,3) + eta*(ce(m,6) + eta*(ce(m,9) + eta*ce(m,12))))+  &\n&    zeta*(ce(m,4) + zeta*(ce(m,7) + zeta*(ce(m,10) +  &\n&    zeta*ce(m,13))))\nend do\n\nreturn\nend
subroutine compute_initial_conditions(u0, d1, d2, d3)\n\n\n\nuse ft_data\nimplicit none\n\ninteger d1, d2, d3\ndouble complex u0(d1+1, d2, d3)\ninteger k, j\ndouble precision x0, start, an, dummy, starts(nz)\n\n\nstart = seed\ncall ipow46(a, 0, an)\ndummy = randlc(start, an)\ncall ipow46(a, 2*nx*ny, an)\n\nstarts(1) = start\ndo k = 2, dims(3)\ndummy = randlc(start, an)\nstarts(k) = start\nend do\n\ndo k = 1, dims(3)\nx0 = starts(k)\ndo j = 1, dims(2)\ncall vranlc(2*nx, x0, a, u0(1, j, k))\nend do\nend do\n\nreturn\nend
subroutine setiv\n\n\n\nuse lu_data\nimplicit none\n\ninteger i, j, k, m\ndouble precision  xi, eta, zeta\ndouble precision  pxi, peta, pzeta\ndouble precision  ue_1jk(5),ue_nx0jk(5),ue_i1k(5),  &\n&        ue_iny0k(5),ue_ij1(5),ue_ijnz(5)\n\n\ndo k = 2, nz - 1\ndo j = 2, ny - 1\nzeta = ( dble (k-1) ) / (nz-1)\neta = ( dble (j-1) ) / (ny0-1)\ndo i = 2, nx - 1\nxi = ( dble (i-1) ) / (nx0-1)\ncall exact (1,j,k,ue_1jk)\ncall exact (nx0,j,k,ue_nx0jk)\ncall exact (i,1,k,ue_i1k)\ncall exact (i,ny0,k,ue_iny0k)\ncall exact (i,j,1,ue_ij1)\ncall exact (i,j,nz,ue_ijnz)\ndo m = 1, 5\npxi =   ( 1.0d+00 - xi ) * ue_1jk(m)  &\n&                              + xi   * ue_nx0jk(m)\npeta =  ( 1.0d+00 - eta ) * ue_i1k(m)  &\n&                              + eta   * ue_iny0k(m)\npzeta = ( 1.0d+00 - zeta ) * ue_ij1(m)  &\n&                              + zeta   * ue_ijnz(m)\n\nu( m, i, j, k ) = pxi + peta + pzeta  &\n&                 - pxi * peta - peta * pzeta - pzeta * pxi  &\n&                 + pxi * peta * pzeta\n\nend do\nend do\nend do\nend do\n\nreturn\nend
subroutine  add\n\n\n\nuse bt_data\nimplicit none\n\ninteger i, j, k, m\n\nif (timeron) call timer_start(t_add)\ndo     k = 1, grid_points(3)-2\ndo     j = 1, grid_points(2)-2\ndo     i = 1, grid_points(1)-2\ndo    m = 1, 5\nu(m,i,j,k) = u(m,i,j,k) + rhs(m,i,j,k)\nenddo\nenddo\nenddo\nenddo\nif (timeron) call timer_stop(t_add)\n\nreturn\nend
subroutine  txinvr\n\n\n\nuse sp_data\nimplicit none\n\ninteger i, j, k\ndouble precision t1, t2, t3, ac, ru1, uu, vv, ww, r1, r2, r3,  &\n&                  r4, r5, ac2inv\n\n\nif (timeron) call timer_start(t_txinvr)\ndo    k = 1, nz2\ndo    j = 1, ny2\ndo    i = 1, nx2\n\nru1 = rho_i(i,j,k)\nuu = us(i,j,k)\nvv = vs(i,j,k)\nww = ws(i,j,k)\nac = speed(i,j,k)\nac2inv = ac*ac\n\nr1 = rhs(1,i,j,k)\nr2 = rhs(2,i,j,k)\nr3 = rhs(3,i,j,k)\nr4 = rhs(4,i,j,k)\nr5 = rhs(5,i,j,k)\n\nt1 = c2 / ac2inv * ( qs(i,j,k)*r1 - uu*r2  -  &\n&                  vv*r3 - ww*r4 + r5 )\nt2 = bt * ru1 * ( uu * r1 - r2 )\nt3 = ( bt * ru1 * ac ) * t1\n\nrhs(1,i,j,k) = r1 - t1\nrhs(2,i,j,k) = - ru1 * ( ww*r1 - r4 )\nrhs(3,i,j,k) =   ru1 * ( vv*r1 - r3 )\nrhs(4,i,j,k) = - t2 + t3\nrhs(5,i,j,k) =   t2 + t3\n\nend do\nend do\nend do\nif (timeron) call timer_stop(t_txinvr)\n\nreturn\nend
subroutine cffts2(is, d1, d2, d3, x, xout, y1, y2)\n\n\nuse ft_data\nimplicit none\n\ninteger is, d1, d2, d3, logd2\ndouble complex x(d1+1,d2,d3)\ndouble complex xout(d1+1,d2,d3)\ndouble complex y1(fftblockpad, d2), y2(fftblockpad, d2)\ninteger i, j, k, ii, in\n\nlogd2 = ilog2(d2)\n\nif (timers_enabled) call timer_start(T_ffty)\ndo k = 1, d3\ndo in = 0, d1/fftblock - 1\nii = in*fftblock\ndo j = 1, d2\ndo i = 1, fftblock\ny1(i,j) = x(i+ii,j,k)\nenddo\nenddo\n\ncall cfftz (is, logd2, d2, y1, y2)\n\ndo j = 1, d2\ndo i = 1, fftblock\nxout(i+ii,j,k) = y1(i,j)\nenddo\nenddo\nenddo\nenddo\nif (timers_enabled) call timer_stop(T_ffty)\n\nreturn\nend
subroutine setbv\n\n\n\nuse lu_data\nimplicit none\n\ninteger i, j, k, m\ndouble precision temp1(5), temp2(5)\n\ndo j = 1, ny\ndo i = 1, nx\ncall exact( i, j, 1, temp1 )\ncall exact( i, j, nz, temp2 )\ndo m = 1, 5\nu( m, i, j, 1 ) = temp1(m)\nu( m, i, j, nz ) = temp2(m)\nend do\nend do\nend do\n\ndo k = 1, nz\ndo i = 1, nx\ncall exact( i, 1, k, temp1 )\ncall exact( i, ny, k, temp2 )\ndo m = 1, 5\nu( m, i, 1, k ) = temp1(m)\nu( m, i, ny, k ) = temp2(m)\nend do\nend do\nend do\n\ndo k = 1, nz\ndo j = 1, ny\ncall exact( 1, j, k, temp1 )\ncall exact( nx, j, k, temp2 )\ndo m = 1, 5\nu( m, 1, j, k ) = temp1(m)\nu( m, nx, j, k ) = temp2(m)\nend do\nend do\nend do\n\nreturn\nend
subroutine  adi\n\n\ncall compute_rhs\n\ncall x_solve\n\ncall y_solve\n\ncall z_solve\n\ncall add\n\nreturn\nend
subroutine vecset(n, v, iv, nzv, i, val)\n\nimplicit           none\n\ninteger            n, iv(*), nzv, i, k\ndouble precision   v(*), val\n\n\nlogical set\n\nset = .false.\ndo k = 1, nzv\nif (iv(k) .eq. i) then\nv(k) = val\nset  = .true.\nendif\nenddo\nif (.not. set) then\nnzv     = nzv + 1\nv(nzv)  = val\niv(nzv) = i\nendif\nreturn\nend
subroutine error_norm(rms)\n\n\n\nuse bt_data\nimplicit none\n\ninteger i, j, k, m, d\ndouble precision xi, eta, zeta, u_exact(5), rms(5), add\n\ndo m = 1, 5\nrms(m) = 0.0d0\nenddo\n\ndo k = 0, grid_points(3)-1\ndo j = 0, grid_points(2)-1\nzeta = dble(k) * dnzm1\neta = dble(j) * dnym1\ndo i = 0, grid_points(1)-1\nxi = dble(i) * dnxm1\ncall exact_solution(xi, eta, zeta, u_exact)\n\ndo m = 1, 5\nadd = u(m,i,j,k)-u_exact(m)\nrms(m) = rms(m) + add*add\nenddo\nenddo\nenddo\nenddo\n\ndo m = 1, 5\ndo d = 1, 3\nrms(m) = rms(m) / dble(grid_points(d)-2)\nenddo\nrms(m) = dsqrt(rms(m))\nenddo\n\nreturn\nend\n\n\n\nsubroutine rhs_norm(rms)\n\n\nuse bt_data\nimplicit none\n\ninteger i, j, k, d, m\ndouble precision rms(5), add\n\ndo m = 1, 5\nrms(m) = 0.0d0\nenddo\n\ndo k = 1, grid_points(3)-2\ndo j = 1, grid_points(2)-2\ndo i = 1, grid_points(1)-2\ndo m = 1, 5\nadd = rhs(m,i,j,k)\nrms(m) = rms(m) + add*add\nenddo\nenddo\nenddo\nenddo\n\ndo m = 1, 5\ndo d = 1, 3\nrms(m) = rms(m) / dble(grid_points(d)-2)\nenddo\nrms(m) = dsqrt(rms(m))\nenddo\n\nreturn\nend
subroutine bubble( ten, j1, j2, j3, m, ind )\n\n\nimplicit none\n\n\ninteger m, ind, j1( m, 0:1 ), j2( m, 0:1 ), j3( m, 0:1 )\ndouble precision ten( m, 0:1 )\ndouble precision temp\ninteger i, j_temp\n\nif( ind .eq. 1 )then\n\ndo  i=1,m-1\nif( ten(i,ind) .gt. ten(i+1,ind) )then\n\ntemp = ten( i+1, ind )\nten( i+1, ind ) = ten( i, ind )\nten( i, ind ) = temp\n\nj_temp           = j1( i+1, ind )\nj1( i+1, ind ) = j1( i,   ind )\nj1( i,   ind ) = j_temp\n\nj_temp           = j2( i+1, ind )\nj2( i+1, ind ) = j2( i,   ind )\nj2( i,   ind ) = j_temp\n\nj_temp           = j3( i+1, ind )\nj3( i+1, ind ) = j3( i,   ind )\nj3( i,   ind ) = j_temp\n\nelse\nreturn\nendif\nenddo\n\nelse\n\ndo  i=1,m-1\nif( ten(i,ind) .lt. ten(i+1,ind) )then\n\ntemp = ten( i+1, ind )\nten( i+1, ind ) = ten( i, ind )\nten( i, ind ) = temp\n\nj_temp           = j1( i+1, ind )\nj1( i+1, ind ) = j1( i,   ind )\nj1( i,   ind ) = j_temp\n\nj_temp           = j2( i+1, ind )\nj2( i+1, ind ) = j2( i,   ind )\nj2( i,   ind ) = j_temp\n\nj_temp           = j3( i+1, ind )\nj3( i+1, ind ) = j3( i,   ind )\nj3( i,   ind ) = j_temp\n\nelse\nreturn\nendif\nenddo\n\nendif\n\nreturn\nend
subroutine showall(z,n1,n2,n3)\n\n\nimplicit none\n\n\ninteger n1,n2,n3,i1,i2,i3\ndouble precision z(n1,n2,n3)\ninteger m1, m2, m3\n\nm1 = min(n1,18)\nm2 = min(n2,14)\nm3 = min(n3,18)\n\nwrite(*,*)'  '\ndo  i3=1,m3\ndo  i1=1,m1\nwrite(*,6)(z(i1,i2,i3),i2=1,m2)\nenddo\nwrite(*,*)' - - - - - - - '\nenddo\nwrite(*,*)'  '\n6    format(15f6.3)\n\nreturn\nend
subroutine init_array(n, x, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: x\nDATA_TYPE, dimension(n, n) :: b\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n\ndo j = 1, n\nx(j, i) = (DBLE((i - 1) * (j)) + 1.0D0) / DBLE(n)\na(j, i) = (DBLE((i - 1) * (j + 1)) + 2.0D0) / DBLE(n)\nb(j, i) = (DBLE((i - 1) * (j + 2)) + 3.0D0) / DBLE(n)\nend do\nend do\nend subroutine
subroutine print_array(d, ni, nl)\nimplicit none\n\nDATA_TYPE, dimension(nl, ni) :: d\ninteger :: nl, ni\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, nl\nwrite(0, DATA_PRINTF_MODIFIER) d(j,i)\n\nif (mod(((i - 1) * ni) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\n\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_durbin(n, y, sumArray, alpha, beta, r,  &\noutArray)\nimplicit none\nDATA_TYPE, dimension(n, n) :: y\nDATA_TYPE, dimension(n, n) :: sumArray\nDATA_TYPE, dimension(n) :: beta\nDATA_TYPE, dimension(n) :: alpha\nDATA_TYPE, dimension(n) :: r\nDATA_TYPE, dimension(n) :: outArray\ninteger :: i, k, n\n\n!$pragma scop\ny(1, 1) = r(1)\nbeta(1) = 1\nalpha(1) = r(1)\ndo k = 2, _PB_N\nbeta(k) = beta(k - 1) - (alpha(k - 1) * alpha(k - 1) * &\nbeta(k -1))\nsumArray(k, 1) = r(k)\ndo i = 1, k - 1\nsumArray(k, i + 1) = sumArray(k, i) + &\n(r(k - i) * y(k - 1, i))\nend do\nalpha(k) = alpha(k) - (sumArray(k, k) * beta(k))\ndo i = 1, k - 1\ny(k, i) = y(k - 1, i) + (alpha(k) * y(k - 1, k - i))\nend do\ny(k, k) = alpha(k)\nend do\n\ndo i = 1, _PB_N\noutArray(i) = y(_PB_N, i)\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i,j\ndo i = 1, n\ndo j = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) a(j, i)\nif (mod((i - 1) * n + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(ni, nj, alpha, beta, c, a)\nimplicit none\n\nDATA_TYPE, dimension(ni, ni) :: a\nDATA_TYPE, dimension(nj, ni) :: c\nDATA_TYPE :: alpha , beta\ninteger :: nj, ni\ninteger :: i, j\n\nalpha = 32412\nbeta = 2123\n\ndo i = 1, ni\ndo j = 1, nj\na(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / DBLE(ni)\nend do\ndo j = 1, ni\nc(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(ni)\nend do\nend do\nend subroutine
subroutine init_array(ni, nj, a, r, q)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: a\nDATA_TYPE, dimension(nj, nj) :: r\nDATA_TYPE, dimension(nj, ni) :: q\ninteger :: ni, nj\ninteger :: i, j\n\ndo i = 1, ni\ndo j = 1, nj\na(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / DBLE(ni)\nq(j, i) = (DBLE(i - 1) * DBLE(j)) / DBLE(nj)\nend do\nend do\n\ndo i = 1, ni\ndo j = 1, nj\nr(j, i) = (DBLE(i - 1) * DBLE(j + 1)) / DBLE(nj)\nend do\nend do\nend subroutine
subroutine init_array(m, n, float_n, dat)\nimplicit none\n\nDATA_TYPE, dimension(N, M) :: dat\nDATA_TYPE :: float_n\ninteger :: m, n\ninteger :: i, j\n\nfloat_n = 1.2D0\ndo i = 1, m\ndo j = 1, n\ndat(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / DBLE(m)\nend do\nend do\nend subroutine
subroutine init_array(m, n, float_n, dat)\nimplicit none\n\nDATA_TYPE, dimension(n, m) :: dat\nDATA_TYPE :: float_n\ninteger :: m, n\ninteger :: i, j\n\nfloat_n = 1.2D0\ndo i = 1, m\ndo j = 1, n\ndat(j, i) = (DBLE((i - 1) * (j - 1))) / DBLE(m)\nend do\nend do\nend subroutine
subroutine print_array(m, symmat)\nimplicit none\n\nDATA_TYPE, dimension(m, m) :: symmat\ninteger :: m\ninteger :: i, j\ndo i = 1, m\ndo j = 1, m\nwrite(0, DATA_PRINTF_MODIFIER) symmat(j, i)\nif (mod(((i - 1) * m) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_doitgen(nr, nq, np , &\na, cFour, sumA)\nimplicit none\n\nDATA_TYPE, dimension(np, nq, nr) :: a\nDATA_TYPE, dimension(np, nq, nr) :: sumA\nDATA_TYPE, dimension(np, np) :: cFour\ninteger :: nr, nq, np\ninteger :: r, s, p, q\n\n!$pragma scop\ndo r = 1, _PB_NR\ndo q = 1, _PB_NQ\ndo p = 1, _PB_NP\nsumA(p, q, r) = 0.0D0\ndo s = 1, _PB_NP\nsumA(p, q, r) = sumA(p, q, r) + (a(s, q, r) * &\ncFour(p, s))\nend do\nend do\ndo p = 1, _PB_NP\na(p, q, r) = sumA(p, q, r)\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine kernel_trisolv(n , a, x, c)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: c\nDATA_TYPE, dimension(n) :: x\ninteger :: n\ninteger :: i, j\n\n!$pragma scop\ndo i = 1, _PB_N\nx(i) = c(i)\ndo j = 1, i - 1\nx(i) = x(i) - (a(j, i) * x(j))\nend do\nx(i) = x(i) / a(i, i)\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, alpha, beta, a, b, x)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: b\nDATA_TYPE, dimension(n) :: x\nDATA_TYPE :: alpha, beta\ninteger :: n\ninteger :: i, j\n\nalpha = 43532.0D0\nbeta = 12313.0D0\n\ndo i = 1, n\nx(i) = DBLE(i - 1) / DBLE(n)\ndo j = 1, n\na(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(n)\nb(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(n)\nend do\nend do\nend subroutine
subroutine print_array(ni, c)\nimplicit none\n\nDATA_TYPE, dimension(ni, ni) :: c\ninteger :: ni\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, ni\nwrite(0, DATA_PRINTF_MODIFIER) c(j, i)\nif (mod(((i - 1) * ni) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_syrk(ni, nj, alpha, beta, c, a)\nimplicit none\n\nDATA_TYPE, dimension(ni, ni) :: a\nDATA_TYPE, dimension(nj, ni) :: c\nDATA_TYPE :: alpha , beta\ninteger :: nj, ni\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 1, _PB_NI\ndo j = 1, _PB_NI\nc(j, i) = c(j, i) * beta\nend do\nend do\ndo i = 1, _PB_NI\ndo j = 1, _PB_NI\ndo k = 1, _PB_NJ\nc(j, i) = c(j, i) + (alpha * a(k, i) * a(k, j))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, x1, x2, y1, y2, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: x1\nDATA_TYPE, dimension(n) :: y1\nDATA_TYPE, dimension(n) :: x2\nDATA_TYPE, dimension(n) :: y2\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n\nx1(i) = DBLE(i - 1) / DBLE(n)\nx2(i) = (DBLE(i - 1) + 1.0D0) / DBLE(n)\ny1(i) = (DBLE(i - 1) + 3.0D0) / DBLE(n)\ny2(i) = (DBLE(i - 1) + 4.0D0) / DBLE(n)\ndo j = 1, n\na(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(n)\nend do\nend do\nend subroutine
subroutine kernel_fdtd_apml(cz, cxm, cym, mui, ch, &\nax, ry, clf, tmp, bza, ex, ey, &\nhz, czm, czp, cxmh, cxph, cymh, cyph)\nimplicit none\ninteger :: cz, cym, cxm\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: ex\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: ey\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: hz\nDATA_TYPE, dimension(cym + 1, cz + 1) :: clf\nDATA_TYPE, dimension(cym + 1, cz + 1) :: ry\nDATA_TYPE, dimension(cym + 1, cz + 1) :: ax\nDATA_TYPE, dimension(cym + 1) :: cymh\nDATA_TYPE, dimension(cym + 1) :: cyph\nDATA_TYPE, dimension(cxm + 1) :: cxmh\nDATA_TYPE, dimension(cxm + 1) :: cxph\nDATA_TYPE, dimension(cz + 1) :: czm\nDATA_TYPE, dimension(cz + 1) :: czp\nDATA_TYPE, dimension(cxm + 1, cym + 1) :: tmp\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: bza\nDATA_TYPE :: mui, ch\ninteger :: ix, iy, iz\n\n!$pragma scop\ndo iz = 1, _PB_CZ\ndo iy = 1, _PB_CYM\ndo ix = 1, _PB_CXM\nclf(iy, iz) = ex(ix, iy, iz) - ex(ix, iy + 1, iz) + &\ney(ix + 1, iy, iz) - ey(ix, iy, iz)\ntmp(iy, iz) = ((cymh(iy) / cyph(iy)) * bza(ix, iy, iz)) - &\n((ch / cyph(iy)) * clf(iy, iz))\nhz(ix, iy, iz) = ((cxmh(ix) / cxph(ix)) * hz(ix, iy, iz)) &\n+ ((mui * czp(iz) / cxph(ix)) * tmp(iy, iz)) &\n- ((mui * czm(iz) / cxph(ix)) * &\nbza(ix, iy, iz))\nbza(ix, iy, iz) = tmp(iy, iz)\nend do\nclf(iy, iz) = ex(_PB_CXM + 1, iy, iz) - &\nex(_PB_CXM + 1, iy + 1, iz) + &\nry(iy, iz) - ey(_PB_CXM + 1, iy, iz)\ntmp(iy, iz) = ((cymh(iy) / cyph(iy)) * &\nbza(_PB_CXM + 1, iy, iz)) - ((ch / cyph(iy))  &\n* clf(iy, iz))\nhz(_PB_CXM + 1, iy, iz) = ((cxmh(_PB_CXM + 1) / &\ncxph(_PB_CXM + 1)) * &\nhz(_PB_CXM + 1, iy, iz)) + &\n((mui * czp(iz) / &\ncxph(_PB_CXM + 1)) * &\ntmp(iy, iz)) - &\n((mui * czm(iz) / &\ncxph(_PB_CXM + 1)) * &\nbza(_PB_CXM + 1, iy, iz))\nbza(_PB_CXM + 1, iy, iz) = tmp(iy, iz)\n\ndo ix = 1, _PB_CXM\nclf(iy, iz) = ex(ix, _PB_CYM + 1, iz) - ax(ix, iz) + &\ney(ix + 1, _PB_CYM + 1, iz) - &\ney(ix, _PB_CYM + 1, iz)\ntmp(iy, iz) = ((cymh(_PB_CYM + 1) / cyph(iy)) * &\nbza(ix, iy, iz)) - ((ch / cyph(iy)) * &\nclf(iy, iz))\nhz(ix, _PB_CYM + 1, iz) = ((cxmh(ix) / cxph(ix)) * &\nhz(ix, _PB_CYM + 1, iz)) + &\n((mui * czp(iz) / cxph(ix)) * &\ntmp(iy, iz)) - &\n((mui * czm(iz) / cxph(ix)) * &\nbza(ix, _PB_CYM + 1, iz))\nbza(ix, _PB_CYM + 1, iz) = tmp(iy, iz)\nend do\nclf(iy, iz) = ex(_PB_CXM + 1, _PB_CYM + 1, iz) - &\nax(_PB_CXM + 1, iz) + ry(_PB_CYM + 1, iz) - &\ney(_PB_CXM + 1, _PB_CYM + 1, iz)\ntmp(iy, iz) = ((cymh(_PB_CYM + 1) / cyph(_PB_CYM + 1)) * &\nbza(_PB_CXM + 1, _PB_CYM + 1, iz)) - &\n((ch / cyph(_PB_CYM + 1)) * clf(iy, iz))\nhz(_PB_CXM + 1, _PB_CYM + 1, iz) = &\n((cxmh(_PB_CXM + 1) / cxph(_PB_CXM + 1)) * &\nhz(_PB_CXM + 1, _PB_CYM + 1, iz)) + &\n((mui * czp(iz) / cxph(_PB_CXM + 1)) * tmp(iy, iz)) - &\n((mui * czm(iz) / cxph(_PB_CXM + 1)) * &\nbza(_PB_CXM + 1, _PB_CYM + 1, iz))\nbza(_PB_CXM + 1, _PB_CYM + 1, iz) = tmp(iy, iz)\nend do\nend do\n\n!$pragma endscop\nend subroutine
subroutine print_array(n, b)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: b\ninteger :: n\ninteger :: i, j\ndo i = 1, n\ndo j = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) b(j, i)\nif (mod(((i - 1) * n) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i,j\ndo i = 1, n\ndo j = 1, n\na(j, i) = ((DBLE(i - 1) * DBLE(j + 1)) + 2.0D0) / n\nend do\nend do\nend subroutine
subroutine init_array(n, p, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: p\ninteger :: n\ninteger :: i, j\ndo i = 1, n\np(i) = 1.0D0  / n\ndo j = 1, n\na(j, i) =  1.0D0 / n\nend do\nend do\nend subroutine
subroutine print_array(ni, nj, c)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: c\ninteger :: ni, nj\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, nj\nwrite(0, DATA_PRINTF_MODIFIER) c(j, i)\nif (mod(((i - 1) * ni) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine print_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i, j\ndo i = 1, n\ndo j = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) a(j, i)\nif (mod(((i - 1) * n) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(n, alpha, beta,  &\na, u1, u2, v1, v2, w, x, y, z)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: u1\nDATA_TYPE, dimension(n) :: u2\nDATA_TYPE, dimension(n) :: v1\nDATA_TYPE, dimension(n) :: v2\nDATA_TYPE, dimension(n) :: w\nDATA_TYPE, dimension(n) :: x\nDATA_TYPE, dimension(n) :: y\nDATA_TYPE, dimension(n) :: z\nDATA_TYPE :: alpha, beta\ninteger :: n\ninteger :: i, j\nalpha = 43532.0D0\nbeta = 12313.0D0\n\ndo i = 1, n\nu1(i) = DBLE(i - 1)\nu2(i) = DBLE(i / n) / 2.0D0\nv1(i) = DBLE(i / n) / 4.0D0\nv2(i) = DBLE(i / n) / 6.0D0\ny(i) = DBLE(i / n) / 8.0D0\nz(i) = DBLE(i / n) / 9.0D0\nx(i) = 0.0D0\nw(i) = 0.0D0\ndo j = 1, n\na(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(n)\nend do\nend do\nend subroutine
subroutine print_array(ni, nj, c)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: c\ninteger :: ni, nj\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, nj\nwrite(0, DATA_PRINTF_MODIFIER) c(j, i)\nif (mod(((i - 1) * ni) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(ni, nj, alpha, beta, c, a, b)\nimplicit none\n\nDATA_TYPE, dimension(nj, nj) :: a\nDATA_TYPE, dimension(nj, ni) :: b\nDATA_TYPE, dimension(nj, ni) :: c\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj\ninteger :: i, j\n\nalpha = 32412D0\nbeta = 2123D0\n\ndo i = 1, ni\ndo j = 1, nj\nc(j, i) = ((DBLE((i - 1) * (j - 1)))) / DBLE(ni)\nb(j, i) = ((DBLE((i - 1) * (j - 1)))) / DBLE(ni)\nend do\nend do\ndo i = 1, nj\ndo j = 1, nj\na(j, i) = (DBLE((i - 1) * (j - 1))) / DBLE(ni)\nend do\nend do\nend subroutine
subroutine print_array(n, x)\nimplicit none\n\nDATA_TYPE, dimension(n) :: x\ninteger :: n\ninteger :: i\ndo i = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) x(i)\nif (mod((i - 1), 20) == 0) then\nwrite(0, *)\nend if\nend do\nend subroutine
subroutine print_array(n, y)\nimplicit none\n\nDATA_TYPE, dimension(n) :: y\ninteger :: n\ninteger :: i\ndo i = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) y(i)\nif (mod(i - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend subroutine
subroutine kernel_gramschmidt(ni, nj, a, r, q)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: a\nDATA_TYPE, dimension(nj, nj) :: r\nDATA_TYPE, dimension(nj, ni) :: q\nDATA_TYPE :: nrm\ninteger :: ni, nj\ninteger :: i, j, k\n\n!$pragma scop\ndo k = 1, _PB_NJ\nnrm = 0.0D0\ndo i = 1, _PB_NI\nnrm = nrm + (a(k, i) * a(k, i))\nend do\nr(k, k) = sqrt(nrm)\ndo i = 1, _PB_NI\nq(k, i) = a(k, i) / r(k, k)\nend do\ndo j = k + 1, _PB_NJ\nr(j, k) = 0.0D0\ndo i = 1, _PB_NI\nr(j, k) = r(j, k) + (q(k, i) * a(j, i))\nend do\ndo i = 1, _PB_NI\na(j, i) = a(j, i) - (q(k, i) * r(j, k))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(n, w)\nimplicit none\n\nDATA_TYPE, dimension(n) :: w\ninteger :: n\ninteger :: i, j\ndo i = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) w(i)\nif (mod(i - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_covariance(m, n, float_n, dat, symmat, mean)\nimplicit none\n\nDATA_TYPE, dimension(m, m) :: symmat\nDATA_TYPE, dimension(n, m) :: dat\nDATA_TYPE, dimension(m) :: mean\nDATA_TYPE :: float_n\ninteger :: m, n\ninteger :: i, j, j1, j2\n!$pragma scop\n!       Determine mean of column vectors of input data matrix\ndo j = 1, _PB_M\nmean(j) = 0.0D0\ndo i = 1, _PB_N\nmean(j) = mean(j) + dat(j, i)\nend do\nmean(j) = mean(j) / float_n\nend do\n\n!       Center the column vectors.\ndo i = 1, _PB_N\ndo j = 1, _PB_M\ndat(j, i) = dat(j, i) - mean(j)\nend do\nend do\n\n!       Calculate the m * m covariance matrix.\ndo j1 = 1, _PB_M\ndo j2 = j1, _PB_M\nsymmat(j2, j1) = 0.0D0\ndo i = 1, _PB_N\nsymmat(j2, j1) = symmat(j2, j1) + (dat(j1, i) * dat(j2, i))\nend do\nsymmat(j1, j2) = symmat(j2, j1)\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine kernel_floyd_warshall(n, path)\nimplicit none\n\nDATA_TYPE, dimension(n,n) :: path\ninteger :: n\ninteger :: i, j, k\n\n!$pragma scop\ndo k=1, _PB_N\ndo i=1, _PB_N\ndo j=1, _PB_N\nif( path(j, i) .GE. path(k, i) + path(j, k) ) then\npath(j, i) = path(k, i) + path(j, k)\nend if\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine kernel_jacobi1d(tsteps, n, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n) :: a\nDATA_TYPE, dimension(n) :: b\ninteger :: n, tsteps\ninteger :: i, t, j\n!$pragma scop\ndo t = 1, _PB_TSTEPS\ndo i = 2, _PB_N - 1\nb(i) = 0.33333D0 * (a(i - 1) + a(i) + a(i + 1))\nend do\n\ndo j = 2, _PB_N -1\na(j) = b(j)\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(output)\nimplicit none\n\nDATA_TYPE :: output\nwrite(0, DATA_PRINTF_MODIFIER) output\nwrite(0, *)\nend subroutine
subroutine print_array(n, path)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: path\ninteger :: i, j, n\n\ndo i=1, n\ndo j=1, n\nwrite(0, DATA_PRINTF_MODIFIER) path(j,i)\n\nif (mod(((i - 1) * n) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_fdtd_2d(tmax, nx, ny, ex, ey, hz, fict)\nimplicit none\n\ninteger :: tmax, nx, ny\nDATA_TYPE, dimension(tmax) :: fict\nDATA_TYPE, dimension(ny, nx) :: ex\nDATA_TYPE, dimension(ny, nx) :: ey\nDATA_TYPE, dimension(ny, nx) :: hz\ninteger :: i, j, t\n\n!$pragma scop\ndo t = 1, _PB_TMAX\ndo j = 1, _PB_NY\ney(j, 1) = fict(t)\nend do\ndo i = 2, _PB_NX\ndo j = 1, _PB_NY\ney(j, i) = ey(j, i) - (0.5D0 * (hz(j, i) - hz(j, i - 1)))\nend do\nend do\ndo i = 1, _PB_NX\ndo j = 2, _PB_NY\nex(j, i) = ex(j, i) - (0.5D0 * (hz(j, i) - hz(j - 1, i)))\nend do\nend do\ndo i = 1, _PB_NX - 1\ndo j = 1, _PB_NY - 1\nhz(j, i) = hz(j, i) - (0.7D0 * (ex(j + 1, i) - ex(j, i)  &\n+ ey(j, i + 1) - ey(j, i)))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(length, c, w)\nimplicit none\n\nDATA_TYPE, dimension(length, length) :: w, c\ninteger :: i, j\ninteger length\n\ndo i = 1, length\ndo j = 1, length\nc(j, i) = mod((i-1)*(j-1), 2)\nw(j, i) = (DBLE((i - 1) - (j - 1))) / DBLE(length)\nend do\nend do\nend subroutine
subroutine kernel_syr2k(ni, nj, alpha, beta, c, a, b)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: a\nDATA_TYPE, dimension(nj, ni) :: b\nDATA_TYPE, dimension(ni, ni) :: c\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 1, _PB_NI\ndo j = 1, _PB_NI\nc(j, i) = c(j, i) * beta\nend do\nend do\ndo i = 1, _PB_NI\ndo j = 1, _PB_NI\ndo k = 1, _PB_NI\nc(j, i) = c(j, i) + (alpha * a(k, i) * b(k, j))\nc(j, i) = c(j, i) + (alpha * b(k, i) * a(k, j))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(a, x, nx, ny)\nimplicit none\n\ndouble precision :: M_PI\nparameter(M_PI = 3.14159265358979323846D0)\nDATA_TYPE, dimension(ny, nx) :: a\nDATA_TYPE, dimension(ny) :: x\ninteger :: nx, ny\ninteger :: i, j\ndo i = 1, ny\nx(i) = DBLE(i - 1) * M_PI\ndo j = 1, ny\na(j, i) = (DBLE((i - 1) * (j))) / nx\nend do\nend do\nend subroutine
subroutine kernel_gemver(n, alpha, beta,  &\na, u1, v1, u2, v2, &\nw, x, y, z)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: u1\nDATA_TYPE, dimension(n) :: u2\nDATA_TYPE, dimension(n) :: v1\nDATA_TYPE, dimension(n) :: v2\nDATA_TYPE, dimension(n) :: w\nDATA_TYPE, dimension(n) :: x\nDATA_TYPE, dimension(n) :: y\nDATA_TYPE, dimension(n) :: z\nDATA_TYPE :: alpha, beta\ninteger :: n\ninteger :: i, j\n\n!$pragma scop\ndo i = 1, _PB_N\ndo j = 1, _PB_N\na(j, i) = a(j, i) + (u1(i) * v1(j)) + (u2(i) * v2(j))\nend do\nend do\ndo i = 1, _PB_N\ndo j = 1, _PB_N\nx(i) = x(i) + (beta * a(i, j) * y(j))\nend do\nend do\ndo i = 1, _PB_N\nx(i) = x(i) + z(i)\nend do\ndo i = 1, _PB_N\ndo j = 1, _PB_N\nw(i) = w(i) + (alpha * a(j, i) * x(j))\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n\ndo j = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) a(j, i)\nif (mod((i - 1) * n + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_lu(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i, j, k\n\n!$pragma scop\ndo k = 1, _PB_N\ndo j = k + 1, _PB_N\na(j, k) = a(j, k) / a(k, k)\nend do\ndo i = k + 1, _PB_N\ndo j = k + 1, _PB_N\na(j, i) = a(j, i) - (a(k, i) * a(j, k))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, y, sumArray, alpha, beta, r)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: y\nDATA_TYPE, dimension(n, n) :: sumArray\nDATA_TYPE, dimension(n) :: beta\nDATA_TYPE, dimension(n) :: alpha\nDATA_TYPE, dimension(n) :: r\ninteger :: i, j\ninteger :: n\n\ndo i = 1, n\nalpha(i) = i\nbeta(i) = (i/n)/DBLE(2.0)\nr(i)  = (i/n)/DBLE(4.0)\ndo j = 1, n\ny(j,i) = DBLE(i*j)/DBLE(n)\nsumArray(j,i) = DBLE(i*j)/DBLE(n)\nend do\nend do\nend subroutine
subroutine kernel_gemm(ni, nj, nk, alpha, beta, c, a, b)\nimplicit none\n\nDATA_TYPE, dimension(nk, ni) :: a\nDATA_TYPE, dimension(nj, nk) :: b\nDATA_TYPE, dimension(nj, ni) :: c\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj, nk\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 1, _PB_NI\ndo j = 1, _PB_NJ\nc(j, i) = c(j, i) * beta\ndo k  = 1, _PB_NK\nc(j, i) = c(j, i) + (alpha * a(k, i) * b(j, k))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(maxgrid, path)\nimplicit none\n\ninteger :: i, j, maxgrid\nDATA_TYPE, dimension (maxgrid, maxgrid) :: path\ndo i = 1, maxgrid\ndo j = 1, maxgrid\nwrite(0, DATA_PRINTF_MODIFIER) path(j, i)\nif (mod(((i - 1) * maxgrid) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(n, alpha, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: b\nDATA_TYPE :: alpha\ninteger :: n\ninteger :: i, j\n\nalpha = 32412D0\ndo i = 1, n\ndo j = 1, n\na(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / DBLE(n)\nb(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(n)\nend do\nend do\nend subroutine
subroutine kernel_mvt(n, x1, x2, y1, y2, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: x1\nDATA_TYPE, dimension(n) :: y1\nDATA_TYPE, dimension(n) :: x2\nDATA_TYPE, dimension(n) :: y2\ninteger :: n\ninteger :: i, j\n\n!$pragma scop\ndo i = 1, _PB_N\ndo j = 1, _PB_N\nx1(i) = x1(i) + (a(j, i) * y1(j))\nend do\nend do\ndo i = 1, _PB_N\ndo j = 1, _PB_N\nx2(i) = x2(i) + (a(i, j) * y2(j))\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(nx, ny, a, r, p)\nimplicit none\n\ndouble precision :: M_PI\nparameter(M_PI = 3.14159265358979323846D0)\nDATA_TYPE, dimension(ny, nx) :: a\nDATA_TYPE, dimension(nx) :: r\nDATA_TYPE, dimension(ny) :: p\ninteger :: nx, ny\ninteger :: i, j\n\ndo i = 1, ny\np(i) = DBLE(i - 1) * M_PI\nend do\n\ndo i = 1, nx\nr(i) = DBLE(i - 1) * M_PI\ndo j = 1, ny\na(j, i) = (DBLE(i - 1) * DBLE(j)) / nx\nend do\nend do\nend subroutine
subroutine init_array(ni, nj, alpha, beta, c, a, b)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: a\nDATA_TYPE, dimension(nj, ni) :: b\nDATA_TYPE, dimension(ni, ni) :: c\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj\ninteger :: i, j\n\nalpha = 32412.0D0\nbeta = 2123.0D0\n\ndo i = 1, ni\ndo j = 1, nj\na(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / DBLE(ni)\nb(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(ni)\nend do\nend do\ndo i = 1, ni\ndo j = 1, ni\nc(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(ni)\nend do\nend do\nend subroutine
subroutine print_array(n, outArray)\nimplicit none\n\nDATA_TYPE, dimension(n) :: outArray\ninteger :: n\ninteger :: i\ndo i = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) outArray(i)\nif (mod(i - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend subroutine
subroutine init_array(alpha, beta, a, b, c ,d, ni, nj,  &\nnk, nl)\nimplicit none\n\nDATA_TYPE, dimension(nk, ni) :: a\nDATA_TYPE, dimension(nj, nk) :: b\nDATA_TYPE, dimension(nl, nj) :: c\nDATA_TYPE, dimension(nl, ni) :: d\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj, nk, nl\ninteger :: i, j\n\nalpha = 32412;\nbeta = 2123;\n\ndo i = 1, ni\ndo j = 1, nk\na(j,i) = DBLE((i-1) * (j-1)) / ni\nend do\nend do\n\ndo i = 1, nk\ndo j = 1, nj\nb(j,i) = (DBLE((i-1) * (j)))/ nj\nend do\nend do\n\ndo i = 1, nl\ndo j = 1, nj\nc(j,i) = (DBLE(i-1) * (j+2))/ nl\nend do\nend do\n\ndo i = 1, ni\ndo j = 1, nl\nd(j,i) = (DBLE(i-1) * (j+1))/ nk\nend do\nend do\nend subroutine
subroutine kernel_dynprog(tsteps , length, c, w, sumC, output)\nimplicit none\n\nDATA_TYPE, dimension(length, length) :: w, c\nDATA_TYPE, dimension(length, length, length) :: sumC\ninteger :: i, j, iter, k\ninteger :: length, tsteps\nDATA_TYPE :: output\n\n!$pragma scop\noutput = 0\n\ndo iter = 1, _PB_TSTEPS\ndo i = 1, _PB_LENGTH\ndo j = 1, _PB_LENGTH\nc(j, i) = 0\nend do\nend do\n\ndo i = 1, _PB_LENGTH - 1\ndo j = i + 1, _PB_LENGTH\nsumC(i, j, i) = 0\ndo k = i + 1, j - 1\nsumC(k, j, i) = sumC(k - 1, j, i) + c(k, i) + c(j, k)\nend do\nc(j, i) = sumC(j - 1, j, i) + w(j, i)\nend do\nend do\noutput = output + c(_PB_LENGTH, 1)\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(n, x1, x2)\nimplicit none\n\nDATA_TYPE, dimension(n) :: x1\nDATA_TYPE, dimension(n) :: x2\ninteger :: n\ninteger :: i\ndo i = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) x1(i)\nwrite(0, DATA_PRINTF_MODIFIER) x2(i)\nif (mod((i - 1), 20) == 0) then\nwrite(0, *)\nend if\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(n, path)\nimplicit none\n\nDATA_TYPE, dimension(n,n) :: path\ninteger :: i, j, n\n\ndo i=1, n\ndo j=1, n\npath(j, i) = (DBLE(i * j))/ DBLE(n)\nend do\nend do\nend subroutine
subroutine init_array(maxgrid, sumTang, mean, path)\nimplicit none\n\ninteger :: maxgrid\nDATA_TYPE, dimension (maxgrid, maxgrid) :: sumTang, mean, path\ninteger :: i, j\ndo i = 1, maxgrid\ndo j = 1, maxgrid\nsumTang(j, i) = i * j\nmean(j, i) = ( i - j ) / (maxgrid)\npath(j, i) = (( i - 1 ) * ( j - 2 )) / (maxgrid)\nend do\nend do\nend subroutine
subroutine kernel_3mm(ni, nj, nk, nl, nm, e, a, b, f, c, d, g)\nimplicit none\n\nDATA_TYPE, dimension(nk, ni) :: a\nDATA_TYPE, dimension(nj, nk) :: b\nDATA_TYPE, dimension(nm, nj) :: c\nDATA_TYPE, dimension(nl, nm) :: d\nDATA_TYPE, dimension(nj, ni) :: e\nDATA_TYPE, dimension(nl, nj) :: f\nDATA_TYPE, dimension(nl, ni) :: g\ninteger :: ni, nj, nk, nl, nm\ninteger :: i, j, k\n\n!$pragma scop\n! E := A*B\ndo i = 1, _PB_NI\ndo j = 1, _PB_NJ\ne(j,i) = 0.0\ndo k = 1, _PB_NK\ne(j,i) = e(j,i) + a(k,i) * b(j,k)\nend do\nend do\nend do\n\n! F := C*D\ndo i = 1, _PB_NJ\ndo j = 1, _PB_NL\nf(j,i) = 0.0\ndo k = 1, _PB_NM\nf(j,i) = f(j,i) + c(k,i) * d(j,k)\nend do\nend do\nend do\n\n! G := E*F\ndo i = 1, _PB_NI\ndo j = 1, _PB_NL\ng(j,i) = 0.0\ndo k = 1, _PB_NJ\ng(j,i) = g(j,i) + e(k,i) * f(j,k)\nend do\nend do\nend do\n!$pragma endscop\n\nend subroutine
subroutine kernel_adi(tsteps, n, x, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: x\nDATA_TYPE, dimension(n, n) :: b\ninteger :: n, tsteps\ninteger :: i1, i2, t\n\n!$pragma scop\ndo t = 1, _PB_TSTEPS\ndo i1 = 1, _PB_N\ndo i2 = 2, _PB_N\nx(i2, i1) = x(i2, i1) - ((x(i2 - 1, i1) * a(i2, i1)) / &\nb(i2 - 1, i1))\nb(i2, i1) = b(i2, i1) - ((a(i2, i1) * a(i2, i1)) / &\nb(i2 - 1, i1))\nend do\nend do\n\ndo i1 = 1, _PB_N\nx(_PB_N, i1) = x(_PB_N, i1) / b(_PB_N, i1)\nend do\n\ndo i1 = 1, _PB_N\ndo i2 = 1, _PB_N - 2\nx(_PB_N - i2, i1) = (x(_PB_N - i2, i1) - &\n(x(_PB_N - i2 - 1, i1) * &\na(_PB_N - i2 - 1, i1))) / &\nb(_PB_N - i2 - 1, i1)\nend do\nend do\n\ndo i1 = 2, _PB_N\ndo i2 = 1, _PB_N\nx(i2, i1) = x(i2, i1) - x(i2, i1 - 1) * a(i2, i1) / &\nb(i2, i1 - 1)\nb(i2, i1) = b(i2, i1) - a(i2, i1) * a(i2, i1) / &\nb(i2, i1 - 1)\n\nend do\nend do\n\ndo i2 = 1, _PB_N\nx(i2, _PB_N) = x(i2, _PB_N) / b(i2, _PB_N)\nend do\n\ndo i1 = 1, _PB_N - 2\ndo i2 = 1, _PB_N\nx(i2, _PB_N - i1) = (x(i2, _PB_N - i1) - &\nx(i2, _PB_N - i1 - 1) * &\na(i2, _PB_N - i1 - 1)) / &\nb(i2, _PB_N - i1)\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, a, b, x, y)\nimplicit none\n\nDATA_TYPE, dimension(n + 1, n + 1) :: a\nDATA_TYPE, dimension(n + 1) :: x\nDATA_TYPE, dimension(n + 1) :: b\nDATA_TYPE, dimension(n + 1) :: y\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n  + 1\nx(i) = DBLE(i)\ny(i) = (i/n/2.0D0) + 1.0D0\nb(i) = (i/n/2.0D0) + 42.0D0\ndo j = 1, n + 1\na(j, i) = (DBLE(i) * DBLE(j)) / DBLE(n)\nend do\nend do\nend subroutine
subroutine init_array(ni, nj, nk, alpha, beta, c, a, b)\nimplicit none\n\nDATA_TYPE, dimension(nk, ni) :: a\nDATA_TYPE, dimension(nj, nk) :: b\nDATA_TYPE, dimension(nj, ni) :: c\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj, nk\ninteger :: i, j\n\nalpha = 32412\nbeta = 2123\n\ndo i = 1, ni\ndo j = 1, nj\nc(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(ni)\nend do\nend do\ndo i = 1, ni\ndo j = 1, nk\na(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(ni)\nend do\nend do\ndo i = 1, nk\ndo j = 1, nj\nb(j, i) = ((DBLE(i - 1) * DBLE(j - 1))) / DBLE(ni)\nend do\nend do\nend subroutine
subroutine kernel_symm(ni, nj, alpha, beta, c, a, b)\nimplicit none\n\nDATA_TYPE, dimension(nj, nj) :: a\nDATA_TYPE, dimension(nj, ni) :: b\nDATA_TYPE, dimension(nj, ni) :: c\nDATA_TYPE :: alpha, beta\nDATA_TYPE :: acc\ninteger :: ni, nj\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 1, _PB_NI\ndo j = 1, _PB_NJ\nacc = 0.0D0\ndo k = 1, j - 2\nc(j, k) = c(j, k) + (alpha * a(i, k) * b(j, i))\nacc = acc + (b(j, k) * a(i, k))\nend do\nc(j, i) = (beta * c(j, i)) + (alpha * a(i, i) * b(j, i)) + &\n(alpha * acc)\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine kernel_atax(nx, ny, a, x, y, tmp)\nimplicit none\n\nDATA_TYPE, dimension(ny, nx) :: a\nDATA_TYPE, dimension(ny) :: x\nDATA_TYPE, dimension(ny) :: y\nDATA_TYPE, dimension(nx) :: tmp\ninteger nx, ny, i, j\n\n!$pragma scop\ndo i = 1, _PB_NY\ny(i) = 0.0D0\nend do\n\ndo i = 1, _PB_NX\ntmp(i) = 0.0D0\ndo j = 1, _PB_NY\ntmp(i) = tmp(i) + (a(j, i) * x(j))\nend do\ndo j = 1, _PB_NY\ny(j) = y(j) + a(j, i) * tmp(i)\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, a, x, c)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: c\nDATA_TYPE, dimension(n) :: x\ninteger :: n\ninteger :: i, j\ndo i = 1, n\nc(i) = DBLE(i - 1) / DBLE(n)\nx(i) = DBLE(i - 1) / DBLE(n)\ndo j = 1, n\na(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / DBLE(n)\nend do\nend do\nend subroutine
subroutine print_array(y, ny)\nimplicit none\n\nDATA_TYPE, dimension(ny) :: y\ninteger :: ny\ninteger :: i\ndo i = 1, ny\nwrite(0, DATA_PRINTF_MODIFIER) y(i)\nif (mod(i - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(nr, nq, np, a, cFour)\nimplicit none\n\nDATA_TYPE, dimension(np, nq, nr) :: a\nDATA_TYPE, dimension(np, np) :: cFour\ninteger :: nr, nq, np\ninteger :: i, j, k\n\ndo i = 1, nr\ndo j = 1, nq\ndo k = 1, np\na(k, j, i) = ((DBLE(i - 1) * DBLE(j - 1)) + DBLE(k - 1)) / &\nDBLE(np)\nend do\nend do\nend do\ndo i = 1, np\ndo j = 1, np\ncFour(j, i) = (DBLE(i - 1) * DBLE(j - 1)) / np\nend do\nend do\nend subroutine
subroutine print_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i, j\ndo i = 1, n\ndo j = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) a(j, i)\nif (mod(((i - 1) * n) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nend subroutine
subroutine kernel_reg_detect(niter, maxgrid, length, &\nsumTang, mean, path, diff, sumDiff)\nimplicit none\n\ninteger :: maxgrid, niter, length\nDATA_TYPE, dimension (maxgrid, maxgrid) :: sumTang, mean, path\nDATA_TYPE, dimension (length, maxgrid, maxgrid) :: sumDiff, diff\ninteger :: i, j, t, cnt\n\n!$pragma scop\ndo t = 1, _PB_NITER\ndo j = 1, _PB_MAXGRID\ndo i = j, _PB_MAXGRID\ndo cnt = 1, _PB_LENGTH\ndiff(cnt, i, j) = sumTang(i, j)\nend do\nend do\nend do\n\ndo j = 1, _PB_MAXGRID\ndo i = j, _PB_MAXGRID\nsumDiff(1, i, j) = diff(1, i, j)\ndo cnt = 2, _PB_LENGTH\nsumDiff(cnt, i, j) = sumDiff(cnt - 1, i, j) + &\ndiff(cnt, i, j)\nend do\nmean(i, j) = sumDiff(_PB_LENGTH, i, j)\nend do\nend do\n\ndo i = 1, _PB_MAXGRID\npath(i, 1) = mean(i, 1)\nend do\n\ndo j = 2, _PB_MAXGRID\ndo i = j, _PB_MAXGRID\npath(i, j) = path(i - 1, j - 1) + mean(i, j)\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: b\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n\ndo j = 1, n\na(j, i) = (DBLE(i - 1) * DBLE(j + 1) + 2.0D0) / n\nb(j, i) = (DBLE(i - 1) * DBLE(j + 2) + 3.0D0) / n\nend do\nend do\nend subroutine
subroutine kernel_correlation(m, n, float_n, dat, symmat, &\nmean, stddev)\nimplicit none\n\nDATA_TYPE, dimension(n,m) :: dat\nDATA_TYPE, dimension(m,m) :: symmat\nDATA_TYPE, dimension(m) :: stddev\nDATA_TYPE, dimension(m) :: mean\nDATA_TYPE :: float_n, EPS\ninteger :: m, n\ninteger :: i, j, j1, j2\n\nEPS = 0.1D0\n!$pragma scop\n!       Determine mean of column vectors of input data matrix\ndo j = 1, _PB_M\nmean(j) = 0.0D0\ndo i = 1, _PB_N\nmean(j) = mean(j) + dat(j, i)\nend do\nmean(j) = mean(j) / float_n\nend do\n\n!       Determine standard deviations of column vectors of data matrix.\ndo j = 1, _PB_M\nstddev(j) = 0.0D0\ndo i = 1, _PB_N\nstddev(j) = stddev(j) + (dat(j, i) - mean(j)) * (dat(j, i) - &\nmean(j))\nend do\nstddev(j) = stddev(j) / float_n\nstddev(j) = sqrt(stddev(j))\nif (stddev(j) <= EPS) then\nstddev(j) = 1.0D0\nendif\nend do\n\n!       Center and reduce the column vectors.\ndo i = 1, _PB_N\ndo j = 1, _PB_M\ndat(j, i) = dat(j, i) - mean(j)\ndat(j, i) = dat(j, i) / (sqrt(float_n) * stddev(j))\nend do\nend do\n\n!       Calculate the m * m correlation matrix.\ndo j1 = 1, _PB_M - 1\nsymmat(j1, j1) = 1.0D0\ndo j2 = j1 + 1, _PB_M\nsymmat(j2, j1) = 0.0D0\ndo i = 1, _PB_N\nsymmat(j2, j1) = symmat(j2, j1) + (dat(j1, i) * dat(j2, i))\nend do\nsymmat(j1, j2) = symmat(j2, j1)\nend do\nend do\nsymmat(_PB_M, _PB_M) = 1.0D0\n!$pragma endscop\nend subroutine
subroutine print_array(ni, nl, g)\nimplicit none\n\nDATA_TYPE, dimension(nl, ni) :: g\ninteger :: ni, nl\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, nl\nwrite(0, DATA_PRINTF_MODIFIER) g(j,i)\nif (mod(((i - 1) * ni) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_gesummv(n, alpha, beta, &\na, b, tmp, x, y)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: b\nDATA_TYPE, dimension(n) :: x, y, tmp\nDATA_TYPE :: alpha, beta\ninteger :: n\ninteger :: i, j\n\n!$pragma scop\ndo i = 1, _PB_N\ntmp(i) = 0.0D0\ny(i) = 0.0D0\ndo j = 1, _PB_N\ntmp(i) = (a(j, i) * x(j)) + tmp(i)\ny(i) = (b(j, i) * x(j)) + y(i)\nend do\ny(i) = (alpha * tmp(i)) + (beta * y(i))\nend do\n!$pragma endscop\nend subroutine
subroutine kernel_ludcmp(n, a, b, x, y)\nimplicit none\n\nDATA_TYPE, dimension(n + 1, n + 1) :: a\nDATA_TYPE, dimension(n + 1) :: x\nDATA_TYPE, dimension(n + 1) :: b\nDATA_TYPE, dimension(n + 1) :: y\nDATA_TYPE :: w\ninteger :: n\ninteger :: i, j, k\n\n!$pragma scop\nb(1) = 1.0D0\ndo i = 1, _PB_N\ndo j = i + 1, _PB_N + 1\nw = a(i, j)\ndo k = 1, i - 1\nw = w - (a(k, j) * a(i, k))\nend do\na(i, j) = w / a(i, i)\nend do\ndo j = i + 1, _PB_N + 1\nw = a(j, i + 1)\ndo k = 1, i\nw = w - (a(k, i + 1) * a(j, k))\nend do\na(j, i + 1) = w\nend do\nend do\ny(1) = b(1)\ndo i = 2, _PB_N + 1\nw = b(i)\ndo j = 1, i - 1\nw = w - (a(j, i) * y(j))\nend do\ny(i) = w\nend do\nx(_PB_N + 1) = y(_PB_N + 1) / a(_PB_N + 1, _PB_N + 1)\ndo i = 1, _PB_N\nw = y(_PB_N + 1 - i)\ndo j = _PB_N + 2 - i, _PB_N + 1\nw = w - (a(j, _PB_N + 1 - i) * x(j))\nend do\nx(_PB_N + 1 - i) = w / a(_PB_N + 1 - i, _PB_N + 1 - i)\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(ni, nj, a, r, q)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: a\nDATA_TYPE, dimension(nj, nj) :: r\nDATA_TYPE, dimension(nj, ni) :: q\ninteger :: ni, nj\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, nj\nwrite(0, DATA_PRINTF_MODIFIER) a(j, i)\nif (mod((i - 1), 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\ndo i = 1, nj\ndo j = 1, nj\nwrite(0, DATA_PRINTF_MODIFIER) r(j, i)\nif (mod((i - 1), 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\ndo i = 1, ni\ndo j = 1, nj\nwrite(0, DATA_PRINTF_MODIFIER) q(j, i)\nif (mod((i - 1), 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(cz, cxm, cym, mui, ch, ax, ry, ex, ey, hz, &\nczm, czp, cxmh, cxph, cymh, cyph)\nimplicit none\n\ninteger :: cz, cym, cxm\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: ex\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: ey\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: hz\nDATA_TYPE, dimension(cym + 1, cz + 1) :: ry\nDATA_TYPE, dimension(cym + 1, cz + 1) :: ax\nDATA_TYPE, dimension(cym + 1) :: cymh\nDATA_TYPE, dimension(cym + 1) :: cyph\nDATA_TYPE, dimension(cxm + 1) :: cxmh\nDATA_TYPE, dimension(cxm + 1) :: cxph\nDATA_TYPE, dimension(cz + 1) :: czm\nDATA_TYPE, dimension(cz + 1) :: czp\nDATA_TYPE :: mui, ch\ninteger :: i, j, k\n\nmui = 2341\nch = 42\ndo i = 1, cz + 1\nczm(i) = (DBLE(i - 1) + 1.0D0) / DBLE(cxm)\nczp(i) = (DBLE(i - 1) + 2.0D0) / DBLE(cxm)\nend do\ndo i = 1, cxm + 1\ncxmh(i) = (DBLE(i - 1) + 3.0D0) / DBLE(cxm)\ncxph(i) = (DBLE(i - 1) + 4.0D0) / DBLE(cxm)\nend do\ndo i = 1, cym + 1\ncymh(i) = (DBLE(i - 1) + 5.0D0) / DBLE(cxm)\ncyph(i) = (DBLE(i - 1) + 6.0D0) / DBLE(cxm)\nend do\ndo i = 1, cz + 1\ndo j = 1, cym + 1\nry(j, i) = ((DBLE(i - 1) * DBLE(j)) + 10.0D0) / &\nDBLE(cym)\nax(j, i) = ((DBLE(i - 1) * DBLE(j + 1)) + 11.0D0) / &\nDBLE(cym)\ndo k = 1, cxm + 1\nex(k, j, i) = ((DBLE(i - 1) * DBLE(j + 2)) + DBLE(k - 1) + &\n1.0D0) / DBLE(cxm)\ney(k, j, i) = ((DBLE(i - 1) * DBLE(j + 3)) + DBLE(k - 1) + &\n2.0D0) / DBLE(cym)\nhz(k, j, i) = ((DBLE(i - 1) * DBLE(j + 4)) + DBLE(k - 1) + &\n3.0D0) / DBLE(cz)\nend do\nend do\nend do\nend subroutine
subroutine kernel_cholesky(n, p, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n) :: p\nDATA_TYPE :: x\ninteger :: n\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 1, _PB_N\nx = a(i, i)\ndo j = 1, i - 1\nx = x - a(j, i) * a(j, i)\nend do\np(i) = 1.0D0 / sqrt(x)\ndo j = i + 1, _PB_N\nx = a(j, i)\ndo k = 1, i - 1\nx = x - (a(k, j) * a(k, i))\nend do\na(i, j) = x * p(i)\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(nx, ny, ex, ey, hz)\nimplicit none\n\nDATA_TYPE, dimension(ny, nx) :: ex\nDATA_TYPE, dimension(ny, nx) :: ey\nDATA_TYPE, dimension(ny, nx) :: hz\ninteger :: nx, ny\ninteger :: i, j\ndo i = 1, nx\ndo j = 1, ny\nwrite(0, DATA_PRINTF_MODIFIER) ex(j, i)\nwrite(0, DATA_PRINTF_MODIFIER) ey(j, i)\nwrite(0, DATA_PRINTF_MODIFIER) hz(j, i)\nif (mod(((i - 1) * nx) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine print_array(a, nr, nq, np)\nimplicit none\n\nDATA_TYPE, dimension(np, nq, nr) :: a\ninteger :: nr, nq, np\ninteger :: i, j, k\ndo i = 1, nr\ndo j = 1, nq\ndo k = 1, np\nwrite(0, DATA_PRINTF_MODIFIER) a(k, j, i)\nif (mod((i - 1), 20) &\n== 0) then\nwrite(0, *)\nend if\nend do\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine print_array(nx, ny, s, q)\nimplicit none\n\nDATA_TYPE, dimension(ny) :: s\nDATA_TYPE, dimension(nx) :: q\ninteger :: nx,ny\ninteger :: i\ndo i = 1, ny\nwrite(0, DATA_PRINTF_MODIFIER) s(i)\nif (mod(i - 1, 80) == 0) then\nwrite(0, *)\nend if\nend do\n\ndo i = 1, nx\nwrite(0, DATA_PRINTF_MODIFIER) q(i)\nif (mod(i - 1, 80) == 0) then\nwrite(0, *)\nend if\nend do\nwrite(0, *)\nend subroutine
subroutine print_array(n, x)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: x\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n\ndo j = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) x(j, i)\nif (mod(((i - 1) * n) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine print_array(ni, c)\nimplicit none\n\nDATA_TYPE, dimension(ni, ni) :: c\ninteger :: ni\ninteger :: i, j\ndo i = 1, ni\ndo j = 1, ni\nwrite(0, DATA_PRINTF_MODIFIER) c(j, i)\nif (mod(((i - 1) * ni) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine init_array(ni, nj, nk, nl, nm, a, b, c , d)\nimplicit none\n\nDATA_TYPE, dimension(nk, ni) :: a\nDATA_TYPE, dimension(nj, nk) :: b\nDATA_TYPE, dimension(nm, nj) :: c\nDATA_TYPE, dimension(nl, nm) :: d\ninteger :: ni, nj, nk, nl, nm\ninteger :: i, j\n\ndo i = 1, ni\ndo j = 1, nk\na(j,i) = DBLE(i-1) * DBLE(j-1) / ni\nend do\nend do\n\ndo i = 1, nk\ndo j = 1, nj\nb(j,i) = (DBLE(i-1) * DBLE(j))/ nj\nend do\nend do\n\ndo i = 1, nj\ndo j = 1, nm\nc(j,i) = (DBLE(i-1) * DBLE(j+2))/ nl\nend do\nend do\n\ndo i = 1, nm\ndo j = 1, nl\nd(j,i) = (DBLE(i-1) * DBLE(j+1))/ nk\nend do\nend do\nend subroutine
subroutine print_array(n, x)\nimplicit none\n\nDATA_TYPE, dimension(n + 1) :: x\ninteger :: n\ninteger :: i\ndo i = 1, n + 1\nwrite(0, DATA_PRINTF_MODIFIER) x(i)\nif (mod(i - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend subroutine
subroutine kernel_jacobi_2d_imper(tsteps, n, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\nDATA_TYPE, dimension(n, n) :: b\ninteger :: n, tsteps\ninteger :: i, j, t\n\n!$pragma scop\ndo t = 1, _PB_TSTEPS\ndo i = 2, _PB_N - 1\ndo j = 2, _PB_N - 1\nb(j, i) = 0.2D0 * (a(j, i) + a(j - 1, i) + a(1 + j, i) + &\na(j, 1 + i) + a(j, i - 1))\nend do\nend do\ndo i = 2, _PB_N - 1\ndo j = 2, _PB_N - 1\na(j, i) = b(j, i)\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n\ninteger :: i, j\n\ndo i = 1, n\ndo j = 1, n\na(j, i) = (DBLE(i) * DBLE(j)) / DBLE(n)\nend do\nend do\nend subroutine
program DRB047_doallchar_orig_no\n    use omp_lib\n    implicit none\n\n    character(len=100), dimension(:), allocatable :: a\n    character(50) :: str\n    integer :: i\n\n    allocate (a(100))\n\n    !$omp parallel do private(str)\n    do i = 1, 100\n        write( str, '(i10)' )  i\n        a(i) = str\n    end do\n    !$omp end parallel do\n\n    print*,'a(i)',a(23)\nend program
module DRB105\n    implicit none\n    integer input\ncontains\n    recursive function fib(n) result(r)\n        use omp_lib\n        implicit none\n        integer :: n, i, j, r\n\n        if (n<2) then\n            r = n\n        else\n            !$omp task shared(i)\n            i = fib(n-1)\n            !$omp end task\n            !$omp task shared(j)\n            j = fib(n-2)\n            !$omp end task\n            !$omp taskwait\n            r = i+j\n        end if\n    end function\nend module\n\nprogram DRB105_taskwait_orig_no\n    use omp_lib\n    use DRB105\n    implicit none\n\n    integer :: result\n    input = 30\n\n    !$omp parallel\n    !$omp single\n    result = fib(input)\n    !$omp end single\n    !$omp end parallel\n\n    print 100, input, result\n    100 format ('Fib for ',3i8,' =',3i8)\nend program
program DRB015_outofbounds_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, n, m, len, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    real, dimension (:,:), allocatable :: b\n    len = 100\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    n = len\n    m = len\n\n    allocate (b(n,m))\n\n    !$omp parallel do private(i)\n    do j = 2, n\n        do i = 1, m\n            b(i,j) = b(i-1,j)\n        end do\n    end do\n    !$omp end parallel do\n    print*,"b(50,50)=",b(50,50)\n\n    deallocate(args,b)\nend program
program DRB125_single_orig_no\n    use omp_lib\n    implicit none\n\n    integer :: init, local\n\n    !$omp parallel shared(init) private(local)\n        !$omp single\n        init = 10\n        !$omp end single\n        local = init\n    !$omp end parallel\nend program
program DRB113_default_orig_no\n    use omp_lib\n    implicit none\n\n    integer len,i,j\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:,:), allocatable :: a,b\n\n    len = 100\n\n    allocate (a(len, len))\n    allocate (b(len, len))\n\n    !$omp parallel do default(none) shared(a) private(i,j)\n    do i = 1, 100\n        do j = 1, 100\n            a(i,j) = a(i,j)+1\n        end do\n    end do\n    !$omp end parallel do\n\n    !$omp parallel do default(shared) private(i,j)\n    do i = 1, 100\n        do j = 1, 100\n            b(i,j) = b(i,j)+1\n        end do\n    end do\n    !$omp end parallel do\n\n    print*,a(50,50),b(50,50)\n\n    deallocate(a,b)\nend program
program DRB165_taskdep4_orig_yes_omp_50\n    use omp_lib\n    implicit none\n\n    !$omp parallel\n    !$omp single\n    call foo()\n    !$omp end single\n    !$omp end parallel\ncontains\n    subroutine foo()\n        implicit none\n        integer :: x, y\n        x = 0\n        y = 2\n\n        !$omp task depend(inout: x) shared(x)\n        x = x+1                                 !!1st Child Task\n        !$omp end task\n\n        !$omp task shared(y)\n        y = y-1                                 !!2nd child task\n        !$omp end task\n\n        !$omp taskwait depend(in: x)            !!1st taskwait\n\n        print*, "x=", x\n        print*, "y=", y\n\n        !$omp taskwait                          !!2nd taskwait\n    end subroutine foo\nend program
program DRB146_atomicupdate_orig_gpu_no\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n        !$omp teams distribute\n        do i = 1, 100\n            !$omp atomic update\n            var = var+1\n            !$omp end atomic\n        end do\n        !$omp end teams distribute\n    !$omp end target\n\n  print*,var\nend program
program DRB142_acquirerelease_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: x, y, thrd\n    integer :: tmp\n    x = 0\n\n    !$omp parallel num_threads(2) private(thrd) private(tmp)\n        thrd = omp_get_thread_num()\n        if (thrd == 0) then\n            !$omp critical\n            x = 10\n            !$omp end critical\n\n            !$omp flush(x)\n\n            !$omp atomic write\n            y = 1\n            !$omp end atomic\n        else\n            tmp = 0\n            do while(tmp == 0)\n            !$omp atomic read acquire ! or seq_cst\n            tmp = x\n            !$omp end atomic\n            end do\n            !$omp critical\n            print *, "x = ", x\n            !$omp end critical\n        end if\n    !$omp end parallel\nend program
program DRB148_critical1_orig_gpu_yes\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp target map(tofrom:var) device(0)\n    !$omp teams distribute parallel do\n    do i = 1, 100\n        !$omp critical(addlock)\n        var = var+1\n        !$omp end critical(addlock)\n    end do\n    !$omp end teams distribute parallel do\n    !$omp end target\n\n    print*,var\nend program
program DRB019_plusplus_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, inLen, outLen, argCount, allocStatus, rdErr, ix\n    character(len=80), dimension(:), allocatable :: args\n    integer, dimension(:), allocatable :: input\n    integer, dimension(:), allocatable :: output\n\n    inLen = 1000\n    outLen = 1\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) inLen\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (input(inLen))\n    allocate (output(inLen))\n\n    do i = 1, inLen\n        input(i) = i\n    end do\n\n    !$omp parallel do\n    do i = 1, inLen\n        output(outLen) = input(i)\n        outLen = outLen + 1\n    end do\n    !$omp end parallel do\n\n    print 100, output(0)\n    100 format ("output(0)=",i3)\n\n\n    deallocate(input,output,args)\nend program
program DRB101_task_value_orig_no\n    use omp_lib\n    use DRB101\n    implicit none\n\n    integer :: i\n    allocate (a(100))\n\n    !$omp parallel\n        !$omp single\n        do i = 1, 100\n            call gen_task(i)\n        end do\n        !$omp end single\n    !$omp end parallel\n\n    do i = 1, 100\n        if (a(i) /= i+1) then\n            print*,'warning: a(',i,') =',a(i),' not expected',i+1\n        end if\n!        print*,a(i),i+1\n    end do\nend program
program DRB022_reductionmissing_var_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, len, argCount, allocStatus, rdErr, ix\n    real :: temp, getSum\n    character(len=80), dimension(:), allocatable :: args\n    real, dimension (:,:), allocatable :: u\n\n    len = 100\n    getSum = 0.0\n\n    argCount = command_argument_count()\n    if (argCount == 0) then\n        write (*,'(a)') "No command line arguments provided."\n    end if\n\n    allocate(args(argCount), stat=allocStatus)\n    if (allocStatus > 0) then\n        write (*,'(a)') "Allocation error, program terminated."\n        stop\n    end if\n\n    do ix = 1, argCount\n        call get_command_argument(ix,args(ix))\n    end do\n\n    if (argCount >= 1) then\n        read (args(1), '(i10)', iostat=rdErr) len\n        if (rdErr /= 0 ) then\n            write (*,'(a)') "Error, invalid integer value."\n        end if\n    end if\n\n    allocate (u(len, len))\n\n    do i = 1, len\n        do j = 1, len\n            u(i,j) = 0.5\n        end do\n    end do\n\n    !$omp parallel do private(temp, i, j)\n    do i = 1, len\n        do j = 1, len\n            temp = u(i,j)\n            getSum = getSum + temp * temp\n        end do\n    end do\n    !$omp end parallel do\n\n    print*,"sum =", getSum\n\n\n    deallocate(args,u)\nend program
program DRB014_outofbounds_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i, j, n, m\n    real, dimension (:,:), allocatable :: b\n\n    n = 100\n    m = 100\n\n    allocate (b(n,m))\n\n    !$omp parallel do private(i)\n    do j = 2, n\n        do i = 1, m\n            b(i,j) = b(i-1,j)\n        end do\n    end do\n    !$omp end parallel do\n    print*,"b(50,50)=",b(50,50)\n\n    deallocate(b)\nend program
program DRB098_simd2_orig_no\n    use omp_lib\n    implicit none\n\n    integer, parameter :: dp = kind(1.0d0)\n    real(dp), dimension(:,:), allocatable :: a,b,c\n    integer :: len, i, j\n\n    len = 100\n    allocate (a(len,len))\n    allocate (b(len,len))\n    allocate (c(len,len))\n\n    do i = 1, len\n        do j = 1, len\n            a(i,j) = real(i,dp)/2.0\n            b(i,j) = real(i,dp)/3.0\n            c(i,j) = real(i,dp)/7.0\n        end do\n    end do\n\n    !$omp simd collapse(2)\n    do i = 1, len\n        do j = 1, len\n            c(i,j)=a(i,j)*b(i,j)\n        end do\n    end do\n    !$omp end simd\n\n    print*,'c(50,50) =',c(50,50)\n\n    deallocate(a,b,c)\nend program
program DRB080_func_arg_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: i\n\n    i = 0\n\n    !$omp parallel\n    call f1(i)\n    !$omp end parallel\n\n    print*,"i = ",i\nend program
program DRB084_threadprivatemissing_orig_yes\n    use omp_lib\n    use DRB084\n    implicit none\n\n    integer (kind=8) :: i, sum\n    sum = 0\n\n    !$omp parallel\n        !$omp do\n            do i = 1, 1001\n                call foo(i)\n            end do\n        !$omp end do\n        !$omp critical\n            sum = sum + sum0\n        !$omp end critical\n    !$omp end parallel\n\n    do i = 1, 1001\n        sum1 = sum1+i\n    end do\n\n    print*,'sum = ',sum,'sum1 =',sum1\nend program
program DRB123_taskundeferred_orig_yes\n    use omp_lib\n    implicit none\n\n    integer :: var, i\n    var = 0\n\n    !$omp parallel sections\n    do i = 1, 10\n        !$omp task shared(var) \n        var = var+1;\n        !$omp end task\n    end do\n    !$omp end parallel sections\n\n    print 100, var\n    100 format ('var =', 3i8)\nend program
subroutine  add\n\n\n\nuse sp_data\nimplicit none\n\ninteger i,j,k,m\n\nif (timeron) call timer_start(t_add)\ndo k = 1, nz2\ndo j = 1, ny2\ndo i = 1, nx2\ndo m = 1, 5\nu(m,i,j,k) = u(m,i,j,k) + rhs(m,i,j,k)\nend do\nend do\nend do\nend do\nif (timeron) call timer_stop(t_add)\n\nreturn\nend
subroutine norm2u3(r,n1,n2,n3,rnm2,rnmu,nx,ny,nz)\n\n\nuse mg_data, only : timeron\n\nimplicit none\n\ninteger n1, n2, n3, nx, ny, nz\ndouble precision rnm2, rnmu, r(n1,n2,n3)\ndouble precision s, a\ninteger i3, i2, i1\n\ndouble precision dn\n\ninteger T_norm2\nparameter (T_norm2=9)\n\nif (timeron) call timer_start(T_norm2)\ndn = 1.0d0*nx*ny*nz\n\ns=0.0D0\nrnmu = 0.0D0\ndo  i3=2,n3-1\ndo  i2=2,n2-1\ndo  i1=2,n1-1\ns=s+r(i1,i2,i3)**2\na=abs(r(i1,i2,i3))\nrnmu=dmax1(rnmu,a)\nenddo\nenddo\nenddo\n\nrnm2=sqrt( s / dn )\nif (timeron) call timer_stop(T_norm2)\n\nreturn\nend
subroutine pintgr\n\n\nuse lu_data\nimplicit none\n\ninteger i, j, k\ninteger ibeg, ifin, ifin1\ninteger jbeg, jfin, jfin1\ndouble precision frc1, frc2, frc3\n\n\n\nibeg = ii1\nifin = ii2\njbeg = ji1\njfin = ji2\nifin1 = ifin - 1\njfin1 = jfin - 1\n\n\ndo j = jbeg,jfin\ndo i = ibeg,ifin\n\nk = ki1\n\nphi1(i,j) = c2*(  u(5,i,j,k)  &\n&           - 0.50d+00 * (  u(2,i,j,k) ** 2  &\n&                         + u(3,i,j,k) ** 2  &\n&                         + u(4,i,j,k) ** 2 )  &\n&                        / u(1,i,j,k) )\n\nk = ki2\n\nphi2(i,j) = c2*(  u(5,i,j,k)  &\n&           - 0.50d+00 * (  u(2,i,j,k) ** 2  &\n&                         + u(3,i,j,k) ** 2  &\n&                         + u(4,i,j,k) ** 2 )  &\n&                        / u(1,i,j,k) )\nend do\nend do\n\n\nfrc1 = 0.0d+00\n\ndo j = jbeg,jfin1\ndo i = ibeg, ifin1\nfrc1 = frc1 + (  phi1(i,j)  &\n&                     + phi1(i+1,j)  &\n&                     + phi1(i,j+1)  &\n&                     + phi1(i+1,j+1)  &\n&                     + phi2(i,j)  &\n&                     + phi2(i+1,j)  &\n&                     + phi2(i,j+1)  &\n&                     + phi2(i+1,j+1) )\nend do\nend do\n\n\nfrc1 = dxi * deta * frc1\n\n\ndo k = ki1, ki2\ndo i = ibeg, ifin\nphi1(i,k) = c2*(  u(5,i,jbeg,k)  &\n&           - 0.50d+00 * (  u(2,i,jbeg,k) ** 2  &\n&                         + u(3,i,jbeg,k) ** 2  &\n&                         + u(4,i,jbeg,k) ** 2 )  &\n&                        / u(1,i,jbeg,k) )\nend do\nend do\n\ndo k = ki1, ki2\ndo i = ibeg, ifin\nphi2(i,k) = c2*(  u(5,i,jfin,k)  &\n&           - 0.50d+00 * (  u(2,i,jfin,k) ** 2  &\n&                         + u(3,i,jfin,k) ** 2  &\n&                         + u(4,i,jfin,k) ** 2 )  &\n&                        / u(1,i,jfin,k) )\nend do\nend do\n\n\nfrc2 = 0.0d+00\n\ndo k = ki1, ki2-1\ndo i = ibeg, ifin1\nfrc2 = frc2 + (  phi1(i,k)  &\n&                     + phi1(i+1,k)  &\n&                     + phi1(i,k+1)  &\n&                     + phi1(i+1,k+1)  &\n&                     + phi2(i,k)  &\n&                     + phi2(i+1,k)  &\n&                     + phi2(i,k+1)  &\n&                     + phi2(i+1,k+1) )\nend do\nend do\n\n\nfrc2 = dxi * dzeta * frc2\n\n\ndo k = ki1, ki2\ndo j = jbeg, jfin\nphi1(j,k) = c2*(  u(5,ibeg,j,k)  &\n&           - 0.50d+00 * (  u(2,ibeg,j,k) ** 2  &\n&                         + u(3,ibeg,j,k) ** 2  &\n&                         + u(4,ibeg,j,k) ** 2 )  &\n&                        / u(1,ibeg,j,k) )\nend do\nend do\n\ndo k = ki1, ki2\ndo j = jbeg, jfin\nphi2(j,k) = c2*(  u(5,ifin,j,k)  &\n&           - 0.50d+00 * (  u(2,ifin,j,k) ** 2  &\n&                         + u(3,ifin,j,k) ** 2  &\n&                         + u(4,ifin,j,k) ** 2 )  &\n&                        / u(1,ifin,j,k) )\nend do\nend do\n\n\nfrc3 = 0.0d+00\n\ndo k = ki1, ki2-1\ndo j = jbeg, jfin1\nfrc3 = frc3 + (  phi1(j,k)  &\n&                     + phi1(j+1,k)  &\n&                     + phi1(j,k+1)  &\n&                     + phi1(j+1,k+1)  &\n&                     + phi2(j,k)  &\n&                     + phi2(j+1,k)  &\n&                     + phi2(j,k+1)  &\n&                     + phi2(j+1,k+1) )\nend do\nend do\n\n\nfrc3 = deta * dzeta * frc3\n\nfrc = 0.25d+00 * ( frc1 + frc2 + frc3 )\n\nreturn\n\n\nend
subroutine print_array(m, symmat)\nimplicit none\n\nDATA_TYPE, dimension(N, M) :: symmat\ninteger :: m\ninteger :: i, j\ndo i = 1, m\ndo j = 1, m\nwrite(0, DATA_PRINTF_MODIFIER) symmat(j, i)\nif (mod(((i - 1) * m) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine print_array(cz, cxm, cym, bza, ex, ey, hz)\nimplicit none\n\ninteger :: cz, cxm, cym\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: bza\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: ex\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: ey\nDATA_TYPE, dimension(cxm + 1, cym + 1, cz + 1) :: hz\ninteger :: i, j, k\n\ndo i = 1, cz + 1\ndo j = 1, cym + 1\ndo k = 1, cxm + 1\nwrite(0, DATA_PRINTF_MODIFIER) bza(k, j, i)\nwrite(0, DATA_PRINTF_MODIFIER) ex(k, j, i)\nwrite(0, DATA_PRINTF_MODIFIER) ey(k, j, i)\nwrite(0, DATA_PRINTF_MODIFIER) hz(k, j, i)\nif (mod(((i - 1) * cxm) + j - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nend do\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_2mm(alpha, beta, tmp, a, b, c, d,  &\nni, nj, nk, nl)\nimplicit none\n\nDATA_TYPE, dimension(nj, ni) :: tmp\nDATA_TYPE, dimension(nk, ni) :: a\nDATA_TYPE, dimension(nj, nk) :: b\nDATA_TYPE, dimension(nl, nj) :: c\nDATA_TYPE, dimension(nl, ni) :: d\nDATA_TYPE :: alpha, beta\ninteger :: ni, nj, nk, nl\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 1, _PB_NI\ndo j = 1, _PB_NJ\ntmp(j,i) = 0.0\ndo k = 1, _PB_NK\ntmp(j,i) = tmp(j,i) + alpha * a(k,i) * b(j,k)\nend do\nend do\nend do\n\ndo i = 1, _PB_NI\ndo j = 1, _PB_NL\nd(j,i) = d(j,i) * beta\ndo k = 1, _PB_NJ\nd(j,i) = d(j,i) + tmp(k,i) * c(j,k)\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine print_array(n, a)\nimplicit none\n\nDATA_TYPE, dimension(n) :: a\ninteger :: n\ninteger :: i\n\ndo i = 1, n\nwrite(0, DATA_PRINTF_MODIFIER) a(i)\nif (mod(i - 1, 20) == 0) then\nwrite(0, *)\nend if\nend do\nwrite(0, *)\nend subroutine
subroutine kernel_seidel(tsteps, n, a)\nimplicit none\n\nDATA_TYPE, dimension(n, n) :: a\ninteger :: n, tsteps\ninteger :: i, t, j\n\n!$pragma scop\ndo t = 1, _PB_TSTEPS\ndo i = 2, _PB_N - 1\ndo j = 2, _PB_N - 1\na(j, i) = (a(j - 1, i - 1) + a(j, i - 1) + a(j + 1, i - 1) + &\na(j - 1, i) + a(j, i) + a(j + 1, i) + &\na(j - 1, i + 1) + a(j, i + 1) + &\na(j + 1, i + 1))/9.0D0\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine kernel_trmm(ni, alpha, a, b)\nimplicit none\n\nDATA_TYPE, dimension(ni, ni) :: a\nDATA_TYPE, dimension(ni, ni) :: b\nDATA_TYPE :: alpha\ninteger :: ni\ninteger :: i, j, k\n\n!$pragma scop\ndo i = 2, _PB_NI\ndo j = 1, _PB_NI\ndo k = 1, i - 1\nb(j, i) = b(j, i) + (alpha * a(k, i) * b(k, j))\nend do\nend do\nend do\n!$pragma endscop\nend subroutine
subroutine init_array(tmax, nx, ny, ex, ey, hz, fict)\nimplicit none\n\ninteger :: nx, ny, tmax\nDATA_TYPE, dimension(tmax) :: fict\nDATA_TYPE, dimension(ny, nx) :: ex\nDATA_TYPE, dimension(ny, nx) :: ey\nDATA_TYPE, dimension(ny, nx) :: hz\ninteger :: i, j\ndo i = 1, tmax\nfict(i) = DBLE(i - 1)\nend do\ndo i = 1, nx\ndo j = 1, ny\nex(j, i) = (DBLE((i - 1) * (j))) / DBLE(nx)\ney(j, i) = (DBLE((i - 1) * (j + 1))) / DBLE(ny)\nhz(j, i) = (DBLE((i - 1) * (j + 2))) / DBLE(nx)\nend do\nend do\nend subroutine
subroutine init_array(n, a, b)\nimplicit none\n\nDATA_TYPE, dimension(n) :: a\nDATA_TYPE, dimension(n) :: b\ninteger :: n\ninteger :: i\n\ndo i = 1, n\na(i) = (DBLE(i-1) + 2.0D0) / n\nb(i) = (DBLE(i-1) + 3.0D0) / n\nend do\nend subroutine
subroutine kernel_bicg(nx, ny, a, s, q, p, r)\nimplicit none\n\nDATA_TYPE, dimension(ny, nx) :: a\nDATA_TYPE, dimension(nx) :: r\nDATA_TYPE, dimension(nx) :: q\nDATA_TYPE, dimension(ny) :: p\nDATA_TYPE, dimension(ny) :: s\ninteger :: nx,ny\ninteger :: i,j\n\n!$pragma scop\ndo i = 1, _PB_NY\ns(i) = 0.0D0\nend do\n\ndo i = 1, _PB_NX\nq(i) = 0.0D0\ndo j = 1, _PB_NY\ns(j) = s(j) + (r(i) * a(j, i))\nq(i) = q(i) + (a(j, i) * p(j))\nend do\nend do\n!$pragma endscop\nend subroutine