#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Function to check if there are close elements in the array\nbool has_close_elements(const std::vector<float>& numbers, int n, float threshold) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> a = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    int n = a.size();\n    if (!has_close_elements(a, n, 0.3)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, n, 0.05)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    a = {1.0, 2.0, 5.9, 4.0, 5.0};\n    n = a.size();\n    if (!has_close_elements(a, n, 0.95)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, n, 0.8)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    a = {1.0, 2.0, 3.0, 4.0, 5.0};\n    n = a.size();\n    if (!has_close_elements(a, n, 2.0)) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    a = {1.1, 2.2, 3.1, 4.1, 5.1};\n    n = a.size();\n    if (!has_close_elements(a, n, 1.0)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n    if (has_close_elements(a, n, 0.5)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `has_close_elements` function in both languages.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nbool below_zero(const std::vector<int>& operations) {\n    int num = 0;\n    for (int i = 0; i < operations.size(); ++i) {\n        num += operations[i];\n        if (num < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test cases\n    std::vector<int> operations;\n\n    // Test case 1: Empty vector\n    operations.clear();\n    if (below_zero(operations)!= false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2: All positive numbers\n    operations = {1, 2, -3, 1, 2, -3};\n    if (below_zero(operations)!= false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3: Mixed numbers with a positive sum\n    operations = {1, 2, -4, 5, 6};\n    if (below_zero(operations)!= true) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4: Mixed numbers with a negative sum\n    operations = {1, -1, 2, -2, 5, -5, 4, -4};\n    if (below_zero(operations)!= false) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5: Mixed numbers with a negative sum and a positive number\n    operations = {1, -1, 2, -2, 5, -5, 4, -5};\n    if (below_zero(operations)!= true) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 6: Mixed numbers with a negative sum and a positive number\n    operations = {1, -2, 2, -2, 5, -5, 4, -4};\n    if (below_zero(operations)!= true) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function to calculate the mean absolute deviation\ndouble mean_absolute_deviation(const std::vector<double>& numbers) {\n    int n = numbers.size();\n    double sum = 0.0;\n    for (int i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double avg = sum / n;\n\n    double msum = 0.0;\n    for (int i = 0; i < n; ++i) {\n        msum += std::abs(numbers[i] - avg);\n    }\n    return msum / n;\n}\n\n// Main function to test the mean absolute deviation function\nint main() {\n    // Test cases\n    std::vector<double> test1 = {1.0, 2.0, 3.0};\n    double result1 = mean_absolute_deviation(test1);\n    if (std::abs(result1 - 2.0/3.0) > 1e-4) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    std::vector<double> test2 = {1.0, 2.0, 3.0, 4.0};\n    double result2 = mean_absolute_deviation(test2);\n    if (std::abs(result2 - 1.0) > 1e-4) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    std::vector<double> test3 = {1.0, 2.0, 3.0, 4.0, 5.0};\n    double result3 = mean_absolute_deviation(test3);\n    if (std::abs(result3 - 6.0/5.0) > 1e-4) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid intersperse(const std::vector<int>& numbers, int delimeter, std::vector<int>& out) {\n    int n = numbers.size();\n    if (n == 0) {\n        out.clear();\n    } else {\n        out.resize(2 * n - 1);\n        out[0] = numbers[0];\n        for (int i = 1; i < n; ++i) {\n            out[2 * i - 2] = delimeter;\n            out[2 * i - 1] = numbers[i];\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n    int delimeter;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    intersperse(numbers, 7, result);\n    assert(issame(result, expected));\n\n    // Test case 2\n    numbers = {5, 6, 3, 2};\n    expected = {5, 8, 6, 8, 3, 8, 2};\n    intersperse(numbers, 8, result);\n    assert(issame(result, expected));\n\n    // Test case 3\n    numbers = {2, 2, 2};\n    expected = {2, 2, 2, 2, 2};\n    intersperse(numbers, 2, result);\n    assert(issame(result, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to parse nested parentheses and return the levels\nstd::vector<int> parse_nested_parens(const std::string& paren_string) {\n    int level = 0;\n    int max_level = 0;\n    std::vector<int> temp_levels(paren_string.length(), 0);\n    std::vector<int> all_levels;\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            ++level;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            --level;\n            if (level == 0) {\n                temp_levels[i] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n\n    // Filter out zeros and return the result\n    for (int lvl : temp_levels) {\n        if (lvl!= 0) all_levels.push_back(lvl);\n    }\n\n    return all_levels;\n}\n\n// Function to check if two vectors are identical\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::pair<std::string, std::vector<int>>> test_cases = {\n        {"(()()) ((())) () ((())()())", {2, 3, 1, 3}},\n        {"() (()) ((())) (((())))", {1, 2, 3, 4}},\n        {"(()(())((())))", {4}}\n    };\n\n    for (const auto& [paren_string, expected] : test_cases) {\n        auto result = parse_nested_parens(paren_string);\n        if (!issame(result, expected)) {\n            std::cerr << "Assertion failed for test case: " << paren_string << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <numeric> // For std::accumulate\n\nclass Utils {\npublic:\n    static std::vector<int> sum_product(const std::vector<int>& numbers) {\n        int sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n        int product = 1;\n        for (int num : numbers) {\n            product *= num;\n        }\n        return {sum, product};\n    }\n\n    static bool issame(const std::vector<int>& a, const std::vector<int>& b) {\n        if (a.size()!= b.size()) {\n            return false;\n        }\n        for (size_t i = 0; i < a.size(); ++i) {\n            if (a[i]!= b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    std::vector<int> empty_array; // Equivalent to an empty array in Fortran\n    std::vector<int> array1 = {1, 1, 1};\n    std::vector<int> array2 = {100, 0};\n    std::vector<int> array3 = {3, 5, 7};\n    std::vector<int> array4 = {10};\n\n    // Test cases\n    auto result = Utils::sum_product(empty_array);\n    if (!Utils::issame(result, {0, 1})) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    result = Utils::sum_product(array1);\n    if (!Utils::issame(result, {3, 1})) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    result = Utils::sum_product(array2);\n    if (!Utils::issame(result, {100, 0})) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    result = Utils::sum_product(array3);\n    if (!Utils::issame(result, {3 + 5 + 7, 3 * 5 * 7})) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    result = Utils::sum_product(array4);\n    if (!Utils::issame(result, {10, 10})) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n\nThis C++ code includes the `Utils` class with `sum_product` and `issame` static methods, which perform the same operations as the Fortran functions. The `main` function contains test cases to verify the correctness of the `sum_product` method.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid rolling_max(const std::vector<int>& numbers, std::vector<int>& out) {\n    out.clear();\n    int max = 0;\n    for (int num : numbers) {\n        if (num > max) max = num;\n        out.push_back(max);\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    rolling_max(numbers, result);\n    assert(issame(result, expected));\n\n    // Test case 2\n    numbers = {1, 2, 3, 4};\n    expected = {1, 2, 3, 4};\n    rolling_max(numbers, result);\n    assert(issame(result, expected));\n\n    // Test case 3\n    numbers = {4, 3, 2, 1};\n    expected = {4, 4, 4, 4};\n    rolling_max(numbers, result);\n    assert(issame(result, expected));\n\n    // Test case 4\n    numbers = {3, 2, 3, 100, 3};\n    expected = {3, 3, 3, 100, 100};\n    rolling_max(numbers, result);\n    assert(issame(result, expected));\n\n    return 0;\n}\n\nThis C++ code replicates the functionality of the original Fortran code, including the `rolling_max` subroutine and the `issame` function. The `assert` subroutine is also implemented to check the correctness of the results.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `rolling_max` function.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const std::string& str) {\n    std::string reversed_str = str;\n    std::reverse(reversed_str.begin(), reversed_str.end());\n    return str == reversed_str;\n}\n\n// Function to make a string palindrome\nstd::string make_palindrome(const std::string& str) {\n    std::string palindrome_str = str;\n    std::string rstr, nstr, n2str;\n\n    for (size_t i = 0; i < str.length(); ++i) {\n        rstr = str.substr(i);\n        if (is_palindrome(rstr)) {\n            nstr = str.substr(0, i);\n            std::reverse(nstr.begin(), nstr.end());\n            palindrome_str = str + nstr;\n            return palindrome_str;\n        }\n    }\n\n    n2str = str;\n    std::reverse(n2str.begin(), n2str.end());\n    palindrome_str = str + n2str;\n    return palindrome_str;\n}\n\n// Function to reverse a string\nstd::string reverse_string(const std::string& str) {\n    std::string reversed_str = str;\n    std::reverse(reversed_str.begin(), reversed_str.end());\n    return reversed_str;\n}\n\n// Function to assert the condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(make_palindrome("") == "");\n    assert(make_palindrome("x") == "x");\n    assert(make_palindrome("xyz") == "xyzyx");\n    assert(make_palindrome("xyx") == "xyx");\n    assert(make_palindrome("jerry") == "jerryrrej");\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(const std::string& a, const std::string& b) {\n    std::string result;\n    int min_len = std::min(a.length(), b.length());\n\n    for (int i = 0; i < min_len; ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n\n    if (a.length() > b.length()) {\n        result += a.substr(min_len);\n    } else if (b.length() > a.length()) {\n        result += b.substr(min_len);\n    }\n\n    return result;\n}\n\nint main() {\n    // Test cases\n    if (string_xor("111000", "101010")!= "010010") {\n        std::cerr << "Assertion failed: string_xor('111000', '101010')!= '010010'" << std::endl;\n        return 1;\n    }\n\n    if (string_xor("1", "1")!= "0") {\n        std::cerr << "Assertion failed: string_xor('1', '1')!= '0'" << std::endl;\n        return 1;\n    }\n\n    if (string_xor("0101", "0000")!= "0101") {\n        std::cerr << "Assertion failed: string_xor('0101', '0000')!= '0101'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to find the longest string in an array of strings\nstd::string longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) return "";\n\n    auto it = std::max_element(strings.begin(), strings.end(), [](const std::string& s1, const std::string& s2) {\n        return s1.length() < s2.length();\n    });\n\n    return *it;\n}\n\nint main() {\n    // Test case 1: Empty array\n    std::vector<std::string> strings1 = {};\n    std::string result = longest(strings1);\n    if (!result.empty()) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2: Array with single character strings\n    std::vector<std::string> strings2 = {"x", "y", "z"};\n    result = longest(strings2);\n    if (result!= "x") {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3: Array with varying length strings\n    std::vector<std::string> strings3 = {"x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "};\n    result = longest(strings3);\n    if (result!= "zzzz    ") {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\nnamespace gcd_module {\n\nint greatest_common_divisor(int a, int b) {\n    int temp_a = a;\n    int temp_b = b;\n\n    while (true) {\n        if (temp_a < temp_b) {\n            int m = temp_a;\n            temp_a = temp_b;\n            temp_b = m;\n        }\n        temp_a = temp_a % temp_b;\n        if (temp_a == 0) {\n            return temp_b;\n        }\n    }\n}\n\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\n} // namespace gcd_module\n\nint main() {\n    using namespace gcd_module;\n\n    assert(greatest_common_divisor(3, 7) == 1, "Assertion failed: gcd(3, 7) == 1");\n    assert(greatest_common_divisor(10, 15) == 5, "Assertion failed: gcd(10, 15) == 5");\n    assert(greatest_common_divisor(49, 14) == 7, "Assertion failed: gcd(49, 14) == 7");\n    assert(greatest_common_divisor(144, 60) == 12, "Assertion failed: gcd(144, 60) == 12");\n\n    return 0;\n}\n\nThis C++ code includes a namespace `gcd_module` that contains the `greatest_common_divisor` function and the `assert` subroutine, similar to the Fortran module. The `main` function uses these to perform assertions to verify the correctness of the `greatest_common_divisor` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid all_prefixes(const std::string& str, std::vector<std::string>& out) {\n    if (str.empty()) {\n        out.push_back("");\n        return;\n    }\n\n    for (size_t i = 0; i < str.size(); ++i) {\n        out.push_back(str.substr(0, i + 1));\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<std::string> prefixes;\n    std::vector<std::string> expected;\n\n    // Test cases\n    std::string str = "";\n    all_prefixes(str, prefixes);\n    expected = {""};\n    assert(issame(prefixes, expected));\n\n    str = "asdfgh";\n    all_prefixes(str, prefixes);\n    expected = {"a", "as", "asd", "asdf", "asdfg", "asdfgh"};\n    assert(issame(prefixes, expected));\n\n    str = "WWW";\n    all_prefixes(str, prefixes);\n    expected = {"W", "WW", "WWW"};\n    assert(issame(prefixes, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <sstream>\n\nstd::string string_sequence(int n) {\n    std::stringstream out;\n    out << "0";\n    for (int i = 1; i <= n; ++i) {\n        out << " " << i;\n    }\n    return out.str();\n}\n\nint main() {\n    // Test cases\n    std::string result = string_sequence(0);\n    if (result!= "0") {\n        std::cerr << "Assertion failed: string_sequence(0) == '0'" << std::endl;\n        return 1;\n    }\n\n    result = string_sequence(3);\n    if (result!= "0 1 2 3") {\n        std::cerr << "Assertion failed: string_sequence(3) == '0 1 2 3'" << std::endl;\n        return 1;\n    }\n\n    result = string_sequence(10);\n    if (result!= "0 1 2 3 4 5 6 7 8 9 10") {\n        std::cerr << "Assertion failed: string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nThis C++ code defines a `string_sequence` function that generates a string containing the numbers from 0 to `n`, similar to the Fortran version. The `main` function then tests this function with various inputs and checks the results against expected outputs, printing a message to indicate whether all tests passed or if an assertion failed.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `string_sequence` function for different input values.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n\n// Function to count distinct characters in a string\nint countDistinctCharacters(const std::string& str) {\n    std::string lowerStr = toLower(str);\n    std::vector<char> distinct;\n\n    for (char c : lowerStr) {\n        if (std::find(distinct.begin(), distinct.end(), c) == distinct.end()) {\n            distinct.push_back(c);\n        }\n    }\n\n    return distinct.size();\n}\n\n// Function to convert a string to lowercase\nstd::string toLower(const std::string& str) {\n    std::string lowerStr = str;\n    for (char& c : lowerStr) {\n        c = std::tolower(static_cast<unsigned char>(c));\n    }\n    return lowerStr;\n}\n\nint main() {\n    // Test cases\n    std::string str;\n    int result;\n\n    str = "";\n    result = countDistinctCharacters(str);\n    if (result!= 0) {\n        std::cerr << "Assertion failed: countDistinctCharacters('') == 0" << std::endl;\n        return 1;\n    }\n\n    str = "abcde";\n    result = countDistinctCharacters(str);\n    if (result!= 5) {\n        std::cerr << "Assertion failed: countDistinctCharacters('abcde') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "abcdecadeCADE";\n    result = countDistinctCharacters(str);\n    if (result!= 5) {\n        std::cerr << "Assertion failed: countDistinctCharacters('abcdecadeCADE') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "aaaaAAAAaaaa";\n    result = countDistinctCharacters(str);\n    if (result!= 1) {\n        std::cerr << "Assertion failed: countDistinctCharacters('aaaaAAAAaaaa') == 1" << std::endl;\n        return 1;\n    }\n\n    str = "Jerry jERRY JeRRRY";\n    result = countDistinctCharacters(str);\n    if (result!= 5) {\n        std::cerr << "Assertion failed: countDistinctCharacters('Jerry jERRY JeRRRY') == 5" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\nThis C++ program includes the `countDistinctCharacters` function to count the distinct characters in a string and the `toLower` function to convert a string to lowercase. The `main` function contains test cases to verify the correctness of the `countDistinctCharacters` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `count_distinct_characters` function in Fortran and the `countDistinctCharacters` function in C++.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::vector<int> parse_music(const std::string& music_string);\nvoid append(std::vector<int>& array, int value);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\nvoid assert_condition(bool condition);\n\nint main() {\n    // Test cases\n    assert_condition(issame(parse_music(""), std::vector<int>{}));\n    assert_condition(issame(parse_music("o o o o"), std::vector<int>{4, 4, 4, 4}));\n    assert_condition(issame(parse_music(".|.|.|.|"), std::vector<int>{1, 1, 1, 1}));\n    assert_condition(issame(parse_music("o| o|.|.| o o o o"), std::vector<int>{2, 2, 1, 1, 4, 4, 4, 4}));\n    assert_condition(issame(parse_music("o|.| o|.| o o| o o|"), std::vector<int>{2, 1, 2, 1, 4, 2, 4, 2}));\n\n    return 0;\n}\n\nstd::vector<int> parse_music(const std::string& music_string) {\n    std::vector<int> out;\n    std::string current = "";\n    std::string local_music_string = music_string;\n    int len_music = local_music_string.length();\n\n    if (len_music > 0) {\n        local_music_string +='';\n    }\n\n    for (char c : local_music_string) {\n        if (c =='') {\n            if (current == "o") {\n                append(out, 4);\n            } else if (current == "o|") {\n                append(out, 2);\n            } else if (current == ".|") {\n                append(out, 1);\n            }\n            current = "";\n        } else {\n            current += c;\n        }\n    }\n\n    std::cout << "Parsed music string: ";\n    for (int val : out) {\n        std::cout << val << " ";\n    }\n    std::cout << std::endl;\n\n    return out;\n}\n\nvoid append(std::vector<int>& array, int value) {\n    array.push_back(value);\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    std::cout << "Comparing arrays: ";\n    for (int val : a) {\n        std::cout << val << " ";\n    }\n    std::cout << " and ";\n    for (int val : b) {\n        std::cout << val << " ";\n    }\n    std::cout << " Result: true" << std::endl;\n\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n
#include <iostream>\n#include <string>\n\n// Function to count the number of times a substring occurs in a string\nint how_many_times(const std::string& str, const std::string& substring) {\n    int out = 0;\n    int str_len = str.length();\n    int sub_len = substring.length();\n\n    if (str_len == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i < str_len - sub_len + 1; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            ++out;\n        }\n    }\n\n    return out;\n}\n\n// Main function to run test cases\nint main() {\n    // Test cases\n    if (how_many_times("", "x")!= 0) {\n        std::cerr << "Assertion failed: how_many_times('', 'x') == 0" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("xyxyxyx", "x")!= 4) {\n        std::cerr << "Assertion failed: how_many_times('xyxyxyx', 'x') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("cacacacac", "cac")!= 4) {\n        std::cerr << "Assertion failed: how_many_times('cacacacac', 'cac') == 4" << std::endl;\n        return 1;\n    }\n\n    if (how_many_times("john doe", "john")!= 1) {\n        std::cerr << "Assertion failed: how_many_times('john doe', 'john') == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(const std::vector<float>& numbers) {\n    std::vector<float> out(2, 0.0f);\n    float min_diff = std::numeric_limits<float>::max();\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < min_diff) {\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n                min_diff = std::abs(numbers[i] - numbers[j]);\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        std::swap(out[0], out[1]);\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<float> test1 = {1.0f, 2.0f, 3.9f, 4.0f, 5.0f, 2.2f};\n    std::vector<float> test2 = {1.0f, 2.0f, 5.9f, 4.0f, 5.0f};\n    std::vector<float> test3 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f};\n    std::vector<float> test4 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f};\n    std::vector<float> test5 = {1.1f, 2.2f, 3.1f, 4.1f, 5.1f};\n\n    auto result = find_closest_elements(test1);\n    if (!issame(result, {3.9f, 4.0f})) {\n        std::cerr << "Assertion failed for test1" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test2);\n    if (!issame(result, {5.0f, 5.9f})) {\n        std::cerr << "Assertion failed for test2" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test3);\n    if (!issame(result, {2.0f, 2.2f})) {\n        std::cerr << "Assertion failed for test3" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test4);\n    if (!issame(result, {2.0f, 2.0f})) {\n        std::cerr << "Assertion failed for test4" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test5);\n    if (!issame(result, {2.2f, 3.1f})) {\n        std::cerr << "Assertion failed for test5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit tests for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Tests\n\nHere is the Fortran unit test code:\n\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n// Function declarations\nstd::vector<float> rescale_to_unit(const std::vector<float>& numbers);\nbool issame(const std::vector<float>& a, const std::vector<float>& b);\n\nint main() {\n    std::vector<std::pair<std::vector<float>, std::vector<float>>> testCases = {\n        {{2.0f, 49.9f}, {0.0f, 1.0f}},\n        {{100.0f, 49.9f}, {1.0f, 0.0f}},\n        {{1.0f, 2.0f, 3.0f, 4.0f, 5.0f}, {0.0f, 0.25f, 0.5f, 0.75f, 1.0f}},\n        {{2.0f, 1.0f, 5.0f, 3.0f, 4.0f}, {0.25f, 0.0f, 1.0f, 0.5f, 0.75f}},\n        {{12.0f, 11.0f, 15.0f, 13.0f, 14.0f}, {0.25f, 0.0f, 1.0f, 0.5f, 0.75f}}\n    };\n\n    for (const auto& testCase : testCases) {\n        auto numbers = testCase.first;\n        auto expected = testCase.second;\n        auto result = rescale_to_unit(numbers);\n\n        if (!issame(result, expected)) {\n            std::cerr << "Assertion failed for test case with numbers: ";\n            for (auto num : numbers) std::cerr << num << " ";\n            std::cerr << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << "All tests passed successfully" << std::endl;\n    return 0;\n}\n\nstd::vector<float> rescale_to_unit(const std::vector<float>& numbers) {\n    std::vector<float> rescaled(numbers.size());\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return rescaled;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size()!= b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4) return false;\n    }\n\n    return true;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function to get the length of a string\nint strlen(const std::string& str) {\n    return str.length();\n}\n\n// Subroutine to run assertions\nvoid run_assertions() {\n    // Assertions\n    if (strlen("")!= 0) {\n        std::cerr << "Assertion failed: strlen("") == 0" << std::endl;\n        exit(1);\n    }\n\n    if (strlen("x")!= 1) {\n        std::cerr << "Assertion failed: strlen("x") == 1" << std::endl;\n        exit(1);\n    }\n\n    if (strlen("asdasnakj")!= 9) {\n        std::cerr << "Assertion failed: strlen("asdasnakj") == 9" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nint main() {\n    // Main program logic\n    run_assertions();\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_divisor(int n) {\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    // Test cases\n    if (largest_divisor(3)!= 1) {\n        std::cerr << "Assertion failed: largest_divisor(3) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_divisor(7)!= 1) {\n        std::cerr << "Assertion failed: largest_divisor(7) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_divisor(10)!= 5) {\n        std::cerr << "Assertion failed: largest_divisor(10) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_divisor(100)!= 50) {\n        std::cerr << "Assertion failed: largest_divisor(100) == 50" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_divisor(49)!= 7) {\n        std::cerr << "Assertion failed: largest_divisor(49) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nvoid factorize(int n, std::vector<int>& out) {\n    int m = n;\n    int count = 0;\n\n    while (m > 1) {\n        for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(m))); ++i) {\n            if (m % i == 0) {\n                m /= i;\n                out.push_back(i);\n                break;\n            }\n        }\n    }\n\n    if (m > 1) {\n        out.push_back(m);\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> factors;\n\n    factorize(2, factors);\n    if (!issame(factors, {2})) {\n        std::cerr << "Assertion failed for factorize(2)" << std::endl;\n        return 1;\n    }\n\n    factorize(4, factors);\n    if (!issame(factors, {2, 2})) {\n        std::cerr << "Assertion failed for factorize(4)" << std::endl;\n        return 1;\n    }\n\n    factorize(8, factors);\n    if (!issame(factors, {2, 2, 2})) {\n        std::cerr << "Assertion failed for factorize(8)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19, factors);\n    if (!issame(factors, {3, 19})) {\n        std::cerr << "Assertion failed for factorize(3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19, factors);\n    if (!issame(factors, {3, 3, 19, 19})) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 3 * 19 * 3 * 19, factors);\n    if (!issame(factors, {3, 3, 3, 19, 19, 19})) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 19 * 19 * 19, factors);\n    if (!issame(factors, {3, 19, 19, 19})) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 19 * 19)" << std::endl;\n        return 1;\n    }\n\n    factorize(3 * 2 * 3, factors);\n    if (!issame(factors, {2, 3, 3})) {\n        std::cerr << "Assertion failed for factorize(3 * 2 * 3)" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> remove_duplicates(const std::vector<int>& numbers) {\n    std::vector<int> has1;\n    std::vector<int> has2;\n    std::vector<int> out;\n\n    if (numbers.empty()) return out;\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int val : has2) {\n            if (val == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) continue;\n\n        found = false;\n        for (int val : has1) {\n            if (val == num) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            has2.push_back(num);\n        } else {\n            has1.push_back(num);\n        }\n    }\n\n    for (int num : numbers) {\n        bool found = false;\n        for (int val : has2) {\n            if (val == num) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            out.push_back(num);\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(issame(remove_duplicates({1, 2, 3, 4}), {1, 2, 3, 4}));\n    assert(issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5}));\n    assert(issame(remove_duplicates({}), {}));\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n\nstd::string flip_case(const std::string& str) {\n    std::string out = "";\n    for (char w : str) {\n        if (std::islower(w)) {\n            out += std::toupper(w);\n        } else if (std::isupper(w)) {\n            out += std::tolower(w);\n        } else {\n            out += w;\n        }\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(flip_case("") == "");\n    assert(flip_case("Hello!") == "hELLO!");\n    assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n\n    return 0;\n}\n\nThis C++ code includes the necessary headers and uses the standard library functions to achieve the same functionality as the Fortran code. The `flip_case` function iterates through each character of the input string and converts it to the opposite case, using `std::toupper` and `std::tolower` for conversion. The `assert` function checks the condition and prints an error message if the condition is false, similar to the Fortran version.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `flip_case` function.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\nint main() {\n    // Test with an empty array\n    {\n        std::vector<std::string> strings;\n        std::string result = concatenate(strings);\n        if (result!= "") {\n            std::cerr << "Assertion failed: concatenate([]) /= ''" << std::endl;\n            exit(1);\n        }\n    }\n\n    // Test with an array of strings\n    {\n        std::vector<std::string> strings = {"x", "y", "z"};\n        std::string result = concatenate(strings);\n        if (result!= "xyz") {\n            std::cerr << "Assertion failed: concatenate(['x', 'y', 'z']) /= 'xyz'" << std::endl;\n            exit(1);\n        }\n    }\n\n    // Test with a larger array of strings\n    {\n        std::vector<std::string> strings = {"x", "y", "z", "w", "k"};\n        std::string result = concatenate(strings);\n        if (result!= "xyzwk") {\n            std::cerr << "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) /= 'xyzwk'" << std::endl;\n            exit(1);\n        }\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n\n// Function to filter strings by a prefix\nstd::vector<std::string> filter_by_prefix(const std::vector<std::string>& strings, const std::string& prefix) {\n    std::vector<std::string> out;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            out.push_back(str);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors of strings are identical\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\nvoid test_cases() {\n    // Test case 1\n    std::vector<std::string> strings1 = {};\n    std::string prefix1 = "john";\n    auto result1 = filter_by_prefix(strings1, prefix1);\n    if (!issame(result1, strings1)) {\n        std::cerr << "Assertion failed: filter_by_prefix({}, 'john')" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2\n    std::vector<std::string> strings2 = {"xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "};\n    std::string prefix2 = "xxx";\n    auto result2 = filter_by_prefix(strings2, prefix2);\n    std::vector<std::string> expected2 = {"xxx     ", "xxxAAA  ", "xxx     "};\n    if (!issame(result2, expected2)) {\n        std::cerr << "Assertion failed: filter_by_prefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    test_cases();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Function to get positive numbers from a vector\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> out;\n    for (float num : l) {\n        if (num > 0.0f) {\n            out.push_back(num);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are identical\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4f) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> input = {-1.0f, -2.0f, 4.0f, 5.0f, 6.0f};\n    std::vector<float> expected = {4.0f, 5.0f, 6.0f};\n    std::vector<float> result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    input = {5.0f, 3.0f, -5.0f, 2.0f, 3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n    expected = {5.0f, 3.0f, 2.0f, 3.0f, 3.0f, 9.0f, 123.0f, 1.0f};\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    input = {-1.0f, -2.0f};\n    expected.clear(); // Clear the expected vector\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    input.clear(); // Clear the input vector\n    expected.clear(); // Clear the expected vector\n    result = get_positive(input);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) {\n        return false;\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Main function to test the is_prime function\nint main() {\n    // Assertions to test the is_prime function\n    if (is_prime(6)!= false) {\n        std::cerr << "Assertion failed: is_prime(6) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(101)!= true) {\n        std::cerr << "Assertion failed: is_prime(101) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(11)!= true) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(13441)!= true) {\n        std::cerr << "Assertion failed: is_prime(13441) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(61)!= true) {\n        std::cerr << "Assertion failed: is_prime(61) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(4)!= false) {\n        std::cerr << "Assertion failed: is_prime(4) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(1)!= false) {\n        std::cerr << "Assertion failed: is_prime(1) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(5)!= true) {\n        std::cerr << "Assertion failed: is_prime(5) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(11)!= true) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(17)!= true) {\n        std::cerr << "Assertion failed: is_prime(17) == true" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(5 * 17)!= false) {\n        std::cerr << "Assertion failed: is_prime(5 * 17) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(11 * 7)!= false) {\n        std::cerr << "Assertion failed: is_prime(11 * 7) == false" << std::endl;\n        return 1;\n    }\n\n    if (is_prime(13441 * 19)!= false) {\n        std::cerr << "Assertion failed: is_prime(13441 * 19) == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `is_prime` function by checking various inputs.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nclass PolynomialModule {\npublic:\n    // Define the poly function\n    static double poly(const std::vector<double>& xs, int n, double x) {\n        double sum = 0.0;\n        for (int i = 0; i < n; ++i) {\n            sum += xs[i] * std::pow(x, i);\n        }\n        return sum;\n    }\n\n    // Define the find_zero function\n    static double find_zero(const std::vector<double>& xs, int n) {\n        double ans = 0.0;\n        double value = poly(xs, n, ans);\n        while (std::abs(value) > 1e-6) {\n            double driv = 0.0;\n            for (int i = 1; i < n; ++i) {\n                driv += xs[i] * i * std::pow(ans, i - 1);\n            }\n            ans -= value / driv;\n            value = poly(xs, n, ans);\n        }\n        return ans;\n    }\n};\n\nint main() {\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i < 100; ++i) {\n        int ncoeff = 2 * (1 + std::rand() % 4);\n        std::vector<double> coeffs(ncoeff);\n\n        for (int j = 0; j < ncoeff; ++j) {\n            coeffs[j] = -10 + std::rand() % 21;\n            if (coeffs[j] == 0) coeffs[j] = 1;\n        }\n\n        double solution = PolynomialModule::find_zero(coeffs, ncoeff);\n        if (std::abs(PolynomialModule::poly(coeffs, ncoeff, solution)) >= 1e-3) {\n            std::cerr << "Assertion failed: abs(poly(coeffs, solution)) < 1e-3" << std::endl;\n            std::exit(1);\n        }\n    }\n\n    return 0;\n}\n\nThis C++ code includes the `PolynomialModule` class with the `poly` and `find_zero` functions, similar to the Fortran module. The `main` function generates random polynomial coefficients and uses the `find_zero` function to find a zero of the polynomial, then checks if the result is correct. If the result is not correct, it prints an error message and exits with a non-zero status.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `poly` and `find_zero` functions by comparing their outputs against expected values.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> sort_third(const std::vector<int>& l) {\n    std::vector<int> third;\n    std::vector<int> out(l.size());\n\n    // Extract every third element\n    for (size_t i = 0; i < third.size(); ++i) {\n        third[i] = l[i * 3];\n    }\n\n    // Sort the third array\n    std::sort(third.begin(), third.end());\n\n    // Reconstruct the output array\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert_condition(issame(sort_third({1, 2, 3}), sort_third({1, 2, 3})));\n    assert_condition(issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}),\n                           sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert_condition(issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}),\n                           sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert_condition(issame(sort_third({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5}));\n    assert_condition(issame(sort_third({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5}));\n    assert_condition(issame(sort_third({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5}));\n    assert_condition(issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to remove duplicates from an array\nstd::vector<int> unique(const std::vector<int>& l) {\n    std::vector<int> temp;\n    for (int num : l) {\n        if (std::find(temp.begin(), temp.end(), num) == temp.end()) {\n            temp.push_back(num);\n        }\n    }\n    return temp;\n}\n\n// Function to sort an array\nvoid sort(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to check if two arrays are identical\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Input array\n    std::vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    // Expected result\n    std::vector<int> expected = {0, 2, 3, 5, 9, 123};\n\n    // Call the unique function\n    std::vector<int> result = unique(input);\n\n    // Check if the result is the same as expected\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: result is not as expected" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function to find the maximum element in the array\nfloat max_element(const std::vector<float>& arr) {\n    float max_val = -10000.0f;\n    for (float val : arr) {\n        if (max_val < val) max_val = val;\n    }\n    return max_val;\n}\n\nint main() {\n    // Test case 1\n    std::vector<float> arr1 = {1.0f, 2.0f, 3.0f};\n    float result1 = max_element(arr1);\n    if (std::abs(result1 - 3.0f) > 1e-4) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    std::vector<float> arr2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 124.0f, 1.0f, -10.0f};\n    float result2 = max_element(arr2);\n    if (std::abs(result2 - 124.0f) > 1e-4) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n\nThis C++ code defines a function `max_element` that takes a vector of floats as input and returns the maximum element in the vector. The `main` function then tests this function with two different vectors and checks if the results match the expected values, printing "All tests passed" if both tests pass.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cstdlib>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count++;\n                q /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assert(fizz_buzz(50) == 0, "fizz_buzz(50) == 0: assertion failed");\n    assert(fizz_buzz(78) == 2, "fizz_buzz(78) == 2: assertion failed");\n    assert(fizz_buzz(79) == 3, "fizz_buzz(79) == 3: assertion failed");\n    assert(fizz_buzz(100) == 3, "fizz_buzz(100) == 3: assertion failed");\n    assert(fizz_buzz(200) == 6, "fizz_buzz(200) == 6: assertion failed");\n    assert(fizz_buzz(4000) == 192, "fizz_buzz(4000) == 192: assertion failed");\n    assert(fizz_buzz(10000) == 639, "fizz_buzz(10000) == 639: assertion failed");\n    assert(fizz_buzz(100000) == 8026, "fizz_buzz(100000) == 8026: assertion failed");\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<float> sort_even(const std::vector<float>& l) {\n    std::vector<float> out(l.size()), even;\n    int n = l.size();\n\n    // Extract even-indexed elements\n    for (int i = 0; i < (n + 1) / 2; ++i) {\n        even.push_back(l[2 * i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even.begin(), even.end());\n\n    // Merge sorted even-indexed elements back into the output array\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\nvoid sort_array(std::vector<float>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[i] > arr[j]) {\n                std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid run_tests() {\n    // Test case 1\n    std::vector<float> l = {1.0, 2.0, 3.0};\n    std::vector<float> expected = {1.0, 2.0, 3.0};\n    std::vector<float> result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 2\n    l = {5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    expected = {-10.0, 3.0, -5.0, 2.0, -3.0, 3.0, 5.0, 0.0, 9.0, 1.0, 123.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        exit(1);\n    }\n\n    // Test case 3\n    l = {5.0, 8.0, -12.0, 4.0, 23.0, 2.0, 3.0, 11.0, 12.0, -10.0};\n    expected = {-12.0, 8.0, 3.0, 4.0, 5.0, 2.0, 12.0, 11.0, 23.0, -10.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint car_race_collision(int n);\n\nint main() {\n    // Assertions\n    if (car_race_collision(2)!= 4) {\n        std::cerr << "Assertion failed: car_race_collision(2) == 4" << std::endl;\n        exit(1);\n    }\n\n    if (car_race_collision(3)!= 9) {\n        std::cerr << "Assertion failed: car_race_collision(3) == 9" << std::endl;\n        exit(1);\n    }\n\n    if (car_race_collision(4)!= 16) {\n        std::cerr << "Assertion failed: car_race_collision(4) == 16" << std::endl;\n        exit(1);\n    }\n\n    if (car_race_collision(8)!= 64) {\n        std::cerr << "Assertion failed: car_race_collision(8) == 64" << std::endl;\n        exit(1);\n    }\n\n    if (car_race_collision(10)!= 100) {\n        std::cerr << "Assertion failed: car_race_collision(10) == 100" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint car_race_collision(int n) {\n    return n * n;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\nTo create a unit test in Fortran, we can use a simple approach by adding a test subroutine in the program. Fortran does not have a built-in unit testing framework like some other languages, so we'll manually check the conditions and print the results.\n\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For std::exit\n\nstd::vector<int> incr_list(const std::vector<int>& l) {\n    std::vector<int> res(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        res[i] = l[i] + 1;\n    }\n    return res;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> l1;\n    std::vector<int> expected1;\n    std::vector<int> result1 = incr_list(l1);\n    if (!issame(result1, expected1)) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    std::vector<int> l2 = {3, 2, 1};\n    std::vector<int> expected2 = {4, 3, 2};\n    std::vector<int> result2 = incr_list(l2);\n    if (!issame(result2, expected2)) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    std::vector<int> l3 = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    std::vector<int> expected3 = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    std::vector<int> result3 = incr_list(l3);\n    if (!issame(result3, expected3)) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n\n// Function to check if any pair of elements in the vector sums to zero\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test cases\n    std::vector<int> l1 = {1, 3, 5, 0};\n    if (pairs_sum_to_zero(l1)!= false) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l2 = {1, 3, -2, 1};\n    if (pairs_sum_to_zero(l2)!= false) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l3 = {1, 2, 3, 7};\n    if (pairs_sum_to_zero(l3)!= false) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l4 = {2, 4, -5, 3, 5, 7};\n    if (pairs_sum_to_zero(l4)!= true) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l5 = {1};\n    if (pairs_sum_to_zero(l5)!= false) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l6 = {-3, 9, -1, 3, 2, 30};\n    if (pairs_sum_to_zero(l6)!= true) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l7 = {-3, 9, -1, 3, 2, 31};\n    if (pairs_sum_to_zero(l7)!= true) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l8 = {-3, 9, -1, 4, 2, 30};\n    if (pairs_sum_to_zero(l8)!= false) {\n        std::cerr << "Test case 8 failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> l9 = {-3, 9, -1, 4, 2, 31};\n    if (pairs_sum_to_zero(l9)!= false) {\n        std::cerr << "Test case 9 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function to change base\nstd::string change_base(int x, int base) {\n    std::string out = "";\n    int temp_x = x;\n    while (temp_x > 0) {\n        int remainder = temp_x % base;\n        out = std::to_string(remainder) + out;\n        temp_x = temp_x / base;\n    }\n    return out;\n}\n\n// Integer to string conversion function\nstd::string itoa(int num) {\n    return std::to_string(num);\n}\n\nint main() {\n    // Assertions\n    if (change_base(8, 3)!= "22") {\n        std::cerr << "Assertion failed: change_base(8, 3) == '22'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(9, 3)!= "100") {\n        std::cerr << "Assertion failed: change_base(9, 3) == '100'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(234, 2)!= "11101010") {\n        std::cerr << "Assertion failed: change_base(234, 2) == '11101010'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(16, 2)!= "10000") {\n        std::cerr << "Assertion failed: change_base(16, 2) == '10000'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(8, 2)!= "1000") {\n        std::cerr << "Assertion failed: change_base(8, 2) == '1000'" << std::endl;\n        std::exit(1);\n    }\n    if (change_base(7, 2)!= "111") {\n        std::cerr << "Assertion failed: change_base(7, 2) == '111'" << std::endl;\n        std::exit(1);\n    }\n\n    for (int x = 2; x <= 7; ++x) {\n        if (change_base(x, x + 1)!= itoa(x)) {\n            std::cerr << "Assertion failed: change_base(" << x << ", " << x + 1 << ") == " << x << std::endl;\n            std::exit(1);\n        }\n    }\n\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `change_base` and `itoa` functions.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function to calculate the area of a triangle\nfloat triangle_area(float a, float h) {\n    return (a * h) * 0.5f;\n}\n\nint main() {\n    // Test cases\n    float result;\n\n    result = triangle_area(5.0f, 3.0f);\n    if (std::abs(result - 7.5f) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(5, 3) should be 7.5" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(2.0f, 2.0f);\n    if (std::abs(result - 2.0f) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(2, 2) should be 2.0" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(10.0f, 8.0f);\n    if (std::abs(result - 40.0f) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(10, 8) should be 40.0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n\nThis C++ code includes the necessary headers and uses the `std::abs` function for floating-point comparison, similar to the Fortran code. The `std::cerr` stream is used for error output, and `std::exit(1)` is called to terminate the program with an error status if any test fails.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `triangle_area` function.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cassert>\n\n// Function declaration\nint fib4(int n);\n\nint main() {\n    // Assertions\n    assert(fib4(5) == 4);\n    std::cout << "fib4(5) == 4: passed" << std::endl;\n\n    assert(fib4(8) == 28);\n    std::cout << "fib4(8) == 28: passed" << std::endl;\n\n    assert(fib4(10) == 104);\n    std::cout << "fib4(10) == 104: passed" << std::endl;\n\n    assert(fib4(12) == 386);\n    std::cout << "fib4(12) == 386: passed" << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint fib4(int n) {\n    int f[100]; // Array to store the sequence\n    int i;\n\n    // Initialize the first four elements\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n\n    // Compute the sequence\n    for (i = 4; i <= n; ++i) {\n        f[i] = f[i-1] + f[i-2] + f[i-3] + f[i-4];\n    }\n\n    return f[n];\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to sort the array\nvoid sort(std::vector<float>& arr) {\n    for (size_t i = 0; i < arr.size() - 1; ++i) {\n        for (size_t j = i + 1; j < arr.size(); ++j) {\n            if (arr[i] > arr[j]) {\n                std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n}\n\n// Function to find the median of the array\nfloat median(const std::vector<float>& arr) {\n    std::vector<float> sorted_arr = arr;\n    sort(sorted_arr);\n    size_t n = sorted_arr.size();\n\n    if (n % 2 == 1) {\n        return sorted_arr[(n + 1) / 2 - 1];\n    } else {\n        return 0.5f * (sorted_arr[n / 2 - 1] + sorted_arr[n / 2]);\n    }\n}\n\n// Main function to test the median function\nint main() {\n    // Test cases\n    std::vector<float> test_case1 = {3.0f, 1.0f, 2.0f, 4.0f, 5.0f};\n    std::vector<float> test_case2 = {-10.0f, 4.0f, 6.0f, 1000.0f, 10.0f, 20.0f};\n    std::vector<float> test_case3 = {5.0f};\n    std::vector<float> test_case4 = {6.0f, 5.0f};\n    std::vector<float> test_case5 = {8.0f, 1.0f, 3.0f, 9.0f, 9.0f, 2.0f, 7.0f};\n\n    float result;\n\n    result = median(test_case1);\n    if (std::abs(result - 3.0f) > 1e-4) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = median(test_case2);\n    if (std::abs(result - 8.0f) > 1e-4) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = median(test_case3);\n    if (std::abs(result - 5.0f) > 1e-4) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = median(test_case4);\n    if (std::abs(result - 5.5f) > 1e-4) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = median(test_case5);\n    if (std::abs(result - 7.0f) > 1e-4) {\n        std::cerr << "Test case 5 failed: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const std::string& text) {\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n\n// Main function to test the is_palindrome function\nint main() {\n    // Test cases\n    if (!is_palindrome("")) {\n        std::cerr << "Assertion failed: is_palindrome('') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aba")) {\n        std::cerr << "Assertion failed: is_palindrome('aba') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        std::cerr << "Assertion failed: is_palindrome('aaaaa') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("zbcd")) {\n        std::cerr << "Assertion failed: is_palindrome('zbcd') == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyx') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywyz")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyz') == false" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywzx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywzx') == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint modp(int n, int p);\n\nint main() {\n    // Assertions\n    if (modp(3, 5)!= 3) {\n        std::cerr << "modp(3, 5) == 3: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (modp(1101, 101)!= 2) {\n        std::cerr << "modp(1101, 101) == 2: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (modp(0, 101)!= 1) {\n        std::cerr << "modp(0, 101) == 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (modp(3, 11)!= 8) {\n        std::cerr << "modp(3, 11) == 8: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (modp(100, 101)!= 1) {\n        std::cerr << "modp(100, 101) == 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (modp(30, 5)!= 4) {\n        std::cerr << "modp(30, 5) == 4: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (modp(31, 5)!= 3) {\n        std::cerr << "modp(31, 5) == 3: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint modp(int n, int p) {\n    int result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n\nstd::string encode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = (s[i] - 'a' + 5) % 26 + 'a';\n        out[i] = static_cast<char>(w);\n    }\n    return out;\n}\n\nstd::string decode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = (s[i] - 'a' + 21) % 26 + 'a';\n        out[i] = static_cast<char>(w);\n    }\n    return out;\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i < 100; ++i) {\n        int l = 10 + std::rand() % 11;\n        std::string str = "";\n        for (int j = 0; j < l; ++j) {\n            char chr = static_cast<char>('a' + std::rand() % 26);\n            str += chr;\n        }\n\n        std::string encoded_str = encode_shift(str);\n        std::string decoded_str = decode_shift(encoded_str);\n\n        if (decoded_str!= str) {\n            std::cerr << "Assertion failed: decoded string does not match original" << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nThis C++ code performs the same operations as the provided Fortran code. It includes the `encode_shift` and `decode_shift` functions to shift the characters of a string by 5 and 21 positions respectively, and a main function that generates random strings, encodes them, decodes them, and checks if the decoded string matches the original string.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `encode_shift` and `decode_shift` functions.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_encode_decode_shift.f90`:\n\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string remove_vowels(const std::string& text) {\n    std::string out = "";\n    std::string vowels = "AEIOUaeiou";\n    size_t len_text = text.length();\n    size_t len_vowels = vowels.length();\n\n    for (size_t i = 0; i < len_text; ++i) {\n        bool is_vowel = false;\n        for (size_t j = 0; j < len_vowels; ++j) {\n            if (text[i] == vowels[j]) {\n                is_vowel = true;\n                break;\n            }\n        }\n        if (!is_vowel) {\n            out += text[i];\n        }\n    }\n    return out;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(remove_vowels("") == "");\n    assert(remove_vowels("abcdef//nghijklm") == "bcdf//nghjklm");\n    assert(remove_vowels("fedcba") == "fdcb");\n    assert(remove_vowels("eeeee") == "");\n    assert(remove_vowels("acBAA") == "cB");\n    assert(remove_vowels("EcBOO") == "cB");\n    assert(remove_vowels("ybcd") == "ybcd");\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function prototype\nbool below_threshold(const std::vector<int>& l, int t);\n\nint main() {\n    // Test cases\n    std::vector<int> l;\n    int t;\n\n    // Test 1\n    l = {1, 2, 4, 10};\n    t = 100;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << std::endl;\n        exit(1);\n    }\n\n    // Test 2\n    l = {1, 20, 4, 10};\n    t = 5;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << std::endl;\n        exit(1);\n    }\n\n    // Test 3\n    l = {1, 20, 4, 10};\n    t = 21;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << std::endl;\n        exit(1);\n    }\n\n    // Test 4\n    l = {1, 20, 4, 10};\n    t = 22;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << std::endl;\n        exit(1);\n    }\n\n    // Test 5\n    l = {1, 8, 4, 10};\n    t = 11;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << std::endl;\n        exit(1);\n    }\n\n    // Test 6\n    l = {1, 8, 4, 10};\n    t = 10;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}\n\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n#include <ctime> // For srand() and rand()\n\n// Function prototype\nint add(int x, int y);\n\nint main() {\n    int i, x, y;\n    float rand_val;\n\n    // Assertions\n    if (add(0, 1)!= 1) {\n        std::cerr << "Assertion failed: add(0, 1) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (add(1, 0)!= 1) {\n        std::cerr << "Assertion failed: add(1, 0) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (add(2, 3)!= 5) {\n        std::cerr << "Assertion failed: add(2, 3) == 5" << std::endl;\n        exit(1);\n    }\n\n    if (add(5, 7)!= 12) {\n        std::cerr << "Assertion failed: add(5, 7) == 12" << std::endl;\n        exit(1);\n    }\n\n    if (add(7, 5)!= 12) {\n        std::cerr << "Assertion failed: add(7, 5) == 12" << std::endl;\n        exit(1);\n    }\n\n    // Loop with random number generation and assertions\n    srand(static_cast<unsigned>(time(nullptr))); // Initialize random number generator\n    for (i = 1; i <= 100; ++i) {\n        rand_val = static_cast<float>(rand()) / RAND_MAX;\n        x = static_cast<int>(rand_val * 1000);\n        rand_val = static_cast<float>(rand()) / RAND_MAX;\n        y = static_cast<int>(rand_val * 1000);\n        if (add(x, y)!= x + y) {\n            std::cerr << "Assertion failed: add(" << x << ", " << y << ") == " << x + y << std::endl;\n            exit(1);\n        }\n    }\n\n    return 0;\n}\n\n// Function definition\nint add(int x, int y) {\n    return x + y;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function prototype\nbool same_chars(const std::string& s0, const std::string& s1);\n\nint main() {\n    bool result;\n\n    // Test cases\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddeddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("abcd", "dddddddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabc') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("dddddddabc", "abcd");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('dddddddabc', 'abcd') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("eabcd", "dddddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcd', 'dddddddabc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("abcd", "dddddddabcf");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabcf') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = same_chars("aabb", "aaccc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('aabb', 'aaccc') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n\n// Function definition\nbool same_chars(const std::string& s0, const std::string& s1) {\n    for (char c : s0) {\n        if (s1.find(c) == std::string::npos) {\n            return false;\n        }\n    }\n\n    for (char c : s1) {\n        if (s0.find(c) == std::string::npos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\nint fib(int n) {\n    int f[1000];\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = f[i-1] + f[i-2];\n    }\n    return f[n];\n}\n\nint main() {\n    // Test cases\n    if (fib(10)!= 55) {\n        std::cerr << "fib(10) == 55: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (fib(1)!= 1) {\n        std::cerr << "fib(1) == 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (fib(8)!= 21) {\n        std::cerr << "fib(8) == 21: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (fib(11)!= 89) {\n        std::cerr << "fib(11) == 89: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (fib(12)!= 144) {\n        std::cerr << "fib(12) == 144: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n\nThis C++ program defines a `fib` function that calculates the nth Fibonacci number using a dynamic array to store the Fibonacci numbers up to the given `n`. It then checks the correctness of the `fib` function against several test cases, similar to the Fortran program. If any test case fails, it prints an error message and exits with a non-zero status. If all tests pass, it prints a success message.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `fib` function for various input values.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to check if the array is monotonic\nbool is_monotonic(const std::vector<float>& l) {\n    bool incr = false;\n    bool decr = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            incr = true;\n        } else if (l[i] < l[i - 1]) {\n            decr = true;\n        }\n    }\n\n    return!(incr && decr);\n}\n\n// Main function to run test cases\nint main() {\n    std::vector<float> l;\n\n    // Test cases\n    l = {1.0, 2.0, 4.0, 10.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 4, 10} should be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {1.0, 2.0, 4.0, 20.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 4, 20} should be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {1.0, 20.0, 4.0, 10.0};\n    if (is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 20, 4, 10} should not be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {4.0, 1.0, 0.0, -10.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {4, 1, 0, -10} should be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {4.0, 1.0, 1.0, 0.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {4, 1, 1, 0} should be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {1.0, 2.0, 3.0, 2.0, 5.0, 60.0};\n    if (is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 3, 2, 5, 60} should not be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {1.0, 2.0, 3.0, 4.0, 5.0, 60.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {1, 2, 3, 4, 5, 60} should be monotonic" << std::endl;\n        exit(1);\n    }\n\n    l = {9.0, 9.0, 9.0, 9.0};\n    if (!is_monotonic(l)) {\n        std::cerr << "Assertion failed: {9, 9, 9, 9} should be monotonic" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass CommonModule {\npublic:\n    static void common(const std::vector<int>& l1, const std::vector<int>& l2, std::vector<int>& out) {\n        std::vector<int> temp(l1.size());\n        int n = 0;\n\n        for (size_t i = 0; i < l1.size(); ++i) {\n            bool found = false;\n            for (int j = 0; j < n; ++j) {\n                if (temp[j] == l1[i]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                if (std::any_of(l2.begin(), l2.end(), [l1, i](int val) { return val == l1[i]; })) {\n                    temp[n] = l1[i];\n                    ++n;\n                }\n            }\n        }\n\n        if (n > 0) {\n            std::sort(temp.begin(), temp.begin() + n);\n            out.resize(n);\n            std::copy(temp.begin(), temp.begin() + n, out.begin());\n        } else {\n            out.clear();\n        }\n    }\n\n    static bool issame(const std::vector<int>& a, const std::vector<int>& b) {\n        if (a.size()!= b.size()) {\n            return false;\n        }\n\n        for (size_t i = 0; i < a.size(); ++i) {\n            if (a[i]!= b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    std::vector<int> l1, l2, result, expected;\n\n    // Test case 1\n    l1 = {1, 4, 3, 34, 653, 2, 5};\n    l2 = {5, 7, 1, 5, 9, 653, 121};\n    expected = {1, 5, 653};\n    CommonModule::common(l1, l2, result);\n    if (!CommonModule::issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    l1 = {5, 3, 2, 8};\n    l2 = {3, 2};\n    expected = {2, 3};\n    CommonModule::common(l1, l2, result);\n    if (!CommonModule::issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    l1 = {4, 3, 2, 8};\n    l2 = {3, 2, 4};\n    expected = {2, 3, 4};\n    CommonModule::common(l1, l2, result);\n    if (!CommonModule::issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    l1 = {4, 3, 2, 8};\n    l2.clear();\n    expected.clear();\n    CommonModule::common(l1, l2, result);\n    if (!CommonModule::issame(result, expected)) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n\nThis C++ code replicates the functionality of the original Fortran code, including the `common` subroutine and the `issame` function. The `common` function in C++ uses `std::vector` for dynamic arrays and `std::any_of` for checking if any element in `l2` matches the current element in `l1`. The `issame` function checks if two vectors are identical.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_prime_factor(int n) {\n    int num = n;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        while (num % i == 0 && num > i) {\n            num /= i;\n        }\n    }\n    return num;\n}\n\nint main() {\n    // Assertions\n    if (largest_prime_factor(15)!= 5) {\n        std::cerr << "Assertion failed: largest_prime_factor(15) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(27)!= 3) {\n        std::cerr << "Assertion failed: largest_prime_factor(27) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(63)!= 7) {\n        std::cerr << "Assertion failed: largest_prime_factor(63) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(330)!= 11) {\n        std::cerr << "Assertion failed: largest_prime_factor(330) == 11" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(13195)!= 29) {\n        std::cerr << "Assertion failed: largest_prime_factor(13195) == 29" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nThis C++ code includes the same logic as the Fortran code you provided. It defines a function `largest_prime_factor` that calculates the largest prime factor of a given number and uses assertions to verify the correctness of the function with predefined inputs and expected outputs. The `std::sqrt` function is used to calculate the square root of a number, and the `std::exit` function is used to terminate the program with an error code if an assertion fails.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `largest_prime_factor` function with various inputs.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint sum_to_n(int n);\n\nint main() {\n    // Assertions\n    if (sum_to_n(1)!= 1) {\n        std::cerr << "sum_to_n(1) == 1: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (sum_to_n(6)!= 21) {\n        std::cerr << "sum_to_n(6) == 21: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (sum_to_n(11)!= 66) {\n        std::cerr << "sum_to_n(11) == 66: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (sum_to_n(30)!= 465) {\n        std::cerr << "sum_to_n(30) == 465: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    if (sum_to_n(100)!= 5050) {\n        std::cerr << "sum_to_n(100) == 5050: assertion failed" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    int level = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            level++;\n        } else if (c == ')') {\n            level--;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nint main() {\n    // Test cases\n    if (!correct_bracketing("()")) {\n        std::cerr << "Assertion failed: ()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("(()())")) {\n        std::cerr << "Assertion failed: (()())" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()(()())()")) {\n        std::cerr << "Assertion failed: ()()(()())()" << std::endl;\n        return 1;\n    }\n\n    if (!correct_bracketing("()()((()()())())(()()(()))")) {\n        std::cerr << "Assertion failed: ()()((()()())())(()()(()))" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("((()())))")) {\n        std::cerr << "Assertion failed: ((()())))" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing(")(()")) {\n        std::cerr << "Assertion failed: )(()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("(")) {\n        std::cerr << "Assertion failed: (" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("((((")) {\n        std::cerr << "Assertion failed: ((((" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing(")")) {\n        std::cerr << "Assertion failed: )" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("(()")) {\n        std::cerr << "Assertion failed: (()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("()()(()())())(()")) {\n        std::cerr << "Assertion failed: ()()(()())())(()" << std::endl;\n        return 1;\n    }\n\n    if (correct_bracketing("()()(()())()))()")) {\n        std::cerr << "Assertion failed: ()()(()())()))()" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib>\n\nint fibfib(int n) {\n    int ff[n+1]; // Array to store the Fibonacci numbers\n    int i;\n\n    // Initial values\n    ff[0] = 0;\n    ff[1] = 0;\n    ff[2] = 1;\n\n    // Compute the sequence\n    for (i = 3; i <= n; ++i) {\n        ff[i] = ff[i-1] + ff[i-2] + ff[i-3];\n    }\n\n    return ff[n];\n}\n\nint main() {\n    // Assertions\n    if (fibfib(2)!= 1) {\n        std::cerr << "fibfib(2) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(1)!= 0) {\n        std::cerr << "fibfib(1) == 0: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(5)!= 4) {\n        std::cerr << "fibfib(5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(8)!= 24) {\n        std::cerr << "fibfib(8) == 24: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(10)!= 81) {\n        std::cerr << "fibfib(10) == 81: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(12)!= 274) {\n        std::cerr << "fibfib(12) == 274: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(14)!= 927) {\n        std::cerr << "fibfib(14) == 927: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nThis C++ code defines a `fibfib` function that computes the `n`th number in the Fibonacci sequence using a dynamic array to store the sequence. The `main` function contains assertions to verify the correctness of the `fibfib` function for various inputs. If any assertion fails, the program prints an error message and exits with a non-zero status.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `fibfib` function for a range of input values.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nint vowels_count(const std::string& s) {\n    std::string vowels = "aeiouAEIOU";\n    int count = 0;\n\n    for (char c : s) {\n        if (vowels.find(c)!= std::string::npos) {\n            count++;\n        }\n    }\n\n    // Check for 'y' or 'Y' at the end of the string\n    if (s.back() == 'y' || s.back() == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n\nint main() {\n    // Test cases\n    std::string s = "abcde";\n    int count = vowels_count(s);\n    if (count!= 2) {\n        std::cerr << "Assertion failed for 'abcde'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "Alone";\n    count = vowels_count(s);\n    if (count!= 3) {\n        std::cerr << "Assertion failed for 'Alone'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "key";\n    count = vowels_count(s);\n    if (count!= 2) {\n        std::cerr << "Assertion failed for 'key'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "bye";\n    count = vowels_count(s);\n    if (count!= 1) {\n        std::cerr << "Assertion failed for 'bye'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "keY";\n    count = vowels_count(s);\n    if (count!= 2) {\n        std::cerr << "Assertion failed for 'keY'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "bYe";\n    count = vowels_count(s);\n    if (count!= 1) {\n        std::cerr << "Assertion failed for 'bYe'" << std::endl;\n        std::exit(1);\n    }\n\n    s = "ACEDY";\n    count = vowels_count(s);\n    if (count!= 3) {\n        std::cerr << "Assertion failed for 'ACEDY'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string circular_shift(int x, int shift) {\n    std::string xs = std::to_string(x);\n    int len_xs = xs.length();\n\n    if (len_xs < shift) {\n        return reverse_string(xs);\n    } else {\n        int actual_shift = shift % len_xs;\n        return xs.substr(len_xs - actual_shift, len_xs) + xs.substr(0, len_xs - actual_shift);\n    }\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string reversed = s;\n    std::reverse(reversed.begin(), reversed.end());\n    return reversed;\n}\n\nvoid run_tests() {\n    if (circular_shift(100, 2)!= "001") {\n        std::cerr << "Assertion failed: circular_shift(100, 2) == '001'" << std::endl;\n        std::exit(1);\n    }\n\n    if (circular_shift(12, 2)!= "12") {\n        std::cerr << "Assertion failed: circular_shift(12, 2) == '12'" << std::endl;\n        std::exit(1);\n    }\n\n    if (circular_shift(97, 8)!= "79") {\n        std::cerr << "Assertion failed: circular_shift(97, 8) == '79'" << std::endl;\n        std::exit(1);\n    }\n\n    if (circular_shift(12, 1)!= "21") {\n        std::cerr << "Assertion failed: circular_shift(12, 1) == '21'" << std::endl;\n        std::exit(1);\n    }\n\n    if (circular_shift(11, 101)!= "11") {\n        std::cerr << "Assertion failed: circular_shift(11, 101) == '11'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint digitSum(const std::string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Assertions\n    if (digitSum("")!= 0) {\n        std::cerr << "Assertion failed: digitSum('') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum("abAB")!= 131) {\n        std::cerr << "Assertion failed: digitSum('abAB') == 131" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum("abcCd")!= 67) {\n        std::cerr << "Assertion failed: digitSum('abcCd') == 67" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum("helloE")!= 69) {\n        std::cerr << "Assertion failed: digitSum('helloE') == 69" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum("woArBld")!= 131) {\n        std::cerr << "Assertion failed: digitSum('woArBld') == 131" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum("aAaaaXa")!= 153) {\n        std::cerr << "Assertion failed: digitSum('aAaaaXa') == 153" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum(" How are yOu?")!= 151) {\n        std::cerr << "Assertion failed: digitSum(' How are yOu?') == 151" << std::endl;\n        std::exit(1);\n    }\n\n    if (digitSum("You arE Very Smart")!= 327) {\n        std::cerr << "Assertion failed: digitSum('You arE Very Smart') == 327" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\nThis C++ program includes the same functionality as the provided Fortran code. It defines a `digitSum` function that calculates the sum of the ASCII values of uppercase letters in a given string and uses assertions to verify the correctness of the `digitSum` function with various inputs.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `digitSum` function with various inputs.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n\n// Function declaration\nint fruit_distribution(const std::string& s, int n);\n\nint main() {\n    // Test cases\n    if (fruit_distribution("5 apples and 6 oranges", 19)!= 8) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fruit_distribution("5 apples and 6 oranges", 21)!= 10) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fruit_distribution("0 apples and 1 oranges", 3)!= 2) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fruit_distribution("1 apples and 0 oranges", 3)!= 2) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fruit_distribution("2 apples and 3 oranges", 100)!= 95) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fruit_distribution("2 apples and 3 oranges", 5)!= 0) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fruit_distribution("1 apples and 100 oranges", 120)!= 19) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n\n// Function definition\nint fruit_distribution(const std::string& s, int n) {\n    std::string num1 = "", num2 = "";\n    int is12 = 0;\n\n    for (char c : s) {\n        if (c >= '0' && c <= '9') {\n            if (is12 == 0) {\n                num1 += c;\n            } else if (is12 == 1) {\n                num2 += c;\n            }\n        } else if (is12 == 0 &&!num1.empty()) {\n            is12 = 1;\n        }\n    }\n\n    int num1_val = std::stoi(num1);\n    int num2_val = std::stoi(num2);\n\n    return n - num1_val - num2_val;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid pluck(const std::vector<int>& arr, std::vector<int>& out) {\n    out.clear();\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (out.empty() || arr[i] < out[0])) {\n            out = {arr[i], i};\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> arr, result;\n    std::vector<int> empty;\n\n    // Test cases\n    arr = {4, 2, 3};\n    pluck(arr, result);\n    assert(issame(result, {2, 1}));\n\n    arr = {1, 2, 3};\n    pluck(arr, result);\n    assert(issame(result, {2, 1}));\n\n    arr = {};\n    pluck(arr, result);\n    assert(issame(result, empty));\n\n    arr = {5, 0, 3, 0, 4, 2};\n    pluck(arr, result);\n    assert(issame(result, {0, 1}));\n\n    arr = {1, 2, 3, 0, 5, 3};\n    pluck(arr, result);\n    assert(issame(result, {0, 3}));\n\n    arr = {5, 4, 8, 4, 8};\n    pluck(arr, result);\n    assert(issame(result, {4, 1}));\n\n    arr = {7, 6, 7, 1};\n    pluck(arr, result);\n    assert(issame(result, {6, 1}));\n\n    arr = {7, 9, 7, 1};\n    pluck(arr, result);\n    assert(issame(result, empty));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to extend the array\nvoid extend_array(std::vector<std::vector<int>>& array, int new_size) {\n    std::vector<std::vector<int>> temp(array.size(), std::vector<int>(new_size));\n    for (int i = 0; i < array.size(); ++i) {\n        for (int j = 0; j < array[i].size(); ++j) {\n            temp[i][j] = array[i][j];\n        }\n    }\n    array = temp;\n}\n\n// Function to search for the maximum frequency element\nint search(const std::vector<int>& lst) {\n    int max = -1;\n    std::vector<std::vector<int>> freq(2, std::vector<int>(0));\n    int freq_size = 0;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        bool has = false;\n        for (int j = 0; j < freq_size; ++j) {\n            if (lst[i] == freq[0][j]) {\n                freq[1][j]++;\n                has = true;\n                if (freq[1][j] >= freq[0][j] && freq[0][j] > max) max = freq[0][j];\n            }\n        }\n        if (!has) {\n            freq_size++;\n            extend_array(freq, freq_size);\n            freq[0][freq_size - 1] = lst[i];\n            freq[1][freq_size - 1] = 1;\n            if (max == -1 && lst[i] == 1) max = 1;\n        }\n    }\n\n    return max;\n}\n\nint main() {\n    // Test cases\n    if (search({5, 5, 5, 5, 1})!= 1) {\n        std::cerr << "Assertion failed: search({5, 5, 5, 5, 1}) == 1" << std::endl;\n        return 1;\n    }\n\n    if (search({4, 1, 4, 1, 4, 4})!= 4) {\n        std::cerr << "Assertion failed: search({4, 1, 4, 1, 4, 4}) == 4" << std::endl;\n        return 1;\n    }\n\n    if (search({3, 3})!= -1) {\n        std::cerr << "Assertion failed: search({3, 3}) == -1" << std::endl;\n        return 1;\n    }\n\n    if (search({8, 8, 8, 8, 8, 8, 8, 8})!= 8) {\n        std::cerr << "Assertion failed: search({8, 8, 8, 8, 8, 8, 8, 8}) == 8" << std::endl;\n        return 1;\n    }\n\n    if (search({2, 3, 3, 2, 2})!= 2) {\n        std::cerr << "Assertion failed: search({2, 3, 3, 2, 2}) == 2" << std::endl;\n        return 1;\n    }\n\n    // Add more assertions as needed...\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nThis C++ code replicates the functionality of the original Fortran code, including the `extend_array` function and the `search` function that finds the maximum frequency element in a list. The `main` function contains several test cases to verify the correctness of the `search` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nnamespace strange_sort_module {\n\nvoid strange_sort_list(const std::vector<int>& lst, std::vector<int>& out) {\n    int n = lst.size();\n    if (n == 0) {\n        out.clear();\n        return;\n    }\n\n    std::vector<int> sorted_lst(lst);\n\n    // Bubble sort\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (sorted_lst[j] > sorted_lst[j + 1]) {\n                std::swap(sorted_lst[j], sorted_lst[j + 1]);\n            }\n        }\n    }\n\n    out.clear();\n    out.resize(n);\n    int l = 0;\n    int r = n - 1;\n    int i = 0;\n\n    while (l < r) {\n        out[i] = sorted_lst[l];\n        ++i;\n        ++l;\n        out[i] = sorted_lst[r];\n        ++i;\n        --r;\n    }\n\n    if (l == r) {\n        out[i] = sorted_lst[l];\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n} // namespace strange_sort_module\n\nint main() {\n    using namespace strange_sort_module;\n    std::vector<int> out;\n\n    // Test cases\n    strange_sort_list({1, 2, 3, 4}, out);\n    test_assert(issame(out, {1, 4, 2, 3}));\n\n    strange_sort_list({5, 6, 7, 8, 9}, out);\n    test_assert(issame(out, {5, 9, 6, 8, 7}));\n\n    strange_sort_list({1, 2, 3, 4, 5}, out);\n    test_assert(issame(out, {1, 5, 2, 4, 3}));\n\n    strange_sort_list({5, 6, 7, 8, 9, 1}, out);\n    test_assert(issame(out, {1, 9, 5, 8, 6, 7}));\n\n    strange_sort_list({5, 5, 5, 5}, out);\n    test_assert(issame(out, {5, 5, 5, 5}));\n\n    // Handle empty array case separately\n    out.clear();\n    strange_sort_list(out, out);\n    test_assert(issame(out, out));\n\n    strange_sort_list({1, 2, 3, 4, 5, 6, 7, 8}, out);\n    test_assert(issame(out, {1, 8, 2, 7, 3, 6, 4, 5}));\n\n    strange_sort_list({0, 2, 2, 2, 5, 5, -5, -5}, out);\n    test_assert(issame(out, {-5, 5, -5, 5, 0, 2, 2, 2}));\n\n    strange_sort_list({111111}, out);\n    test_assert(issame(out, {111111}));\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function to calculate the area of a triangle\ndouble triangle_area(double a, double b, double c) {\n    double area = -1.0;\n    if (a + b > c && a + c > b && b + c > a) {\n        double h = (a + b + c) / 2.0;\n        area = std::sqrt(h * (h - a) * (h - b) * (h - c));\n    }\n    return area;\n}\n\n// Subroutine to check the assertion\nvoid check_assertion(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Main program body\n    check_assertion(std::abs(triangle_area(3.0, 4.0, 5.0) - 6.0) < 0.01, "Assertion failed: triangle_area(3, 4, 5)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 10)");\n    check_assertion(std::abs(triangle_area(4.0, 8.0, 5.0) - 8.18) < 0.01, "Assertion failed: triangle_area(4, 8, 5)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 2.0) - 1.73) < 0.01, "Assertion failed: triangle_area(2, 2, 2)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 3)");\n    check_assertion(std::abs(triangle_area(10.0, 5.0, 7.0) - 16.25) < 0.01, "Assertion failed: triangle_area(10, 5, 7)");\n    check_assertion(std::abs(triangle_area(2.0, 6.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 6, 3)");\n    check_assertion(std::abs(triangle_area(1.0, 1.0, 1.0) - 0.43) < 0.01, "Assertion failed: triangle_area(1, 1, 1)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 2, 10)");\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nclass FlightModule {\npublic:\n    static bool will_it_fly(const std::vector<int>& q, int w) {\n        int sum = 0;\n        int n = q.size();\n\n        for (int i = 0; i < n; ++i) {\n            if (q[i]!= q[n - 1 - i]) {\n                return false;\n            }\n            sum += q[i];\n        }\n\n        return sum <= w;\n    }\n};\n\nint main() {\n    std::vector<int> q;\n    int w;\n\n    // Test cases\n    q = {3, 2, 3};\n    w = 9;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    q = {1, 2};\n    w = 5;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    q = {3};\n    w = 5;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    q = {3, 2, 3};\n    w = 1;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    q = {3, 2, 3};\n    w = 6;\n    if (FlightModule::will_it_fly(q, w)) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    q = {5};\n    w = 5;\n    if (!FlightModule::will_it_fly(q, w)) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n\nThis C++ code defines a `FlightModule` class with a static `will_it_fly` method, which performs the same logic as the Fortran function. The `main` function contains several test cases to verify the correctness of the `will_it_fly` method.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint smallest_change(const std::vector<int>& arr) {\n    int out = 0;\n    int n = arr.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i]!= arr[n - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}\n\nint main() {\n    std::vector<int> test_case1 = {1, 2, 3, 5, 4, 7, 9, 6};\n    if (smallest_change(test_case1)!= 4) {\n        std::cerr << "Assertion failed: smallest_change({1, 2, 3, 5, 4, 7, 9, 6}) == 4" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case2 = {1, 2, 3, 4, 3, 2, 2};\n    if (smallest_change(test_case2)!= 1) {\n        std::cerr << "Assertion failed: smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case3 = {1, 4, 2};\n    if (smallest_change(test_case3)!= 1) {\n        std::cerr << "Assertion failed: smallest_change({1, 4, 2}) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case4 = {1, 4, 4, 2};\n    if (smallest_change(test_case4)!= 1) {\n        std::cerr << "Assertion failed: smallest_change({1, 4, 4, 2}) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case5 = {1, 2, 3, 2, 1};\n    if (smallest_change(test_case5)!= 0) {\n        std::cerr << "Assertion failed: smallest_change({1, 2, 3, 2, 1}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case6 = {3, 1, 1, 3};\n    if (smallest_change(test_case6)!= 0) {\n        std::cerr << "Assertion failed: smallest_change({3, 1, 1, 3}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case7 = {1};\n    if (smallest_change(test_case7)!= 0) {\n        std::cerr << "Assertion failed: smallest_change({1}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test_case8 = {0, 1};\n    if (smallest_change(test_case8)!= 1) {\n        std::cerr << "Assertion failed: smallest_change({0, 1}) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<std::string> total_match(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    std::vector<std::string> res;\n    int num1 = 0, num2 = 0;\n\n    for (const auto& str : lst1) {\n        num1 += str.length();\n    }\n\n    for (const auto& str : lst2) {\n        num2 += str.length();\n    }\n\n    if (num1 > num2) {\n        res = lst2;\n    } else {\n        res = lst1;\n    }\n\n    return res;\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "condition: assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nstd::string pad(const std::string& str, int len) {\n    std::string padded_str = str;\n    padded_str.resize(len,'');\n    return padded_str;\n}\n\nint main() {\n    std::vector<std::string> empty;\n\n    // Test cases\n    assert_condition(issame(total_match({pad("hi", 100), pad("admin", 100)}, {pad("hi", 100), pad("hi", 100)}), {pad("hi", 100), pad("hi", 100)}));\n    assert_condition(issame(total_match({pad("hi", 100), pad("admin", 100)}, {pad("hi", 100), pad("hi", 100), pad("admin", 100), pad("project", 100)}), {pad("hi", 100), pad("admin", 100)}));\n    assert_condition(issame(total_match({pad("4", 100)}, {pad("1", 100), pad("2", 100), pad("3", 100), pad("4", 100), pad("5", 100)}), {pad("4", 100)}));\n    assert_condition(issame(total_match({pad("hi", 100), pad("admin", 100)}, {pad("hI", 100), pad("Hi", 100)}), {pad("hI", 100), pad("Hi", 100)}));\n    assert_condition(issame(total_match({pad("hi", 100), pad("admin", 100)}, {pad("hI", 100), pad("hi", 100), pad("hi", 100)}), {pad("hI", 100), pad("hi", 100), pad("hi", 100)}));\n    assert_condition(issame(total_match({pad("hi", 100), pad("admin", 100)}, {pad("hI", 100), pad("hi", 100), pad("hii", 100)}), {pad("hi", 100), pad("admin", 100)}));\n    assert_condition(issame(total_match(empty, {pad("this", 100)}), empty));\n    assert_condition(issame(total_match({pad("this", 100)}, empty), empty));\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    int p = 1;\n    int count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) {\n            return true;\n        }\n        p = p * n;\n        count++;\n    }\n    return false;\n}\n\nint main() {\n    // Test cases\n    if (!is_simple_power(1, 4)) {\n        std::cout << "Assertion failed: is_simple_power(1, 4) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(2, 2)) {\n        std::cout << "Assertion failed: is_simple_power(2, 2) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(8, 2)) {\n        std::cout << "Assertion failed: is_simple_power(8, 2) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(3, 2)) {\n        std::cout << "Assertion failed: is_simple_power(3, 2) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(3, 1)) {\n        std::cout << "Assertion failed: is_simple_power(3, 1) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(5, 3)) {\n        std::cout << "Assertion failed: is_simple_power(5, 3) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(16, 2)) {\n        std::cout << "Assertion failed: is_simple_power(16, 2) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(143214, 16)) {\n        std::cout << "Assertion failed: is_simple_power(143214, 16) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(4, 2)) {\n        std::cout << "Assertion failed: is_simple_power(4, 2) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(9, 3)) {\n        std::cout << "Assertion failed: is_simple_power(9, 3) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(16, 4)) {\n        std::cout << "Assertion failed: is_simple_power(16, 4) == true" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(24, 2)) {\n        std::cout << "Assertion failed: is_simple_power(24, 2) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(128, 4)) {\n        std::cout << "Assertion failed: is_simple_power(128, 4) == false" << std::endl;\n        return 1;\n    }\n    if (is_simple_power(12, 6)) {\n        std::cout << "Assertion failed: is_simple_power(12, 6) == false" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(1, 1)) {\n        std::cout << "Assertion failed: is_simple_power(1, 1) == true" << std::endl;\n        return 1;\n    }\n    if (!is_simple_power(1, 12)) {\n        std::cout << "Assertion failed: is_simple_power(1, 12) == true" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool iscuber(int a) {\n    if (a == 0) return true;\n    if (a < 0) a = -a;\n    for (int i = 0; i <= static_cast<int>(std::pow(a, 1.0/3.0)); ++i) {\n        if (i*i*i == a) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Assertions\n    if (!iscuber(1)) {\n        std::cerr << "iscuber(1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(2)) {\n        std::cerr << "iscuber(2): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(-1)) {\n        std::cerr << "iscuber(-1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(64)) {\n        std::cerr << "iscuber(64): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(180)) {\n        std::cerr << "iscuber(180): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(1000)) {\n        std::cerr << "iscuber(1000): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(0)) {\n        std::cerr << "iscuber(0): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(1729)) {\n        std::cerr << "iscuber(1729): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nconst std::string key = "2357BD";\n\nint hex_key(const std::string& num) {\n    int out = 0;\n    for (char c : num) {\n        if (key.find(c)!= std::string::npos) {\n            out++;\n        }\n    }\n    return out;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assert_condition(hex_key("AB") == 1);\n    assert_condition(hex_key("1077E") == 2);\n    assert_condition(hex_key("ABED1A33") == 4);\n    assert_condition(hex_key("2020") == 2);\n    assert_condition(hex_key("123456789ABCDEF0") == 6);\n    assert_condition(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert_condition(hex_key("") == 0);\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return "db0db";\n    }\n\n    std::string out = "";\n    int temp = decimal;\n    while (temp > 0) {\n        out = std::string(1, '0' + temp % 2) + out;\n        temp /= 2;\n    }\n\n    return "db" + out + "db";\n}\n\nvoid test_decimal_to_binary() {\n    if (decimal_to_binary(0)!= "db0db") {\n        std::cerr << "Assertion failed: decimal_to_binary(0) == 'db0db'" << std::endl;\n        std::exit(1);\n    }\n\n    if (decimal_to_binary(32)!= "db100000db") {\n        std::cerr << "Assertion failed: decimal_to_binary(32) == 'db100000db'" << std::endl;\n        std::exit(1);\n    }\n\n    if (decimal_to_binary(103)!= "db1100111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(103) == 'db1100111db'" << std::endl;\n        std::exit(1);\n    }\n\n    if (decimal_to_binary(15)!= "db1111db") {\n        std::cerr << "Assertion failed: decimal_to_binary(15) == 'db1111db'" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_decimal_to_binary();\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n\nThis C++ code includes the `decimal_to_binary` function and the `test_decimal_to_binary` function to verify the correctness of the `decimal_to_binary` function. The `main` function calls `test_decimal_to_binary` to perform the tests and prints "All assertions passed." if all tests are successful.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `decimal_to_binary` function.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n\nbool is_happy(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (size_t i = 2; i < s.length(); ++i) {\n        if (s[i] == s[i - 1] || s[i] == s[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    // Test cases\n    if (!is_happy("a")) {\n        std::cout << "Test 1 passed" << std::endl;\n    } else {\n        std::cout << "Test 1 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("aa")) {\n        std::cout << "Test 2 passed" << std::endl;\n    } else {\n        std::cout << "Test 2 failed" << std::endl;\n        return 1;\n    }\n\n    if (is_happy("abcd")) {\n        std::cout << "Test 3 passed" << std::endl;\n    } else {\n        std::cout << "Test 3 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("aabb")) {\n        std::cout << "Test 4 passed" << std::endl;\n    } else {\n        std::cout << "Test 4 failed" << std::endl;\n        return 1;\n    }\n\n    if (is_happy("adb")) {\n        std::cout << "Test 5 passed" << std::endl;\n    } else {\n        std::cout << "Test 5 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("xyy")) {\n        std::cout << "Test 6 passed" << std::endl;\n    } else {\n        std::cout << "Test 6 failed" << std::endl;\n        return 1;\n    }\n\n    if (is_happy("iopaxpoi")) {\n        std::cout << "Test 7 passed" << std::endl;\n    } else {\n        std::cout << "Test 7 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("iopaxioi")) {\n        std::cout << "Test 8 passed" << std::endl;\n    } else {\n        std::cout << "Test 8 failed" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nvoid numerical_letter_grade(const std::vector<float>& grades, std::vector<std::string>& out) {\n    out.resize(grades.size());\n\n    for (size_t i = 0; i < grades.size(); ++i) {\n        if (grades[i] >= 3.9999f) {\n            out[i] = "A+";\n        } else if (grades[i] > 3.7001f && grades[i] < 3.9999f) {\n            out[i] = "A ";\n        } else if (grades[i] > 3.3001f && grades[i] <= 3.7001f) {\n            out[i] = "A-";\n        } else if (grades[i] > 3.0001f && grades[i] <= 3.3001f) {\n            out[i] = "B+";\n        } else if (grades[i] > 2.7001f && grades[i] <= 3.0001f) {\n            out[i] = "B ";\n        } else if (grades[i] > 2.3001f && grades[i] <= 2.7001f) {\n            out[i] = "B-";\n        } else if (grades[i] > 2.0001f && grades[i] <= 2.3001f) {\n            out[i] = "C+";\n        } else if (grades[i] > 1.7001f && grades[i] <= 2.0001f) {\n            out[i] = "C ";\n        } else if (grades[i] > 1.3001f && grades[i] <= 1.7001f) {\n            out[i] = "C-";\n        } else if (grades[i] > 1.0001f && grades[i] <= 1.3001f) {\n            out[i] = "D+";\n        } else if (grades[i] > 0.7001f && grades[i] <= 1.0001f) {\n            out[i] = "D ";\n        } else if (grades[i] > 0.0001f && grades[i] <= 0.7001f) {\n            out[i] = "D-";\n        } else {\n            out[i] = "E ";\n        }\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::string> result;\n    std::vector<std::string> expected1 = {"A+", "B ", "C-", "C ", "A-"};\n    std::vector<std::string> expected2 = {"D+"};\n    std::vector<std::string> expected3 = {"D-"};\n    std::vector<std::string> expected4 = {"E "};\n    std::vector<std::string> expected5 = {"D ", "D-", "C-", "B ", "B+"};\n    std::vector<std::string> expected6 = {"E ", "D-"};\n\n    numerical_letter_grade({4.0f, 3.0f, 1.7f, 2.0f, 3.5f}, result);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        exit(1);\n    }\n\n    numerical_letter_grade({1.2f}, result);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        exit(1);\n    }\n\n    numerical_letter_grade({0.5f}, result);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        exit(1);\n    }\n\n    numerical_letter_grade({0.0f}, result);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for test case 4" << std::endl;\n        exit(1);\n    }\n\n    numerical_letter_grade({1.0f, 0.3f, 1.5f, 2.8f, 3.3f}, result);\n    if (!issame(result, expected5)) {\n        std::cerr << "Assertion failed for test case 5" << std::endl;\n        exit(1);\n    }\n\n    numerical_letter_grade({0.0f, 0.7f}, result);\n    if (!issame(result, expected6)) {\n        std::cerr << "Assertion failed for test case 6" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\n// Function declaration\nbool is_prime_length(const std::string& s) {\n    int l = s.length();\n    if (l < 2) {\n        return false;\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(l))); ++i) {\n        if (l % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Subroutine run_tests\nvoid run_tests() {\n    std::string str;\n    bool result;\n\n    str = "Hello";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('Hello') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "abcdcba";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('abcdcba') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "kittens";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('kittens') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "orange";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('orange') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "wow";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('wow') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "world";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('world') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "MadaM";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('MadaM') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "Wow";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('Wow') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "HI";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('HI') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "go";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('go') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "gogo";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('gogo') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "aaaaaaaaaaaaaaa";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('aaaaaaaaaaaaaaa') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "Madam";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('Madam') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "M";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('M') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "0";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('0') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint starts_one_ends(int n);\n\nint main() {\n    // Assertions\n    if (starts_one_ends(1)!= 1) {\n        std::cerr << "Assertion failed: starts_one_ends(1) == 1" << std::endl;\n        exit(1);\n    }\n\n    if (starts_one_ends(2)!= 18) {\n        std::cerr << "Assertion failed: starts_one_ends(2) == 18" << std::endl;\n        exit(1);\n    }\n\n    if (starts_one_ends(3)!= 180) {\n        std::cerr << "Assertion failed: starts_one_ends(3) == 180" << std::endl;\n        exit(1);\n    }\n\n    if (starts_one_ends(4)!= 1800) {\n        std::cerr << "Assertion failed: starts_one_ends(4) == 1800" << std::endl;\n        exit(1);\n    }\n\n    if (starts_one_ends(5)!= 18000) {\n        std::cerr << "Assertion failed: starts_one_ends(5) == 18000" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\n// Function definition\nint starts_one_ends(int n) {\n    if (n < 1) {\n        return 0;\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    int out = 18;\n    for (int i = 2; i <= n - 1; ++i) {\n        out *= 10;\n    }\n\n    return out;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function prototype\nstd::string solve(int N);\n\nint main() {\n    std::string result;\n\n    result = solve(1000);\n    if (result!= "1") {\n        std::cerr << "Assertion failed for solve(1000)" << std::endl;\n        std::exit(1);\n    }\n\n    result = solve(150);\n    if (result!= "110") {\n        std::cerr << "Assertion failed for solve(150)" << std::endl;\n        std::exit(1);\n    }\n\n    result = solve(147);\n    if (result!= "1100") {\n        std::cerr << "Assertion failed for solve(147)" << std::endl;\n        std::exit(1);\n    }\n\n    result = solve(333);\n    if (result!= "1001") {\n        std::cerr << "Assertion failed for solve(333)" << std::endl;\n        std::exit(1);\n    }\n\n    result = solve(963);\n    if (result!= "10010") {\n        std::cerr << "Assertion failed for solve(963)" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nstd::string solve(int N) {\n    std::string bi;\n    std::string str = std::to_string(N);\n    int sum = 0;\n    int digit;\n    char digit_char;\n\n    // Calculate the sum of digits\n    for (char c : str) {\n        digit = c - '0';\n        sum += digit;\n    }\n\n    // Convert sum to binary\n    while (sum > 0) {\n        digit_char = (sum % 2) + '0';\n        bi = digit_char + bi;\n        sum /= 2;\n    }\n\n    // Handle the case when sum is 0\n    if (bi.empty()) {\n        bi = "0";\n    }\n\n    return bi;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `solve` function by checking its output against expected values for a range of input values.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\nint add(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size() / 2; ++i) {\n        if (lst[2 * i + 1] % 2 == 0) {\n            sum += lst[2 * i + 1];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    if (add({4, 88})!= 88) {\n        std::cerr << "Assertion failed: add({4, 88}) == 88" << std::endl;\n        exit(1);\n    }\n\n    if (add({4, 5, 6, 7, 2, 122})!= 122) {\n        std::cerr << "Assertion failed: add({4, 5, 6, 7, 2, 122}) == 122" << std::endl;\n        exit(1);\n    }\n\n    if (add({4, 0, 6, 7})!= 0) {\n        std::cerr << "Assertion failed: add({4, 0, 6, 7}) == 0" << std::endl;\n        exit(1);\n    }\n\n    if (add({4, 4, 6, 8})!= 12) {\n        std::cerr << "Assertion failed: add({4, 4, 6, 8}) == 12" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n\nThis C++ code defines a function `add` that takes a vector of integers as input and returns the sum of the elements at even positions (0-based indexing in C++). The `main` function contains several test cases to verify the correctness of the `add` function. If any test case fails, the program prints an error message and exits with a non-zero status. Otherwise, it prints "All tests passed successfully."\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `add` function in both languages.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_main.f90`:\n\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> sort_array(const std::vector<int>& array) {\n    std::vector<int> out = array;\n    int n = out.size();\n\n    if (n == 0) {\n        return out;\n    }\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (out[j] > out[j + 1]) {\n                std::swap(out[j], out[j + 1]);\n            }\n        }\n    }\n\n    if ((out[0] + out[n - 1]) % 2 == 1) {\n        return out;\n    } else {\n        std::reverse(out.begin(), out.end());\n        return out;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid test_cases() {\n    assert_condition(issame(sort_array({0}), {0}));\n    assert_condition(issame(sort_array({5}), {5}));\n    assert_condition(issame(sort_array({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5}));\n    assert_condition(issame(sort_array({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0}));\n    assert_condition(issame(sort_array({2, 1}), {1, 2}));\n    assert_condition(issame(sort_array({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87}));\n    assert_condition(issame(sort_array({21, 14, 23, 11}), {23, 21, 14, 11}));\n}\n\nint main() {\n    test_cases();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to sort the list\nvoid sort(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to find the next smallest number in the list\nint next_smallest(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    std::vector<int> sorted_lst = lst;\n    sort(sorted_lst);\n\n    for (size_t i = 1; i < sorted_lst.size(); ++i) {\n        if (sorted_lst[i]!= sorted_lst[i - 1]) {\n            return sorted_lst[i];\n        }\n    }\n\n    return -1;\n}\n\n// Main function to run the tests\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test case 1\n    lst = {1, 2, 3, 4, 5};\n    result = next_smallest(lst);\n    if (result!= 2) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    lst = {5, 1, 4, 3, 2};\n    result = next_smallest(lst);\n    if (result!= 2) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    lst = {};\n    result = next_smallest(lst);\n    if (result!= -1) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    lst = {1, 1};\n    result = next_smallest(lst);\n    if (result!= -1) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    lst = {1, 1, 1, 1, 0};\n    result = next_smallest(lst);\n    if (result!= 1) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 6\n    lst = {-35, 34, 12, -45};\n    result = next_smallest(lst);\n    if (result!= -35) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\n// Function prototype\nint is_bored(const std::string& S);\n\n// Assert function prototype\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(is_bored("Hello world") == 0);\n    assert(is_bored("Is the sky blue?") == 0);\n    assert(is_bored("I love It!") == 1);\n    assert(is_bored("bIt") == 0);\n    assert(is_bored("I feel good today. I will be productive. will kill It") == 2);\n    assert(is_bored("You and I are going for a walk") == 0);\n\n    return 0;\n}\n\nint is_bored(const std::string& S) {\n    bool isstart = true;\n    bool isi = false;\n    int sum = 0;\n    int lenS = S.length();\n\n    for (int i = 0; i < lenS; ++i) {\n        if (S[i] =='' && isi) {\n            isi = false;\n            sum++;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = true;\n        } else {\n            isi = false;\n        }\n        if (S[i]!='') {\n            isstart = false;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = true;\n        }\n    }\n\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool any_int(float a, float b, float c) {\n    if (std::round(a)!= a) return false;\n    if (std::round(b)!= b) return false;\n    if (std::round(c)!= c) return false;\n    if (a + b == c || a + c == b || b + c == a) return true;\n    return false;\n}\n\nvoid run_tests() {\n    bool result;\n\n    result = any_int(2.0f, 3.0f, 1.0f);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 3, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.5f, 2.0f, 3.0f);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.5, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(1.5f, 5.0f, 3.5f);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(1.5, 5, 3.5) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0f, 6.0f, 2.0f);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2, 6, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(4.0f, 2.0f, 2.0f);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(4, 2, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.2f, 2.2f, 2.2f);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.2, 2.2, 2.2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(-4.0f, 6.0f, 2.0f);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(-4, 6, 2) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(2.0f, 1.0f, 1.0f);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 1, 1) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.0f, 4.0f, 7.0f);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(3, 4, 7) == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = any_int(3.01f, 4.0f, 7.0f);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(3.01, 4, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nint skjkasdkd(const std::vector<int>& lst) {\n    int largest = 0;\n    bool prime;\n    std::string s;\n    int digit;\n\n    for (int num : lst) {\n        if (num > largest) {\n            prime = true;\n            for (int j = 2; j <= static_cast<int>(std::sqrt(static_cast<double>(num))); ++j) {\n                if (num % j == 0) {\n                    prime = false;\n                    break;\n                }\n            }\n            if (prime) largest = num;\n        }\n    }\n\n    int sum = 0;\n    std::stringstream ss;\n    ss << largest;\n    s = ss.str();\n\n    for (char c : s) {\n        digit = c - '0';\n        sum += digit;\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<std::pair<std::vector<int>, int>> tests = {\n        {{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n        {{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n        {{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n        {{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n        {{0, 81, 12, 3, 1, 21}, 3},\n        {{0, 8, 1, 2, 1, 7}, 7},\n        {{8191}, 19},\n        {{8191, 123456, 127, 7}, 19},\n        {{127, 97, 8192}, 10}\n    };\n\n    bool all_tests_passed = true;\n    for (const auto& test : tests) {\n        int result = skjkasdkd(test.first);\n        if (result!= test.second) {\n            std::cerr << "Assertion failed: result /= " << test.second << std::endl;\n            all_tests_passed = false;\n        }\n    }\n\n    if (all_tests_passed) {\n        std::cout << "All tests passed." << std::endl;\n    }\n\n    return all_tests_passed? 0 : 1;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `skjkasdkd` function by comparing its output against expected values for given inputs.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cstdlib> // For exit()\n\n// Function declaration\nint multiply(int a, int b);\n\nint main() {\n    int result;\n\n    // Assertions\n    result = multiply(148, 412);\n    if (result!= 16) {\n        std::cerr << "Assertion failed: multiply(148, 412) == 16" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(19, 28);\n    if (result!= 72) {\n        std::cerr << "Assertion failed: multiply(19, 28) == 72" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(2020, 1851);\n    if (result!= 0) {\n        std::cerr << "Assertion failed: multiply(2020, 1851) == 0" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(14, -15);\n    if (result!= 20) {\n        std::cerr << "Assertion failed: multiply(14, -15) == 20" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(76, 67);\n    if (result!= 42) {\n        std::cerr << "Assertion failed: multiply(76, 67) == 42" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(17, 27);\n    if (result!= 49) {\n        std::cerr << "Assertion failed: multiply(17, 27) == 49" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(0, 1);\n    if (result!= 0) {\n        std::cerr << "Assertion failed: multiply(0, 1) == 0" << std::endl;\n        exit(1);\n    }\n\n    result = multiply(0, 0);\n    if (result!= 0) {\n        std::cerr << "Assertion failed: multiply(0, 0) == 0" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}\n\n// Function definition\nint multiply(int a, int b) {\n    return (a % 10) * (b % 10);\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function declaration\nint count_upper(const std::string& s);\n\nint main() {\n    // Test cases\n    if (count_upper("aBCdEf")!= 1) {\n        std::cerr << "Assertion failed: count_upper('aBCdEf') == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (count_upper("abcdefg")!= 0) {\n        std::cerr << "Assertion failed: count_upper('abcdefg') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (count_upper("dBBE")!= 0) {\n        std::cerr << "Assertion failed: count_upper('dBBE') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (count_upper("B")!= 0) {\n        std::cerr << "Assertion failed: count_upper('B') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (count_upper("U")!= 1) {\n        std::cerr << "Assertion failed: count_upper('U') == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (count_upper("")!= 0) {\n        std::cerr << "Assertion failed: count_upper('') == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (count_upper("EEEE")!= 2) {\n        std::cerr << "Assertion failed: count_upper('EEEE') == 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\n// Function definition\nint count_upper(const std::string& s) {\n    std::string uvowel = "AEIOU";\n    int count = 0;\n    int len_s = s.length();\n\n    for (int i = 0; i < len_s; i += 2) {\n        if (uvowel.find(s[i])!= std::string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\nThis C++ code includes the necessary headers and uses the standard library features such as `std::string` for string manipulation and `std::exit` for terminating the program with an error code. The `count_upper` function is defined to count the number of uppercase vowels in a given string, similar to the Fortran version. The main function contains test cases to verify the correctness of the `count_upper` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will verify the correctness of the `count_upper` function.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n\n// Function to find the closest integer\nint closest_integer(const std::string& value) {\n    float w = std::stof(value);\n    return std::round(w);\n}\n\n// Subroutine to assert the condition\nvoid assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Main program body\n    assert(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid make_a_pile(int n, std::vector<int>& out) {\n    out.resize(n);\n    out[0] = n;\n    for (int i = 1; i < n; ++i) {\n        out[i] = out[i - 1] + 2;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> pile;\n\n    make_a_pile(3, pile);\n    assert(issame(pile, {3, 5, 7}));\n\n    make_a_pile(4, pile);\n    assert(issame(pile, {4, 6, 8, 10}));\n\n    make_a_pile(5, pile);\n    assert(issame(pile, {5, 7, 9, 11, 13}));\n\n    make_a_pile(6, pile);\n    assert(issame(pile, {6, 8, 10, 12, 14, 16}));\n\n    make_a_pile(8, pile);\n    assert(issame(pile, {8, 10, 12, 14, 16, 18, 20, 22}));\n\n    return 0;\n}\n
#include <iostream>\n#include <cstdlib>\n\nint choose_num(int x, int y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && y % 2 == 1) {\n        return -1;\n    } else if (y % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n\nint main() {\n    int result;\n\n    result = choose_num(12, 15);\n    if (result!= 14) {\n        std::cerr << "Assertion failed: choose_num(12, 15) == 14" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(13, 12);\n    if (result!= -1) {\n        std::cerr << "Assertion failed: choose_num(13, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(33, 12354);\n    if (result!= 12354) {\n        std::cerr << "Assertion failed: choose_num(33, 12354) == 12354" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(5234, 5233);\n    if (result!= -1) {\n        std::cerr << "Assertion failed: choose_num(5234, 5233) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(6, 29);\n    if (result!= 28) {\n        std::cerr << "Assertion failed: choose_num(6, 29) == 28" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(27, 10);\n    if (result!= -1) {\n        std::cerr << "Assertion failed: choose_num(27, 10) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(7, 7);\n    if (result!= -1) {\n        std::cerr << "Assertion failed: choose_num(7, 7) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = choose_num(546, 546);\n    if (result!= 546) {\n        std::cerr << "Assertion failed: choose_num(546, 546) == 546" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n\nnamespace utils {\n\n    std::string rounded_avg(int n, int m) {\n        if (n > m) {\n            return "-1";\n        }\n\n        int num = (m + n) / 2;\n        std::string temp_out = "";\n        while (num > 0) {\n            int remainder = num % 2;\n            char digit = static_cast<char>(remainder + '0');\n            temp_out = digit + temp_out;\n            num /= 2;\n        }\n\n        if (temp_out.empty()) {\n            temp_out = "0";\n        }\n\n        return temp_out;\n    }\n\n    void assert(bool condition, const std::string& message) {\n        if (!condition) {\n            std::cerr << message << std::endl;\n            std::exit(1);\n        }\n    }\n\n} // namespace utils\n\nint main() {\n    using namespace utils;\n\n    // Main program\n    assert(rounded_avg(1, 5) == "11", "Assertion failed: rounded_avg(1, 5) == '11'");\n    assert(rounded_avg(7, 13) == "1010", "Assertion failed: rounded_avg(7, 13) == '1010'");\n    assert(rounded_avg(964, 977) == "1111001010", "Assertion failed: rounded_avg(964, 977) == '1111001010'");\n    assert(rounded_avg(996, 997) == "1111100100", "Assertion failed: rounded_avg(996, 997) == '1111100100'");\n    assert(rounded_avg(560, 851) == "1011000001", "Assertion failed: rounded_avg(560, 851) == '1011000001'");\n    assert(rounded_avg(185, 546) == "101101101", "Assertion failed: rounded_avg(185, 546) == '101101101'");\n    assert(rounded_avg(362, 496) == "110101101", "Assertion failed: rounded_avg(362, 496) == '110101101'");\n    assert(rounded_avg(350, 902) == "1001110010", "Assertion failed: rounded_avg(350, 902) == '1001110010'");\n    assert(rounded_avg(197, 233) == "11010111", "Assertion failed: rounded_avg(197, 233) == '11010111'");\n    assert(rounded_avg(7, 5) == "-1", "Assertion failed: rounded_avg(7, 5) == '-1'");\n    assert(rounded_avg(5, 1) == "-1", "Assertion failed: rounded_avg(5, 1) == '-1'");\n    assert(rounded_avg(5, 5) == "101", "Assertion failed: rounded_avg(5, 5) == '101'");\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstruct NumToType {\n    int key;\n    std::string value;\n\n    NumToType(int k, std::string v) : key(k), value(v) {}\n};\n\nvoid sortArray(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\nstd::vector<std::string> byLength(const std::vector<int>& arr) {\n    std::vector<std::string> out;\n    std::vector<NumToType> numto = {\n        {0, "Zero"}, {1, "One"}, {2, "Two"},\n        {3, "Three"}, {4, "Four"}, {5, "Five"},\n        {6, "Six"}, {7, "Seven"}, {8, "Eight"},\n        {9, "Nine"}\n    };\n\n    std::vector<int> tempArr = arr;\n    sortArray(tempArr);\n\n    for (int i = tempArr.size() - 1; i >= 0; --i) {\n        if (tempArr[i] >= 1 && tempArr[i] <= 9) {\n            out.push_back(numto[tempArr[i]].value);\n        }\n    }\n\n    return out;\n}\n\nbool isSame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::string> expected1 = {\n        "Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"\n    };\n    std::vector<std::string> expected2 = {\n        "One"\n    };\n    std::vector<std::string> expected3 = {\n        "Three", "Two", "One"\n    };\n    std::vector<std::string> expected4 = {\n        "Nine", "Eight", "Four"\n    };\n\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    std::vector<std::string> result1 = byLength(arr1);\n    if (!isSame(result1, expected1)) {\n        std::cerr << "Test 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr2 = {};\n    std::vector<std::string> result2 = byLength(arr2);\n    if (!isSame(result2, expected2)) {\n        std::cerr << "Test 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    std::vector<std::string> result3 = byLength(arr3);\n    if (!isSame(result3, expected2)) {\n        std::cerr << "Test 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr4 = {1, -1, 3, 2};\n    std::vector<std::string> result4 = byLength(arr4);\n    if (!isSame(result4, expected3)) {\n        std::cerr << "Test 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> arr5 = {9, 4, 8};\n    std::vector<std::string> result5 = byLength(arr5);\n    if (!isSame(result5, expected4)) {\n        std::cerr << "Test 5: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0;\n    int prod = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) {\n            out[i-1] = prod;\n        } else {\n            out[i-1] = sum;\n        }\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    std::vector<int> expected3 = {1};\n    std::vector<int> expected4 = {1, 2, 6};\n\n    std::vector<int> result = f(5);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for f(5)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(7);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for f(7)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(1);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for f(1)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(3);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for f(3)" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n\nstd::vector<int> even_odd_palindrome(int n);\nstd::string reverse_string(const std::string& s);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\n\nvoid test_even_odd_palindrome(int n, const std::vector<int>& expected) {\n    std::vector<int> result = even_odd_palindrome(n);\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_even_odd_palindrome(123, {8, 13});\n    test_even_odd_palindrome(12, {4, 6});\n    test_even_odd_palindrome(3, {1, 2});\n    test_even_odd_palindrome(63, {6, 8});\n    test_even_odd_palindrome(25, {5, 6});\n    test_even_odd_palindrome(19, {4, 6});\n    test_even_odd_palindrome(9, {4, 5});\n    test_even_odd_palindrome(1, {0, 1});\n\n    return 0;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> res(2, 0);\n    for (int i = 1; i <= n; ++i) {\n        std::string w = std::to_string(i);\n        std::string p = reverse_string(w);\n        if (w == p) {\n            if (i % 2 == 1) {\n                res[1]++;\n            } else {\n                res[0]++;\n            }\n        }\n    }\n    return res;\n}\n\nstd::string reverse_string(const std::string& s) {\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return rev;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n    return true;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n\nint count_nums(const std::vector<int>& n) {\n    int num = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        if (n[i] > 0) {\n            ++num;\n        } else {\n            int sum = 0;\n            int w = std::abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w /= 10;\n            }\n            sum -= w;\n            if (sum > 0) ++num;\n        }\n    }\n    return num;\n}\n\nint main() {\n    std::vector<std::pair<std::vector<int>, int>> testCases = {\n        {{0}, 0},\n        {{-1, -2, 0}, 0},\n        {{1, 1, 2, -2, 3, 4, 5}, 6},\n        {{1, 6, 9, -6, 0, 1, 5}, 5},\n        {{1, 100, 98, -7, 1, -1}, 4},\n        {{12, 23, 34, -45, -56, 0}, 5},\n        {{-0, 1}, 1},\n        {{1}, 1}\n    };\n\n    bool allTestsPassed = true;\n    for (const auto& [nums, expected] : testCases) {\n        int result = count_nums(nums);\n        if (result!= expected) {\n            std::cerr << "Assertion failed: count_nums(" << nums << ") == " << expected << std::endl;\n            allTestsPassed = false;\n            break;\n        }\n    }\n\n    if (allTestsPassed) {\n        std::cout << "All tests passed." << std::endl;\n    }\n\n    return allTestsPassed? 0 : 1;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n// Function to check if one ball can be moved\nbool move_one_ball(const std::vector<int>& arr) {\n    int num = 0;\n    if (arr.size() == 0) {\n        return true;\n    }\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            num++;\n        }\n    }\n\n    if (arr.back() > arr.front()) {\n        num++;\n    }\n\n    return num < 2;\n}\n\n// Main function with test cases\nint main() {\n    std::vector<int> arr;\n    bool result;\n\n    // Test case 1\n    arr = {3, 4, 5, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    arr = {3, 5, 10, 1, 2};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    arr = {4, 3, 1, 2};\n    result = move_one_ball(arr);\n    if (result) {\n        std::cerr << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4\n    arr = {3, 5, 4, 1, 2};\n    result = move_one_ball(arr);\n    if (result) {\n        std::cerr << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5\n    arr = {};\n    result = move_one_ball(arr);\n    if (!result) {\n        std::cerr << "Assertion failed for {}" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For std::exit\n\nstd::string exchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int num = 0;\n    for (int i = 0; i < lst1.size(); ++i) {\n        if (lst1[i] % 2 == 0) num++;\n    }\n    for (int i = 0; i < lst2.size(); ++i) {\n        if (lst2[i] % 2 == 0) num++;\n    }\n\n    if (num >= lst1.size()) {\n        return "YES";\n    } else {\n        return "NO";\n    }\n}\n\nint main() {\n    std::vector<int> lst1, lst2;\n    std::string result;\n\n    // Test 1\n    lst1 = {1, 2, 3, 4};\n    lst2 = {1, 2, 3, 4};\n    result = exchange(lst1, lst2);\n    if (result!= "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test 2\n    lst1 = {1, 2, 3, 4};\n    lst2 = {1, 5, 3, 4};\n    result = exchange(lst1, lst2);\n    if (result!= "NO") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test 3\n    lst1 = {1, 2, 3, 4};\n    lst2 = {2, 1, 4, 3};\n    result = exchange(lst1, lst2);\n    if (result!= "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test 4\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 4};\n    result = exchange(lst1, lst2);\n    if (result!= "YES") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test 5\n    lst1 = {5, 7, 3};\n    lst2 = {2, 6, 3};\n    result = exchange(lst1, lst2);\n    if (result!= "NO") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 3}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test 6\n    lst1 = {3, 2, 6, 1, 8, 9};\n    lst2 = {3, 5, 5, 1, 1, 1};\n    result = exchange(lst1, lst2);\n    if (result!= "NO") {\n        std::cerr << "Assertion failed: exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test 7\n    lst1 = {100, 200};\n    lst2 = {200, 200};\n    result = exchange(lst1, lst2);\n    if (result!= "YES") {\n        std::cerr << "Assertion failed: exchange({100, 200}, {200, 200}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nvoid odd_count(const std::vector<std::string>& lst, std::vector<std::string>& out) {\n    std::string s = "the number of odd elements in the string i of the input.";\n    out.resize(lst.size());\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int sum = 0;\n        for (char c : lst[i]) {\n            if (c >= '0' && c <= '9') {\n                if ((c - '0') % 2 == 1) sum++;\n            }\n        }\n\n        std::string s2 = "";\n        size_t pos = 0;\n        for (char c : s) {\n            if (c == 'i') {\n                s2 += std::to_string(sum);\n            } else {\n                s2 += c;\n            }\n        }\n        out[i] = s2;\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size()!= b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid print_results(const std::vector<std::string>& output, const std::vector<std::string>& expected) {\n    std::cout << "Actual Output:" << std::endl;\n    for (const auto& str : output) {\n        std::cout << str << std::endl;\n    }\n\n    std::cout << "Expected Output:" << std::endl;\n    for (const auto& str : expected) {\n        std::cout << str << std::endl;\n    }\n}\n\nint main() {\n    std::vector<std::string> input, output, expected;\n\n    // Test case 1\n    input = {"1234567"};\n    expected = {"the number of odd elements 4n the str4ng 4 of the 4nput."};\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 2\n    input = {"3", "11111111"};\n    expected = {"the number of odd elements 1n the str1ng 1 of the 1nput.", "the number of odd elements 8n the str8ng 8 of the 8nput."};\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 3\n    input = {"271", "137", "314"};\n    expected = {"the number of odd elements 2n the str2ng 2 of the 2nput.", "the number of odd elements 3n the str3ng 3 of the 3nput.", "the number of odd elements 2n the str2ng 2 of the 2nput."};\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<int> sort_array(const std::vector<int>& arr) {\n    std::vector<int> sorted_arr(arr);\n    std::vector<int> bin(arr.size());\n\n    // Calculate the number of 1s in the binary representation of each element\n    for (size_t i = 0; i < arr.size(); ++i) {\n        int b = 0;\n        int n = std::abs(arr[i]);\n        while (n > 0) {\n            b += n % 2;\n            n /= 2;\n        }\n        bin[i] = b;\n    }\n\n    // Sort the array based on the bin values and the original values\n    for (size_t i = 0; i < arr.size(); ++i) {\n        for (size_t j = 1; j < arr.size(); ++j) {\n            if (bin[j] < bin[j - 1] || (bin[j] == bin[j - 1] && sorted_arr[j] < sorted_arr[j - 1])) {\n                std::swap(sorted_arr[j], sorted_arr[j - 1]);\n                std::swap(bin[j], bin[j - 1]);\n            }\n        }\n    }\n\n    return sorted_arr;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_case(const std::vector<int>& arr, const std::vector<int>& expected) {\n    std::vector<int> sorted_arr = sort_array(arr);\n    if (!issame(sorted_arr, expected)) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    // Test cases\n    test_case({1, 5, 2, 3, 4}, {1, 2, 4, 3, 5});\n    test_case({-2, -3, -4, -5, -6}, {-4, -2, -6, -5, -3});\n    test_case({1, 0, 2, 3, 4}, {0, 1, 2, 4, 3});\n    test_case({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}, {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77});\n    test_case({3, 6, 44, 12, 32, 5}, {32, 3, 5, 6, 12, 44});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string get_closest_vowel(const std::string& word) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result = "";\n\n    for (int i = word.length() - 1; i >= 1; --i) {\n        if (vowels.find(word[i])!= std::string::npos) {\n            if (vowels.find(word[i + 1]) == std::string::npos && vowels.find(word[i - 1]) == std::string::npos) {\n                result = word.substr(i, 1);\n                return result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid assert_equal(const std::string& expected, const std::string& actual, const std::string& test_case) {\n    if (expected!= actual) {\n        std::cerr << "Assertion failed: " << test_case << " - Expected: " << expected << ", Actual: " << actual << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_equal("u", get_closest_vowel("yogurt"), "yogurt");\n    assert_equal("u", get_closest_vowel("full"), "full");\n    assert_equal("", get_closest_vowel("easy"), "easy");\n    assert_equal("", get_closest_vowel("eAsy"), "eAsy");\n    assert_equal("", get_closest_vowel("ali"), "ali");\n    assert_equal("a", get_closest_vowel("bad"), "bad");\n    assert_equal("o", get_closest_vowel("most"), "most");\n    assert_equal("", get_closest_vowel("ab"), "ab");\n    assert_equal("", get_closest_vowel("ba"), "ba");\n    assert_equal("", get_closest_vowel("quick"), "quick");\n    assert_equal("i", get_closest_vowel("anime"), "anime");\n    assert_equal("", get_closest_vowel("Asia"), "Asia");\n    assert_equal("o", get_closest_vowel("Above"), "Above");\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\n// Function declarations\nvector<int> bubble_sort(vector<int>& arr);\nvector<int> maximum(const vector<int>& arr, int k);\nbool issame(const vector<int>& a, const vector<int>& b);\nvoid assert_condition(bool condition);\nvoid run_tests();\n\nint main() {\n    run_tests();\n    return 0;\n}\n\nvector<int> bubble_sort(vector<int>& arr) {\n    vector<int> sorted_arr = arr;\n    for (int i = 0; i < sorted_arr.size() - 1; ++i) {\n        for (int j = 0; j < sorted_arr.size() - i - 1; ++j) {\n            if (sorted_arr[j] > sorted_arr[j + 1]) {\n                swap(sorted_arr[j], sorted_arr[j + 1]);\n            }\n        }\n    }\n    return sorted_arr;\n}\n\nvector<int> maximum(const vector<int>& arr, int k) {\n    vector<int> sorted_arr = bubble_sort(const_cast<vector<int>&>(arr));\n    vector<int> result(k);\n    for (int i = 0; i < k; ++i) {\n        result[i] = sorted_arr[sorted_arr.size() - k + i];\n    }\n    return result;\n}\n\nbool issame(const vector<int>& a, const vector<int>& b) {\n    if (a.size()!= b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        cerr << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert_condition(issame(maximum({-3, -4, 5}, 3), {-4, -3, 5}));\n    assert_condition(issame(maximum({4, -4, 4}, 2), {4, 4}));\n    assert_condition(issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1), {2}));\n    assert_condition(issame(maximum({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123}));\n    assert_condition(issame(maximum({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20}));\n    assert_condition(issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15}));\n    assert_condition(issame(maximum({-1, 0, 2, 5, 3, -10}, 2), {3, 5}));\n    assert_condition(issame(maximum({1, 0, 5, -7}, 1), {5}));\n    assert_condition(issame(maximum({4, -4}, 2), {-4, 4}));\n    assert_condition(issame(maximum({-10, 10}, 2), {-10, 10}));\n    // Handle the empty array case separately\n    vector<int> expected;\n    assert_condition(issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0), expected));\n}\n
#include <iostream>\n#include <vector>\n\n// Function prototype\nint solutions(const std::vector<int>& lst);\n\nint main() {\n    // Test cases\n    if (solutions({5, 8, 7, 1})!= 12) {\n        std::cerr << "Assertion failed: solutions({5, 8, 7, 1}) == 12" << std::endl;\n        return 1;\n    }\n\n    if (solutions({3, 3, 3, 3, 3})!= 9) {\n        std::cerr << "Assertion failed: solutions({3, 3, 3, 3, 3}) == 9" << std::endl;\n        return 1;\n    }\n\n    if (solutions({30, 13, 24, 321})!= 0) {\n        std::cerr << "Assertion failed: solutions({30, 13, 24, 321}) == 0" << std::endl;\n        return 1;\n    }\n\n    if (solutions({5, 9})!= 5) {\n        std::cerr << "Assertion failed: solutions({5, 9}) == 5" << std::endl;\n        return 1;\n    }\n\n    if (solutions({2, 4, 8})!= 0) {\n        std::cerr << "Assertion failed: solutions({2, 4, 8}) == 0" << std::endl;\n        return 1;\n    }\n\n    if (solutions({30, 13, 23, 32})!= 23) {\n        std::cerr << "Assertion failed: solutions({30, 13, 23, 32}) == 23" << std::endl;\n        return 1;\n    }\n\n    if (solutions({3, 13, 2, 9})!= 3) {\n        std::cerr << "Assertion failed: solutions({3, 13, 2, 9}) == 3" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\n// Function definition\nint solutions(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to add elements within a range [-99, 99]\nint add_elements(const std::vector<int>& arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Test cases\n    std::vector<int> test_case1 = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    if (add_elements(test_case1, 3)!= -4) {\n        std::cerr << "Assertion failed: result /= -4" << std::endl;\n        exit(1);\n    }\n\n    std::vector<int> test_case2 = {111, 121, 3, 4000, 5, 6};\n    if (add_elements(test_case2, 2)!= 0) {\n        std::cerr << "Assertion failed: result /= 0" << std::endl;\n        exit(1);\n    }\n\n    std::vector<int> test_case3 = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    if (add_elements(test_case3, 4)!= 125) {\n        std::cerr << "Assertion failed: result /= 125" << std::endl;\n        exit(1);\n    }\n\n    std::vector<int> test_case4 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    if (add_elements(test_case4, 4)!= 24) {\n        std::cerr << "Assertion failed: result /= 24" << std::endl;\n        exit(1);\n    }\n\n    std::vector<int> test_case5 = {1};\n    if (add_elements(test_case5, 1)!= 1) {\n        std::cerr << "Assertion failed: result /= 1" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> get_odd_collatz(int n);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\nvoid sort(std::vector<int>& array);\n\nvoid test_odd_collatz(int n, const std::vector<int>& expected) {\n    std::vector<int> result = get_odd_collatz(n);\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    test_odd_collatz(14, {1, 5, 7, 11, 13, 17});\n    test_odd_collatz(5, {1, 5});\n    test_odd_collatz(12, {1, 3, 5});\n    test_odd_collatz(1, {1});\n\n    return 0;\n}\n\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> out{1};\n    int temp = n;\n\n    while (temp!= 1) {\n        if (temp % 2 == 1) {\n            out.push_back(temp);\n            temp = 3 * temp + 1;\n        } else {\n            temp = temp / 2;\n        }\n    }\n\n    sort(out);\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid sort(std::vector<int>& array) {\n    std::sort(array.begin(), array.end());\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool valid_date(const std::string& date) {\n    if (date.length()!= 10) {\n        return false;\n    }\n\n    for (size_t i = 0; i < date.length(); ++i) {\n        if (i == 2 || i == 5) {\n            if (date[i]!= '-') {\n                return false;\n            }\n        } else {\n            if (date[i] < '0' || date[i] > '9') {\n                return false;\n            }\n        }\n    }\n\n    int mm = std::stoi(date.substr(0, 2));\n    int dd = std::stoi(date.substr(3, 2));\n    int yy = std::stoi(date.substr(6, 4));\n\n    if (mm < 1 || mm > 12) {\n        return false;\n    }\n\n    if (dd < 1 || dd > 31) {\n        return false;\n    }\n\n    if (dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11 || mm == 2)) {\n        return false;\n    }\n\n    if (dd == 30 && mm == 2) {\n        return false;\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nstd::string pad(const std::string& str) {\n    std::string padded_str = str;\n    padded_str.append(10 - str.length(),'');\n    return padded_str;\n}\n\nint main() {\n    // Test cases\n    assert(valid_date(pad("03-11-2000")) == true);\n    assert(valid_date(pad("15-01-2012")) == false);\n    assert(valid_date(pad("04-0-2040")) == false);\n    assert(valid_date(pad("06-04-2020")) == true);\n    assert(valid_date(pad("01-01-2007")) == true);\n    assert(valid_date(pad("03-32-2011")) == false);\n    assert(valid_date(pad("")) == false);\n    assert(valid_date(pad("04-31-3000")) == false);\n    assert(valid_date(pad("06-06-2005")) == true);\n    assert(valid_date(pad("21-31-2000")) == false);\n    assert(valid_date(pad("04-12-2003")) == true);\n    assert(valid_date(pad("04122003")) == false);\n    assert(valid_date(pad("20030412")) == false);\n    assert(valid_date(pad("2003-04")) == false);\n    assert(valid_date(pad("2003-04-12")) == false);\n    assert(valid_date(pad("04-2003")) == false);\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    std::vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 4, 5, 6};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5, 6, 7};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5, 6, 7};\n    assert(is_sorted(lst) == false);\n\n    lst = {};\n    assert(is_sorted(lst) == true);\n\n    lst = {1};\n    assert(is_sorted(lst) == true);\n\n    lst = {3, 2, 1};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 2, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 3, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 3, 3, 4};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4};\n    assert(is_sorted(lst) == true);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::string intersection(const std::vector<int>& interval1, const std::vector<int>& interval2) {\n    int inter1 = std::max(interval1[0], interval2[0]);\n    int inter2 = std::min(interval1[1], interval2[1]);\n    int l = inter2 - inter1;\n\n    if (l < 2) {\n        return "NO";\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(l))); ++i) {\n        if (l % i == 0) {\n            return "NO";\n        }\n    }\n\n    return "YES";\n}\n\nint main() {\n    std::vector<std::pair<std::vector<int>, std::string>> tests = {\n        {{1, 2}, "NO"},\n        {{-1, 1}, "NO"},\n        {{-3, -1}, "YES"},\n        {{-2, 2}, "YES"},\n        {{-11, 2}, "NO"},\n        {{1, 2}, "NO"},\n        {{1, 2}, "NO"},\n        {{-2, -2}, "NO"},\n    };\n\n    for (const auto& test : tests) {\n        std::vector<int> interval1 = test.first;\n        std::string expected = test.second;\n        std::string result = intersection(interval1, {interval1[1], interval1[1] + 1}); // Assuming the second interval is always [end, end+1] for simplicity\n        if (result!= expected) {\n            std::cerr << "Assertion failed: intersection(" << interval1[0] << ", " << interval1[1]\n                      << ") == '" << expected << "' but got '" << result << "'" << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nThis C++ code mirrors the functionality of the original Fortran code. It includes a function `intersection` that computes the intersection of two intervals, and a `main` function that runs several tests to verify the correctness of the `intersection` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the `intersection` function in both languages.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function to compute the product of signs of the elements in the array\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty() || (arr.size() == 1 && arr[0] == 0)) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int prods = 1;\n\n    for (int num : arr) {\n        sum += std::abs(num);\n        if (num == 0) {\n            prods = 0;\n        } else if (num < 0) {\n            prods = -prods;\n        }\n    }\n\n    return sum * prods;\n}\n\n// Main function with test cases\nint main() {\n    // Test cases\n    if (prod_signs({1, 2, 2, -4})!= -9) {\n        std::cerr << "Assertion failed: prod_signs({1, 2, 2, -4}) == -9" << std::endl;\n        std::exit(1);\n    }\n\n    if (prod_signs({0, 1})!= 0) {\n        std::cerr << "Assertion failed: prod_signs({0, 1}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (prod_signs({1, 1, 1, 2, 3, -1, 1})!= -10) {\n        std::cerr << "Assertion failed: prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle the empty array case separately\n    if (prod_signs({0})!= -32768) {\n        std::cerr << "Assertion failed: prod_signs({0}) == -32768" << std::endl;\n        std::exit(1);\n    }\n\n    if (prod_signs({2, 4, 1, 2, -1, -1, 9})!= 20) {\n        std::cerr << "Assertion failed: prod_signs({2, 4, 1, 2, -1, -1, 9}) == 20" << std::endl;\n        std::exit(1);\n    }\n\n    if (prod_signs({-1, 1, -1, 1})!= 4) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, -1, 1}) == 4" << std::endl;\n        std::exit(1);\n    }\n\n    if (prod_signs({-1, 1, 1, 1})!= -4) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, 1, 1}) == -4" << std::endl;\n        std::exit(1);\n    }\n\n    if (prod_signs({-1, 1, 1, 0})!= 0) {\n        std::cerr << "Assertion failed: prod_signs({-1, 1, 1, 0}) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid minPath(const std::vector<std::vector<int>>& grid, int k, std::vector<int>& result) {\n    int n = grid.size();\n    int x = -1, y = -1;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    int min = n * n;\n    if (x > 0 && grid[x-1][y] < min) min = grid[x-1][y];\n    if (x < n-1 && grid[x+1][y] < min) min = grid[x+1][y];\n    if (y > 0 && grid[x][y-1] < min) min = grid[x][y-1];\n    if (y < n-1 && grid[x][y+1] < min) min = grid[x][y+1];\n\n    result.resize(k);\n    for (int i = 0; i < k; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1;\n        } else {\n            result[i] = min;\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> grid;\n    std::vector<int> result;\n    int k;\n\n    // Test cases\n    {\n        grid = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        k = 3;\n        minPath(grid, k, result);\n        assert(issame(result, {1, 2, 1}));\n    }\n\n    {\n        grid = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n        k = 1;\n        minPath(grid, k, result);\n        assert(issame(result, {1}));\n    }\n\n    {\n        grid = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n        k = 4;\n        minPath(grid, k, result);\n        assert(issame(result, {1, 2, 1, 2}));\n    }\n\n    // Add more test cases as needed\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid tri(int n, std::vector<int>& out) {\n    if (n == 0) {\n        out = {1};\n        return;\n    }\n\n    out.resize(n + 1);\n    out[0] = 1;\n    out[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = 1 + (i - 1) / 2;\n        } else {\n            out[i] = out[i - 1] + out[i - 2] + 1 + (i / 2);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_tri(int n, const std::vector<int>& expected) {\n    std::vector<int> result;\n    tri(n, result);\n\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_tri(3, {1, 3, 2, 8});\n    test_tri(4, {1, 3, 2, 8, 3});\n    test_tri(5, {1, 3, 2, 8, 3, 15});\n    test_tri(6, {1, 3, 2, 8, 3, 15, 4});\n    test_tri(7, {1, 3, 2, 8, 3, 15, 4, 24});\n    test_tri(8, {1, 3, 2, 8, 3, 15, 4, 24, 5});\n    test_tri(9, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35});\n    test_tri(20, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11});\n    test_tri(0, {1});\n    test_tri(1, {1, 3});\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint digits(int n);\nvoid assert(bool condition);\n\nint main() {\n    // Assertions\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n\n    return 0;\n}\n\nint digits(int n) {\n    int prod = 1;\n    bool has = false;\n    std::string s = std::to_string(n);\n\n    for (char c : s) {\n        if (c % 2 == 1) {\n            has = true;\n            prod *= c - '0';\n        }\n    }\n\n    if (!has) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_nested(const std::string& str) {\n    int count = 0;\n    int maxcount = 0;\n    for (char c : str) {\n        if (c == '[') count++;\n        if (c == ']') count--;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert(is_nested("[[]]") == true);\n    assert(is_nested("[]]]]]]][[[[[]") == false);\n    assert(is_nested("[][]") == false);\n    assert(is_nested("[]") == false);\n    assert(is_nested("[[[[]]]]") == true);\n    assert(is_nested("[]]]]]]]]]]") == false);\n    assert(is_nested("[][][[]]") == true);\n    assert(is_nested("[[]") == false);\n    assert(is_nested("[]]") == false);\n    assert(is_nested("[[]][[") == true);\n    assert(is_nested("[[][]]") == true);\n    assert(is_nested("") == false);\n    assert(is_nested("[[[[[[[[") == false);\n    assert(is_nested("]]]]]]]]") == false);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function to calculate the sum of squares of elements in a list\nint sum_squares(const std::vector<float>& lst) {\n    int sum = 0;\n    for (float num : lst) {\n        sum += std::pow(std::ceil(num), 2);\n    }\n    return sum;\n}\n\n// Subroutine to assert a condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Subroutine to run tests\nvoid run_tests() {\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert(sum_squares({1.0, 3.0, 5.0, 7.0}) == 84);\n    assert(sum_squares({1.4, 4.2, 0.0}) == 29);\n    assert(sum_squares({-2.4, 1.0, 1.0}) == 6);\n    assert(sum_squares({100.0, 1.0, 15.0, 2.0}) == 10230);\n    assert(sum_squares({10000.0, 10000.0}) == 200000000);\n    assert(sum_squares({-1.4, 4.6, 6.3}) == 75);\n    assert(sum_squares({-1.4, 17.9, 18.9, 19.9}) == 1086);\n    assert(sum_squares({0.0}) == 0);\n    assert(sum_squares({-1.0}) == 1);\n    assert(sum_squares({-1.0, 1.0, 0.0}) == 2);\n}\n\nint main() {\n    // Main program\n    run_tests();\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cstdlib> // For exit()\n\n// Function to find the maximum value that can be arranged in a non-decreasing order\nint can_arrange(const std::vector<int>& arr, int n) {\n    int max = -1;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= i) {\n            max = i;\n        } else {\n            break; // Exit the loop as soon as a value is not in the correct position\n        }\n    }\n    return max;\n}\n\n// Function to handle the empty array case\nint can_arrange_empty() {\n    return -1;\n}\n\nint main() {\n    // Test cases\n    std::vector<int> test1 = {1, 2, 4, 3, 5};\n    if (can_arrange(test1, 5)!= 3) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,3,5}) /= 3" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test2 = {1, 2, 4, 5};\n    if (can_arrange(test2, 4)!= -1) {\n        std::cerr << "Assertion failed: can_arrange({1,2,4,5}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test3 = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    if (can_arrange(test3, 9)!= 2) {\n        std::cerr << "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) /= 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::vector<int> test4 = {4, 8, 5, 7, 3};\n    if (can_arrange(test4, 5)!= 4) {\n        std::cerr << "Assertion failed: can_arrange({4,8,5,7,3}) /= 4" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle the empty array case separately\n    if (can_arrange_empty()!= -1) {\n        std::cerr << "Assertion failed: can_arrange({}) /= -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nstd::pair<int, int> largest_smallest_integers(const std::vector<int>& lst) {\n    int maxneg = 0;\n    int minpos = 0;\n\n    for (int num : lst) {\n        if (num < 0 && (maxneg == 0 || num > maxneg)) maxneg = num;\n        if (num > 0 && (minpos == 0 || num < minpos)) minpos = num;\n    }\n\n    return {maxneg, minpos};\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) return false;\n    }\n\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    test_case({2, 4, 1, 3, 5, 7}, {0, 1});\n    test_case({2, 4, 1, 3, 5, 7, 0}, {0, 1});\n    test_case({1, 3, 2, 4, 5, 6, -2}, {-2, 1});\n    test_case({4, 5, 3, 6, 2, 7, -7}, {-7, 2});\n    test_case({7, 3, 8, 4, 9, 2, 5, -9}, {-9, 2});\n    test_case({0}, {0, 0});\n    test_case({-1, -3, -5, -6}, {-1, 0});\n    test_case({-1, -3, -5, -6, 0}, {-1, 0});\n    test_case({-6, -4, -4, -3, 1}, {-3, 1});\n    test_case({-6, -4, -4, -3, -100, 1}, {-3, 1});\n\n    // Special case for empty array\n    test_case_empty({0, 0});\n}\n\nvoid test_case(const std::vector<int>& input_array, const std::pair<int, int>& expected) {\n    std::vector<int> test_array = input_array;\n    assert_condition(issame(largest_smallest_integers(test_array), expected));\n}\n\nvoid test_case_empty(const std::pair<int, int>& expected) {\n    std::vector<int> test_array = {};\n    assert_condition(issame(largest_smallest_integers(test_array), expected));\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n
#include` directives instead of `use` statements, and the `exit` function from `<cstdlib>` is used to terminate the program.\n\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string file_name_check(const std::string& file_name) {\n    int numdigit = 0;\n    int numdot = 0;\n\n    if (file_name.length() < 5) {\n        return "No";\n    }\n\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') {\n        return "No";\n    }\n\n    std::string last = file_name.substr(file_name.length() - 4, 4);\n    if (last!= ".txt" && last!= ".exe" && last!= ".dll") {\n        return "No";\n    }\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') numdigit++;\n        if (file_name[i] == '.') numdot++;\n    }\n\n    if (numdigit > 3 || numdot!= 1) {\n        return "No";\n    } else {\n        return "Yes";\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(file_name_check("example.txt") == "Yes");\n    assert(file_name_check("1example.dll") == "No");\n    assert(file_name_check("s1sdf3.asd") == "No");\n    assert(file_name_check("K.dll") == "Yes");\n    assert(file_name_check("MY16FILE3.exe") == "Yes");\n    assert(file_name_check("His12FILE94.exe") == "No");\n    assert(file_name_check("_Y.txt") == "No");\n    assert(file_name_check("?aREYA.exe") == "No");\n    assert(file_name_check("/this_is_valid.dll") == "No");\n    assert(file_name_check("this_is_valid.wow") == "No");\n    assert(file_name_check("this_is_valid.txt") == "Yes");\n    assert(file_name_check("this_is_valid.txtexe") == "No");\n    assert(file_name_check("#this2_i4s_5valid.ten") == "No");\n    assert(file_name_check("@this1_is6_valid.exe") == "No");\n    assert(file_name_check("this_is_12valid.6exe4.txt") == "No");\n    assert(file_name_check("all.exe.txt") == "No");\n    assert(file_name_check("I563_No.exe") == "Yes");\n    assert(file_name_check("Is3youfault.txt") == "Yes");\n    assert(file_name_check("no_one#knows.dll") == "Yes");\n    assert(file_name_check("1I563_Yes3.exe") == "No");\n    assert(file_name_check("I563_Yes3.txtt") == "No");\n    assert(file_name_check("final..txt") == "No");\n    assert(file_name_check("final132") == "No");\n    assert(file_name_check("_f4indsartal132.") == "No");\n    assert(file_name_check(".txt") == "No");\n    assert(file_name_check("s.") == "No");\n\n    return 0;\n}\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These unit tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool simplify(const std::string& x, const std::string& n) {\n    int a, b, c, d;\n    size_t pos;\n\n    pos = x.find('/');\n    a = std::stoi(x.substr(0, pos));\n    b = std::stoi(x.substr(pos + 1));\n\n    pos = n.find('/');\n    c = std::stoi(n.substr(0, pos));\n    d = std::stoi(n.substr(pos + 1));\n\n    return (a * c) % (b * d) == 0;\n}\n\nint main() {\n    bool result;\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/6", "2/1");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('1/6', '2/1') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/1", "3/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('5/1', '3/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/10", "10/2");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('7/10', '10/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/10", "50/10");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/10', '50/10') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("7/2", "4/2");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('7/2', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("11/6", "6/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('11/6', '6/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/3", "5/2");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('2/3', '5/2') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("5/2", "3/5");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('5/2', '3/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "8/4");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/4', '8/4') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("2/4", "4/2");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('2/4', '4/2') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "5/1");\n    if (!result) {\n        std::cerr << "Assertion failed: simplify('1/5', '5/1') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = simplify("1/5", "1/5");\n    if (result) {\n        std::cerr << "Assertion failed: simplify('1/5', '1/5') == false" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n\nThis C++ code includes the `simplify` function that performs the same logic as the Fortran version. The `main` function contains the assertions to verify the correctness of the `simplify` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\nSave the following Fortran code in a file named `test_fortran.f90`:\n\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<int> order_by_points(const std::vector<int>& nums) {\n    std::vector<int> sorted_nums = nums;\n    std::vector<int> sumdigit(nums.size());\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        std::string w = std::to_string(std::abs(nums[i]));\n        int sum = 0;\n        for (size_t j = 0; j < w.length(); ++j) {\n            sum += w[j] - '0';\n        }\n        if (nums[i] > 0) {\n            sum += w[0] - '0';\n        } else {\n            sum -= (w[0] - '0');\n        }\n        sumdigit[i] = sum;\n    }\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        for (size_t j = 1; j < nums.size(); ++j) {\n            if (sumdigit[j-1] > sumdigit[j]) {\n                std::swap(sumdigit[j], sumdigit[j-1]);\n                std::swap(sorted_nums[j], sorted_nums[j-1]);\n            }\n        }\n    }\n\n    return sorted_nums;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> nums, result;\n\n    // Test cases\n    nums = {1, 11, -1, -11, -12};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-1, -11, 1, -12, 11}));\n\n    nums = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n\n    nums = {};\n    result = order_by_points(nums);\n    assert_condition(issame(result, nums));\n\n    nums = {1, -11, -32, 43, 54, -98, 2, -3};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-3, -32, -98, -11, 1, 2, 43, 54}));\n\n    nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n\n    nums = {0, 6, 6, -76, -21, 23, 4};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-76, -21, 0, 4, 23, 6, 6}));\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For exit()\n\nclass SpecialFilterModule {\npublic:\n    static int specialFilter(const std::vector<int>& nums) {\n        int num = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] > 10) {\n                std::string w = std::to_string(nums[i]);\n                if ((w[0] - '0') % 2 == 1 && (w[w.length() - 1] - '0') % 2 == 1) {\n                    ++num;\n                }\n            }\n        }\n        return num;\n    }\n\n    static int specialFilterEmpty() {\n        return 0;\n    }\n};\n\nint main() {\n    // Test cases\n    if (SpecialFilterModule::specialFilter({5, -2, 1, -5})!= 0) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (SpecialFilterModule::specialFilter({15, -73, 14, -15})!= 1) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (SpecialFilterModule::specialFilter({33, -2, -3, 45, 21, 109})!= 2) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (SpecialFilterModule::specialFilter({43, -12, 93, 125, 121, 109})!= 4) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (SpecialFilterModule::specialFilter({71, -2, -33, 75, 21, 19})!= 3) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (SpecialFilterModule::specialFilter({1})!= 0) {\n        std::cerr << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle empty array case separately\n    if (SpecialFilterModule::specialFilterEmpty()!= 0) {\n        std::cerr << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n\nint get_matrix_triples(int n) {\n    std::vector<int> a(n);\n    std::vector<std::vector<int>> sum(n + 1, std::vector<int>(3, 0));\n    std::vector<std::vector<int>> sum2(n + 1, std::vector<int>(3, 0));\n\n    // Fill array 'a' and compute initial sums\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i * i - i + 1) % 3;\n        sum[i + 1] = sum[i];\n        sum[i + 1][a[i]] += 1;\n    }\n\n    // Compute sums for times = 1 and 2\n    for (int times = 1; times <= 2; ++times) {\n        for (int i = 0; i < n; ++i) {\n            sum2[i + 1] = sum2[i];\n            for (int j = 0; j < 3; ++j) {\n                sum2[i + 1][(a[i] + j) % 3] += sum[i][j];\n            }\n        }\n        sum = sum2;\n        sum2.assign(n + 1, std::vector<int>(3, 0));\n    }\n\n    return sum[n][0];\n}\n\nint main() {\n    // Test cases\n    if (get_matrix_triples(5)!= 1) {\n        std::cerr << "Assertion failed: get_matrix_triples(5) == 1" << std::endl;\n        return 1;\n    }\n\n    if (get_matrix_triples(6)!= 4) {\n        std::cerr << "Assertion failed: get_matrix_triples(6) == 4" << std::endl;\n        return 1;\n    }\n\n    if (get_matrix_triples(10)!= 36) {\n        std::cerr << "Assertion failed: get_matrix_triples(10) == 36" << std::endl;\n        return 1;\n    }\n\n    if (get_matrix_triples(100)!= 53361) {\n        std::cerr << "Assertion failed: get_matrix_triples(100) == 53361" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint x_or_y(int n, int x, int y) {\n    bool isp = true;\n    if (n < 2) isp = false;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(static_cast<double>(n))); ++i) {\n        if (n % i == 0) {\n            isp = false;\n            break;\n        }\n    }\n\n    if (isp) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nint main() {\n    // Assertions\n    if (x_or_y(7, 34, 12)!= 34) {\n        std::cerr << "Assertion failed: x_or_y(7, 34, 12) == 34" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(15, 8, 5)!= 5) {\n        std::cerr << "Assertion failed: x_or_y(15, 8, 5) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3, 33, 5212)!= 33) {\n        std::cerr << "Assertion failed: x_or_y(3, 33, 5212) == 33" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1259, 3, 52)!= 3) {\n        std::cerr << "Assertion failed: x_or_y(1259, 3, 52) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(7919, -1, 12)!= -1) {\n        std::cerr << "Assertion failed: x_or_y(7919, -1, 12) == -1" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(3609, 1245, 583)!= 583) {\n        std::cerr << "Assertion failed: x_or_y(3609, 1245, 583) == 583" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(91, 56, 129)!= 129) {\n        std::cerr << "Assertion failed: x_or_y(91, 56, 129) == 129" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(6, 34, 1234)!= 1234) {\n        std::cerr << "Assertion failed: x_or_y(6, 34, 1234) == 1234" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(1, 2, 0)!= 0) {\n        std::cerr << "Assertion failed: x_or_y(1, 2, 0) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (x_or_y(2, 2, 0)!= 2) {\n        std::cerr << "Assertion failed: x_or_y(2, 2, 0) == 2" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function to calculate the double the difference\nint64_t double_the_difference(const std::vector<double>& lst) {\n    int64_t sum = 0;\n    for (double num : lst) {\n        int64_t rounded_value = static_cast<int64_t>(std::round(num));\n        if (std::abs(num - static_cast<double>(rounded_value)) < 1e-4) {\n            if (num > 0 && rounded_value % 2 == 1) {\n                sum += rounded_value * rounded_value;\n            }\n        }\n    }\n    return sum;\n}\n\n// Subroutine to assert the condition\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(double_the_difference({0.0}) == 0);\n    assert(double_the_difference({5.0, 4.0}) == 25);\n    assert(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert(double_the_difference({-1.0, -2.0, 8.0}) == 0);\n    assert(double_the_difference({0.2, 3.0, 5.0}) == 34);\n\n    // Initialize variables\n    int64_t odd_sum = 0;\n    std::vector<double> lst(100, 0.0);\n\n    // Fill the array and calculate odd_sum\n    for (int i = -99; i <= 99; i += 2) {\n        lst[(i + 101) / 2] = static_cast<double>(i);\n        if (i > 0 && i % 2 == 1) {\n            odd_sum += i * i;\n        }\n    }\n\n    // Check the final assertion\n    int64_t result = double_the_difference(lst);\n    assert(result == odd_sum);\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nbool cycpattern_check(const std::string& a, const std::string& b) {\n    int len_a = a.length();\n    int len_b = b.length();\n\n    for (int i = 0; i < len_b; ++i) {\n        std::string rotate = b.substr(i) + b.substr(0, i);\n        // Debugging print statement\n        // std::cout << "Checking rotation: " << rotate << std::endl;\n        if (a.find(rotate)!= std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    bool result;\n\n    result = cycpattern_check("xyzw", "xyw");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('xyzw', 'xyw') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("yello", "ell");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('yello', 'ell') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("whattup", "ptut");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('whattup', 'ptut') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("efef", "fee");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('efef', 'fee') == true" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("abab", "aabb");\n    if (result) {\n        std::cerr << "Assertion failed: cycpattern_check('abab', 'aabb') == false" << std::endl;\n        std::exit(1);\n    }\n\n    result = cycpattern_check("winemtt", "tinem");\n    if (!result) {\n        std::cerr << "Assertion failed: cycpattern_check('winemtt', 'tinem') == true" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::pair<int, int> even_odd_count(int num) {\n    std::string w = std::to_string(std::abs(num));\n    int n1 = 0, n2 = 0;\n\n    for (char c : w) {\n        if (c % 2 == 1) {\n            n1++;\n        } else {\n            n2++;\n        }\n    }\n\n    return {n2, n1};\n}\n\nbool issame(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    return a == b;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(issame(even_odd_count(7), {0, 1}));\n    assert(issame(even_odd_count(-78), {1, 1}));\n    assert(issame(even_odd_count(3452), {2, 2}));\n    assert(issame(even_odd_count(346211), {3, 3}));\n    assert(issame(even_odd_count(-345821), {3, 3}));\n    assert(issame(even_odd_count(-2), {1, 0}));\n    assert(issame(even_odd_count(-45347), {2, 3}));\n    assert(issame(even_odd_count(0), {1, 0}));\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\nstd::string int_to_mini_romank(int number) {\n    std::vector<std::pair<int, std::string>> rep = {\n        {1000, "m "}, {900, "cm"}, {500, "d "}, {400, "cd"},\n        {100, "c "}, {90, "xc"}, {50, "l "}, {40, "xl"},\n        {10, "x "}, {9, "ix"}, {5, "v "}, {4, "iv"}, {1, "i "}\n    };\n\n    std::string current = "";\n    int temp_number = number;\n\n    while (temp_number > 0) {\n        for (const auto& [num, str] : rep) {\n            while (temp_number >= num) {\n                current += str;\n                temp_number -= num;\n            }\n        }\n    }\n\n    return current;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(int_to_mini_romank(19) == "xix");\n    assert(int_to_mini_romank(152) == "clii");\n    assert(int_to_mini_romank(251) == "ccli");\n    assert(int_to_mini_romank(426) == "cdxxvi");\n    assert(int_to_mini_romank(500) == "d");\n    assert(int_to_mini_romank(1) == "i");\n    assert(int_to_mini_romank(4) == "iv");\n    assert(int_to_mini_romank(43) == "xliii");\n    assert(int_to_mini_romank(90) == "xc");\n    assert(int_to_mini_romank(94) == "xciv");\n    assert(int_to_mini_romank(532) == "dxxxii");\n    assert(int_to_mini_romank(900) == "cm");\n    assert(int_to_mini_romank(994) == "cmxciv");\n    assert(int_to_mini_romank(1000) == "m");\n\n    return 0;\n}\n
#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\n// Function declaration\nbool right_angle_triangle(float a, float b, float c);\n\nint main() {\n    // Assertions\n    if (!right_angle_triangle(3.0f, 4.0f, 5.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(3, 4, 5) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(1.0f, 2.0f, 3.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(1, 2, 3) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(10.0f, 6.0f, 8.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(10, 6, 8) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(2.0f, 2.0f, 2.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(2, 2, 2) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(7.0f, 24.0f, 25.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(7, 24, 25) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(10.0f, 5.0f, 7.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(10, 5, 7) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(5.0f, 12.0f, 13.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(5, 12, 13) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(15.0f, 8.0f, 17.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(15, 8, 17) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (!right_angle_triangle(48.0f, 55.0f, 73.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(48, 55, 73) == true" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(1.0f, 1.0f, 1.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(1, 1, 1) == false" << std::endl;\n        std::exit(1);\n    }\n\n    if (right_angle_triangle(2.0f, 2.0f, 10.0f)) {\n        std::cout << "Assertion failed: right_angle_triangle(2, 2, 10) == false" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nbool right_angle_triangle(float a, float b, float c) {\n    const float epsilon = 1.0e-4f;\n\n    if (std::abs(a*a + b*b - c*c) < epsilon || std::abs(a*a + c*c - b*b) < epsilon || std::abs(b*b + c*c - a*a) < epsilon) {\n        return true;\n    } else {\n        return false;\n    }\n}\nThis C++ code includes the necessary headers and uses the `std::abs` function for floating-point absolute values, similar to the Fortran `abs` function. The `right_angle_triangle` function checks if the given lengths of the sides of a triangle form a right-angled triangle, returning `true` or `false` accordingly. The main function contains a series of assertions to verify the correctness of the `right_angle_triangle` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These tests will help verify the correctness of the `right_angle_triangle` function in both languages.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to find the maximum word in a vector of strings\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string max_word = "";\n    int maxu = 0;\n    for (const auto& word : words) {\n        std::string unique = "";\n        for (char c : word) {\n            if (unique.find(c) == std::string::npos) {\n                unique += c;\n            }\n        }\n        if (unique.length() > maxu || (unique.length() == maxu && word < max_word)) {\n            max_word = word;\n            maxu = unique.length();\n        }\n    }\n    return max_word;\n}\n\n// Main function to run unit tests\nint main() {\n    std::vector<std::string> words;\n    std::string result;\n\n    // Test 1\n    words = {"name   ", "of     ", "string "};\n    result = find_max(words);\n    if (result!= "string") {\n        std::cerr << "Assertion failed: expected'string', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 2\n    words = {"name   ", "enam   ", "game   "};\n    result = find_max(words);\n    if (result!= "enam") {\n        std::cerr << "Assertion failed: expected 'enam', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 3\n    words = {"aaaaaaa", "bb     ", "cc     "};\n    result = find_max(words);\n    if (result!= "aaaaaaa") {\n        std::cerr << "Assertion failed: expected 'aaaaaaa', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 4\n    words = {"abc    ", "cba    "};\n    result = find_max(words);\n    if (result!= "abc") {\n        std::cerr << "Assertion failed: expected 'abc', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 5\n    words = {"play    ", "this    ", "game    ", "of      ", "footbott"};\n    result = find_max(words);\n    if (result!= "footbott") {\n        std::cerr << "Assertion failed: expected 'footbott', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 6\n    words = {"we      ", "are     ", "gonna   ", "rock    "};\n    result = find_max(words);\n    if (result!= "gonna") {\n        std::cerr << "Assertion failed: expected 'gonna', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 7\n    words = {"we      ", "are     ", "a       ", "mad     ", "nation  "};\n    result = find_max(words);\n    if (result!= "nation") {\n        std::cerr << "Assertion failed: expected 'nation', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 8\n    words = {"this    ", "is      ", "a       ", "prrk    "};\n    result = find_max(words);\n    if (result!= "this") {\n        std::cerr << "Assertion failed: expected 'this', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 9\n    words = {"b       "};\n    result = find_max(words);\n    if (result!= "b") {\n        std::cerr << "Assertion failed: expected 'b', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    // Test 10\n    words = {"play    ", "play    ", "play    "};\n    result = find_max(words);\n    if (result!= "play") {\n        std::cerr << "Assertion failed: expected 'play', got '" << result << "'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n
#include <iostream>\n#include <array>\n\nstd::array<int, 2> eat(int number, int need, int remaining) {\n    if (need > remaining) {\n        return {number + remaining, 0};\n    } else {\n        return {number + need, remaining - need};\n    }\n}\n\nbool issame(const std::array<int, 2>& a, const std::array<int, 2>& b) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    std::array<int, 2> result;\n    std::array<int, 2> expected;\n\n    // Test cases\n    result = eat(5, 6, 10);\n    expected = {11, 4};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(5, 6, 10) == {11, 4}" << std::endl;\n        return 1;\n    }\n\n    result = eat(4, 8, 9);\n    expected = {12, 1};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 8, 9) == {12, 1}" << std::endl;\n        return 1;\n    }\n\n    result = eat(1, 10, 10);\n    expected = {11, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(1, 10, 10) == {11, 0}" << std::endl;\n        return 1;\n    }\n\n    result = eat(2, 11, 5);\n    expected = {7, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(2, 11, 5) == {7, 0}" << std::endl;\n        return 1;\n    }\n\n    result = eat(4, 5, 7);\n    expected = {9, 2};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 7) == {9, 2}" << std::endl;\n        return 1;\n    }\n\n    result = eat(4, 5, 1);\n    expected = {5, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 1) == {5, 0}" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n
#include <iostream>\n#include <string>\n#include <cctype>\n\nstd::string solve(const std::string& s) {\n    std::string out = "";\n    int nletter = 0;\n    int len_s = s.length();\n\n    for (int i = 0; i < len_s; ++i) {\n        char w = s[i];\n        if (std::isupper(w)) {\n            w = std::tolower(w);\n        } else if (std::islower(w)) {\n            w = std::toupper(w);\n        } else {\n            nletter++;\n        }\n        out += w;\n    }\n\n    if (nletter == len_s) {\n        std::string rev = "";\n        for (int i = len_s - 1; i >= 0; --i) {\n            rev += s[i];\n        }\n        out = rev;\n    }\n\n    return out;\n}\n\nint main() {\n    // Test cases\n    std::string s, result;\n\n    s = "AsDf";\n    result = solve(s);\n    if (result!= "aSdF") {\n        std::cerr << "Assertion failed: solve('AsDf') == 'aSdF'" << std::endl;\n        return 1;\n    }\n\n    s = "1234";\n    result = solve(s);\n    if (result!= "4321") {\n        std::cerr << "Assertion failed: solve('1234') == '4321'" << std::endl;\n        return 1;\n    }\n\n    s = "ab";\n    result = solve(s);\n    if (result!= "AB") {\n        std::cerr << "Assertion failed: solve('ab') == 'AB'" << std::endl;\n        return 1;\n    }\n\n    s = "#a@C";\n    result = solve(s);\n    if (result!= "#A@c") {\n        std::cerr << "Assertion failed: solve('#a@C') == '#A@c'" << std::endl;\n        return 1;\n    }\n\n    s = "#AsdfW^45";\n    result = solve(s);\n    if (result!= "#aSDFw^45") {\n        std::cerr << "Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'" << std::endl;\n        return 1;\n    }\n\n    s = "#6@2";\n    result = solve(s);\n    if (result!= "2@6#") {\n        std::cerr << "Assertion failed: solve('#6@2') == '2@6#'" << std::endl;\n        return 1;\n    }\n\n    s = "#$a^D";\n    result = solve(s);\n    if (result!= "#$A^d") {\n        std::cerr << "Assertion failed: solve('#$a^D') == '#$A^d'" << std::endl;\n        return 1;\n    }\n\n    s = "#ccc";\n    result = solve(s);\n    if (result!= "#CCC") {\n        std::cerr << "Assertion failed: solve('#ccc') == '#CCC'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nThis C++ code includes the `solve` function that performs the same operations as the Fortran code. It iterates through the input string, converts uppercase letters to lowercase, converts lowercase letters to uppercase, and keeps non-letter characters as they are. If the input string consists solely of non-letter characters, it reverses the string. The `main` function contains test cases to verify the correctness of the `solve` function.\nLet's write some test to verify if the translation is correct. \nBelow are the unit test codes for both the original Fortran code and the translated C++ code. These unit tests will help verify the correctness of the translation.\n\n### Fortran Unit Test Code\n\n
#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid generate_integers(int a, int b, std::vector<int>& out) {\n    int temp_a = a;\n    int temp_b = b;\n\n    if (temp_b < temp_a) {\n        std::swap(temp_a, temp_b);\n    }\n\n    int count = 0;\n    std::vector<int> temp(temp_b - temp_a + 1);\n    for (int i = temp_a; i <= temp_b; ++i) {\n        if (i < 10 && i % 2 == 0) {\n            temp[count] = i;\n            ++count;\n        }\n    }\n\n    if (count > 0) {\n        out.resize(count);\n        for (int i = 0; i < count; ++i) {\n            out[i] = temp[i];\n        }\n    } else {\n        out.resize(0);\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size()!= b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i]!= b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result;\n    std::vector<int> empty_array(0);\n\n    generate_integers(2, 10, result);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    generate_integers(10, 2, result);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    generate_integers(132, 2, result);\n    assert(issame(result, {2, 4, 6, 8}));\n\n    generate_integers(17, 89, result);\n    assert(issame(result, empty_array));\n\n    return 0;\n}\n
